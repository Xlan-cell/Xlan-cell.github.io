<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最近的笔记方向</title>
    <link href="/2024/11/19/%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/11/19/%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本周</p><p>11&#x2F;4-11-10</p><p>1.mysql 01-习题复习总结</p><p>2.java IO操作</p><p>具体 </p><p>Bio Nio Aio -多路复用-配合以前学习c++笔记学习</p><p>3.java刷题-每天35题</p><p>4.java jvm  </p><p>11-10-11-7</p><p>java-编写高并发常见情况-或者造轮子 -看哔哩哔哩 -或者读spring-springboot源码或者mybits-plus源码</p><p>mysql 背</p><p>java刷题30题</p><p>数据结构刷题  01 02 03 04 数据结构-数组矩阵</p><p>jvm</p>]]></content>
    
    
    <categories>
      
      <category>杂言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jvm调优篇</title>
    <link href="/2024/11/13/java%20jvm/%E5%9F%BA%E7%A1%80/Jvm%E8%B0%83%E4%BC%98/"/>
    <url>/2024/11/13/java%20jvm/%E5%9F%BA%E7%A1%80/Jvm%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Jvm调优篇"><a href="#Jvm调优篇" class="headerlink" title="Jvm调优篇"></a>Jvm调优篇</h1><h3 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h3><h3 id="Gc调优"><a href="#Gc调优" class="headerlink" title="Gc调优"></a>Gc调优</h3><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UnixIo模型</title>
    <link href="/2024/11/10/java/javaIo/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UnixIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/11/10/java/javaIo/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UnixIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Unix-Io模型"><a href="#Unix-Io模型" class="headerlink" title="Unix Io模型"></a>Unix Io模型</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/67653e9ef27fc4319275e2e0cf812de2.png"></p><blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java网络通信</title>
    <link href="/2024/11/10/java/javaIo/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/11/10/java/javaIo/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="java网络通信"><a href="#java网络通信" class="headerlink" title="java网络通信"></a>java网络通信</h1><p>本笔记来源 </p><p>黑马C++网络编程</p><p>黑马java Nio bio aio基础讲解</p><h4 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h4><h6 id="1-mac地址"><a href="#1-mac地址" class="headerlink" title="1.mac地址"></a>1.mac地址</h6><p>网卡-&gt;物理地址 通常不会重复 虚拟网卡除外 48位 6字节</p><p>00:00:00:00:00:00</p><h6 id="2-ip地址"><a href="#2-ip地址" class="headerlink" title="2.ip地址"></a>2.ip地址</h6><p>标识主机Id 为虚拟的 有ipv4(32位) ipv6(64位)</p><p>分为子网ID 和主机 ID 其中的计算需要子网掩码搭配 netmask</p><p>ip中连续的1覆盖的位 子网ip</p><p>连续0覆盖的位 主机id</p><p>ip:(二进制)10.1.1.2 -&gt;0000 1010 0000 0001 0000 0001 0000 0010</p><p>netmask-&gt;255.255.255.0-&gt;1111 1111 1111 1111 1111 1111 0000 0000</p><p>10.1.1 子网id 主机id2</p><p>网段地址：10.1.1.0</p><p>广播地址:10.1.1.255</p><p>可设置范围</p><p>1-254</p><h6 id="3-ping"><a href="#3-ping" class="headerlink" title="3.ping"></a>3.ping</h6><p>127.0.0.1-&gt;254 都是属于对本机进行联通</p><h6 id="5-ip-netmask设置"><a href="#5-ip-netmask设置" class="headerlink" title="5.ip netmask设置"></a>5.ip netmask设置</h6><p>linux中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">sudo  ifconfig ens33 <span class="hljs-number">192.168</span><span class="hljs-number">.26</span><span class="hljs-number">.33</span> netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><h6 id="6-桥接和nat的区别"><a href="#6-桥接和nat的区别" class="headerlink" title="6.桥接和nat的区别"></a><strong>6.桥接和nat的区别</strong></h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bbcc39fa6e524cf485a0685d97dd28c5.png" alt="在这里插入图片描述"></p><p>桥接（Bridge）<strong>是用于连接不同网络段的设备，主要在数据链路层工作，转发数据帧并实现不同网络之间的通信；</strong></p><p><strong>NAT（网络地址转换，Network Address Translation）</strong>是一种在网络层使用的技术，主要用于将私有网络地址转换为公网地址，或者将公网地址映射到多个私有网络地址，从而实现内外网的通信。NAT通常用于路由器或防火墙设备，帮助多个设备共享一个公网IP地址，解决IPv4地址不足的问题。</p><h6 id="7-端口"><a href="#7-端口" class="headerlink" title="7.端口"></a>7.端口</h6><p>每个程序都有一个&#x2F;多个端口<br>作用:用来标识应用程序</p><p>port:2字节 0-65535 其中0-1023知名端口 自定义端口1024-65535</p><p>端口类似于进程号，同一时刻只能只能标志一个，可以重复使用</p><h6 id="8-网络分层模型"><a href="#8-网络分层模型" class="headerlink" title="8.网络分层模型"></a>8.网络分层模型</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106104603426.png" alt="image-20241106104603426"></p><p>物理层：双绞线的接口类型 光纤的传输速度<br>数据链路层：mac 负责收发数据<br>网络层：ip给两台主机 提供路径选择<br>传输层：port 区分数据递送到哪一个应用层<br>会话层：建立链接<br>表示层：解码<br>应用层：拿到数据<br>物 数 网 传 会 话 层</p><p>开发中 四层 TCP&#x2F;IP模型</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image001.png" alt="img"></p><h6 id="8-协议"><a href="#8-协议" class="headerlink" title="8.协议"></a>8.协议</h6><p>规定数据传输的方式和格式</p><p>应用层协议<br>ftp:文件传输协议<br>http:超文本传输协议<br>省<br>传输层协议<br>tcp:传输控制协议<br>udp:用户数据报协议</p><p>网络层<br>ip:因特网互联协议<br>icmp：因特网控制报文协议 ping命令<br>ugmp：因特网管理协议】链路层<br>arp:地址解析协议 通过Ip找mac<br>rarp:反向地址解析协议 通过mac找ip</p><p>ttl-&gt;最大在网络出游走数</p><blockquote><p>TCP&#x2F;IP中的TTL 原创 <strong>TTL是IP协议包中的一个值，它告诉网络,数据包在网络中的时间是否太长而应被丢弃</strong>。</p></blockquote><p>防止在路由器内循环</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/796873de8ad287eb584fb7275c01f440.png" alt="img"></p><h6 id="9-组包过程"><a href="#9-组包过程" class="headerlink" title="9.组包过程"></a>9.组包过程</h6><p>组包。简单的说就是tcp协议把过大的数据包分成了几个小的包传输，接收方要把同一组的数据包重新组合成一个完整的数据包。</p><p>圆圈内通过</p><blockquote><p>以前笔记的图片丢失想不起来了</p></blockquote><p><a href="https://blog.csdn.net/Chaman1378/article/details/107160327">https://blog.csdn.net/Chaman1378/article/details/107160327</a></p><h6 id="10-arp通信"><a href="#10-arp通信" class="headerlink" title="10.arp通信"></a>10.arp通信</h6><p>地址解析协议 ip找mac地址</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image001.png" alt="img"></p><p>a-&gt;广播发送信息 传给b b返回mac(局域网）</p><h6 id="11-网络模式"><a href="#11-网络模式" class="headerlink" title="11.网络模式"></a>11.网络模式</h6><p>B&#x2F;S 网页&#x2F;服务器 开发周期段</p><p>CS 客户端&#x2F;服务器-&gt;客户端计算 容易开挂 开发时间长</p><h6 id="12-socket通信流程"><a href="#12-socket通信流程" class="headerlink" title="12.socket通信流程"></a>12.socket通信流程</h6><p>tcp服务器通信步骤<br>1.创建套接字<br>2.绑定<br>3.监听<br>4.提取<br>5.读写<br>6.关闭</p><p>服务器创建api</p><p>给套接字绑定固定的端口和ip</p><p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image002.jpg" alt="img"></p><p><strong>在网络通信中，套接字一定是成对出现的。</strong>一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106105615967.png" alt="image-20241106105615967"></p><h6 id="13-粘包"><a href="#13-粘包" class="headerlink" title="13.粘包"></a>13.粘包</h6><p>对服务器客户端等函数进行报错处理 以及简化处理</p><p>缓冲区内 由于没发送完毕另外一个包就来了直接挤占前一个包的缓冲区(被信号打断的情况</p><p>解决方式<br>1.约定 一次发送固定字节数<br>2.数据结尾要\n<br>3.头部加上数据的大小</p><h6 id="14三次握手"><a href="#14三次握手" class="headerlink" title="14三次握手"></a>14三次握手</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197287-20230817213100878-1430094444.webp" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106105955301.png" alt="image-20241106105955301"></p><p>三次握手<br>我们如果要设计一个通信软件 如和设计<br>设计 连接性<br>1.创建套接字 -&gt;让套接字中包含服务器的ip和端口进行链接<br>链接实现</p><p>1 发送链接请求<br>2 收到链接请求 并且链接客户端<br>3 测试是否发送成功<br>设计处三次请求</p><p>如果丢包了呢<br>TCP 第一次握手的 SYN 丢包了，会发生了什么？<br>场景 客户端链接服务器 但是服务器被D死了<br>重复发送 第一次超时1s 第2次超时 4s 一次增加<br>当超过最大重传次数后，客户端不再发送 SYN 包。</p><p>内核中定义超时请求次数 5次 那么就发送5次 时间会叠加</p><p>TCP 第二次握手的 SYN、ACK 丢包了，会发生什么？<br>场景 客户端链接服务器 服务器防火墙禁止数据链接</p><p>客户端:无法收到syn ack包 超时重传 达到内核设置次数 就终止<br>服务器:服务器能收但是不能传 服务器回syn ack 但是客户端收不到 服务器就等待客户端回第三次握手的ack<br>超时重传</p><p>TCP 第三次握手的 ACK 包丢了，会发生什么？</p><p>场景 客户端链接服务器 但是服务器被D死了</p><p>客户端状态:已完成 TCP 连接建立，处于 ESTABLISHED 状态-&gt;<br>手法发送数据 ——&gt;到达不了 自动断开<br>依靠保活机制</p><p>服务端状态:处于 SYN_RECV 如果一直收不到ack包则断开链接 -&gt;重发syn ack包 到达次数就断开链接</p><h6 id="15四次挥手"><a href="#15四次挥手" class="headerlink" title="15四次挥手"></a>15四次挥手</h6><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">第一次挥手（<span class="hljs-built_in">Active</span> <span class="hljs-built_in">Close</span>）：<br>客户端发送一个<span class="hljs-variable">FIN</span>（<span class="hljs-variable">Finish</span>）报文给服务器，表示客户端不再发送数据。客户端进入<span class="hljs-type">FIN_WAIT</span><span class="hljs-type">_</span><span class="hljs-number">1</span>状态，等待服务器的确认。<br><br>第二次挥手（<span class="hljs-variable">Passive</span> <span class="hljs-built_in">Close</span>）：<br>服务器收到客户端的<span class="hljs-variable">FIN</span>报文后，发送一个<span class="hljs-variable">ACK</span>（<span class="hljs-variable">Acknowledge</span>）报文作为确认，表示已经收到了客户端的关闭请求。服务器进入<span class="hljs-type">CLOSE_WAIT</span>状态。此时，服务器可能还有未发送完的数据，因此仍可以发送数据给客户端。<br><br>第三次挥手（<span class="hljs-variable">Passive</span> <span class="hljs-built_in">Close</span>）：<br>服务器发送一个<span class="hljs-variable">FIN</span>报文给客户端，表示服务器也准备关闭连接。同时，服务器通知客户端：我已经没有数据要发送了。服务器进入<span class="hljs-type">LAST_ACK</span>状态。<br><br>第四次挥手（<span class="hljs-built_in">Active</span> <span class="hljs-built_in">Close</span>）：<br>客户端收到服务器的<span class="hljs-variable">FIN</span>报文后，发送一个<span class="hljs-variable">ACK</span>报文作为确认。客户端进入<span class="hljs-type">TIME_WAIT</span>状态，并等待一段时间（两个最大报文段生存时间的时间），以确保服务器接收到了<span class="hljs-variable">ACK</span>报文。<br><br>在等待时间结束后，客户端关闭了连接，进入<span class="hljs-variable">CLOSED</span>状态。服务器接收到<span class="hljs-variable">ACK</span>报文后，也关闭了连接，进入<span class="hljs-variable">CLOSED</span>状态。<br></code></pre></td></tr></table></figure><p>服务器在发送最后一个FIN报文后，并不会立即断开连接，而是进入LAST_ACK状态。在LAST_ACK状态下，服务器等待客户端发送确认的ACK报文。</p><p>在接收到客户端的确认ACK报文后，服务器才会关闭连接并进入CLOSED状态。这个过程中，服务器也需要等待一段时间以确保客户端接收到ACK报文，避免出现网络延迟或丢包导致的问题。</p><p>因此，可以说服务器在发送最后一个FIN报文后并不立即断开连接，而是等待客户端的确认ACK报文后才关闭连接。这样做是为了确保连接的正常关闭，并保证数据的可靠传输。</p><p>如果服务器最后发送的FIN报文没有收到客户端的ACK报文，那么服务器就无法确认连接已经被关闭，因此不能立即关闭连接。在这种情况下，服务器会等待一段时间（通常是2倍的最大报文段生存时间）以确认ACK报文是否丢失或者延迟到达。</p><p>如果在等待时间结束后服务器仍然没有收到客户端的ACK报文，那么服务器就会强制关闭连接。在强制关闭连接后，服务器可能会向上层应用程序或者其他系统发送错误报告或日志，以提醒管理员发现和修复问题。</p><p>需要注意的是，在正常情况下，四次挥手过程中服务器不会强制关闭连接，除非发送的FIN报文丢失或者延迟到达导致ACK报文没有及时到达。四次挥手过程中的等待时间是为了保证数据传输的可靠性和完整性，并尽可能避免数据丢失或损坏。</p><h6 id="16-滑动窗口"><a href="#16-滑动窗口" class="headerlink" title="16 滑动窗口"></a>16 滑动窗口</h6><p>mms</p><p>mss 出现三次握手前两次 告知对方发送数据最大长度<br>MTU 跟网卡有关系 一帧最大传输单元</p><h6 id="17-tcp浏览控制"><a href="#17-tcp浏览控制" class="headerlink" title="17.tcp浏览控制"></a>17.tcp浏览控制</h6><p>TCP报文窗口尺寸 发送报文者的最大缓冲区</p><p>三次握手第2次告诉<br>发送流程</p><h6 id="18-tcp状态"><a href="#18-tcp状态" class="headerlink" title="18.tcp状态"></a>18.tcp状态</h6><p>概念图</p><p><img src="https://xiehongfeng100.github.io/images/network/tcp/tcp-state-transition-diagram/tcp-state-transition-diagram.png" alt="img"></p><p>简化图</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a94aadf6633e7592243edbc0c03244a6.png" alt="img"></p><p>简化图未考虑特殊情况</p><p>netstat 命令（了解)</p><h6 id="19-什么是套接字"><a href="#19-什么是套接字" class="headerlink" title="19 什么是套接字"></a>19 什么是套接字</h6><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-number">1</span>.客户端与服务端 如何靠sock进行通信<br>服务器端的返回的套接字是不是客户端的套接字<br><br>服务器端<br>创建监听套接字<span class="hljs-keyword">socket</span> 绑定<span class="hljs-keyword">bind</span> 监听 <span class="hljs-keyword">listen</span> 提取<span class="hljs-keyword">accept</span><br>客户端<br>创建链接套接字 链接<br><br><span class="hljs-keyword">socket</span> 是用来实现网络传输功能的，它负责不同主机进程之间的网络通信连接<br><span class="hljs-number">1</span>.寻找<br>结构体<br><br>ip+端口 实现进程通信<br><span class="hljs-number">2</span>.协议选择<br><br>创建多个数据结构继承sock<br><br>例如 负责udp协议 udp_sock<br><br><span class="hljs-number">3</span>.sock<br>sock进行网络传输,对网卡进行操作 需在内核中 我们将各类sock封装成文件 并返回一个文件句柄 fd<br>使得应用层可以靠文件句柄进行操作<br><br>接口 <span class="hljs-keyword">send</span> <span class="hljs-keyword">bind</span> <span class="hljs-keyword">listen</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">recv</span><br><br>处在用户态的程序通过 <span class="hljs-keyword">socket</span> 提供的接口，将网络传输的这部分工作外包给了 Linux 内核<br><br><span class="hljs-number">4</span>.总结sock是什么<br>sock是处于内核的一种数据结构 用来实现网络传输<br>因为协议不同 衍生了各类sock<br>同时sock会在linux中生成为文件 提高接口<br><br>应用层<br>创建sock 绑定文件描述符 让应用层可以调用接口<br></code></pre></td></tr></table></figure><h6 id="20-总结"><a href="#20-总结" class="headerlink" title="20.总结"></a>20.总结</h6><p>一年前学习的网络基础，同时大部分笔记图片消失，Io复用基于的cpp不进行探究</p><p>但是一年前讲cpp的老师也是选择讲java的一个人</p><h4 id="Java-数据交换"><a href="#Java-数据交换" class="headerlink" title="Java 数据交换"></a>Java 数据交换</h4><p>I&#x2F;O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能，Java 共支持 3 种网络编程的&#x2F;IO 模型：<strong>BIO、NIO、AIO</strong><br>实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的I&#x2F;O模型</p><h5 id="1-bio"><a href="#1-bio" class="headerlink" title="1.bio"></a>1.bio</h5><p>同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器<br>端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111001207.png" alt="image-20241106111001207"></p><h5 id="2-nio"><a href="#2-nio" class="headerlink" title="2.nio"></a>2.nio</h5><p>Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注<br>册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求就进行处理 【简单示意图】</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111045351.png" alt="image-20241106111045351"></p><h5 id="3-aio"><a href="#3-aio" class="headerlink" title="3.aio"></a>3.aio</h5><p>Java AIO(NIO.2) ： 异步 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较<br>多且连接时间较长的应用</p><h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111251206.png" alt="image-20241106111251206"></p><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><h5 id="Bio介绍"><a href="#Bio介绍" class="headerlink" title="Bio介绍"></a>Bio介绍</h5><ul><li>Java BIO 就是传统的 java io  编程，其相关的类和接口在 java.io</li><li>BIO(blocking I&#x2F;O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需<br>要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器).</li></ul><h5 id="bio工作机制"><a href="#bio工作机制" class="headerlink" title="bio工作机制"></a>bio工作机制</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107102941646.png" alt="image-20241107102941646"></p><p>对 对 BIO  编程流程的梳理</p><ol><li><p>服务器端启动一个 <strong>ServerSocket</strong>，注册端口，调用accpet方法监听客户端的Socket连接。</p><p>绑定 监听  提取 读写 </p></li><li><p>客户端启动 <strong>Socket</strong> 对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</p><p>链接 读写</p></li></ol><h5 id="bio编程实例回顾"><a href="#bio编程实例回顾" class="headerlink" title="bio编程实例回顾"></a>bio编程实例回顾</h5><p>​网络编程的基本模型是Client&#x2F;Server模型，也就是两个进程之间进行相互通信<strong>，其中服务端提供位置信（绑定IP地址和端口）</strong>，<strong>客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。</strong></p><p>​传统的同步阻塞模型开发中，服务端ServerSocket负责绑定IP地址，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。<br>​ 基于BIO模式下的通信，<strong>客户端 - 服务端是完全同步，完全耦合的</strong>。 </p><h6 id="1-单行发送"><a href="#1-单行发送" class="headerlink" title="1.单行发送"></a>1.单行发送</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ser&quot;</span>);<br>        <span class="hljs-comment">//注册</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//注册端口</span><br>            ServerSocket sersocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>            <span class="hljs-comment">//等待链接</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">soccket</span> <span class="hljs-operator">=</span> sersocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>);<br>            <span class="hljs-comment">//拿取输入流</span><br>            InputStream is=soccket.getInputStream();<br>            <span class="hljs-comment">//转字节</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">//读取数据</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>            &#125;<br><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cli</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//链接服务器</span><br>        System.out.println(<span class="hljs-string">&quot;cli&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>            System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>            <span class="hljs-comment">//转字符</span><br>           <span class="hljs-comment">// BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os));</span><br>            <span class="hljs-comment">///FilterOutputStream继承</span><br>            PrintStream ps=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br>            ps.println(<span class="hljs-string">&quot;你好&quot;</span>);<br>            ps.flush();<br><br><br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<span class="hljs-comment">//异常规范1 捕捉详细异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-comment">//输出流发送信息</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketException</span>: Connection reset<br>at oenday<span class="hljs-selector-class">.ser</span><span class="hljs-selector-class">.main</span>(ser<span class="hljs-selector-class">.java</span>:<span class="hljs-number">33</span>)<br>Caused by: java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketException</span>: Connection reset<br>at java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketInputStream</span><span class="hljs-selector-class">.read</span>(SocketInputStream<span class="hljs-selector-class">.java</span>:<span class="hljs-number">209</span>)<br>at java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketInputStream</span><span class="hljs-selector-class">.read</span>(SocketInputStream<span class="hljs-selector-class">.java</span>:<span class="hljs-number">141</span>)<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.cs</span><span class="hljs-selector-class">.StreamDecoder</span><span class="hljs-selector-class">.readBytes</span>(StreamDecoder<span class="hljs-selector-class">.java</span>:<span class="hljs-number">284</span>)<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.cs</span><span class="hljs-selector-class">.StreamDecoder</span><span class="hljs-selector-class">.implRead</span>(StreamDecoder<span class="hljs-selector-class">.java</span>:<span class="hljs-number">326</span>)<br>at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.cs</span><span class="hljs-selector-class">.StreamDecoder</span><span class="hljs-selector-class">.read</span>(StreamDecoder<span class="hljs-selector-class">.java</span>:<span class="hljs-number">178</span>)<br>at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.InputStreamReader</span><span class="hljs-selector-class">.read</span>(InputStreamReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">184</span>)<br>at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.BufferedReader</span><span class="hljs-selector-class">.fill</span>(BufferedReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">161</span>)<br>at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.BufferedReader</span><span class="hljs-selector-class">.readLine</span>(BufferedReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">324</span>)<br>at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.BufferedReader</span><span class="hljs-selector-class">.readLine</span>(BufferedReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">389</span>)<br>at oenday<span class="hljs-selector-class">.ser</span><span class="hljs-selector-class">.main</span>(ser<span class="hljs-selector-class">.java</span>:<span class="hljs-number">26</span>)<br><br></code></pre></td></tr></table></figure><p>双方没有规范退出</p><h6 id="2-多行发送"><a href="#2-多行发送" class="headerlink" title="2.多行发送"></a>2.多行发送</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cli</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//链接服务器</span><br>        System.out.println(<span class="hljs-string">&quot;cli&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>            System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>            <span class="hljs-comment">//转字符</span><br>           <span class="hljs-comment">// BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os));</span><br>            <span class="hljs-comment">///FilterOutputStream继承</span><br>            PrintStream ps=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                System.out.print(<span class="hljs-string">&quot;请说:&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<span class="hljs-comment">//异常规范1 捕捉详细异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-comment">//输出流发送信息</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-接收多个客户端-多线程"><a href="#3-接收多个客户端-多线程" class="headerlink" title="3.接收多个客户端-多线程"></a>3.接收多个客户端-多线程</h6><p>改造思路</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107104749199.png" alt="image-20241107104749199"></p><p>写法1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ser&quot;</span>);<br>        <span class="hljs-comment">//注册</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//注册端口</span><br>            ServerSocket sersocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>            <span class="hljs-comment">//等待链接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">soccket</span> <span class="hljs-operator">=</span> sersocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>+soccket.getInetAddress());<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>                 <span class="hljs-keyword">private</span> <span class="hljs-type">Socket</span> <span class="hljs-variable">socketInstance</span> <span class="hljs-operator">=</span> soccket;<br>                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                     <span class="hljs-keyword">try</span> &#123;<br>                         <span class="hljs-comment">//拿取输入流</span><br>                         InputStream is=soccket.getInputStream();<br>                         <span class="hljs-comment">//转字节</span><br>                         <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>                         <span class="hljs-comment">//读取数据</span><br>                         String msg;<br>                         <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                             System.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>                         &#125;<br><br>                     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                     &#125;<br>                 &#125;<br>             &#125;.start();<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写法2</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerReadThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Socket</span> socket;<br>    <span class="hljs-type">ServerReadThread</span>(<span class="hljs-type">Socket</span> socket) &#123;<br>        <span class="hljs-keyword">this</span>.socket=socket;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public void run() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//拿取输入流</span><br>            <span class="hljs-type">InputStream</span> is=socket.getInputStream();<br>            <span class="hljs-comment">//转字节</span><br>            <span class="hljs-type">BufferedReader</span> br = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(is));<br>            <span class="hljs-comment">//读取数据</span><br>            <span class="hljs-type">String</span> msg;<br>            <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">IOException</span> e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;==服务器的启动==&quot;</span>);<br>        <span class="hljs-comment">// （1）注册端口</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">7777</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReadThread</span>(socket).start();<br>            System.out.println(socket.getRemoteSocketAddress()+<span class="hljs-string">&quot;上线了！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题</p><ul><li>1.每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；</li><li>2.每个线程都会占用栈空间和CPU资源；</li><li>3.并不是每个socket都进行IO操作，无意义的线程处理；  </li><li>4.客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</li></ul><h6 id="4-伪异步IO"><a href="#4-伪异步IO" class="headerlink" title="4.伪异步IO"></a>4.伪异步IO</h6><p>​在上述案例中：客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</p><p>​接下来我们采用一个伪异步I&#x2F;O的通信框架，</p><p>采用线程池和任务队列实现</p><p>当客户端接入时，将客户端的Socket封装成一个Task(该任务实现java.lang.Runnable线程任务接口)交给后端的线程池中进行处理。</p><p>JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p>图示如下:</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107110025257.png" alt="image-20241107110025257"></p><p>线程池</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerSocketThreadPool</span> &#123;<br>    <span class="hljs-keyword">private</span> ExecutorService executor;<br>    <span class="hljs-built_in">HandlerSocketThreadPool</span>(<span class="hljs-type">int</span> maxPoolSize,<span class="hljs-type">int</span> queueSize) &#123;<br>        <span class="hljs-keyword">this</span>.executor=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadPoolExecutor</span>(<br>                maxPoolSize,<span class="hljs-comment">//最大线程数</span><br>                maxPoolSize,<span class="hljs-comment">//活跃线程数</span><br>                <span class="hljs-number">120L</span><span class="hljs-comment">//线程空闲时间</span><br>                ,  TimeUnit.SECONDS,<span class="hljs-comment">//时间单位</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBlockingQueue</span>&lt;Runnable&gt;(queueSize)<span class="hljs-comment">//队列长度</span><br>        );<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.executor.<span class="hljs-built_in">execute</span>(r);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>服务端编写</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderClientRunnable</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Runnable</span></span></span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    ReaderClientRunnable(Socket socket) &#123;<br>        <span class="hljs-built_in">this</span>.socket=socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void run() &#123;<br>        <span class="hljs-comment">//拿取输入流</span><br>        InputStream <span class="hljs-keyword">is</span>= <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">is</span> = socket.getInputStream();<br>            BufferedReader br = <span class="hljs-keyword">new</span><span class="hljs-type"></span> BufferedReader(<span class="hljs-keyword">new</span><span class="hljs-type"></span> InputStreamReader(<span class="hljs-keyword">is</span>));<br>            <span class="hljs-comment">//读取数据</span><br>            <span class="hljs-keyword">String</span> msg;<br>            <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> RuntimeException(e);<br>        &#125;<br><br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ser</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;ser&quot;</span>);<br>        <span class="hljs-comment">//注册</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//注册端口</span><br>            ServerSocket sersocket=<span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);<br>            HandlerSocketThreadPool handlerSocketThreadPool =<br>                    <span class="hljs-keyword">new</span> HandlerSocketThreadPool(<span class="hljs-number">3</span>, <span class="hljs-number">1000</span>);<br>            <span class="hljs-comment">//等待链接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                Socket soccket = sersocket.accept();<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;链接成功&quot;</span>+soccket.getInetAddress());<br>                handlerSocketThreadPool.execute(<span class="hljs-keyword">new</span> ReaderClientRunnable(soccket));<br><br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。</li><li>如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的i&#x2F;o消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。</li></ul><h6 id="5-bio文件传递"><a href="#5-bio文件传递" class="headerlink" title="5.bio文件传递"></a>5.bio文件传递</h6><p>cli</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cli</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Socket socket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>            <span class="hljs-comment">//打开文件输入流</span><br>            InputStream is=<span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;D:\\调试信息.txt&quot;</span>);<br>            DataOutputStream dos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataOutputStream</span>(socket.<span class="hljs-built_in">getOutputStream</span>());<br>            dos.<span class="hljs-built_in">writeUTF</span>(<span class="hljs-string">&quot;.txt&quot;</span>);<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span>((len=is.<span class="hljs-built_in">read</span>(buffer))&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                dos.<span class="hljs-built_in">write</span>(buffer,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            dos.<span class="hljs-built_in">flush</span>();<br>            Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br><br><br>        &#125; <span class="hljs-built_in">catch</span> (IOException | InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ser</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ServerReaderThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    ServerReaderThread(Socket socket)<br><br>    &#123;<br>        <span class="hljs-keyword">this</span>.socket = socket;<br><br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(socket.getInputStream());<br>            String suffx=dis.readUTF();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;服务端已经成功接收到了文件类型：&quot;</span> + suffx);<br>            OutputStream <span class="hljs-keyword">out</span>=<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;I:\\mp3&quot;</span>);<br>            <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-built_in">int</span> len;<br>            <span class="hljs-keyword">while</span>((len=dis.read(buffer))&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">out</span>.write(buffer,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            <span class="hljs-keyword">out</span>.close();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;服务端接收文件保存成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(clientSocket).run();<br><br><br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-端口转发思想"><a href="#6-端口转发思想" class="headerlink" title="6.端口转发思想"></a>6.端口转发思想</h6><p>需求：需要实现一个客户端的消息可以发送给<strong>所有的客户端去接收</strong>。（群聊实现）</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107112959220.png" alt="image-20241107112959220"></p><p>客户端接收文件</p><p>服务端</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">List&lt;Socket&gt; sockets <span class="hljs-operator">=</span> new ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//不排除自己</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>           &#123;<br>               Socket clientSocket = serverSocket.accept();<br>               sockets.<span class="hljs-keyword">add</span>(clientSocket);<br>               <span class="hljs-keyword">new</span> ServerReaderThread(sockets,clientSocket).run();<br><br>           &#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>&#123;<br><span class="hljs-comment">//clientsocket获取输入流</span><br><span class="hljs-comment">//循环往sockets写获取到的输入流</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>NIO支持面<strong>向缓冲区</strong>的、基于<strong>通道</strong>的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO</p><p>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</p><p>NIO 有三大核心部分：<strong>Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</strong></p><p>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p><p>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来,根据实际情况，可以分配20 或者 80个线程来处理。不像之前的阻塞 IO 那样，非得分配 1000 个。</p><p>* </p><ul><li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</li><li>BIO 是阻塞的，NIO 则是非阻塞的</li><li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道<br>读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111103809430.png" alt="image-20241111103809430"></p><h5 id="Nio三大核心"><a href="#Nio三大核心" class="headerlink" title="Nio三大核心"></a>Nio三大核心</h5><h6 id="1-Buffer缓冲区"><a href="#1-Buffer缓冲区" class="headerlink" title="1.Buffer缓冲区"></a>1.Buffer缓冲区</h6><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer API更加容易操作和管理。</p><h6 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2.Channel"></a>2.Channel</h6><p>Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output)读写通常是单向的。 通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。</p><h6 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3.Selector"></a>3.Selector</h6><p>Selector是 一个Java NIO组件，可以能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104002133.png" alt="image-20241111104002133"></p><ul><li>每个 channel 都会对应一个 Buffer</li><li>一个线程对应Selector ， 一个Selector对应多个 channel(连接)</li><li>程序切换到哪个 channel 是由事件决定的</li><li>Selector 会根据不同的事件，在各个通道上切换</li><li><strong>Buffer 就是一个内存块 ， 底层是一个数组</strong></li><li>数据的读取写入是通过 Buffer完成的 , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。</li><li>Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。</li><li>通道表示打开到 IO 设备(例如：文件、 套接字)的连接。</li><li>若需要使用 NIO 系统，需要获取 用于连接 IO 设备的通道以及用于容纳数据的缓冲 区。</li><li>然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</li></ul><h5 id="Nio-Buffer"><a href="#Nio-Buffer" class="headerlink" title="Nio-Buffer"></a>Nio-Buffer</h5><h6 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h6><p>一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104159852.png" alt="image-20241111104159852"></p><h6 id="2-子类及本身"><a href="#2-子类及本身" class="headerlink" title="2.子类及本身"></a>2.子类及本身</h6><p><strong>Buffer</strong> 就像一个数组，可以保存多个相同类型的数据。根 据数据类型不同 ，有以下 Buffer 常用子类： </p><ul><li>ByteBuffer </li><li>CharBuffer </li><li>ShortBuffer </li><li>IntBuffer </li><li>LongBuffer </li><li>FloatBuffer </li><li>DoubleBuffer</li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> XxxBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> : 创建一个容量为capacity 的 XxxBuffer 对象<br></code></pre></td></tr></table></figure><h6 id="3-基本属性"><a href="#3-基本属性" class="headerlink" title="3.基本属性"></a>3.基本属性</h6><p>Buffer 中的重要概念： </p><p><strong>容量 (capacity)</strong> ：作为一个内存块，Buffer具有一定的固定大小，也称为”容量”，缓冲区容量不能为负，并且创建后不能更改。 </p><p><strong>限制 (limit)<strong>：表示缓冲区中可以操作数据的大小</strong>（limit 后数据不能进行读写）</strong>。缓冲区的限制不能为负，并且不能大于其容量。 <strong>写入模式，限制等于buffer的容量。读取模式下，limit等于写入的数据量</strong>。</p><p><strong>位置 (position)<strong>：</strong>下一个要读取或写入的数据的索引</strong>。缓冲区的位置不能为 负，并且不能大于其限制 </p><p>**标记 (mark)与重置 (reset)**：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position.</p><p><strong>标记、位置、限制、容量遵守以下不变式： 0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104624115.png" alt="image-20241111104624115"></p><h6 id="4-常见方法"><a href="#4-常见方法" class="headerlink" title="4.常见方法"></a>4.常见方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs j">Buffer clear() 清空缓冲区并返回对缓冲区的引用<br>Buffer flip() 为 将缓冲区的界限设置为当前位置，并将当前位置充值为 0<br>int capacity() 返回 Buffer 的 capacity 大小<br>boolean hasRemaining() 判断缓冲区中是否还有元素<br>int limit() 返回 Buffer 的界限(limit) 的位置<br>Buffer limit(int n) 将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象<br>Buffer mark() 对缓冲区设置标记<br>int position() 返回缓冲区的当前位置 position<br>Buffer position(int n) 将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象<br>int remaining() 返回 position 和 limit 之间的元素个数<br>Buffer reset() 将位置 position 转到以前设置的 mark 所在的位置<br>Buffer rewind() 将位置设为为 0， 取消设置的 mark<br></code></pre></td></tr></table></figure><h6 id="5-缓冲区数据操作"><a href="#5-缓冲区数据操作" class="headerlink" title="5.缓冲区数据操作"></a>5.缓冲区数据操作</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Buffer 所有子类提供了两个用于数据操作的方法：<span class="hljs-built_in">get</span>()<span class="hljs-built_in">put</span>() 方法<br>取获取 Buffer中的数据<br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">()</span></span> ：读取单个字节<br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(byte[] dst)</span></span>：批量读取多个字节到 dst 中<br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(int index)</span></span>：读取指定索引位置的字节(不会移动 <span class="hljs-attribute">position</span>)<br>    <br>放到 入数据到 Buffer 中 中<br><span class="hljs-function"><span class="hljs-title">put</span><span class="hljs-params">(byte b)</span></span>：将给定单个字节写入缓冲区的当前位置<br><span class="hljs-function"><span class="hljs-title">put</span><span class="hljs-params">(byte[] src)</span></span>：将 <span class="hljs-attribute">src</span> 中的字节写入缓冲区的当前位置<br><span class="hljs-function"><span class="hljs-title">put</span><span class="hljs-params">(int index, byte b)</span></span>：将指定字节写入缓冲区的索引位置(不会移动 <span class="hljs-attribute">position</span>)<br></code></pre></td></tr></table></figure><p><strong>使用Buffer读写数据一般遵循以下四个步骤：</strong></p><ul><li>1.写入数据到Buffer</li><li>2.调用flip()方法，转换为读取模式  &#x2F;&#x2F;&#x2F;为 将缓冲区的界限设置为当前位置，并将当前位置充值为 0</li><li>3.从Buffer中读取数据</li><li>4.调用buffer.clear()方法或者buffer.compact()方法清除缓冲区</li></ul><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111105239984.png" alt="image-20241111105239984"></strong></p><h6 id="6-案例演示"><a href="#6-案例演示" class="headerlink" title="6.案例演示"></a>6.案例演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> nio1;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBuffer</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//分配直接缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);<br>        System.out.println(buf.isDirect());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据读取</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itheima&quot;</span>;<br><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        buf.put(str.getBytes());<br><br>        <span class="hljs-comment">///开启读</span><br>        buf.flip();<br>        <span class="hljs-comment">//缓冲区的大小</span><br>        <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>        buf.get(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>        <span class="hljs-comment">//返回当前位置 position</span><br>        System.out.println(buf.position());<br><br>        <span class="hljs-comment">//mark() : 标记</span><br>        buf.mark();<br><br>        buf.get(dst, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>        <span class="hljs-comment">//返回当前位置 position</span><br>        System.out.println(buf.position());<br><br>        <span class="hljs-comment">//reset() : 恢复到 mark 的位置</span><br>        buf.reset();<br>        System.out.println(buf.position());<br><br>        <span class="hljs-comment">//判断缓冲区中是否还有剩余数据</span><br>        <span class="hljs-keyword">if</span>(buf.hasRemaining())&#123;<br>            <span class="hljs-comment">//获取缓冲区中可以操作的数量</span><br>            System.out.println(buf.remaining());<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itheima&quot;</span>;<br>        <span class="hljs-comment">//1. 分配一个指定大小的缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        System.out.println(<span class="hljs-string">&quot;-----------------allocate()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//2. 利用 put() 存入数据到缓冲区中</span><br>        buf.put(str.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;-----------------put()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//3. 切换读取数据模式</span><br>        buf.flip();<br>        System.out.println(<span class="hljs-string">&quot;-----------------flip()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//4. 利用 get() 读取缓冲区中的数据</span><br>        <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>        buf.get(dst);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, dst.length));<br><br>        System.out.println(<span class="hljs-string">&quot;-----------------get()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br>        <span class="hljs-comment">//5. rewind() : 可重复读</span><br>        buf.rewind();<br>        System.out.println(<span class="hljs-string">&quot;-----------------rewind()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span><br>        buf.clear();<br>        System.out.println(<span class="hljs-string">&quot;-----------------clear()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br>        System.out.println((<span class="hljs-type">char</span>)buf.get());<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="7-直接与非直接缓冲区"><a href="#7-直接与非直接缓冲区" class="headerlink" title="7.直接与非直接缓冲区"></a>7.直接与非直接缓冲区</h6><p>什么是直接内存与非直接内存</p><p>根据官方文档的描述：</p><p><strong><code>byte byffer</code>可以是两种类型，一种是基于直接内存（也就是非堆内存）</strong>；</p><p>另一种是非直接内存（也就是堆内存）。</p><p>对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。</p><p>从数据流的角度，非直接内存是下面这样的作用链：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">本地IO</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">非直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">本地IO</span><br></code></pre></td></tr></table></figure><p>而直接内存是：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">本地IO</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">本地IO</span><br></code></pre></td></tr></table></figure><p>很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用<strong>allocateDirect</strong>创建，但是它比申请普通的堆内存需要耗费更高的性能。不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以呢，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect()  方法来确定。</p><p><strong>使用场景</strong></p><ul><li>1 有很大的数据需要存储，它的生命周期又很长</li><li>2 适合频繁的IO操作，比如网络并发场景</li></ul><h5 id="Nio-channel"><a href="#Nio-channel" class="headerlink" title="Nio-channel"></a>Nio-channel</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h6><p>通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互。</p><p>1、 NIO 的通道类似于流，但有些区别如下：</p><ul><li><p>通道可以同时进行读写，而流只能读或者只能写</p></li><li><p>通道可以实现异步读写数据</p></li><li><p>通道可以从缓冲读数据，也可以写数据到缓冲:</p></li></ul><p>2、BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)<br>  是双向的，可以读操作，也可以写操作。</p><p>3、Channel 在 NIO 中是一个接口</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Channel</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Closeable</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h6 id="2-channel实现类"><a href="#2-channel实现类" class="headerlink" title="2.channel实现类"></a>2.channel实现类</h6><ul><li><p><strong>FileChannel</strong>：用于读取、写入、映射和操作文件的通道。</p></li><li><p><strong>DatagramChannel</strong>：通过 UDP 读写网络中的数据通道。</p></li><li><blockquote><p><strong>SocketChannel</strong>：通过 TCP 读写网络中的数据。</p></blockquote></li><li><p><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 <strong>SocketChannel</strong>。 <strong>【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</strong></p></li></ul><h6 id="3-FileChannel类"><a href="#3-FileChannel类" class="headerlink" title="3.FileChannel类"></a>3.FileChannel类</h6><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket<br>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道</li></ul><h6 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(ByteBuffer dst)</span> 从 从  Channel 到 中读取数据到  ByteBuffer<br><span class="hljs-type">long</span>  <span class="hljs-title function_">read</span><span class="hljs-params">(ByteBuffer[] dsts)</span> 将 将  Channel 到 中的数据“分散”到  ByteBuffer[]<br><span class="hljs-type">int</span>  <span class="hljs-title function_">write</span><span class="hljs-params">(ByteBuffer src)</span> 将 将  ByteBuffer 到 中的数据写入到  Channel<br><span class="hljs-type">long</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ByteBuffer[] srcs)</span> 将 将  ByteBuffer[] 到 中的数据“聚集”到  Channel<br><span class="hljs-type">long</span> <span class="hljs-title function_">position</span><span class="hljs-params">()</span> 返回此通道的文件位置<br>FileChannel <span class="hljs-title function_">position</span><span class="hljs-params">(<span class="hljs-type">long</span> p)</span> 设置此通道的文件位置<br><span class="hljs-type">long</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> 返回此通道的文件的当前大小<br>FileChannel <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">long</span> s)</span> 将此通道的文件截取为给定大小<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">force</span><span class="hljs-params">(<span class="hljs-type">boolean</span> metaData)</span> 强制将所有对此通道的文件更新写入到存储设备中<br></code></pre></td></tr></table></figure><h6 id="5-本地读写文件"><a href="#5-本地读写文件" class="headerlink" title="5.本地读写文件"></a>5.本地读写文件</h6><p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,黑马Java程序员！” 写入到 data.txt 中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1、字节输出流通向目标文件</span><br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>            <span class="hljs-comment">// 2、得到字节输出流对应的通道Channel</span><br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> fos.getChannel();<br>            <span class="hljs-comment">// 3、分配缓冲区</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            buffer.put(<span class="hljs-string">&quot;hello,黑马Java程序员！&quot;</span>.getBytes());<br>            <span class="hljs-comment">// 4、把缓冲区切换成写出模式</span><br>            buffer.flip();<br>            channel.write(buffer);<br>            channel.close();<br>            System.out.println(<span class="hljs-string">&quot;写数据到文件中！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>本地读</p><p>1.获取输入流  获取通道 </p><p>2.开辟缓存区-将通道数据传到缓冲区</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Test</span><br><span class="hljs-function"> <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> throws Exception </span>&#123;<br>     <span class="hljs-comment">// 1、定义一个文件字节输入流与源文件接通</span><br>     FileInputStream is = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>     <span class="hljs-comment">// 2、需要得到文件字节输入流的文件通道</span><br>     FileChannel channel = is.<span class="hljs-built_in">getChannel</span>();<br>     <span class="hljs-comment">// 3、定义一个缓冲区</span><br>     ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">1024</span>);<br>     <span class="hljs-comment">// 4、读取数据到缓冲区</span><br>     channel.<span class="hljs-built_in">read</span>(buffer);<br>     buffer.<span class="hljs-built_in">flip</span>();<br>     <span class="hljs-comment">// 5、读取出缓冲区中的数据并输出即可</span><br>     <span class="hljs-type">String</span> rs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(buffer.<span class="hljs-built_in">array</span>(),<span class="hljs-number">0</span>,buffer.<span class="hljs-built_in">remaining</span>());<br>     System.out.<span class="hljs-built_in">println</span>(rs);<br><br> &#125;<br></code></pre></td></tr></table></figure><h6 id="6-文件拷贝完成"><a href="#6-文件拷贝完成" class="headerlink" title="6.文件拷贝完成"></a>6.文件拷贝完成</h6><p>使用 FileChannel(通道) ，完成文件的拷贝。</p><p>1.打开文件&#x3D;&gt;获取输入流&#x3D;&gt;获取通道</p><p>2.打开文件 &#x3D;&gt;获取输出流&#x3D;&gt;获取通道</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 源文件</span><br>  <span class="hljs-type">File</span> srcFile <span class="hljs-operator">=</span> new <span class="hljs-type">File</span>(<span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>dlei<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>BIO,NIO,AIO<span class="hljs-subst">\\</span>文件<span class="hljs-subst">\\</span>壁纸.jpg&quot;</span>);<br>  <span class="hljs-type">File</span> destFile <span class="hljs-operator">=</span> new <span class="hljs-type">File</span>(<span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>dlei<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>BIO,NIO,AIO<span class="hljs-subst">\\</span>文件<span class="hljs-subst">\\</span>壁纸new.jpg&quot;</span>);<br>  <span class="hljs-comment">// 得到一个字节字节输入流</span><br>  <span class="hljs-type">FileInputStream</span> fis <span class="hljs-operator">=</span> new <span class="hljs-type">FileInputStream</span>(srcFile);<br>  <span class="hljs-comment">// 得到一个字节输出流</span><br>  <span class="hljs-type">FileOutputStream</span> fos <span class="hljs-operator">=</span> new <span class="hljs-type">FileOutputStream</span>(destFile);<br>  <span class="hljs-comment">// 得到的是文件通道</span><br>  <span class="hljs-type">FileChannel</span> isChannel <span class="hljs-operator">=</span> fis.getChannel();<br>  <span class="hljs-type">FileChannel</span> osChannel <span class="hljs-operator">=</span> fos.getChannel();<br></code></pre></td></tr></table></figure><p>3.开辟缓冲区&#x3D;&gt;1往缓冲区赛值 &#x3D;&gt;2往缓冲区放值-写入</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 分配缓冲区<br>  ByteBuffer buffer <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-comment">// 必须先清空缓冲然后再写入数据到缓冲区</span><br>      buffer.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-comment">// 开始读取一次数据</span><br>      <span class="hljs-type">int</span> flag = isChannel.<span class="hljs-built_in">read</span>(buffer);<br>      <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>)&#123;<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 已经读取了数据 ，把缓冲区的模式切换成可读模式</span><br>      buffer.<span class="hljs-built_in">flip</span>();<br>      <span class="hljs-comment">// 把数据写出到</span><br>      osChannel.<span class="hljs-built_in">write</span>(buffer);<br>  &#125;<br>  isChannel.<span class="hljs-built_in">close</span>();<br>  osChannel.<span class="hljs-built_in">close</span>();<br>  System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;复制完成！&quot;</span>);<br></code></pre></td></tr></table></figure><h6 id="7-分散和聚合"><a href="#7-分散和聚合" class="headerlink" title="7.分散和聚合"></a>7.分散和聚合</h6><p>分散读取（Scatter ）:是指把<strong>Channel通道</strong>的数据<strong>读入到多个缓冲区</strong>中去</p><p>聚集写入（Gathering ）是指将<strong>多个 Buffer 中的数据“聚集”到 Channel</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>       <span class="hljs-comment">//1. 获取通道</span><br>       <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel1</span> <span class="hljs-operator">=</span> raf1.getChannel();<br><br>       <span class="hljs-comment">//2. 分配指定大小的缓冲区</span><br>       <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">100</span>);<br>       <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>       <span class="hljs-comment">//3. 分散读取</span><br>       ByteBuffer[] bufs = &#123;buf1, buf2&#125;;<br>       channel1.read(bufs);<br><br>       <span class="hljs-keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;<br>           byteBuffer.flip();<br>       &#125;<br><br>       System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufs[<span class="hljs-number">0</span>].array(), <span class="hljs-number">0</span>, bufs[<span class="hljs-number">0</span>].limit()));<br>       System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>       System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufs[<span class="hljs-number">1</span>].array(), <span class="hljs-number">0</span>, bufs[<span class="hljs-number">1</span>].limit()));<br><br>       <span class="hljs-comment">//4. 聚集写入</span><br>       <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>       <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel2</span> <span class="hljs-operator">=</span> raf2.getChannel();<br><br>       channel2.write(bufs);<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药�</span><br><span class="hljs-section">-----------------</span><br>��谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁<br></code></pre></td></tr></table></figure><h6 id="8-transferFrom"><a href="#8-transferFrom" class="headerlink" title="8.transferFrom()"></a>8.transferFrom()</h6><p>从目标通道中去复制原通道数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1、字节输入管道</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">isChannel</span> <span class="hljs-operator">=</span> is.getChannel();<br>    <span class="hljs-comment">// 2、字节输出流管道</span><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;data03.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">osChannel</span> <span class="hljs-operator">=</span> fos.getChannel();<br>    <span class="hljs-comment">// 3、复制</span><br>    osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());<br>    isChannel.close();<br>    osChannel.close();<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="9-transferTo"><a href="#9-transferTo" class="headerlink" title="9.transferTo()"></a>9.transferTo()</h6><p>把原通道数据复制到目标通道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1、字节输入管道</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">isChannel</span> <span class="hljs-operator">=</span> is.getChannel();<br>    <span class="hljs-comment">// 2、字节输出流管道</span><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;data04.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">osChannel</span> <span class="hljs-operator">=</span> fos.getChannel();<br>    <span class="hljs-comment">// 3、复制</span><br>    isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);<br>    isChannel.close();<br>    osChannel.close();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Nio-选择器-Selector"><a href="#Nio-选择器-Selector" class="headerlink" title="Nio-选择器 Selector"></a>Nio-选择器 Selector</h5><h6 id="1-选择器介绍"><a href="#1-选择器介绍" class="headerlink" title="1.选择器介绍"></a>1.选择器介绍</h6><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111135338630.png" alt="image-20241111135338630"></p><ul><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <strong>Selector</strong>(选择器)</li><li>Selector <strong>能够检测多个注册的通道上是否有事件发生</strong>(注意:<strong>多个 Channel 以事件的方式可以注册到同一个</strong><br><strong>Selector</strong>)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管<br>理多个通道，也就是管理多个连接和请求。</li><li>只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都<br>创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul><h6 id="2-选择器应用"><a href="#2-选择器应用" class="headerlink" title="2.选择器应用"></a>2.选择器应用</h6><p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 获取通道</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><span class="hljs-comment">//2. 切换非阻塞模式</span><br>ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//3. 绑定连接</span><br>ssChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9898</span>));<br><span class="hljs-comment">//4. 获取选择器</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span><br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><p> 当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey  的四个常量 表示）：</p><ul><li>读 : SelectionKey.OP_READ （1）</li><li>写 : SelectionKey.OP_WRITE （4）</li><li>连接 : SelectionKey.OP_CONNECT （8）</li><li>接收 : SelectionKey.OP_ACCEPT （16）</li><li>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</li></ul><h5 id="nio网络通信解析"><a href="#nio网络通信解析" class="headerlink" title="nio网络通信解析"></a>nio网络通信解析</h5><p>Selector 示意图和特点说明</p><p>Selector可以实现： 一个 I&#x2F;O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I&#x2F;O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111140153891.png" alt="image-20241111140153891"></p><p>服务端流程</p><p>当客户端连接服务端时，服务端会通过 ServerSocketChannel 得到 SocketChannel：</p><ol><li>获取通道</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ServerSocketChannel ssChannel <span class="hljs-operator">=</span> ServerSocketChannel.open()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2、切换非阻塞模式</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ssChannel.configureBlocking(false)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3、绑定连接</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ssChannel.bind(new InetSocketAddress(<span class="hljs-number">9999</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>4.获取选择器</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p>5、 将通道注册到选择器上, 并且指定“监听接收事件”</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">ssChannel.<span class="hljs-keyword">register</span>(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><p>6.轮询式的获取选择器上已经“准备就绪”的事件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//轮询式的获取选择器上已经“准备就绪”的事件</span><br> <span class="hljs-keyword">while</span> (selector.<span class="hljs-keyword">select</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;轮一轮&quot;</span>);<br>        <span class="hljs-comment">//7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span><br>        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-comment">//8. 获取准备“就绪”的是事件</span><br>            SelectionKey sk = it.next();<br>            <span class="hljs-comment">//9. 判断具体是什么事件准备就绪</span><br>            <span class="hljs-keyword">if</span> (sk.isAcceptable()) &#123;<br>                <span class="hljs-comment">//10. 若“接收就绪”，获取客户端连接</span><br>                SocketChannel sChannel = ssChannel.accept();<br>                <span class="hljs-comment">//11. 切换非阻塞模式</span><br>                sChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">//12. 将该通道注册到选择器上</span><br>                sChannel.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sk.isReadable()) &#123;<br>                <span class="hljs-comment">//13. 获取当前选择器上“读就绪”状态的通道</span><br>                SocketChannel sChannel = (SocketChannel) sk.channel();<br>                <span class="hljs-comment">//14. 读取数据</span><br>                ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="hljs-number">0</span>) &#123;<br>                    buf.flip();<br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));<br>                    buf.clear();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//15. 取消选择键 SelectionKey</span><br>            it.<span class="hljs-keyword">remove</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><p>1.获取通道</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">SocketChannel sChannel = SocketChannel.<span class="hljs-keyword">open</span>(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2.切换非阻塞模式</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">sChannel.configureBlocking(false)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3.分配指定大小的缓冲区</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuffer buf <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>4.发送数据给服务端</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Scanner scan = <span class="hljs-built_in">new</span> Scanner(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>);<br><span class="hljs-keyword">while</span>(scan.hasNext())&#123;<br>String str = scan.nextLine();<br>buf.put((<span class="hljs-built_in">new</span> SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(<span class="hljs-keyword">System</span>.currentTimeMillis())<br>+ &quot;\n&quot; + str).getBytes());<br>buf.flip();<br>sChannel.<span class="hljs-keyword">write</span>(buf);<br>buf.clear();<br>&#125;<br>//关闭通道<br>sChannel.<span class="hljs-keyword">close</span>();<br></code></pre></td></tr></table></figure><h5 id="nio网络通信案例代码"><a href="#nio网络通信案例代码" class="headerlink" title="nio网络通信案例代码"></a>nio网络通信案例代码</h5><p>ser</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">nioser</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerSocketChannel ssChannel=   ServerSocketChannel.<span class="hljs-built_in">open</span>();<br>            ssChannel.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            ssChannel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>            Selector selector = Selector.<span class="hljs-built_in">open</span>();<br>            ssChannel.<span class="hljs-built_in">register</span>(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-keyword">while</span> (selector.<span class="hljs-built_in">select</span>()&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                Iterator&lt;SelectionKey&gt; key = selector.<span class="hljs-built_in">selectedKeys</span>().<span class="hljs-built_in">iterator</span>();<br>                <span class="hljs-keyword">while</span> (key.<span class="hljs-built_in">hasNext</span>())<br>                &#123;<br>                    SelectionKey selKey = key.<span class="hljs-built_in">next</span>();<br>                    <span class="hljs-keyword">if</span>(selKey.<span class="hljs-built_in">isAcceptable</span>())<br>                    &#123;<br>                        SocketChannel sChannel =  ssChannel.<span class="hljs-built_in">accept</span>();<br>                        sChannel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                        sChannel.<span class="hljs-built_in">register</span>(selector,SelectionKey.OP_READ);<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;有新链接上线了&quot;</span>);<br><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selKey.<span class="hljs-built_in">isReadable</span>())<br>                    &#123;<br>                        SocketChannel sChannel = (SocketChannel) selKey.<span class="hljs-built_in">channel</span>();<br><br>                        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">while</span>((len=sChannel.<span class="hljs-built_in">read</span>(buffer))&gt;<span class="hljs-number">0</span>)<br>                        &#123;<br>                            buffer.<span class="hljs-built_in">flip</span>();<br>                            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(buffer.<span class="hljs-built_in">array</span>(),<span class="hljs-number">0</span>,len));<br>                            buffer.<span class="hljs-built_in">clear</span>();<br><br>                        &#125;<br>                    &#125;<br>                    key.<span class="hljs-built_in">remove</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>cli</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">public class niocli &#123;<br><br>    public static void main(String[] args) throws Exception&#123;<br>        SocketChannel <span class="hljs-keyword">sch=SocketChannel.open(new </span>InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>));<br>        <span class="hljs-keyword">sch.configureBlocking(false);</span><br><span class="hljs-keyword"></span>        <span class="hljs-keyword">ByteBuffer </span><span class="hljs-keyword">buf=ByteBuffer.allocate(1024);</span><br><span class="hljs-keyword"></span>        <span class="hljs-keyword">Scanner </span><span class="hljs-keyword">scan </span>= new <span class="hljs-keyword">Scanner(System.in);</span><br><span class="hljs-keyword"></span>        while (<span class="hljs-keyword">scan.hasNext())&#123;</span><br><span class="hljs-keyword"></span>            String str=<span class="hljs-keyword">scan.nextLine();</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">buf.put(str.getBytes());</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">buf.flip();</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">sch.write(buf);</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">buf.clear();</span><br><span class="hljs-keyword"></span>        &#125;<br>        <span class="hljs-keyword">sch.close();</span><br><span class="hljs-keyword"></span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="nio群聊系统"><a href="#nio群聊系统" class="headerlink" title="nio群聊系统"></a>nio群聊系统</h5><ul><li>编写一个 NIO 群聊系统，实现客户端与客户端的通信需求（非阻塞）</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 channel 可以无阻塞发送消息给其它所有客户端用户，同时可以接受其它客户端用户通过服务端转发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-comment">//定义属性</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> ServerSocketChannel ssChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">9999</span>;<br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//初始化工作</span><br>    Server()&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ssChannel=ServerSocketChannel.open();<br>            ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            ssChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.net.InetSocketAddress(PORT));<br>            selector=Selector.open();<br>            ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-comment">//监听</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listen</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;开始一轮事件处理~~~&quot;</span>);<br>                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>                <span class="hljs-keyword">while</span>(it.hasNext())<br>                &#123;<br>                 SelectionKey selectionKey=  it.next();<br>                 <span class="hljs-keyword">if</span>(selectionKey.isAcceptable())<br>                 &#123;<br>                     <span class="hljs-comment">// 10、直接获取当前接入的客户端通道</span><br>                     <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">schannel</span> <span class="hljs-operator">=</span> ssChannel.accept();<br>                     <span class="hljs-comment">// 11 、切换成非阻塞模式</span><br>                     schannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                     <span class="hljs-comment">// 12、将本客户端通道注册到选择器</span><br>                     System.out.println(schannel.getRemoteAddress() + <span class="hljs-string">&quot; 上线 &quot;</span>);<br>                     schannel.register(selector , SelectionKey.OP_READ);<br>                     <span class="hljs-comment">//提示</span><br>                 &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(selectionKey.isReadable())<br>                 &#123;<br>                     <span class="hljs-comment">//处理读 (专门写方法..)</span><br>                     readData(selectionKey);<br>                 &#125;<br><br>                &#125;<br><br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readData</span><span class="hljs-params">(SelectionKey sk)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel= (SocketChannel) sk.channel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>            <span class="hljs-comment">//根据count的值做处理</span><br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//把缓存区的数据转成字符串</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array());<br>                <span class="hljs-comment">//输出该消息</span><br>                System.out.println(<span class="hljs-string">&quot;form 客户端: &quot;</span> + msg);<br>                <span class="hljs-comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span><br>                sendInfoToOtherClients(msg, channel);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)<br>        &#123; <br>            System.out.println(channel.getRemoteAddress() + <span class="hljs-string">&quot; 离线了..&quot;</span>);<br>            e.printStackTrace();<br>            <span class="hljs-comment">//取消注册</span><br>            sk.cancel();<br>            <span class="hljs-comment">//关闭通道</span><br>            channel.close();<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器转发消息中...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span><br>        <span class="hljs-keyword">for</span>(SelectionKey key: selector.keys()) &#123;<br>            <span class="hljs-comment">//通过 key  取出对应的 SocketChannel</span><br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">targetChannel</span> <span class="hljs-operator">=</span> key.channel();<br>            <span class="hljs-comment">//排除自己</span><br>            <span class="hljs-keyword">if</span>(targetChannel <span class="hljs-keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != channel) &#123;<br>                <span class="hljs-comment">//转型</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> (SocketChannel)targetChannel;<br>                <span class="hljs-comment">//将msg 存储到buffer</span><br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msg.getBytes());<br>                <span class="hljs-comment">//将buffer 的数据写入 通道</span><br>                dest.write(buffer);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建服务器对象</span><br>        <span class="hljs-type">Server</span> <span class="hljs-variable">groupChatServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>        groupChatServer.listen();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>cli</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-comment">//定义相关的属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HOST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <span class="hljs-comment">// 服务器的ip</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">9999</span>; <span class="hljs-comment">//服务器端口</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">//构造器, 完成初始化工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        selector = Selector.open();<br>        <span class="hljs-comment">//连接服务器</span><br>        socketChannel = socketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, PORT));<br>        <span class="hljs-comment">//设置非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//将channel 注册到selector</span><br>        socketChannel.register(selector, SelectionKey.OP_READ);<br>        <span class="hljs-comment">//得到username</span><br>        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);<br>        System.out.println(username + <span class="hljs-string">&quot; is ok...&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendInfo</span><span class="hljs-params">(String info)</span> &#123;<br>        info = username + <span class="hljs-string">&quot; 说：&quot;</span> + info;<br>        <span class="hljs-keyword">try</span> &#123;<br>            socketChannel.write(ByteBuffer.wrap(info.getBytes()));<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//读取从服务器端回复的消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">readChannels</span> <span class="hljs-operator">=</span> selector.select();<br>            <span class="hljs-keyword">if</span>(readChannels &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有可以用的通道</span><br><br>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                    <span class="hljs-keyword">if</span>(key.isReadable()) &#123;<br>                        <span class="hljs-comment">//得到相关的通道</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-comment">//得到一个Buffer</span><br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-comment">//读取</span><br>                        sc.read(buffer);<br>                        <span class="hljs-comment">//把读到的缓冲区的数据转成字符串</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array());<br>                        System.out.println(msg.trim());<br>                    &#125;<br>                &#125;<br>                iterator.remove(); <span class="hljs-comment">//删除当前的selectionKey, 防止重复操作</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span><br><br>            &#125;<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//启动我们客户端</span><br>        <span class="hljs-type">Client</span> <span class="hljs-variable">chatClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br>        <span class="hljs-comment">//启动一个线程, 每个3秒，读取从服务器发送数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    chatClient.readInfo();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);<br>                    &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-comment">//发送数据给服务器端</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            chatClient.sendInfo(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Aio"><a href="#Aio" class="headerlink" title="Aio"></a>Aio</h4><p>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">AIO</span><br>异步非阻塞，基于<span class="hljs-variable">NIO</span>的，可以称之为<span class="hljs-variable">NIO2</span><span class="hljs-number">.0</span><br>    <span class="hljs-variable">BIO</span>                   <span class="hljs-variable">NIO</span>                              <span class="hljs-variable">AIO</span>        <br><span class="hljs-built_in">Socket</span>                <span class="hljs-variable">SocketChannel</span>                    <span class="hljs-variable">AsynchronousSocketChannel</span><br><span class="hljs-variable">ServerSocket</span>          <span class="hljs-variable">ServerSocketChannel</span>       <span class="hljs-variable">AsynchronousServerSocketChannel</span><br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">与NIO不同，当进行读写操作时，只须直接调用API的<span class="hljs-built_in">read</span>或<span class="hljs-built_in">write</span>方法即可, 这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入<span class="hljs-built_in">read</span>方法的缓冲区,对于写操作而言，当操作系统将<span class="hljs-built_in">write</span>方法传递的流写入完毕时，操作系统主动通知应用程序<br><br>即可以理解为，<span class="hljs-built_in">read</span>/<span class="hljs-built_in">write</span>方法都是异步的，完成后会主动调用回调函数。在JDK1<span class="hljs-number">.7</span>中，这部分内容被称作NIO<span class="hljs-number">.2</span>，主要在Java.nio.channels包下增加了下面四个异步通道：<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AsynchronousSocketChannel</span><br><span class="hljs-attribute">AsynchronousServerSocketChannel</span><br><span class="hljs-attribute">AsynchronousFileChannel</span><br><span class="hljs-attribute">AsynchronousDatagramChannel</span><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>BIO、NIO、AIO：</strong></p><ul><li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li><li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li></ul><p><strong>BIO、NIO、AIO适用场景分析:</strong></p><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。Netty!</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jvm 垃圾回收篇</title>
    <link href="/2024/11/06/java%20jvm/%E5%9F%BA%E7%A1%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <url>/2024/11/06/java%20jvm/%E5%9F%BA%E7%A1%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm垃圾回收"><a href="#jvm垃圾回收" class="headerlink" title="jvm垃圾回收"></a>jvm垃圾回收</h1><h3 id="了解垃圾回收"><a href="#了解垃圾回收" class="headerlink" title="了解垃圾回收"></a>了解垃圾回收</h3><h6 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1.内存泄漏"></a>1.内存泄漏</h6><p>内存泄漏指 不在使用的对象没有进行回收</p><p>例如cpp-new-delete过去</p><p>java特性-对象自动回收-就减少内存泄漏</p><h6 id="2-java的内存管理"><a href="#2-java的内存管理" class="headerlink" title="2.java的内存管理"></a>2.java的内存管理</h6><p>java-引入了自动回收</p><p>通过垃圾回收器对不在使用的对象进行回收-主要是对堆上的内存进行回收</p><p>垃圾回收的作用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106084915250.png" alt="image-20241106084915250"></p><h6 id="3-方法区的回收选择"><a href="#3-方法区的回收选择" class="headerlink" title="3.方法区的回收选择"></a>3.方法区的回收选择</h6><p>那么垃圾回收器需要负责对哪些部分的内存进行回收呢？</p><p>首先是线程不共享的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。</p><p>–再不死线程内的资源-就需要回收</p><p>方法除外-方外会自动将开辟的空间置空循环使用</p><hr><p>方法区中能回收的内容主要就是不再使用的类。</p><hr><p>ps：方法区存储着类信息-一个从来不使用的类就可以被注销了</p><blockquote><p>回收三大条件</p><p>1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象</p><p>2、加载该类的类加载器已经被回收</p><p>3、该类对应的 java.lang.Class 对象没有在任何地方被引用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            ArrayList&lt;URLClassLoader&gt; loaders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            ArrayList&lt;Object&gt; objs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>               <span class="hljs-comment">// 通过类记载器加载自己指定类</span><br>               <br>                <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:H:\\java jvm\\test01\\target\\classes&quot;</span>)&#125;);<br>                Class&lt;?&gt; clazz = loader.loadClass(<span class="hljs-string">&quot;Student&quot;</span>);<br>                System.gc();<br>            &#125;<br></code></pre></td></tr></table></figure><p>如上</p><p>死循环-本质就是jmp跳-所以的数据的指向-会在下一次循环被置空 满足回收条件</p><hr><p>那么类卸载主要用在什么场景下呢？</p><p>开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。</p><p>每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p><h3 id="对象回收判断算法"><a href="#对象回收判断算法" class="headerlink" title="对象回收判断算法"></a>对象回收判断算法</h3><h5 id="1-可达分析算法"><a href="#1-可达分析算法" class="headerlink" title="1.可达分析算法"></a>1.可达分析算法</h5><p>Java使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。</p><p>案例</p><p>下图中A到B再到C和D，形成了一个引用链，可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就不可被回收。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106085455514.png" alt="image-20241106085455514"></p><p>哪些对象被称之为GC Root对象呢？</p><ul><li><strong>线程Thread对象</strong>，引用线程栈帧中的方法参数、局部变量等。</li><li><strong>系统类加载器加载的java.lang.Class对象</strong>，引用类中的静态变量。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106085512796.png" alt="image-20241106085512796"></p><p><strong>监视器对象，用来保存同步锁synchronized关键字持有的对象。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106085519943.png" alt="image-20241106085519943"></p><p><strong>本地方法调用时使用的全局对象。</strong></p><p>GC   root查看</p><p>通过arthas和eclipse Memory Analyzer (MAT) 工具可以查看GC Root，MAT工具是eclipse推出的Java堆内存检测工具。具体操作步骤如下：</p><p>1、使用arthas的heapdump命令将堆内存快照保存到本地磁盘中。</p><p>2、使用MAT工具打开堆内存快照文件。</p><p>3、选择GC Roots功能查看所有的GC Root。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106085535079.png" alt="image-20241106085535079"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106085539142.png" alt="image-20241106085539142"></p><h5 id="2-引用记数法"><a href="#2-引用记数法" class="headerlink" title="2.引用记数法"></a>2.引用记数法</h5><p>引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。</p><p>比如下图中，对象A的计数器初始为0，局部变量a1对它引用之后，计数器加1就变成了1。同样A对B产生了引用，B的计数器也是1。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106085841574.png" alt="image-20241106085841574"></p><p>引用计数法的优点是实现简单，C++中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点：</p><p>1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响</p><p>2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。</p><p>循环引用问题探究</p><p>由于A和B之间存在互相引用，所以计数器都为1，两个对象都不能被回收。但是由于没有局部变量对这两个代码产生引用，代码中已经无法访问到这两个对象，理应可以被回收。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106090047018.png" alt="image-20241106090047018"></p><p>Java并未采用该计数法</p><h3 id="对象引用探究"><a href="#对象引用探究" class="headerlink" title="对象引用探究"></a>对象引用探究</h3><h5 id="1-软引用"><a href="#1-软引用" class="headerlink" title="1.软引用"></a>1.软引用</h5><p>软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。</p><p>如下图中，对象A被GC Root对象强引用了，同时我们创建了一个软引用SoftReference对象（它本身也是一个对象），软引用对象中引用了对象A。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106090245386.png" alt="image-20241106090245386"></p><p>接下来强引用被去掉之后，对象A暂时还是处于不可回收状态，因为有软引用存在并且内存还够用。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106090307209.png" alt="image-20241106090307209"></p><p>如果内存出现不够用的情况，对象A就处于可回收状态，可以被垃圾回收器回收。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106090314970.png" alt="image-20241106090314970"></p><p>作用</p><p>缓存-当内存够用提供快速访问 内存不够用就清理掉-不影响操作</p><p><strong>软引用对象本身，也需要被强引用，否则软引用对象也会被回收掉。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106090343675.png" alt="image-20241106090343675"></p><p>代码案例</p><p>软引用的执行过程如下：</p><p>1.将对象使用软引用包装起来，new SoftReference&lt;对象类型&gt;(对象)。</p><p>2.内存不足时，虚拟机尝试进行垃圾回收。</p><p>3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。</p><p>4.如果依然内存不足，抛出OutOfMemory异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">softReference</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>];<br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(bytes);<br>        bytes = <span class="hljs-literal">null</span>;<br>        System.out.println(softReference.get());<br>        <span class="hljs-type">byte</span>[] bytes2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>];<br>        System.out.println(softReference.get());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>softReference怎么回收呢</strong></p><p>1、软引用创建时，通过构造器传入引用队列</p><p>2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列</p><p>3、通过代码遍历引用队列，将SoftReference的强引用删除</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">softReference</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//软引用</span><br>        ArrayList&lt;SoftReference&gt; softReferences=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//队列</span><br>        ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queues=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        &#123;<br>            <span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span>  <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">100</span>];<br>            <span class="hljs-comment">//传递数据和队列 -再数据消失时 将队列加载进队列中</span><br>            SoftReference studentRef=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;<span class="hljs-type">byte</span>[]&gt;(bytes,queues);<br>            softReferences.add(studentRef);<br>        &#125;<br>        <span class="hljs-comment">//200m内存-也就是没循环一次就会gc一个软引用</span><br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;ref=<span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((ref = (SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;) queues.poll()) != <span class="hljs-literal">null</span>) &#123;<br>            count++;<br>        &#125;<br>        System.out.println(count);<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-弱引用"><a href="#2-弱引用" class="headerlink" title="2.弱引用"></a>2.弱引用</h5><p>弱引用的整体机制和软引用基本一致，<strong>区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收</strong>。在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">softReference</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">//软引用</span><br>      <span class="hljs-built_in">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">100</span>];<br>        ReferenceQueue&lt;<span class="hljs-built_in">byte</span>[]&gt; queues=<span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br>      <span class="hljs-comment">//参数2就是队列</span><br>        WeakReference&lt;<span class="hljs-built_in">byte</span>[]&gt; weakReference=<span class="hljs-keyword">new</span> WeakReference&lt;&gt;(bytes,queues);<br>      bytes=<span class="hljs-literal">null</span>;<br><br>        System.gc();<br>        System.<span class="hljs-keyword">out</span>.println(weakReference.<span class="hljs-keyword">get</span>());<br>        System.<span class="hljs-keyword">out</span>.println(weakReference);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-虚引用-终结器引用"><a href="#3-虚引用-终结器引用" class="headerlink" title="3.虚引用 终结器引用"></a>3.虚引用 终结器引用</h5><ul><li><p><strong>虚引用</strong>（也叫幽灵引用）是一种特殊的引用类型，它的作用是：<strong>当对象被垃圾回收器回收时，能够收到通知。但不能通过虚引用访问到对象本身</strong>。虚引用常用于直接内存的管理，帮助垃圾回收器及时知道内存中不再使用的对象，以便回收内存。在Java中，虚引用是通过 <code>PhantomReference</code> 类实现的。</p><p><strong>终结器引用</strong> <strong>是一种在对象准备被垃圾回收时，能够执行特殊操作的引用类型。当对象即将被回收时，终结器引用会把对象放入一个叫做“引用队列”的地方。稍后，由一个专门的线程（<code>FinalizerThread</code>）从队列中取出这些对象，并执行它们的 <code>finalize</code> 方法。在这个方法中，可以做一些清理工作，例如释放资源。但是，不推荐在 <code>finalize</code> 方法中使用强引用来重新引用对象，因为这可能导致内存泄漏。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminatorReference</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TerminatorReference reference=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;当前对象还存活&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//直接强引用自救</span><br>            System.out.println(<span class="hljs-string">&quot;finalize()执行了...&quot;</span>);<br>            <span class="hljs-comment">//设置强引用自救</span><br>            reference = <span class="hljs-built_in">this</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">super</span>.finalize();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminatorReference</span>();<br>            test();<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        reference=<span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//被清除-会执行自救</span><br>        System.gc();<br>        <span class="hljs-comment">//执行finalize方法的优先级比较低，休眠500ms等待一下</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">if</span> (reference != <span class="hljs-literal">null</span>) &#123;<br>            reference.alive();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;对象已被回收&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><strong>对哪些对象需要回收进行标记的算法</strong></p><h5 id="1-算法历史"><a href="#1-算法历史" class="headerlink" title="1.算法历史"></a>1.算法历史</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106091530893.png" alt="image-20241106091530893"></p><h5 id="2-算法效率探究"><a href="#2-算法效率探究" class="headerlink" title="2.算法效率探究"></a>2.算法效率探究</h5><p>Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程 停止时间就是STW</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106091543623.png" alt="image-20241106091543623"></p><blockquote><p>为什么一定有STW</p><p>在GC过程中，所有的应用程序线程都会被暂停，直到GC完成。这个机制的出现主要是为了确保垃圾回收器能够在不被其他线程干扰的情况下，对堆内存进行操作。</p><p>1.内存的安全操作</p><ol start="2"><li><strong>确保一致性</strong></li><li><strong>对象的引用清理</strong></li><li><strong>避免内存泄漏和误回收</strong></li><li><strong>JVM的一致性要求</strong></li></ol></blockquote><p>1.吞吐量</p><p>吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 &#x3D; 执行用户代码时间 &#x2F;（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高</p><p>2.最大暂停时间</p><p>用户进行GC的最大时间</p><p>3.堆使用效率</p><p><strong>不同垃圾回收算法，对堆内存的使用方式是不同的。</strong></p><p>1.标记内存-可以使用整个堆内存</p><p>2.复制算法 每次只能使用一般内存</p><h5 id="3-标记清除算法"><a href="#3-标记清除算法" class="headerlink" title="3.标记清除算法"></a>3.标记清除算法</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2339917-20210928133755704-1878053182.gif" alt="img"></p><p>1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。</p><p>2.清除阶段，从内存中删除没有被标记也就是非存活对象。</p><p><strong>优点</strong> </p><p>优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。</p><p><strong>缺点</strong></p><p>1.碎片化问题 </p><p>由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。</p><p>2.分配速度慢</p><p>由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。</p><p> 我们需要用一个链表来维护，哪些空间可以分配对象，很有可能需要遍历这个链表到最后，才能发现这块空间足够我们去创建一个对象。</p><h5 id="4-复制算法"><a href="#4-复制算法" class="headerlink" title="4.复制算法"></a>4.复制算法</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2339917-20210928133814345-705702370.gif" alt="img"></p><p>优点：</p><ul><li>吞吐量高，复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动</li><li>不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。</li></ul><p>缺点：</p><p><strong>内存使用效率低，每次只能让一半的内存空间来为创建对象使用。</strong></p><p>流程</p><p>1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。–一半内存消耗</p><p>对象A首先分配在From空间：</p><p>2.在垃圾回收GC阶段，将From中存活对象复制到To空间。– 对象转移</p><p>在垃圾回收阶段，如果对象A存活，就将其复制到To空间。然后将From空间直接清空。</p><p>3.将两块空间的From和To名字互换。</p><p>接下来将两块空间的名称互换，下次依然在From空间上创建对象。</p><h5 id="5-标记整理算法"><a href="#5-标记整理算法" class="headerlink" title="5.标记整理算法"></a>5.标记整理算法</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2339917-20210928133823716-1397860580.gif" alt="img"></p><p>标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。</p><p>优缺点</p><p>优点：</p><ul><li>内存使用效率高，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存</li><li>不会发生碎片化，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间</li></ul><p>缺点：</p><p><strong>整理阶段的效率不高</strong></p><p>核心思想分为两个阶段：</p><p>1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。</p><p>2.整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。-堆的移动</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106092949767.png" alt="image-20241106092949767"></p><h3 id="分代垃圾回收思想"><a href="#分代垃圾回收思想" class="headerlink" title="分代垃圾回收思想"></a>分代垃圾回收思想</h3><p>现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法(Generational GC)。</p><p>特色分区</p><p>分代垃圾回收将整个内存区域划分为年轻代和老年代：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093041662.png" alt="image-20241106093041662"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093046108.png" alt="image-20241106093046108"></p><p>Eden + survivor 这两块区域组成了年轻代。</p><p>tenured_gen指的是晋升区域，其实就是老年代。</p><p>虚拟机参数</p><table><thead><tr><th>参数名</th><th>参数含义</th><th>示例</th></tr></thead><tbody><tr><td>-Xms</td><td>设置堆的最小和初始大小，必须是1024倍数且大于1MB</td><td>比如初始大小6MB的写法： -Xms6291456 -Xms6144k -Xms6m</td></tr><tr><td>-Xmx</td><td>设置最大堆的大小，必须是1024倍数且大于2MB</td><td>比如最大堆80 MB的写法： -Xmx83886080 -Xmx81920k -Xmx80m</td></tr><tr><td>-Xmn</td><td>新生代的大小</td><td>新生代256 MB的写法： -Xmn256m -Xmn262144k -Xmn268435456</td></tr><tr><td>-XX:SurvivorRatio</td><td>伊甸园区和幸存区的比例，默认为8 新生代1g内存，伊甸园区800MB,S0和S1各100MB</td><td>比例调整为4的写法：-XX:SurvivorRatio&#x3D;4</td></tr><tr><td>-XX:+PrintGCDetailsverbose:gc</td><td>打印GC日志</td><td>无</td></tr></tbody></table><p><strong>———算法垃圾回收流程、</strong></p><p>1、分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。</p><p>2、随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。</p><p>Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093126144.png" alt="image-20241106093126144"></p><p>3、接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093135417.png" alt="image-20241106093135417"></p><p>此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。</p><p>注意：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093142578.png" alt="image-20241106093142578"></p><p>4、如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093148487.png" alt="image-20241106093148487"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093152184.png" alt="image-20241106093152184"></p><p>当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。</p><p>如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093202751.png" alt="image-20241106093202751"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: Java heap space<br>at jvm<span class="hljs-selector-class">.softReference</span><span class="hljs-selector-class">.main</span>(softReference<span class="hljs-selector-class">.java</span>:<span class="hljs-number">21</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>为什么分区</p><p>为什么分代GC算法要把堆分成年轻代和老年代？首先我们要知道堆内存中对象的特性：</p><ul><li>系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。</li><li>老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。</li><li>在虚拟机的默认设置中，新生代大小要远小于老年代的大小。</li></ul><p>减少gc时间-老年代的一般都是不会被释放掉的</p><p>分代GC算法将堆分成年轻代和老年代主要原因有：</p><p>1、可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。</p><p>2、新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。</p><p>3、分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW时间就会减少。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器是垃圾回收算法的具体实现。</p><p>垃圾回收器分为年轻代和老年代，除了G1之外其他垃圾回收器必须成对组合进行使用。</p><p>具体的关系图如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106093404794.png" alt="image-20241106093404794"></p><h5 id="1-Serial-serial-old-单线程"><a href="#1-Serial-serial-old-单线程" class="headerlink" title="1.Serial-serial old  单线程"></a>1.Serial-serial old  单线程</h5><p>1.年轻代组合</p><p>Serial是是一种单线程串行回收年轻代的垃圾回收器。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171034719.png" alt="image-20241106171034719"></p><p><strong>回收算法：</strong> 复制算法</p><p><strong>优点</strong></p><p>单CPU处理器下吞吐量非常出色</p><p><strong>缺点</strong></p><p>多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</p><p><strong>适用场景</strong></p><p>Java编写的客户端程序或者硬件配置有限的场景</p><p>老年代 SerialOld垃圾回收器</p><p>SerialOld是Serial垃圾回收器的老年代版本，采用单线程串行回收</p><p>-XX:+UseSerialGC 新生代、老年代都使用串行回收器。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171108123.png" alt="image-20241106171108123"></p><p>算法 标记整理算法</p><p><strong>优点</strong></p><p>单CPU处理器下吞吐量非常出色</p><p><strong>缺点</strong></p><p>多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待</p><p><strong>适用场景</strong></p><p>与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用</p><h5 id="2-parNew-cms-年轻并发-老并行"><a href="#2-parNew-cms-年轻并发-老并行" class="headerlink" title="2.parNew-cms 年轻并发 老并行"></a>2.parNew-cms 年轻并发 老并行</h5><p>1.年轻代parNew</p><p><strong>ParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收</strong></p><p>-XX:+UseParNewGC 新生代使用ParNew回收器， 老年代使用串行回收器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171134722.png" alt="image-20241106171134722"></p><p>复制算法</p><p><strong>优点</strong></p><p>多CPU处理器下停顿时间较短</p><p><strong>缺点</strong></p><p>吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用</p><p><strong>适用场景</strong></p><p> JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用</p><p>2.老年代 cms</p><p>CMS垃圾回收器关注的是系统的暂停时间，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。</p><p>参数：XX:+UseConcMarkSweepGC</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171152034.png" alt="image-20241106171152034"></p><p>老年代</p><p>标记清除算法</p><p><strong>优点</strong></p><p>系统由于垃圾回收出现的停顿时间较短，用户体验好</p><p><strong>缺点</strong></p><p>1、内存碎片问题</p><p>2、退化问题</p><p>3、浮动垃圾问题</p><p><strong>适用场景</strong></p><p> 大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等</p><p>CMS执行步骤：</p><p>1.初始标记，用极短的时间标记出GC Roots能直接关联到的对象。</p><p>2.并发标记,   标记所有的对象，用户线程不需要暂停。</p><p>3.重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。</p><p>4.并发清理，清理死亡的对象，用户线程不需要暂停。</p><p>缺点：</p><p>1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction&#x3D;N 参数（默认0）调整N次Full GC之后再整理。</p><p>2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。</p><p>3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。</p><p>并发线程数：</p><p>在CMS中并发阶段运行时的线程数可以通过-XX:ConcGCThreads参数设置，默认值为0，由系统计算得出。</p><p>计算公式为(-XX:ParallelGCThreads定义的线程数 + 3) &#x2F; 4， ParallelGCThreads是STW停顿之后的并行线程数</p><p>ParallelGCThreads是由处理器核数决定的：</p><p>  1、当cpu核数小于8时，ParallelGCThreads &#x3D; CPU核数</p><p>  2、否则 ParallelGCThreads &#x3D; 8 + (CPU核数 – 8 )*5&#x2F;8 </p><p>我的电脑上逻辑处理器有12个，所以ParallelGCThreads  &#x3D;  8 + （12 - 8）* 5&#x2F;8 &#x3D; 10，ConcGCThreads &#x3D; (-XX:ParallelGCThreads定义的线程数 + 3) &#x2F; 4 &#x3D; （10 + 3） &#x2F; 4 &#x3D; 3</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171300643.png" alt="image-20241106171300643"></p><p>最终可以得到这张图：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171308964.png" alt="image-20241106171308964"></p><p>并发标记和并发清理阶段，会使用3个线程并行处理。重新标记阶段会使用10个线程处理。</p><p>由于CPU的核心数有限，并发阶段会影响用户线程执行的性能。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171319587.png" alt="image-20241106171319587"></p><h5 id="3-Parallel-parallel-old-年轻并发-自动调整堆大小-老年并发"><a href="#3-Parallel-parallel-old-年轻并发-自动调整堆大小-老年并发" class="headerlink" title="3.Parallel  parallel old 年轻并发(自动调整堆大小) 老年并发"></a>3.Parallel  parallel old 年轻并发(自动调整堆大小) 老年并发</h5><p>1.年轻代</p><p>Parallel Scavenge是JDK8默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。<strong>具备自动调整堆内存大小的特点。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171426482.png" alt="image-20241106171426482"></p><p>复制算法</p><p><strong>优点</strong></p><p><strong>吞吐量高，而且手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数</strong></p><p><strong>缺点</strong></p><p>不能保证单次的停顿时间</p><p><strong>适用场景</strong></p><p>后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出</p><p><strong>常用参数：</strong></p><p>Parallel Scavenge允许手动设置最大暂停时间和吞吐量。Oracle官方建议在使用这个组合时，不要设置堆内存的最大值，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小。</p><ul><li>最大暂停时间，<code>-XX:MaxGCPauseMillis=n</code> 设置每次垃圾回收时的最大停顿毫秒数</li><li>吞吐量，<code>-XX:GCTimeRatio=n</code> 设置吞吐量为n（用户线程执行时间 &#x3D; n&#x2F;n + 1）</li><li>自动调整内存大小, <code>-XX:+UseAdaptiveSizePolicy</code>设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小</li></ul><p>老年代</p><p>arallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。</p><p>参数： -XX:+UseParallelGC  或</p><p>​           -XX:+UseParallelOldGC可以使用Parallel Scavenge + Parallel Old这种组合。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171452187.png" alt="image-20241106171452187"></p><p><strong>回收年代和算法：</strong></p><p>老年代</p><p>标记-整理算法</p><p><strong>优点</strong></p><p>并发收集，在多核CPU下效率较高</p><p><strong>缺点</strong></p><p>暂停时间会比较长</p><p><strong>适用场景</strong></p><p>与Parallel Scavenge配套使用</p><h3 id="g1垃圾回收期"><a href="#g1垃圾回收期" class="headerlink" title="g1垃圾回收期"></a>g1垃圾回收期</h3><h6 id="1-g1介绍"><a href="#1-g1介绍" class="headerlink" title="1.g1介绍"></a>1.g1介绍</h6><p>JDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。</p><p> <strong>Parallel Scavenge关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。CMS关注暂停时间，但是吞吐量方面会下降。</strong></p><p>G1设计目标就是将上述两种垃圾回收器的优点融合：</p><p>1.支持巨大的堆空间回收，并有较高的吞吐量。</p><p>2.支持多CPU并行垃圾回收。</p><p>3.允许用户设置最大暂停时间。</p><p>JDK9之后强烈建议使用G1垃圾回收器。</p><h6 id="2-g1空间设计"><a href="#2-g1空间设计" class="headerlink" title="2.g1空间设计"></a>2.g1空间设计</h6><p>之前都分新时代和老年代区-从内存逻辑上看还是连续的</p><p>G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。分为Eden、Survivor、Old区。</p><p>Region的大小通过堆空间大小&#x2F;2048计算得到，也可以通过参数-XX:G1HeapRegionSize&#x3D;32m指定(其中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171929990.png" alt="image-20241106171929990"></p><p>G1垃圾回收有两种方式：</p><p>1、年轻代回收（Young GC）</p><p>2、混合回收（Mixed GC）</p><h6 id="3-G1回收触发"><a href="#3-G1回收触发" class="headerlink" title="3.G1回收触发"></a>3.G1回收触发</h6><p>年轻代回收（Young GC），回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数</p><p>-XX:MaxGCPauseMillis&#x3D;n（默认200）  设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。</p><p>1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行Young GC。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106171953522.png" alt="image-20241106171953522"></p><p>2、标记出Eden和Survivor区域中的存活对象，</p><p>3、根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">//</span>最大暂停时间计算<br><span class="hljs-variable">G1</span>在进行<span class="hljs-variable">Young</span> <span class="hljs-variable">GC</span>的过程中会去记录每次垃圾回收时每个<span class="hljs-variable">Eden</span>区和<span class="hljs-variable">Survivor</span>区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个<span class="hljs-built_in">Region</span>区域了。<br>比如 <span class="hljs-operator">-</span><span class="hljs-variable">XX</span><span class="hljs-operator">:</span><span class="hljs-variable">MaxGCPauseMillis</span><span class="hljs-operator">=</span><span class="hljs-variable">n</span>（默认<span class="hljs-number">200</span>），每个<span class="hljs-built_in">Region</span>回收耗时<span class="hljs-number">40</span><span class="hljs-variable">ms</span>，那么这次回收最多只能回收<span class="hljs-number">4</span>个<span class="hljs-built_in">Region</span>。<br></code></pre></td></tr></table></figure><p>4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172011066.png" alt="image-20241106172011066"></p><p>5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172018843.png" alt="image-20241106172018843"></p><p>6、部分对象如果大小超过<strong>Region</strong>的一半，会直接放入老年代，这类老年代被称为<strong>Humongous</strong>区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。(HUmongous)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172025355.png" alt="image-20241106172025355"></p><p>7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时</p><p>（-XX:InitiatingHeapOccupancyPercent默认45%）会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172036931.png" alt="image-20241106172036931"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172041019.png" alt="image-20241106172041019"></p><h6 id="4-G1回收方法"><a href="#4-G1回收方法" class="headerlink" title="4.G1回收方法"></a>4.G1回收方法</h6><p>混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize Marking）、并发清理（cleanup）</p><p>G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage first）名称的由来。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172056643.png" alt="image-20241106172056643"></p><p>最后清理阶段使用复制算法，不会产生内存碎片。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172107827.png" alt="image-20241106172107827"></p><p>注意：如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172114954.png" alt="image-20241106172114954"></p><h6 id="5-使用g1"><a href="#5-使用g1" class="headerlink" title="5.使用g1"></a>5.使用g1</h6><p>参数1： <code>-XX:+UseG1GC</code>  打开G1的开关，JDK9之后默认不需要打开</p><p>参数2：<code>-XX:MaxGCPauseMillis=毫秒值</code> 最大暂停的时</p><p><strong>回收年代和算法：</strong></p><p>年轻代+老年代</p><p>复制算法</p><p><strong>优点</strong></p><p>对比较大的堆如超过6G的堆回收时，延迟可控</p><p>不会产生内存碎片</p><p>并发标记的SATB算法效率高</p><p><strong>缺点</strong></p><p>JDK8之前还不够成熟</p><p><strong>适用场景</strong></p><p>JDK8最新版本、JDK9之后建议默认使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chapter04.gc;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 垃圾回收器案例3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//-XX:+UseG1GC   -Xmn8g -Xmx16g -XX:SurvivorRatio=8  -XX:+PrintGCDetails -verbose:gc </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GcDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//System.out.println(++count);</span><br>            <span class="hljs-keyword">if</span>(count++ % <span class="hljs-number">10240</span> == <span class="hljs-number">0</span>)&#123;<br>                list.clear();<br>            &#125;<br><span class="hljs-comment">//            byte[] bytes = new byte[1024 * 1024 * 1];</span><br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1</span> / <span class="hljs-number">2</span>]);<br><span class="hljs-comment">//            System.gc();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个region大小为2m，一共有84个young区，26个幸存者区。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106172133667.png" alt="image-20241106172133667"></p><p>初始标记花了0.0478秒。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723819332280-62.png" alt="img"></p><p>并发标记总共耗时10ms，不会产生STW。</p><p>![img](G:\360MoveData\Users\nixg\Desktop\java Jvm\day02\assets\1723819332281-63.png)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下：</p><p>JDK8及之前：</p><p>ParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old (关注吞吐量)、 G1（JDK8之前不建议，较大堆并且关注暂停时间）</p><p>JDK9之后:</p><p>G1（默认）</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java jvm基础篇</title>
    <link href="/2024/11/04/java%20jvm/%E5%9F%BA%E7%A1%80/2024-8-5%20java%20jvm%20235412/"/>
    <url>/2024/11/04/java%20jvm/%E5%9F%BA%E7%A1%80/2024-8-5%20java%20jvm%20235412/</url>
    
    <content type="html"><![CDATA[<h1 id="jvm基础01"><a href="#jvm基础01" class="headerlink" title="jvm基础01"></a>jvm基础01</h1><p>1.jvm介绍</p><p>2.字节码文件介绍</p><p>3.字节码工具</p><p>4.类的生命周期</p><p>5.双亲委派机制</p><p>6.三种打破双亲委派机制方法</p><h3 id="jvm介绍"><a href="#jvm介绍" class="headerlink" title="jvm介绍"></a>jvm介绍</h3><h6 id="1-什么是jvm"><a href="#1-什么是jvm" class="headerlink" title="1.什么是jvm"></a>1.什么是jvm</h6><p>一份源码-hell.java-javac编译</p><p>成为字节码文件-class文件</p><p>-&gt;java虚拟机 -机器码文件能够被计算执行</p><p>在运行时将字节码转换为机器码执行。 </p><p>就是java虚拟机的作用</p><h6 id="2-即时编译"><a href="#2-即时编译" class="headerlink" title="2.即时编译"></a>2.即时编译</h6><p>-为什么java需要即时编译</p><p>cpp-编译和连接-机器码</p><p>java-class-jvm(即使编译)-机器码</p><p>再性能上不如cpp-</p><p>优点</p><p>跨平台性-只需要class满足jvm规范 那么在任何操作系统都能被使用</p><p>将字节码转机器码-</p><p>例如 一个函数-经常被执行-就将该机器码存储在内存中再次调用直接拿取 </p><p>无需转换</p><h6 id="3-jvm功能概述"><a href="#3-jvm功能概述" class="headerlink" title="3.jvm功能概述"></a>3.jvm功能概述</h6><p>1.解释和运行-对字节码中的指令转换为机器码运行</p><p>2.内存管理-自动为对象方法-等分片内存 -自动的垃圾回收机制 回收不使用对象</p><p>3.即使编译 对热点代码进行优化</p><h6 id="4-虚拟机版本"><a href="#4-虚拟机版本" class="headerlink" title="4.虚拟机版本"></a>4.虚拟机版本</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4a93a411fd36a4345d0fdd27acfcaa5b.png" alt="4a93a411fd36a4345d0fdd27acfcaa5b"></p><p>虚拟机历史</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/595e1caeadcad1f1a283e40e949f9bb9.png" alt="595e1caeadcad1f1a283e40e949f9bb9"></p><h3 id="字节码文件详解"><a href="#字节码文件详解" class="headerlink" title="字节码文件详解"></a>字节码文件详解</h3><h6 id="1-java虚拟机组成"><a href="#1-java虚拟机组成" class="headerlink" title="1.java虚拟机组成"></a>1.java虚拟机组成</h6><p>字节码-&gt;加载</p><p>类加载器 -运行时候数据区-执行引擎-本地接口</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/39cbc2414fcf975886dd8c510cc3a299.png" alt="39cbc2414fcf975886dd8c510cc3a299"></p><h6 id="2-字节码文件查看"><a href="#2-字节码文件查看" class="headerlink" title="2.字节码文件查看"></a>2.字节码文件查看</h6><p>使用jcalsslib工具-或者其他工具打开都可以</p><h6 id="3-字节码文件组成0一般信息"><a href="#3-字节码文件组成0一般信息" class="headerlink" title="3.字节码文件组成0一般信息"></a>3.字节码文件组成0一般信息</h6><p>字节码文件：可以分为以下几个部分</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d25432bd6a67508403c830e3cee2fe58.png" alt="d25432bd6a67508403c830e3cee2fe58"></p><ul><li><strong>基础信息</strong>：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息</li><li><strong>常量池****：</strong> 保存了<strong>字符串常量、类或接口名、字段名，主要在字节码指令中使用</strong></li><li><strong>字段：</strong> <strong>当前类或接口声明的字段信息</strong></li><li><strong>方法：</strong> <strong>当前类或接口声明的方法信息，核心内容为方法的字节码指令</strong></li><li><strong>属性：</strong> <strong>类的属性，比如源码的文件名、内部类的列表等</strong></li></ul><p>详细解释</p><p>基础信息</p><p>1.魔术头-对等于PE结构-决定了文件的真正属性-class-属性就是cafebabe</p><p>2.主副版本号</p><p>-值的是编译字节码的jdk版本号</p><p>主版本-标识大版本号 jdk1.0 -1.1  45-45.3</p><p>jdk1.2后-是46 每升级大版本就+1</p><p>副版本是主版本号都相同时-进行区别 </p><p>一搬都关心主版本号</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e4621cd3033cb32a51359a6e1d37d2e1.png" alt="e4621cd3033cb32a51359a6e1d37d2e1"></p><p>所有类共同父类-</p><h6 id="4-字节码常量池"><a href="#4-字节码常量池" class="headerlink" title="4.字节码常量池"></a>4.字节码常量池</h6><p>常量池内保存了字符串常量 类或接口名  字段名 -再class内存储</p><p>例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bdd45e6ba0ab876a2334b38610695310.png" alt="bdd45e6ba0ab876a2334b38610695310"></p><p>我们创建的变量 String id&#x3D;null;</p><p>id这个字段名-也存储在常量池内</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5e0f86dd0b4becc8399592ba17dde170.png" alt="5e0f86dd0b4becc8399592ba17dde170"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/725e671840ae024ba4ba1fc61b7ba96c.png" alt="725e671840ae024ba4ba1fc61b7ba96c"></p><p>还是指针思想</p><h6 id="5-方法"><a href="#5-方法" class="headerlink" title="5.方法"></a>5.方法</h6><p>例</p><p>字节码中的方法区是存放字节码指令的核心文件</p><p>字节码指令的内容存放在方法的code属性中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/312c2aa6983a87172e578e99bf795a9d.png" alt="312c2aa6983a87172e578e99bf795a9d"></p><h6 id="1-字节码阅读"><a href="#1-字节码阅读" class="headerlink" title="1.字节码阅读"></a>1.字节码阅读</h6><p>再此之前 我们要抽象出一个</p><p><strong>操作数栈(及时存放区域)</strong></p><p><strong>局部变量表</strong></p><p>再汇编内存角度来看-大家其实都在同一个栈空间内-由编译器来找到谁是谁</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iload</span>-从局部变量表值复制到栈<br><br><span class="hljs-attribute">iconst_0</span>入操作数栈栈-<br><br><span class="hljs-attribute">istore</span>-<span class="hljs-number">1</span>将操作数栈的值赋值到局部变量表 -值弹出<br><br><br><span class="hljs-attribute">iinc</span>-直接在变量表相加<br><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0130bc68cd14d60dde719775f59df6dd.png" alt="0130bc68cd14d60dde719775f59df6dd"></p><p>代码反编译</p><p>操作数 0(弹出) 0(复制)</p><p>局部变量表 main   0</p><p>​                                 1</p><p>​                                 0</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int i</span>=0;<br><span class="hljs-attribute">i</span>=i++;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b8200d935408292b8a92a59bad5892f5.png" alt="b8200d935408292b8a92a59bad5892f5"></p><p>疑问</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7ab520d97b5dba347befc249859baa8.png" alt="e7ab520d97b5dba347befc249859baa8"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>          <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br>          i++;<br>         j=j<span class="hljs-number">+1</span>;<br>         k+=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">0 iconst_0<br><span class="hljs-number"> 1 </span>istore_1<br><span class="hljs-number"> 2 </span>iconst_0<br><span class="hljs-number"> 3 </span>istore_2<br><span class="hljs-number"> 4 </span>iconst_0<br><span class="hljs-number"> 5 </span>istore_3<br> //定义变量<br><span class="hljs-number"> 6 </span>iinc<span class="hljs-number"> 1 </span>by 1<br> //i++<br><span class="hljs-number"> 9 </span>iload_2<br>10 iconst_1<br>11 iadd<br>12 istore_2<br>///j=j+1<br>13 iinc<span class="hljs-number"> 3 </span>by 1<br>//k=k+1<br>16 return<br><br></code></pre></td></tr></table></figure><h3 id="字节码工具"><a href="#字节码工具" class="headerlink" title="字节码工具"></a>字节码工具</h3><p>java-v 命令 </p><p>idea  jclasslib</p><h6 id="1-Arthas"><a href="#1-Arthas" class="headerlink" title="1.Arthas"></a>1.Arthas</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a49150ab2fff4a52a02101a46c6c507b.png" alt="a49150ab2fff4a52a02101a46c6c507b"></p><p>是一款线上监控诊断产品</p><p>通过全局视角实时查看应用load 内存 gc 线程的状态信息</p><p>监控面板</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4ae4f916159f6c15bdf6e57d0943f040.png" alt="4ae4f916159f6c15bdf6e57d0943f040"></p><p>线程区域<br>内存区域<br>运行过程信息</p><p>dump</p><p>dump命令可以将字节码文件保存到本地</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8661a914ff422a3a897c91ce38d96858.png" alt="8661a914ff422a3a897c91ce38d96858"></p><p>jad命令可以将类的字节码文件进行反编译成源代码</p><p>jad arthas.demo</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><h6 id="1-基础了解"><a href="#1-基础了解" class="headerlink" title="1.基础了解"></a>1.基础了解</h6><p>一个类再虚拟机中被加载的过程-</p><p>对此来学习类加载过程-虚拟机</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/71da608c7028defc98a2fd169274f104.png" alt="71da608c7028defc98a2fd169274f104"></p><h6 id="2-加载阶段"><a href="#2-加载阶段" class="headerlink" title="2.加载阶段"></a>2.加载阶段</h6><p>1.类加载器根据类的全限命名通过不同的渠道以二进制流获取字节码信息</p><p>2.加载完所有类后-虚拟机将<strong>字节码的信息保存到内存的方法区</strong></p><p>(生成InstancekLass对象)-&gt;保存类的信息 等等等</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/872c0501254834f8ac49434459e81f24.png" alt="872c0501254834f8ac49434459e81f24"></p><p>4.再堆中生成一份与方法区数据类似的java lang class对象</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/223d3f3ed7398915cf9dee03edf2e271.png" alt="223d3f3ed7398915cf9dee03edf2e271"></p><p>关联-也就是指针指向了对方的地址</p><p>开发者就只需要访问堆中的class对象-就无需访问方法区</p><h4 id="3-连接阶段"><a href="#3-连接阶段" class="headerlink" title="3.连接阶段"></a>3.连接阶段</h4><h6 id="1-验证阶段"><a href="#1-验证阶段" class="headerlink" title="1.验证阶段"></a>1.验证阶段</h6><p>验证是否符合规范</p><p>例 类必须有父类</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ce2015dc5f81ac8e7555d38d8f6973b9.png" alt="ce2015dc5f81ac8e7555d38d8f6973b9"></p><p>代码分析</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/96c22f3c430029122ec1e715860001b0.png" alt="96c22f3c430029122ec1e715860001b0"></p><h6 id="2-准备阶段"><a href="#2-准备阶段" class="headerlink" title="2.准备阶段"></a>2.准备阶段</h6><p>准备阶段为静态变量（static）分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6c72b9e5420c1cb7608cc07a00331e67.png" alt="6c72b9e5420c1cb7608cc07a00331e67"></p><p>再堆区开辟空间了但是没有存值</p><p><strong>final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1623962452481b73d228f7148d1c70f6.png" alt="1623962452481b73d228f7148d1c70f6"></p><p>为什么会这样</p><p><strong>因为final修饰的变量后续不会发生值的变更。</strong></p><h6 id="3-解析"><a href="#3-解析" class="headerlink" title="3.解析"></a>3.解析</h6><p>解析阶段主要是将<strong>常量池中的符号引用替换为直接引用，符号引用就是在字节码文件中使用编号来访问常量池中的内容。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723005139588-6.png" alt="1723005139588-6"></p><p>直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723005175053-11.png" alt="1723005175053-11"></p><p>a-&gt;地址-&gt;真实数据<br>a-&gt;真实数据</p><h4 id="4-初始化阶段"><a href="#4-初始化阶段" class="headerlink" title="4.初始化阶段"></a>4.初始化阶段</h4><p>初始化阶段会执行字节码文件中clinit（class init 类的初始化）方法的字节码指令，包含了静态代码块中的代码，并为静态变量赋值。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723005681468-14.png" alt="1723005681468-14"></p><ul><li>init方法，会在对象初始化时执行</li><li>main方法，主方法</li><li>clinit方法，类的初始化阶段执行</li></ul><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723005799461-17.png" alt="1723005799461-17"></p><p>代码变换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        value = <span class="hljs-number">2</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码指令的位置也会发生变化：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723005826274-20.png" alt="1723005826274-20"></p><p>最后静态变量的值就是1</p><hr><p>以下几种方式会导致类的初始化：</p><p>1.访问一个<strong>类的静态变量或者静态方法</strong>，注意变量是<strong>final修饰的并且等号右边是常量不会触发初始化。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package jvm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>       mq.<span class="hljs-title function_">cats</span>();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mq</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">String</span> value = <span class="hljs-string">&quot;ass&quot;</span>;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>    <span class="hljs-built_in">void</span>   <span class="hljs-title function_">cats</span>(<span class="hljs-params"></span>)<br><br>    &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;我是cats函数&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.调用Class.forName(String className)。</strong></p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">Class</span>&lt;?&gt; aClass =  <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;jvm.mq&quot;</span>)<span class="hljs-comment">;</span><br><span class="hljs-comment">//反射插眼</span><br></code></pre></td></tr></table></figure><p>3.new一个该类的对象时。</p><p>4.执行Main方法的当前类。</p><p>添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类</p><hr><hr><p>clinit不会执行的几种情况</p><p>1.无静态代码块且无静态变量赋+值语句。</p><p>2.有静态变量的声明，但是没有赋值语句。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723006795305-23.png" alt="1723006795305-23"></p><p>3.静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723006795305-24.png" alt="1723006795305-24"></p><h4 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h4><h6 id="1-类加载器的作用"><a href="#1-类加载器的作用" class="headerlink" title="1.类加载器的作用"></a>1.类加载器的作用</h6><p>对类的加载-虚拟机有多套类加载器选择</p><p>类加载器将加载过程中的字节码获取并加载到内存</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723007347098-29.png" alt="1723007347098-29"></p><p>类加载器-通过二进制流记载字节码内容-将数据交给java虚拟机-由虚拟机在方法区和堆上生成对应的对象</p><h6 id="2-类加载器的分类"><a href="#2-类加载器的分类" class="headerlink" title="2.类加载器的分类"></a>2.类加载器的分类</h6><p>JDK8及之前的版本，默认的类加载器有如下几种：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723007619223-32.png" alt="1723007619223-32"></p><p>类加载器的详细信息可以通过Arthas的classloader命令查看：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7bf4ee30655d68181fea795afa2d392.png" alt="e7bf4ee30655d68181fea795afa2d392"></p><ul><li>BootstrapClassLoader是启动类加载器，numberOfInstances是类加载器的数量只有1个，loadedCountTotal是加载类的数量1861个。</li><li>ExtClassLoader是扩展类加载器</li><li>AppClassLoader是应用程序类加载器</li></ul><h6 id="1-启动类加载器"><a href="#1-启动类加载器" class="headerlink" title="1.启动类加载器"></a>1.启动类加载器</h6><p>启动类加载器 BootStrap ClassLoader 由hotspot虚拟机提供 使用c++编写</p><p>默认加载 java jre&#x2F;lib 下类文件 </p><p>比如rt.jar，tools.jar，resources.jar等</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"> ClassLoader classLoader <span class="hljs-operator">=</span> String.class.getClassLoader()<span class="hljs-comment">;</span><br>System.out.println(classLoader)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>打印null</p><p>因为由cpp编写拿不到</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/abb25d1c18a6bbc60de60bd8123a6248.png" alt="abb25d1c18a6bbc60de60bd8123a6248"></p><p>用户扩展启动类</p><p>用户扩展</p><p>如果用户想扩展一些比较基础的jar包，让启动类加载器加载，有两种途径：</p><ul><li><strong>放入jre&#x2F;lib下进行扩展</strong>。不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载。</li><li><strong>使用参数进行扩展。</strong>推荐，使用-Xbootclasspath&#x2F;a:jar包目录&#x2F;jar包名 进行扩展，参数中的&#x2F;a代表新增。</li></ul><p>下图，在IDEA配置中添加虚拟机参数，就可以加载<code>D:/jvm/jar/classloader-test.jar</code>这个jar包了。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723010756907-37.png" alt="1723010756907-37"></p><h6 id="2-扩展类-应用类加载器"><a href="#2-扩展类-应用类加载器" class="headerlink" title="2.扩展类 应用类加载器"></a>2.扩展类 应用类加载器</h6><ul><li>它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自<strong>URLClassLoader</strong>。具备通过目录或者指定jar包将字节码文件加载到内存中。</li></ul><p>继承关系图如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723010844442-40.png" alt="1723010844442-40"></p><ul><li>ClassLoader类定义了具体的行为模式，简单来说就是先从本地或者网络获得字节码信息，然后调用虚拟机底层的方法创建方法区和堆上的对象。这样的好处就是让子类只需要去实现如何获取字节码信息这部分代码。</li><li>SecureClassLoader提供了证书机制，提升了安全性。</li><li>URLClassLoader提供了根据URL获取目录下或者指定jar包进行加载，获取字节码的数据。</li><li><strong>扩展类加载器和应用程序类加载器继承</strong>自URLClassLoader，获得了上述的三种能力。</li></ul><p>1.扩展类加载器</p><p>扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载Java安装目录&#x2F;jre&#x2F;lib&#x2F;ext下的类文件。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ClassLoader classLoader <span class="hljs-operator">=</span> ScriptEnvironment.class.getClassLoader()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>ScriptEnvironment是nashorn框架中用来运行javascript语言代码的环境类，他位于nashorn.jar包中被扩展类加载器加载</strong></p><p>扩展加载</p><ul><li><strong>放入&#x2F;jre&#x2F;lib&#x2F;ext下进行扩展</strong>。不推荐，尽可能不要去更改JDK安装目录中的内容。</li><li><strong>使用参数进行扩展使用参数进行扩展</strong>。推荐，使用-Djava.ext.dirs&#x3D;jar包目录 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos&#x2F;linux)追加上原始目录</li></ul><p>如下图中：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723011029979-43.png" alt="1723011029979-43"></p><p>使用<code>引号</code>将整个地址包裹起来，这样路径中即便是有空格也不需要额外处理。路径中要包含原来ext文件夹，同时在最后加上扩展的路径。</p><hr><p>应用程序加载器</p><p>应用程序类加载器会加载classpath下的类文件，默认加载的是项目中的类以及通过maven引入的第三方jar包中的类。</p><p>如下案例中，打印出<code>Student</code>和<code>FileUtils</code>的类加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 应用程序类加载器案例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppClassLoaderDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">//当前项目中创建的Student类</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Student.class.getClassLoader();<br>        System.out.println(classLoader);<br><br>        <span class="hljs-comment">//maven依赖中包含的类</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> FileUtils.class.getClassLoader();<br>        System.out.println(classLoader1);<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.in.read();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类加载器的加载路径可以通过classloader –c hash值 查看：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1723011261055-46.png" alt="1723011261055-46"></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h5 id="1-了解双亲委派机制"><a href="#1-了解双亲委派机制" class="headerlink" title="1.了解双亲委派机制"></a>1.了解双亲委派机制</h5><p>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，</p><p>再由顶向下进行加载。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105160402551.png" alt="image-20241105160402551"></p><p>在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。</p><h5 id="2-双亲委派机制作用"><a href="#2-双亲委派机制作用" class="headerlink" title="2.双亲委派机制作用"></a>2.双亲委派机制作用</h5><p>1.保证类加载的安全性。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。</p><p>2.避免重复加载。双亲委派机制可以避免同一个类被多次加载。</p><h5 id="3-指定类加载器加载"><a href="#3-指定类加载器加载" class="headerlink" title="3.指定类加载器加载"></a>3.指定类加载器加载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">///获取到类加载器</span><br>ClassLoader classLoader=mq.class.getClassLoader();<br>  System.out.println(classLoader);<br>  <span class="hljs-comment">//通过类加载器的loadClass方法指定某个类加载器加载。</span><br>  Class&lt;?&gt;clazz=classLoader.loadClass(<span class="hljs-string">&quot;jvm.mq&quot;</span>);<br>  System.out.println(clazz);<br></code></pre></td></tr></table></figure><p><strong>类的双亲委派机制是什么？</strong></p><ul><li>当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。</li><li>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。</li><li>双亲委派机制的好处有两点：第一是避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。</li></ul><h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><ul><li>1.自定义类加载器并且重写loadClass方法。Tomcat通过这种方式实现应用之间类隔离，《面试篇》中分享它的做法。</li><li>2.线程上下文类加载器。利用上下文类加载器加载类，比如JDBC和JNDI等。</li><li>3.Osgi框架的类加载器。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。</li></ul><p>三种方法</p><h5 id="1-自定义类加载器"><a href="#1-自定义类加载器" class="headerlink" title="1.自定义类加载器"></a>1.自定义类加载器</h5><p>案例 tomcats</p><p>应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105160658779.png" alt="image-20241105160658779"></p><p>Tomcat使用了定义类加载器来实现应用之间类的隔离。 每一个应用会有一个独立的类加载器加载对应的类。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105160716014.png" alt="image-20241105160716014"></p><p>ClassLoader中包含了4个核心方法，双亲委派机制的核心代码就位于loadClass方法中。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">public abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name)<br>类加载的入口，提供了双亲委派机制。内部会调用findClass   重要<br><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name)<br>由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)<br>做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span><br>执行类生命周期中的连接阶段<br></code></pre></td></tr></table></figure><h6 id="1-双亲委派机制源码分析"><a href="#1-双亲委派机制源码分析" class="headerlink" title="1.双亲委派机制源码分析"></a>1.双亲委派机制源码分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>false-静态变量查看</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (resolve) &#123;<br>    <span class="hljs-built_in">resolveClass</span>(c);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 使用类加载锁保证多线程下的安全加载，防止多个线程并发加载相同的类时产生线程安全问题</span><br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 查找的是 当前类加载器已经加载过该类类</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <br>        <span class="hljs-comment">// 如果该类没有被加载，继续加载</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();  <span class="hljs-comment">// 记录开始时间，用于性能统计</span><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 先尝试通过父类加载器加载该类（父类加载器遵循双亲委派机制）</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果父类加载器存在，通过父类加载器加载类 -通过扩展类加载器查询是否加载</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果父类加载器为 null，即已经到了启动类加载器层级，通过启动类加载器查找类 -最根级递归</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// 如果父类加载器未能加载到该类，会抛出 ClassNotFoundException</span><br>                <span class="hljs-comment">// 捕获并忽略异常，继续加载</span><br>            &#125;<br><br>            <span class="hljs-comment">// 双亲委派机制：</span><br>            <span class="hljs-comment">// 如果父加载器未加载成功，继续使用当前加载器加载类。</span><br>            <span class="hljs-comment">// 启动类加载器和扩展类加载器都不能找到时，才进入当前加载器的查找过程</span><br>            <span class="hljs-comment">// 到达当前加载器后，进行类的实际加载</span><br><br>            <span class="hljs-comment">// 如果还是没有找到，进入到实际的加载阶段</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果找不到类，调用 findClass 方法来加载该类</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime(); <span class="hljs-comment">// 记录当前加载过程开始的时间</span><br><br>                <span class="hljs-comment">// 调用 findClass 方法进行类的加载，findClass 是具体的加载逻辑实现</span><br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录统计数据，计算查找类所花费的时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment(); <span class="hljs-comment">// 增加类加载次数</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果需要解析类，在此进行解析操作（比如加载静态代码块）</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> c; <span class="hljs-comment">// 返回加载的类</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>find class方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要</p><h6 id="2-打破双亲委派机制"><a href="#2-打破双亲委派机制" class="headerlink" title="2.打破双亲委派机制"></a>2.打破双亲委派机制</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BreakClassLoader1</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> String basePath;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">FILE_EXT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.class&quot;</span>;<br><br>    <span class="hljs-comment">//设置加载目录</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBasePath</span><span class="hljs-params">(String basePath)</span> &#123;<br>        <span class="hljs-built_in">this</span>.basePath = basePath;<br>    &#125;<br>    <span class="hljs-comment">//使用commons io 从指定目录下加载文件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadClassData(String name)  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tempName</span> <span class="hljs-operator">=</span> name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, Matcher.quoteReplacement(File.separator));<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(basePath + tempName + FILE_EXT);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> IOUtils.toByteArray(fis);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                IOUtils.closeQuietly(fis);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;自定义类加载器加载失败，错误原因：&quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//重写loadClass方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//如果是java包下，还是走双亲委派机制</span><br>        <span class="hljs-keyword">if</span>(name.startsWith(<span class="hljs-string">&quot;java.&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.loadClass(name);<br>        &#125;<br>        <span class="hljs-comment">//从磁盘中指定目录下加载</span><br>        <span class="hljs-type">byte</span>[] data = loadClassData(name);<br>        <span class="hljs-comment">//调用虚拟机底层方法，方法区和堆区创建对象</span><br>        <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, IOException &#123;<br> <span class="hljs-comment">//第一个自定义类加载器对象</span><br>        <span class="hljs-comment">// 创建第一个自定义类加载器对象</span><br>        <span class="hljs-type">BreakClassLoader1</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader1</span>();<br><br>        <span class="hljs-comment">// 设置类加载器的加载路径为 &quot;D:\\lib\\&quot;</span><br>        classLoader1.setBasePath(<span class="hljs-string">&quot;D:\\lib\\&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 classLoader1 加载指定的类 &quot;com.itheima.my.A&quot;</span><br>        <span class="hljs-comment">// 该类会从 &quot;D:\\lib\\&quot; 目录下加载对应的 .class 文件</span><br>        Class&lt;?&gt; clazz1 = classLoader1.loadClass(<span class="hljs-string">&quot;com.itheima.my.A&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第二个自定义类加载器对象</span><br>        <span class="hljs-type">BreakClassLoader1</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BreakClassLoader1</span>();<br><br>        <span class="hljs-comment">// 设置第二个类加载器的加载路径也为 &quot;D:\\lib\\&quot;</span><br>        classLoader2.setBasePath(<span class="hljs-string">&quot;D:\\lib\\&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 classLoader2 加载相同的类 &quot;com.itheima.my.A&quot;</span><br>        <span class="hljs-comment">// 该类也会从 &quot;D:\\lib\\&quot; 目录下加载对应的 .class 文件</span><br>        Class&lt;?&gt; clazz2 = classLoader2.loadClass(<span class="hljs-string">&quot;com.itheima.my.A&quot;</span>);<br><br>        <span class="hljs-comment">// 输出比较两者加载的类是否相同</span><br>        <span class="hljs-comment">// 因为 classLoader1 和 classLoader2 是不同的加载器，虽然加载的是相同的类，</span><br>        <span class="hljs-comment">// 但不同的类加载器会导致不同的 Class 对象，因此 clazz1 和 clazz2 不会相同</span><br>        System.out.println(clazz1 == clazz2);  <span class="hljs-comment">// 结果会是 false</span><br><br>        <span class="hljs-comment">// 设置当前线程的上下文类加载器为 classLoader1</span><br>        <span class="hljs-comment">// 这样可以改变线程默认的类加载器，使得该线程可以使用 classLoader1 加载类</span><br>        Thread.currentThread().setContextClassLoader(classLoader1);<br><br>        <span class="hljs-comment">// 输出当前线程的上下文类加载器</span><br>        <span class="hljs-comment">// 应该会输出 classLoader1，因为我们刚刚将其设置为当前线程的上下文类加载器</span><br>        System.out.println(Thread.currentThread().getContextClassLoader());<br><br>        <span class="hljs-comment">// 阻塞程序，等待用户输入，以便在控制台查看输出</span><br>        System.in.read();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>自定义类加载器父类怎么是AppClassLoader呢？</p><p>默认情况下自定义类加载器的父类加载器是应用程序类加载器：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162641692.png" alt="image-20241105162641692"></p><p>以Jdk8为例，ClassLoader类中提供了构造方法设置parent的内容：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162654286.png" alt="image-20241105162654286"></p><p>这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的是AppClassLoader。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162704484.png" alt="image-20241105162704484"></p><p>回到问题-两个自定义加载器加载相同限定名字的类-冲突问题</p><p>不会冲突，在同一个Java虚拟机中，只有相同类加载器+相同的类限定名才会被认为是同一个类。</p><h5 id="2-线程上下文加载器"><a href="#2-线程上下文加载器" class="headerlink" title="2.线程上下文加载器"></a>2.线程上下文加载器</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 设置当前线程的上下文类加载器为 classLoader1</span><br><span class="hljs-comment">// 这样可以改变线程默认的类加载器，使得该线程可以使用 classLoader1 加载类</span><br>Thread<span class="hljs-selector-class">.currentThread</span>()<span class="hljs-selector-class">.setContextClassLoader</span>(classLoader1);<br><br><span class="hljs-comment">// 输出当前线程的上下文类加载器</span><br><span class="hljs-comment">// 应该会输出 classLoader1，因为我们刚刚将其设置为当前线程的上下文类加载器</span><br>System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(Thread.currentThread()<span class="hljs-selector-class">.getContextClassLoader</span>());<br></code></pre></td></tr></table></figure><p>利用上下文类加载器加载类，比如JDBC和JNDI等。</p><p>JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。</p><p>DriverManager类位于rt.jar包中，由启动类加载器加载。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162821690.png" alt="image-20241105162821690"></p><p>依赖中的mysql驱动对应的类，由应用程序类加载器来加载。</p><p>–mysql是否打破双亲委派-</p><p>跳过双亲委派规则-直接给了应用启动器</p><p>从结果上看没打破-过程上打破了</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162826428.png" alt="image-20241105162826428"></p><p>那么问题来了，DriverManager怎么知道jar包中要加载的驱动在哪儿？</p><p>spi机制</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162836478.png" alt="image-20241105162836478"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162841152.png" alt="image-20241105162841152"></p><p>在类的初始化代码中有这么一个方法<code>LoadInitialDrivers</code>：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162847681.png" alt="image-20241105162847681"></p><p>2、这里使用了SPI机制，去加载所有jar包中实现了Driver接口的实现类。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162853733.png" alt="image-20241105162853733"></p><p>3、SPI机制就是在这个位置下存放了一个文件，文件名是接口名，文件里包含了实现类的类名。这样SPI机制就可以找到实现类了。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162904481.png" alt="image-20241105162904481"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162908607.png" alt="image-20241105162908607"></p><p>4、SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162914969.png" alt="image-20241105162914969"></p><p>总结：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105162921185.png" alt="image-20241105162921185"></p><h5 id="3-Osgi框架的类加载器"><a href="#3-Osgi框架的类加载器" class="headerlink" title="3.Osgi框架的类加载器"></a>3.Osgi框架的类加载器</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105163546428.png" alt="image-20241105163546428"></p><h5 id="4-Jdk9-后类加载器"><a href="#4-Jdk9-后类加载器" class="headerlink" title="4.Jdk9 后类加载器"></a>4.Jdk9 后类加载器</h5><p>JDK8及之前的版本中，<strong>扩展类加载器和应用程序类加载器的源码</strong>位于rt.jar包中的sun.misc.Launcher.java。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105163614676.png" alt="image-20241105163614676"></p><p>由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。</p><p>1.启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。</p><p>   Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。</p><p>   启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。</p><p>2、扩展类加载器被替换成了平台类加载器（Platform Class Loader）。</p><p>​     平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。</p><h1 id="Jvm02-运行时数据区"><a href="#Jvm02-运行时数据区" class="headerlink" title="Jvm02 运行时数据区"></a>Jvm02 运行时数据区</h1><p>Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107140839281.png" alt="image-20241107140839281"></p><h2 id="线程不共享区"><a href="#线程不共享区" class="headerlink" title="线程不共享区"></a>线程不共享区</h2><p>ps:单独的线程-</p><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p>EIP寄存器</p><p>程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。</p><p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。不管是分支、跳转、异常，只需要在程序计数器中放入下一行要执行的指令地址即可。</p><p>在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行。</p><p>程序计数器不会出现内存溢出</p><h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><h4 id="1-认识java虚拟机栈"><a href="#1-认识java虚拟机栈" class="headerlink" title="1.认识java虚拟机栈"></a>1.认识java虚拟机栈</h4><p>Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodDemo</span> &#123;   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        <br>         study();    <br>     &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span>()</span>&#123;<br>        eat();<br><br>        sleep();<br>    &#125;   <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>&#123;       <br>         System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;吃饭&quot;</span>);   <br>    &#125;    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span>()</span>&#123;        <br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;睡觉&quot;</span>);    <br>        &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107141042179.png" alt="image-20241107141042179"></p><p>循环调用–</p><p>再return前-会将当前开辟的栈帧的地址置0</p><p>return 会返回上一个函数的起始地址</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107141051590.png" alt="image-20241107141051590"></p><p>Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。</p><h5 id="栈帧数据探究"><a href="#栈帧数据探究" class="headerlink" title="栈帧数据探究"></a>栈帧数据探究</h5><p>Java虚拟机栈的栈帧中主要包含三方面的内容：</p><ul><li>局部变量表，局部变量表的作用是在运行过程中存放所有的局部变量</li><li>操作数栈，操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域</li><li>帧数据，帧数据主要包含动态链接、方法出口、异常表的引用</li></ul><h6 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1.局部变量表"></a><strong>1.局部变量表</strong></h6><p>局部变量表的作用是在方法执行过程中存放所有的局部变量。局部变量表分为两种，一种是字节码文件中的，另外一种是栈帧中的也就是保存在内存中。</p><p>栈帧中的局部变量表是根据字节码文件中的内容生成的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span>()</span>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">long</span> j = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>test1方法的局部变量表如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107141235461.png" alt="image-20241107141235461"></p><p>局部变量表中保存了字节码指令生效的偏移量：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107141253697.png" alt="image-20241107141253697"></p><p>比如<code>i</code>这个变量，它的起始PC是2，代表从<code>lconst_1</code>这句指令开始才能使用<code>i</code>，长度为3，也就是2-4这三句指令都可以使用<code>i</code>。为什么从2才能使用，因为0和1这两句字节码指令还在处理<code>int i = 0</code>这句赋值语句。<code>j</code>这个变量只有等3指令执行完之后也就是<code>long j = 1</code>代码执行完之后才能使用，所以起始PC为4，只能在4这行字节码指令中使用。</p><h6 id="2-栈帧中的局部变量"><a href="#2-栈帧中的局部变量" class="headerlink" title="2.栈帧中的局部变量"></a>2.<strong>栈帧中的局部变量</strong></h6><p>栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107141311922.png" alt="image-20241107141311922"></p><p><code>i</code>占用数组下标为0的位置，<code>j</code>占用数组下标1-2的位置。</p><hr><hr><p>刚才看到的是静态方法，实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107141319364.png" alt="image-20241107141319364"></p><p>方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107141325186.png" alt="image-20241107141325186"></p><p>test3方法中包含两个参数<code>k</code>,<code>m</code>，这两个参数也会被加入到局部变量表中</p><p>ps:</p><p>槽在我看来也是抽象出来的概念-包括字节码文件中的局部变量</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0x11</span>],<span class="hljs-number">3</span><br><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span>,[<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0x11</span>]<br><br>//汇编忘差不多了 -在我看来这就是局部变量<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> j=i<span class="hljs-comment">;</span><br>局部变量的开辟<br></code></pre></td></tr></table></figure><p>实例</p><p>以下代码的局部变量表中会占用几个槽？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">test4</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> m)</span></span>&#123;<br>    &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-comment">// 1 +2 +2-2</span><br>    &#123;<br>        <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-number">3</span><span class="hljs-number">+1</span><span class="hljs-number">-1</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">3</span><span class="hljs-number">+1</span><br>    <span class="hljs-type">long</span> j = <span class="hljs-number">1</span>; <span class="hljs-number">4</span><span class="hljs-number">+2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量表数值的长度为6。这一点在编译期间就可以确定了，运行过程中只需要在栈帧中创建长度为6的数组即可。</p><p>数组再汇编中也是如上</p><p>数组在反汇编中的本质</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">实践<span class="hljs-number">1</span><br><span class="hljs-number">10</span>: <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;<span class="hljs-comment">;</span><br>00333E85  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [a],<span class="hljs-number">1</span><br>00333E8C  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">14h</span>],<span class="hljs-number">2</span><br>00333E93  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">10h</span>],<span class="hljs-number">3</span><br>00333E9A  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0Ch</span>],<span class="hljs-number">4</span><br>00333EA1  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>],<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h6 id="3-操作数栈"><a href="#3-操作数栈" class="headerlink" title="3.操作数栈"></a>3.操作数栈</h6><p>操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。</p><p>在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143511406.png" alt="image-20241107143511406"></p><p>比如之前的相加案例中，操作数栈最大的深入会出现在这个时刻：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143517414.png" alt="image-20241107143517414"></p><p>所以操作数栈的深度会定义为2。</p><h6 id="4-帧数据"><a href="#4-帧数据" class="headerlink" title="4.帧数据"></a>4.帧数据</h6><p>帧数据主要包含动态链接、方法出口、异常表的引用。</p><p><strong>1.动态链接</strong></p><p>当前类的字节码指令引用了其他类的属性或者方法时</p><p>需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。</p><p>动态链接就保存了编号到运行时常量池的内存地址的映射关系。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143706792.png" alt="image-20241107143706792"></p><p><strong>2.方法出口</strong></p><p>return的数据</p><p>方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143725407.png" alt="image-20241107143725407"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143728895.png" alt="image-20241107143728895"></p><p>再进入函数前-会将下一条指令压入栈中</p><p>后续开栈-恢复后 return自然就到了当时压栈的那个返回地址</p><p>3.异常表</p><p>异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143742926.png" alt="image-20241107143742926"></p><p><code>如下案例：i=1</code>这行源代码编译成字节码指令之后，会包含偏移量2-4这三行指令。其中2-3是对i进行赋值1的操作，4的没有异常就跳转到10方法结束。如果出现异常的情况下，继续执行到7这行指令，7会将异常对象放入操作数栈中，这样在catch代码块中就可以使用异常对象了。接下来执行8-9，对i进行赋值为2的操作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143751102.png" alt="image-20241107143751102"></p><p>所以异常表中，异常捕获的起始偏移量就是2，结束偏移量是4，在2-4执行过程中抛出了<code>java.lang.Exception</code>对象或者子类对象，就会将其捕获，然后跳转到偏移量为7的指令。</p><h5 id="栈溢出问题探究"><a href="#栈溢出问题探究" class="headerlink" title="栈溢出问题探究"></a>栈溢出问题探究</h5><p>Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。Java虚拟机栈内存溢出时会出现StackOverflowError的错误。</p><p>JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构。</p><p>要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss 。</p><ul><li>语法：-Xss栈大小</li><li>单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xss1048576 </span><br><span class="hljs-deletion">-Xss1024K      </span><br><span class="hljs-deletion">-Xss1m</span><br><span class="hljs-deletion">-Xss1g</span><br></code></pre></td></tr></table></figure><p>一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数可以手动指定为-Xss256k节省内存。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈存储的是native本地方法的栈帧。</p><p>在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143843001.png" alt="image-20241107143843001"></p><p>执行之后发生异常，会打印出所有栈帧的名字：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107143849262.png" alt="image-20241107143849262"></p><p><code>open0</code>是一个本地方法，所以创建了本地方法的栈帧。本地方法和Java虚拟机方法的栈帧在一个栈上。</p><h2 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h2><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><h4 id="1-了解堆内存"><a href="#1-了解堆内存" class="headerlink" title="1.了解堆内存"></a>1.了解堆内存</h4><p>一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ublic class Test &#123;    <br>    public static void main(String[] args) &#123;        <br>        Student s1 <span class="hljs-operator">=</span> new Student()<span class="hljs-comment">;        </span><br>        s1.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span><span class="hljs-comment">;       </span><br>        s1.age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><span class="hljs-comment">;       </span><br>        s1.id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>        s1.printTotalScore()<span class="hljs-comment">;        </span><br>        s1.printAverageScore()<span class="hljs-comment">;        </span><br>        <br>        Student s2 <span class="hljs-operator">=</span> new Student()<span class="hljs-comment">;       </span><br>        s2.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;李四&quot;</span><span class="hljs-comment">;        </span><br>        s2.age <span class="hljs-operator">=</span> <span class="hljs-number">19</span><span class="hljs-comment">;        </span><br>        s2.id<span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;        </span><br>        s2.printTotalScore()<span class="hljs-comment">;        </span><br>        s2.printAverageScore()<span class="hljs-comment">;    </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中通过<code>new</code>关键字创建了两个<code>Student</code>类的对象，这两个对象会被存放在堆上。在栈上通过<code>s1</code>和<code>s2</code>两个局部变量保存堆上两个对象的地址，从而实现了引用关系的建立。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107145706200.png" alt="image-20241107145706200"></p><p>堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出OutOfMemory错误。</p><h4 id="2-堆内存特性"><a href="#2-堆内存特性" class="headerlink" title="2.堆内存特性"></a>2.堆内存特性</h4><p>堆空间有三个需要关注的值，used、total、max。used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107145725307.png" alt="image-20241107145725307"></p><p>当内存不够-&gt;total向max扩张</p><p>那么是不是当used &#x3D; max &#x3D; total的时候，堆内存就溢出了呢？</p><p>不是，堆内存溢出的判断条件比较复杂，在下一章《垃圾回收器》中会详细介绍。</p><h4 id="3-设置堆大小"><a href="#3-设置堆大小" class="headerlink" title="3.设置堆大小"></a>3.设置堆大小</h4><p>要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)。</p><p>语法：<code>-Xmx值 -Xms值</code></p><p>单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)</p><p>限制：Xmx必须大于 2 MB，Xms必须大于1MB</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms6291456</span><br><span class="hljs-deletion">-Xms6144k</span><br><span class="hljs-deletion">-Xms6m</span><br><span class="hljs-deletion">-Xmx83886080</span><br><span class="hljs-deletion">-Xmx81920k</span><br><span class="hljs-deletion">-Xmx80m</span><br></code></pre></td></tr></table></figure><p>这样可以将max和初始的total都设置为4g，在启动后就已经获得了最大的堆内存大小。运行过程中不需要向操作系统申请。</p><p>Java服务端程序开发时，建议将-Xmx和-Xms设置为相同的值，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。-Xmx具体设置的值与实际的应用程序运行环境有关，在《实战篇》中会给出设置方案。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是存放基础信息的位置，线程共享，主要包含三部分内容：</p><ul><li>类的元信息，保存了所有类的基本信息</li><li>运行时常量池，保存了字节码文件中的常量池内容</li><li>字符串常量池，保存了字符串常量</li></ul><h6 id="1-类的元信息"><a href="#1-类的元信息" class="headerlink" title="1,类的元信息"></a>1,类的元信息</h6><p>方法区是用来存储每个类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成。其中就包含了类的字段、方法等字节码文件中的内容，同时还保存了运行过程中需要使用的虚方法表（实现多态的基础）等信息。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107150120811.png" alt="image-20241107150120811"></p><h6 id="2-运行时常量池"><a href="#2-运行时常量池" class="headerlink" title="2.运行时常量池"></a>2.运行时常量池</h6><p>常量池中存放的是字节码中的常量池内容。</p><p>字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池。</p><h6 id="3-方法区的实现"><a href="#3-方法区的实现" class="headerlink" title="3.方法区的实现"></a>3.方法区的实现</h6><p>JDK7及之前的版本将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数来控制。</p><p>JDK8及之后的版本将方法区存放在元空间中<strong>，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。</strong></p><h6 id="4-方法区的溢出"><a href="#4-方法区的溢出" class="headerlink" title="4.方法区的溢出"></a>4.方法区的溢出</h6><ul><li>JDK7将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数-XX:MaxPermSize&#x3D;值来控制。</li><li>JDK8将方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。可以使用-XX:MaxMetaspaceSize&#x3D;值将元空间最大大小进行限制。</li></ul><h6 id="5-字符串常量池–堆的特性"><a href="#5-字符串常量池–堆的特性" class="headerlink" title="5.字符串常量池–堆的特性"></a>5.字符串常量池–堆的特性</h6><p>字符串常量池存储在代码中定义的常量字符串内容。比如“123” 这个123就会被放入字符串常量池。</p><p>如下代码执行时，代码中包含<code>abc</code>字符串，就会被直接放入字符串常量池。在堆上创建String对象，并通过局部变量s1引用堆上的对象。</p><p>接下来通过s2局部变量引用字符串常量池的<code>abc</code>。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107150157429.png" alt="image-20241107150157429"></p><p>所以s1和s2指向的不是同一个对象，打印出<code>false</code>。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107150204626.png" alt="image-20241107150204626"></p><h6 id="6-静态变量在哪"><a href="#6-静态变量在哪" class="headerlink" title="6.静态变量在哪"></a>6.静态变量在哪</h6><ul><li>JDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代。</li><li>JDK7及之后的版本中，静态变量是存放在堆中的Class对象中，脱离了永久代。具体源码可参考虚拟机源码：BytecodeInterpreter针对putstatic指令的处理。</li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:</p><p>1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。</p><p>2、IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。</p><p>现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。</p><p>使用堆创建对象的过程：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107150231276.png" alt="image-20241107150231276"></p><p>使用直接内存创建对象的过程，不需要进行复制对象，数据直接存放在直接内存中：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107150237643.png" alt="image-20241107150237643"></p><p>要创建直接内存上的数据，可以使用<code>ByteBuffer</code>。</p><p>语法： <code>ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);</code></p><h3 id="特性了解"><a href="#特性了解" class="headerlink" title="特性了解"></a>特性了解</h3><p>方法区-根据版本不同-在元空间或者永久代中</p><p>元空间 jdk1.8提出的概念-再直接内存中</p><p>永久代-堆中位于永久代中-老概念</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-排序</title>
    <link href="/2024/11/02/design%20mode/%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/11/02/design%20mode/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法-排序"><a href="#算法-排序" class="headerlink" title="算法-排序"></a>算法-排序</h1><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/849589-20180402133438219-1946132192.png" alt="img"></p><h5 id="1-排序概念"><a href="#1-排序概念" class="headerlink" title="1.排序概念"></a>1.排序概念</h5><p>对元素进行倒序或增序排序</p><p>默认情况下都是递增排序</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241102121738083.png" alt="image-20241102121738083"></p><h5 id="2-内排序-外排序"><a href="#2-内排序-外排序" class="headerlink" title="2.内排序 外排序"></a>2.内排序 外排序</h5><p><strong>内排序</strong>：如果在排序过程中，整个数据表可以全部放在内存中进行处理，不需要涉及数据的内存和外存交换，这样的排序称为内排序。<br>例如，当数据量较小，能够一次性加载到内存中时，我们可以直接使用内存进行排序（如快速排序、插入排序等）。</p><p><strong>外排序</strong>：如果在排序过程中，数据量太大，无法一次性放入内存中，需要通过外存（如硬盘）进行数据的交换和处理，这样的排序称为外排序。<br>例如，在处理超大规模的数据集（如数百万条记录）时，无法将所有数据都放入内存中，这时需要使用外排序方法，如归并排序。外排序通常会分批将数据加载到内存中，进行部分排序后再将结果写回外存，最终通过多次合并获得完整的排序结果。</p><p><strong>内排序的例子</strong>：假设我们有一个包含 1000 个整数的数组，这些整数都可以被加载到内存中。我们可以直接使用内存中的快速排序算法对数据进行排序。</p><p><strong>外排序的例子</strong>：假设我们有一个包含 10 亿条记录的大型文件，这些数据无法一次性加载到内存中。我们可以先将文件分成多个小文件，每个小文件都可以被加载到内存中，逐个对它们进行排序，然后将排序后的小文件依次合并，最终得到完整的排序结果。</p><h5 id="3-内排序的分类"><a href="#3-内排序的分类" class="headerlink" title="3.内排序的分类"></a>3.内排序的分类</h5><p>内排序可以分为 <strong>基于比较的排序算法</strong> 和 <strong>不基于比较的排序算法</strong>，具体如下：</p><ol><li><strong>基于比较的排序算法</strong>：</li></ol><p>这种排序算法通过<strong>对数据中的关键字</strong>进行两两比较，来决定元素之间的顺序。</p><p>常见的基于比较的排序算法有：</p><ul><li><strong>插入排序</strong>：将元素逐个插入到已排序的部分中。</li><li><strong>交换排序</strong>（如冒泡排序）：通过交换无序的相邻元素，将较大（或较小）的元素逐步移动到正确位置。</li><li><strong>选择排序</strong>：在每一轮中选择最小（或最大）的元素并放到相应位置。</li><li><strong>归并排序</strong>：通过分治思想，将数组分为若干子数组排序后合并。</li><li><strong>快速排序</strong>：通过选取一个“基准”元素，将数组分成比基准小和比基准大的两部分，递归排序。</li></ul><p>快速排序：假设有一组数字 <code>[3, 1, 4, 1, 5, 9]</code>，选择 3 作为基准值，将数组分为 <code>[1, 1, 3]</code> 和 <code>[4, 5, 9]</code>，然后递归地对每部分排序，最后合并得到有序数组。</p><p>2.<strong>不基于比较的排序算法</strong>：</p><p>这种排序算法不直接比较关键字的大小，而是利用元素的特定属性或结构进行排序，通常用于特定的数据类型或范围。</p><p>常见的不基于比较的排序算法有：</p><ul><li><strong>基数排序</strong>：按位（如个位、十位）逐步排序，一次排序一个位数。</li><li><strong>计数排序</strong>：根据元素的取值范围统计每个值的出现次数，直接构造排序结果。</li><li><strong>桶排序</strong>：将数据分配到若干个“桶”中，每个桶内分别排序，最后合并各桶的数据。</li></ul><p>基数排序：对电话号码 <code>[123, 456, 789, 234]</code> 进行排序，先按个位、再按十位、最后按百位排序，可以得到有序的结果 <code>[123, 234, 456, 789]</code>。</p><p>基于比较的排序适用于一般情况，但效率上限为 O(nlog⁡n)O(n \log n)O(nlogn)。不基于比较的排序利用数据特性，可能实现线性时间复杂度，但通常需要额外的空间或特定数据特性。</p><h5 id="4-基于笔记的排序性能"><a href="#4-基于笔记的排序性能" class="headerlink" title="4.基于笔记的排序性能"></a>4.基于笔记的排序性能</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241102122804607.png" alt="image-20241102122804607"></p><h5 id="5-内排序的稳定性"><a href="#5-内排序的稳定性" class="headerlink" title="5.内排序的稳定性"></a>5.内排序的稳定性</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241102123203565.png" alt="image-20241102123203565"></p><h5 id="6-内排序的数据的组织"><a href="#6-内排序的数据的组织" class="headerlink" title="6.内排序的数据的组织"></a>6.内排序的数据的组织</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241102123236723.png" alt="image-20241102123236723"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cea4494c5b1b89f7b8043d2836b95e3c.png" alt="cea4494c5b1b89f7b8043d2836b95e3c"></p><p>相同元素</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7d0800a8ef3b1a73c95940d0879df06c.png" alt="7d0800a8ef3b1a73c95940d0879df06c"></p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d26fade4b50bf4d5072c720bb6b7ca9e.png" alt="d26fade4b50bf4d5072c720bb6b7ca9e"></p><p>实现2</p><p>带哨兵</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/22081188eace06348bedb6b9f6ccd4e8.png" alt="22081188eace06348bedb6b9f6ccd4e8"></p><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241103105301559.png" alt="image-20241103105301559"></p><h3 id="折半查找排序"><a href="#折半查找排序" class="headerlink" title="折半查找排序"></a>折半查找排序</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/47f0101a5c3b01820e4590219a233177.png" alt="47f0101a5c3b01820e4590219a233177"></p><p>low-开头 high-末尾 折半查看落在哪个范围内</p><p>找到条件</p><p>if(high&lt;low)</p><p>稳定性-方向不变<br>当前处理元素值相同</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e3b30e7a0c3c4d47fa97a2a466faa0a2.png" alt="e3b30e7a0c3c4d47fa97a2a466faa0a2"></p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/47cc24b8e2051d2bb680e9ef05dcbe29.png" alt="47cc24b8e2051d2bb680e9ef05dcbe29"></p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2b9290c174cfcf3008dc4efe5364c803.png" alt="2b9290c174cfcf3008dc4efe5364c803"></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106141547824.png" alt="image-20241106141547824"></p><h5 id="1-简单选择排序"><a href="#1-简单选择排序" class="headerlink" title="1.简单选择排序"></a>1.简单选择排序</h5><p>过程</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106141617792.png" alt="image-20241106141617792"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106141630080.png" alt="image-20241106141630080"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106141642011.png" alt="image-20241106141642011"></p><p>时间复杂度、</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106141713643.png" alt="image-20241106141713643"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106141730669.png" alt="image-20241106141730669"></p><p><img src="C:\Users\nixg\AppData\Roaming\Typora\typora-user-images\image-20241106141738469.png" alt="image-20241106141738469"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/849589-20171015230936371-1413523412.gif" alt="img"></p><p>过程</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106170141559.png" alt="image-20241106170141559"></p><p>low high一直走</p><p>low左边部分都要小于49</p><p>high都要大于49</p><p>直到low&#x3D;high确定-49最终位置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a3e6e57e9c1c7bc6ce10476c5e2d9486.jpg" alt="a3e6e57e9c1c7bc6ce10476c5e2d9486"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a4910b0a4f1a3ccaa9f9232a853f25e9.jpg" alt="a4910b0a4f1a3ccaa9f9232a853f25e9"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8b906e70d61994d144ed0717b6e43c3c.jpg" alt="8b906e70d61994d144ed0717b6e43c3c"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5ecba7e388992d8c103a010cfef42767.jpg" alt="5ecba7e388992d8c103a010cfef42767"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/557eaa9ef0048c03e840d25159f33b4d.jpg" alt="557eaa9ef0048c03e840d25159f33b4d"></p><h6 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/86b892646cfadce20546df644225f60d.jpg" alt="86b892646cfadce20546df644225f60d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5c6c4804734eee57429fbd00f63f6eb.jpg" alt="d5c6c4804734eee57429fbd00f63f6eb"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/64bda6b8d95410672b187bfe240accf7_720.jpg" alt="64bda6b8d95410672b187bfe240accf7_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/26036f9ba279b100dc48958f4e28149f.jpg" alt="26036f9ba279b100dc48958f4e28149f"></p><p>快速排序分析</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a0b4e58accc2a95754893bed9de24fdc.jpg" alt="a0b4e58accc2a95754893bed9de24fdc"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a87ce6b391a8c2a3dd1a4ff29dd144fd.jpg" alt="a87ce6b391a8c2a3dd1a4ff29dd144fd"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/be3ed950ac36e0582fc17242be4fc172.jpg" alt="be3ed950ac36e0582fc17242be4fc172"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62b74e286b36eca8055cdc5cbb40f908.jpg" alt="62b74e286b36eca8055cdc5cbb40f908"></p><h6 id="最坏-好的情况"><a href="#最坏-好的情况" class="headerlink" title="最坏 好的情况"></a>最坏 好的情况</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dc98e1d3c34af11bcc226eb0e000eea3.jpeg" alt="dc98e1d3c34af11bcc226eb0e000eea3"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41761ba3e2391bb971f71294ebfd6868.jpg" alt="41761ba3e2391bb971f71294ebfd6868"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b568c7d9ebd2e2967b1344826c7fbf8e.jpg" alt="b568c7d9ebd2e2967b1344826c7fbf8e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/22606ec0e935db49c580fa26f260072c.jpg" alt="22606ec0e935db49c580fa26f260072c"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed072ac9eb8e7a39520133b5df66f5b2_720.jpg" alt="ed072ac9eb8e7a39520133b5df66f5b2_720"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java异常</title>
    <link href="/2024/11/01/java/java%E5%BC%82%E5%B8%B8/java%E5%BC%82%E5%B8%B8/"/>
    <url>/2024/11/01/java/java%E5%BC%82%E5%B8%B8/java%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常认识"><a href="#异常认识" class="headerlink" title="异常认识"></a>异常认识</h2><h5 id="Java异常类层次结构"><a href="#Java异常类层次结构" class="headerlink" title="Java异常类层次结构"></a>Java异常类层次结构</h5><p>Throwable 是 Java 语言中所有错误与异常的超类。 </p><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误</p><p>Exception 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：<strong>运行时异常和编译时异常。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5b8dd265a5f94619125f81a2829c14c1.png" alt="5b8dd265a5f94619125f81a2829c14c1"></p><h6 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h6><p>运行时异常都是RuntimeException类及其子类异常</p><p>如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等</p><p>这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h6 id="非运行时异常"><a href="#非运行时异常" class="headerlink" title="非运行时异常"></a>非运行时异常</h6><p>非运行时异常 （编译异常）是RuntimeException以外的异常，类型上都属于Exception类及其子类。</p><p>从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。</p><p>如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常</p><h6 id="可查-不可查异常"><a href="#可查-不可查异常" class="headerlink" title="可查&#x2F;不可查异常"></a>可查&#x2F;不可查异常</h6><p>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）区别？</p><p>可查异常（编译器要求必须处置的异常）<strong>非运行时异常</strong>：正确的程序在运行中，很容易出现的、情理可容的异常状况。</p><p>可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了<strong>RuntimeException</strong>及其子类以外，其他的Exception类及其子类都属于可查异常。</p><p>这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><p>不可查异常(编译器不要求强制处置的异常)包括运行时异常 <strong>运行时异常</strong>（RuntimeException与其子类）和错误（Error）。</p><h4 id="异常的基础代码"><a href="#异常的基础代码" class="headerlink" title="异常的基础代码"></a>异常的基础代码</h4><p><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</p><p><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</p><p><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</p><p><strong>throw</strong> – 用于抛出异常。</p><p><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</p><h5 id="throw和throws的区别？"><a href="#throw和throws的区别？" class="headerlink" title="throw和throws的区别？"></a>throw和throws的区别？</h5><h6 id="1-throws"><a href="#1-throws" class="headerlink" title="1.throws"></a>1.throws</h6><p>在 Java 中，程序的执行始于 <code>main</code> 方法。每个执行的语句都在某个方法内。如果一个方法可能抛出可查异常（checked exception），那么必须在方法头中使用 <code>throws</code> 关键字声明该异常，以提醒调用者需要处理它。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void <span class="hljs-keyword">method</span><span class="hljs-params">()</span> <span class="hljs-title function_">throws</span> <span class="hljs-title function_">IOException</span>, <span class="hljs-title function_">FileNotFoundException</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    // 方法内容</span><br><span class="hljs-comment">&#125;</span><br><br></code></pre></td></tr></table></figure><p>如果一个父类的方法没有声明异常，子类在覆盖时也不能声明异常。</p><p><strong>异常处理的建议：</strong></p><p><strong>捕获异常</strong>：如果你知道如何处理某个异常，应该在方法内使用 <code>try-catch</code> 来捕获它。</p><p><strong>传递异常</strong>：如果你不知道如何处理该异常，可以在方法签名中使用 <code>throws</code> 关键字将其抛出，让调用者处理。</p><p>例如，下面的 <code>readFile</code> 方法声明可能抛出 <code>IOException</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> readFile(String filePath) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(filePath);<br>    String result;<br>    BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-keyword">file</span>));<br>    <span class="hljs-keyword">while</span> ((result = reader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>        System.out.<span class="hljs-keyword">println</span>(result);<br>    &#125;<br>    reader.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于 <code>throws</code> 的规则：</strong></p><ol><li><strong>可查异常</strong>：如果方法可能抛出可查异常，必须使用 <code>throws</code> 声明，或在方法内捕获它。</li><li><strong>不可查异常</strong>：对于 <code>Error</code> 和 <code>RuntimeException</code> 及其子类，可以不声明，虽然在运行时可能会抛出这些异常。</li><li><strong>覆盖方法</strong>：当子类覆盖父类方法时，不能声明与父类不同的异常。声明的异常必须是父类声明异常的同类或子类。</li></ol><h6 id="2-throw"><a href="#2-throw" class="headerlink" title="2.throw"></a>2.throw</h6><p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> double <span class="hljs-keyword">method</span><span class="hljs-params">(int value)</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    if(value == 0) &#123;</span><br><span class="hljs-comment">        throw new ArithmeticException(&quot;参数不能为0&quot;); //抛出一个运行时异常</span><br><span class="hljs-comment">    &#125;</span><br>    <span class="hljs-title function_">return</span> 5.0 / <span class="hljs-title function_">value</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。</p><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> MyException &#123;    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-type">MyException</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(<span class="hljs-string">&quot;read file failed.&quot;</span>);<br>        ex.initCause(e);<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="异常的自定义"><a href="#异常的自定义" class="headerlink" title="异常的自定义"></a>异常的自定义</h4><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-built_in">super</span>(msg);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>异常捕获处理的方法通常有： try-catch try-catch-finally try-finally try-with-resource</p><h6 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h6><p>这是最常见的异常处理方式。在 <code>try</code> 块中放置可能抛出异常的代码，<code>catch</code> 块用于捕获并处理该异常。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123;<br>    <span class="hljs-comment">// 异常处理代码</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h6><p>这种方式在 <code>try-catch</code> 的基础上增加了 <code>finally</code> 块。无论 <code>try</code> 块中的代码是否抛出异常，<code>finally</code> 块中的代码都会执行，通常用于清理资源</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123;<br>    <span class="hljs-comment">// 异常处理代码</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 无论是否有异常，都会执行的代码</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h6><p>这种方式只包含 <code>try</code> 和 <code>finally</code> 块。如果 <code>try</code> 块中抛出异常，<code>finally</code> 块中的代码仍会被执行，但没有 <code>catch</code> 块来处理异常。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 无论是否有异常，都会执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h6 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h6><p>try-with-resource是Java 7中引入的，很容易被忽略。</p><p>finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。</p><p>JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><hr><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryWithResourceTest</span>()</span>&#123;<br>    <span class="hljs-keyword">try</span> (Scanner scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        <span class="hljs-comment">// handle exception</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>看下Scanner</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Scanner</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Iterator</span>&lt;<span class="hljs-symbol">String</span>&gt;, <span class="hljs-symbol">Closeable</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Closeable</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> close() throws IOException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取</p><hr><h4 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2bda92351dcc892f1e5d6e5b6a6c6517_720.jpg" alt="2bda92351dcc892f1e5d6e5b6a6c6517_720"></p><h2 id="异常实践"><a href="#异常实践" class="headerlink" title="异常实践"></a>异常实践</h2><p>对异常的处理</p><h6 id="1-只针对不正常的情况才使用异常"><a href="#1-只针对不正常的情况才使用异常" class="headerlink" title="1.只针对不正常的情况才使用异常"></a>1.只针对不正常的情况才使用异常</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101164347019.png" alt="image-20241101164347019"></p><h3 id="在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="在 finally 块中清理资源或者使用 try-with-resource 语句"></a>在 finally 块中清理资源或者使用 try-with-resource 语句</h3><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> doNotCloseResourceInTry() &#123;<br>    FileInputStream inputStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>        inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">file</span>);<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>        <span class="hljs-comment">// do NOT do this</span><br>        inputStream.close();<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        log.error(e);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>方法一：使用 finally 代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeResourceInFinally</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>        inputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                inputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>方法二：Java 7 的 try-with-resource 语法</li></ul><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p><hr><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 <span class="hljs-keyword">try</span> 子句中打开资源，资源会在 <span class="hljs-keyword">try</span> 代码块执行后或异常处理后自动关闭。<br><br></code></pre></td></tr></table></figure><h3 id="尽量使用标准的异常"><a href="#尽量使用标准的异常" class="headerlink" title="尽量使用标准的异常"></a>尽量使用标准的异常</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165242767.png" alt="image-20241101165242767"></p><h3 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165302605.png" alt="image-20241101165302605"></p><h3 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h3><blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165328094.png" alt="image-20241101165328094"></p></blockquote><h3 id="不要捕获-Throwable-类"><a href="#不要捕获-Throwable-类" class="headerlink" title="不要捕获 Throwable 类"></a>不要捕获 Throwable 类</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165342076.png" alt="image-20241101165342076"></p><h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165357075.png" alt="image-20241101165357075"></p><h3 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165419496.png" alt="image-20241101165419496"></p><h3 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165441805.png" alt="image-20241101165441805"></p><h3 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h3><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h3 id="不要在finally块中使用return。"><a href="#不要在finally块中使用return。" class="headerlink" title="不要在finally块中使用return。"></a>不要在finally块中使用return。</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101165509040.png" alt="image-20241101165509040"></p><h2 id="深入理解异常"><a href="#深入理解异常" class="headerlink" title="深入理解异常"></a>深入理解异常</h2><h6 id="JVM理解"><a href="#JVM理解" class="headerlink" title="JVM理解"></a>JVM理解</h6><p>提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleTryCatch</span>()</span> &#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>       testNPE();<br>   &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55a6788fda381eca924a1c8bbff8b7c5.jpg" alt="55a6788fda381eca924a1c8bbff8b7c5"></p><p>Exception table，异常表。异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下from 可能发生异常的起始点to 可能发生异常的结束点target 上述from和to之前发生异常后的异常处理者的位置type 异常处理者处理的异常的类信息</p><blockquote><p>答案是异常发生的时候，当一个异常发生时</p><ul><li>1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理</li><li>2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。</li><li>3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目</li><li>4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。</li><li>5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。</li><li>6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。</li></ul><p>以上就是JVM处理异常的一些机制。</p></blockquote><h6 id="try-catch-finally-1"><a href="#try-catch-finally-1" class="headerlink" title="try catch -finally"></a><strong>try catch -finally</strong></h6><p>除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleTryCatchFinally</span>()</span> &#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>       testNPE();<br>   &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       e.printStackTrace();<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>       System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>   &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241101170705389.png" alt="image-20241101170705389"></p><p>finally是如何保证自己一定被执行的</p><p>正常情况下。执行完后调转到41</p><p>异常情况。从异常表跳到14 如果异常内正常执行 就跳到41</p><p>如果异常内发生错误14-19 就跳转到31执行finally</p><h6 id="cathc问题"><a href="#cathc问题" class="headerlink" title="cathc问题"></a>cathc问题</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4f479bcf6c21c2e1c7dd2ec5f6b97ec.jpeg" alt="c4f479bcf6c21c2e1c7dd2ec5f6b97ec"></p><p>异常表越靠前，就越先被捕获</p><h6 id="return和finally"><a href="#return和finally" class="headerlink" title="return和finally"></a>return和finally</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fe9a179b2d5911bec2067818b2bebafd_720.jpg" alt="fe9a179b2d5911bec2067818b2bebafd_720"></p><p>都会执行</p><p>还是三种情况<br>正常情况下。 拷贝1<br>异常情况。异常内有异常 跳转拷贝<br>异常正常执行情况  拷贝</p><h6 id="异常耗时"><a href="#异常耗时" class="headerlink" title="异常耗时"></a>异常耗时</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4950aabdfa51244c7e19861cbd621f57_720.jpg" alt="4950aabdfa51244c7e19861cbd621f57_720"></p><p>newException() 方法：<br>这个方法创建了testTimes个Exception实例。<br>与Object不同，Exception类包含了一些额外的字段和方法，用于存储异常信息、堆栈跟踪等。<br>创建Exception对象时，JVM需要分配更多的内存，并可能执行一些初始化操作，比如设置异常消息和堆栈跟踪。<br>这些额外的操作使得创建Exception对象比创建Object对象要慢。<br>3.<br>catchException() 方法：<br>这个方法不仅创建了testTimes个Exception对象，还抛出了它们并捕获。<br>抛出异常涉及到在调用栈中查找合适的异常处理器，这需要遍历调用栈并检查每个方法是否有匹配的catch块。<br>捕获异常时，JVM需要执行catch块中的代码，这可能包括记录日志、清理资源等操作。<br>这些操作比仅仅创建对象要复杂得多，因此这个方法执行起来最慢。</p><p><a href="https://www.iteye.com/blog/icyfenix-857722">https://www.iteye.com/blog/icyfenix-857722</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-数据库的管理和维护</title>
    <link href="/2024/10/31/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E7%BB%B4%E6%8A%A4/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E7%BB%B4%E6%8A%A4/"/>
    <url>/2024/10/31/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E7%BB%B4%E6%8A%A4/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E7%BB%B4%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库的管理和维护"><a href="#数据库的管理和维护" class="headerlink" title="数据库的管理和维护"></a>数据库的管理和维护</h1><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><p>1.数据备份和还原</p><p>2.用户管理</p><p>user表</p><p>创建用户</p><p>删除用户</p><p>修改用户密码</p><p>3.权限管理</p><p>mysql权限</p><p>授予权限</p><p>查看权限权限</p><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><h4 id="9-11数据的备份"><a href="#9-11数据的备份" class="headerlink" title="9.11数据的备份"></a>9.11数据的备份</h4><p><code>mysqldump</code> 是 MySQL 提供的一个命令行工具，可以生成数据库的逻辑备份。可以备份单个或多个数据库</p><p>备份单个数据库的命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysqldump -u username -<span class="hljs-selector-tag">p</span> password   dbname <span class="hljs-selector-attr">[tbname1 tbname2]</span> &gt; backup_file<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><p>dbname是数据库，后面是表名。表名用空格隔开，如果不指定表名就备份整个表</p><p>备份多个数据库</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysqldump -u username -<span class="hljs-selector-tag">p</span> password   <span class="hljs-attr">--databases</span> database1 database2 database3  &gt; backup_file<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><p>database参数后面 至少指定一个数据库。如果有多个用空格隔开</p><p>备份所有数据库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mysqldump -u username -<span class="hljs-selector-tag">p</span> password <span class="hljs-attr">--all-databases</span> &gt; all_databases_backup<span class="hljs-selector-class">.sql</span><br><br></code></pre></td></tr></table></figure><p>如果使用了 –all-databases 参数备份了所有数据库，在还原时，就不需要创建数据库，并指定要操作的数据库了</p><p>备份文件包含了use语句 create database</p><p>数据库备份文件包含了mysqldump的版本号和mysql的版本号 主机名称和备份的数据库名称等注释信息</p><p>–开头sql语言的注释</p><p>&#x2F;*! *&#x2F;结尾都是可执行的mysql语句</p><h4 id="9-12-数据的还原"><a href="#9-12-数据的还原" class="headerlink" title="9.12 数据的还原"></a>9.12 数据的还原</h4><p>数据还原可以使用mysql命令和source命令</p><h6 id="mysql还原"><a href="#mysql还原" class="headerlink" title="mysql还原"></a>mysql还原</h6><p>还原单个数据库</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u username -<span class="hljs-selector-tag">p</span>   database_name&lt; backup_file<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><p>database_name还原的数据库名称 (backup_file-如果包含创建数据库就不需要指定)</p><p>还原所有</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u username -<span class="hljs-selector-tag">p</span> &lt; all_databases_backup<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><p>案例</p><p>1，创建数据库</p><p>2.还原数据</p><p>3.查看数据</p><h6 id="source还原"><a href="#source还原" class="headerlink" title="source还原"></a>source还原</h6><p><code>source</code> 命令是 MySQL 提供的一种用于执行 SQL 脚本的命令，可以用于还原数据库的备份。使用 <code>source</code> 命令可以从指定的 SQL 文件中逐条执行 SQL 语句。</p><ul><li><pre><code class="hljs">mysql&gt; source /path/to/backup_file.sql;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>source sqlname.sql<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>###### 区别<br><br>![image<span class="hljs-number">-20241031104754434</span>](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241031104754434.png)</span><br><br>mysql不需要登录数据库 source需要<br><br>## 用户管理<br><br>&gt; 掌握用户的管理，能够使用rool用户创建用户、删除用户和修改用户的密码;<br><br>mysql分为两类用户 root user用户<br><br>我们给user用户指定权限，达到数据库安全<br><br>##### user表<br><br>MySQL 的 `user` 表是存储用户账户信息和权限的系统表，位于 MySQL 数据库的 `mysql` 系统数据库中。<br><br>在安装mysql时就自动创建<br><br>`user` 表包含多个字段，主要用于存储用户的身份信息、权限和连接控制等。<br><br>###### <span class="hljs-number">1.</span>用户字段<br><br>字段 <br><br>host  cgar(<span class="hljs-number">255</span>)  主机名<br><br>user char(<span class="hljs-number">32</span>) 用户<br><br>Password/authentication_string text 密码(哈希加密)<br><br><br><br>mysql链接会匹配这三个值<br><br>###### <span class="hljs-number">2.</span>权限字段<br><br>权限字段决定了用户权限 包括查询权限 修改权限 关闭服务等<br><br>select_priv insert_priv updare_priv-&gt;以priv结尾的字段<br><br>![<span class="hljs-number">33685</span>c1ec19ae59b59d864312e868b8e_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/33685c1ec19ae59b59d864312e868b8e_720.jpg)</span><br><br>![<span class="hljs-number">6183917</span>d0760defa618102ab643b4b45_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/6183917d0760defa618102ab643b4b45_720.jpg)</span><br><br>###### <span class="hljs-number">3.</span>安全字段<br><br><br><br>![aa83d9bb9c41bad1716e97c6dc03b557_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/aa83d9bb9c41bad1716e97c6dc03b557_720.jpg)</span><br><br>###### <span class="hljs-number">4.</span>资源控制字段<br><br>![<span class="hljs-number">5</span>c25a2a2957ad420ab916cb08d668fe7_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/5c25a2a2957ad420ab916cb08d668fe7_720.jpg)</span><br><br>![<span class="hljs-number">6</span>b8b1b82f1773315982e26d55093108b_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/6b8b1b82f1773315982e26d55093108b_720.jpg)</span><br><br>#### 用户控制<br><br>###### 用户创建<br><br>mysql用户信息保存在mysql.user表中-我们可以直接在整个表进行增删改查，但是这种方法并不好<br><br>mysql提供了create user <br><br>使用该语句，每创建一个新用户，都会在mysql.user表中添加一条记录，并同时自动修改相应授权表<br><br>默认权限只有链接权限<br><br><br><br></code></pre></td></tr></table></figure>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;,&#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><br>- 案例语句<br><br>- ```<br>  <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;xx&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-string">&#x27;xx2&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure>查询select hsot,user from mysql.user where user=&#39;xx&#39;;</code></pre></li></ul><p>Grant语句创建用户</p><p>在8.0之前版本可以通过grant创建语句 并且在创建用户时对用户进行授权</p><p>语法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> privilege_type <span class="hljs-keyword">ON</span> database_name.<span class="hljs-built_in">table_name</span> <br><span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;password&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>privilege_type 表示要授予的权限类型，可以是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span>：授予所有权限。<br><span class="hljs-keyword">SELECT</span>：查询权限。<br><span class="hljs-keyword">INSERT</span>：插入权限。<br><span class="hljs-keyword">UPDATE</span>：更新权限。<br><span class="hljs-keyword">DELETE</span>：删除权限。<br><span class="hljs-keyword">CREATE</span>：创建表或数据库的权限。<br><span class="hljs-keyword">DROP</span>：删除表或数据库的权限。<br>其他具体权限（如 <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>、<span class="hljs-keyword">INDEX</span>、<span class="hljs-keyword">ALTER</span> 等）。<br></code></pre></td></tr></table></figure><p>**<code>database_name.table_name</code>**：</p><p>指定权限的作用范围。如果是所有数据库，可以使用 <code>*.*</code>，如果是某个数据库的所有表，可以使用 <code>database_name.*</code>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <br>database_name.* <br><span class="hljs-keyword">TO</span> <br><span class="hljs-string">&#x27;newuser&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;secure_password&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><p>drop user&#x2F; delete语句删除用户</p><p>1.使用drop user删除用户</p><p>drop user ‘user‘@’hostname’, ‘user‘@’hostname’;</p><p>执行该用户的必须有drop user权限</p><p>2.使用delete语句删除用户</p><p>delete from mysql.user where host&#x3D;’hostname’ and user&#x3D;’username’;</p><h5 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h5><p>mysql修改密码的方法有四种</p><p>1.使用mysqladmin修改用户密码</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4eed1a88b6a6b07d453c56d76f430a4f.jpeg" alt="4eed1a88b6a6b07d453c56d76f430a4f"></p><p>2.方法2</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fc1bcc377ad46ef518a06d466f6a6914.jpeg" alt="fc1bcc377ad46ef518a06d466f6a6914"></p><p>执行的用户有修改密码权限</p><p>3.方法3</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7cf9fb2b2fd947cbffec998fabfbdc6b.jpeg" alt="7cf9fb2b2fd947cbffec998fabfbdc6b"></p><p>4.方法4</p><p>通过update语句修改用户密码</p><p>通过updata直接更新mysql_user的数据，需要root权限</p><p>update mysql_user set authentication_string&#x3D;password(‘new_password’ )where user&#x3D;’username’ and host&#x3D;’hostname’;</p><h4 id="Root用户找回"><a href="#Root用户找回" class="headerlink" title="Root用户找回"></a>Root用户找回</h4><blockquote><p>1.停止 MySQL 服务</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">net stop Mysql80<br></code></pre></td></tr></table></figure><p>2.启动 MySQL 时跳过授权表，允许无密码访问。使用以下命令：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><br><span class="hljs-comment">mysqld</span> <span class="hljs-literal">--</span><span class="hljs-comment">shared</span><span class="hljs-literal">-</span><span class="hljs-comment">memory</span> <span class="hljs-literal">--</span><span class="hljs-comment">skip</span><span class="hljs-literal">-</span><span class="hljs-comment">grant</span><span class="hljs-literal">-</span><span class="hljs-comment">tables</span><br></code></pre></td></tr></table></figure><p>3.使用命令行工具连接到 MySQL</p><ul><li><pre><code class="hljs">mysql -u root<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>4.加载权限表<br><br></code></pre></td></tr></table></figure>FLUSH PRIVILEGES; --<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>5.设置密码<br><br></code></pre></td></tr></table></figure>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <span class="hljs-number">6.</span>启动mysql服务登录<br><br><br><br><br><br><br><br><br><br><br><br><br><br>##  权限管理<br><br>限制用户在权限范围内操作<br><br>##### <span class="hljs-number">1.</span>Mysql权限<br><br>![<span class="hljs-number">18</span>f52ca6d6f7a70175b2242168bce61d_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/18f52ca6d6f7a70175b2242168bce61d_720.jpg)</span><br><br>![<span class="hljs-number">4</span>f362e9b6d4f608909c910e608814893_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/4f362e9b6d4f608909c910e608814893_720.jpg)</span><br><br><br><br>![fe9e88edc93d2addf7967bf02461ea30_720](https:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/fe9e88edc93d2addf7967bf02461ea30_720.jpg)</span><br><br>##### <span class="hljs-number">2.</span>授予权限<br><br>myqsl提供未用户授予权限语句<br><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>GRANT 权限类型 [字段列表]ON 权限级别(数据库.表名 ) TO ‘用户名‘@’主机名’，’用户名‘@’主机名’ with with_option;</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>权限类是上面的图片中的权限<br><br>字段列表，单独给某个字段给值，如果没指定就是整个表的权限<br><br>权限级别 <span class="hljs-number">9</span><span class="hljs-number">-6</span>包含的权限级别 值<br><br>* ![image<span class="hljs-number">-20241102111847102</span>](https://raw.githubusercontent.com/Xlan-cell/tupian/master/image<span class="hljs-number">-20241102111847102.</span>png)<br><br><span class="hljs-keyword">to</span><br><br>指定 <span class="hljs-number">1</span>个或多个用户<br><br>`<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">OPTION</span>` 选项的取值主要包括以下五个<br><br>**<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>**：允许被授予权限的用户将他们所拥有的权限再授予其他用户。<br><br>**<span class="hljs-keyword">WITH</span> MAX_QUERIES_PER_HOUR**：限制用户每小时最大查询次数。<br><br></code></pre></td></tr></table></figure><p>GRANT SELECT ON mydb.* TO ‘user‘@’localhost’ WITH MAX_QUERIES_PER_HOUR 100;</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>**<span class="hljs-keyword">WITH</span> MAX_UPDATES_PER_HOUR**：限制用户每小时最大更新次数。<br><br>- ```<br>  <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> mydb.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">WITH</span> MAX_UPDATES_PER_HOUR <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p><strong>WITH MAX_CONNECTIONS_PER_HOUR</strong>：限制用户每小时最大连接次数。</p><p><strong>WITH MAX_USER_CONNECTIONS</strong>：限制用户最大同时连接数。</p><p>案例</p><p>给emp_test 用户授予数据库ems的员工表emp的select权限  以及对empno和ename字段的插入权限</p><p>grant select,insert(empno,ename) on ems.emp to ‘emp_test‘@’localhost’;</p><h5 id="3-查看权限"><a href="#3-查看权限" class="headerlink" title="3.查看权限"></a>3.查看权限</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241102115225797.png" alt="image-20241102115225797"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241102115240963.png" alt="image-20241102115240963"></p><h5 id="4-收回权限"><a href="#4-收回权限" class="headerlink" title="4.收回权限"></a>4.收回权限</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241102120036127.png" alt="image-20241102120036127"></p><p>一次性收回</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0cb87ae0e12c6ed6be56712dfdc9cb94.png" alt="0cb87ae0e12c6ed6be56712dfdc9cb94"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java 反射</title>
    <link href="/2024/10/30/java/java%E5%8F%8D%E5%B0%84/java%E5%8F%8D%E5%B0%84/"/>
    <url>/2024/10/30/java/java%E5%8F%8D%E5%B0%84/java%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h5 id="0-反射认识"><a href="#0-反射认识" class="headerlink" title="0.反射认识"></a>0.反射认识</h5><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java反射机制在框架设计中极为广泛，需要深入理解。</p><p>运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p><p>反射就是把java类中的各种成分映射成一个个的Java对象</p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><h5 id="1-反射-原理探究"><a href="#1-反射-原理探究" class="headerlink" title="1.反射 原理探究"></a>1.反射 原理探究</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030111139721.png" alt="image-20241030111139721"></p><p>在Java中，所有的类的父类都是<code>java.lang.Class</code>，这是一个管理类元数据的对象。每个类在加载时，JVM会生成一个唯一的<code>Class</code>对象，这个对象与该类相对应。 当一个类被加载时，JVM会在方法区（Method Area）中为该类创建一个对应的<code>Class</code>对象。这个对象包含了类的结构信息，如字段、方法、父类、接口等元数据。</p><p>通过反射，你可以访问这个<code>Class</code>对象来获取类的元数据信息，比如类名、字段、方法和构造方法等。</p><p>具体来说，每个类都会在第一次被JVM加载时，创建一个唯一的<code>Class</code>实例，并且所有对该类的引用都会指向同一个<code>Class</code>实例。因此，不同实例之间共享同一个<code>Class</code>对象，避免了额外的内存开销。我们可以从反射的角度来验证这一点：</p><p><strong><code>Class</code>对象唯一性</strong>：对于某个类<code>A</code>，不管创建多少个实例，通过反射或<code>A.class</code>获取到的<code>Class</code>对象始终是唯一的。因此，<code>Class</code>对象是每个类的“单例”表示。</p><p><strong>反射访问元数据</strong>：通过反射，<code>Class</code>对象允许我们在运行时访问类的元数据，但不需要知道类的具体信息。比如，可以调用<code>getDeclaredFields</code>获取类的字段，或者调用<code>getDeclaredMethods</code>获取方法，这些操作都作用于同一个<code>Class</code>对象。</p><h5 id="2-获取类实例-原理"><a href="#2-获取类实例-原理" class="headerlink" title="2.获取类实例 原理"></a>2.获取类实例 原理</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="类加载流程"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Class</span>&lt;A&gt; clazz1 = A.<span class="hljs-keyword">class</span>;<br><span class="hljs-keyword">Class</span>&lt;A&gt; clazz2 = (<span class="hljs-keyword">Class</span>&lt;A&gt;) <span class="hljs-keyword">Class</span>.forName(&quot;A&quot;);<br><br>// clazz1 和 clazz2 指向同一个 <span class="hljs-keyword">Class</span> 对象<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(clazz1 == clazz2); // <span class="hljs-keyword">true</span><br><br></code></pre></td></tr></table></figure><p>class.forName(“A”) 如何拿取这个类的信息的呢</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/java-basic-reflection-1.png" alt="img"></p><p>研究</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">package</span> <span class="hljs-title">java.lang;</span><br></code></pre></td></tr></table></figure><p>根据给定的类名返回对应的<code>Class</code>对象，同时还会触发该类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable,<br>                              GenericDeclaration,<br>                              Type,<br>                              AnnotatedElement &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ANNOTATION= <span class="hljs-number">0x00002000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ENUM</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0x00004000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SYNTHETIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x00001000</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerNatives</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        registerNatives();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>forname探究</p><blockquote><p>类加载器的层级结构意味着子类可以从父类的类加载器继承行为。如果使用调用者的类加载器加载类，可以确保类之间的继承关系和访问权限能够正确地处理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-comment">//获取调用者的类  -&gt;方便后续获取类加载器</span><br>    Class&lt;?&gt; caller = Reflection.getCallerClass();<br>    <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-literal">true</span>, ClassLoader.getClassLoader(caller), caller);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><code>className</code>: 需要查找的类的名称。</p><p><code>true</code>: 这个参数指示是否需要初始化类。</p><p><code>ClassLoader.getClassLoader(caller)</code>: 获取调用者的类加载器，以确保使用正确的加载器去加载目标类。只 返回类加载器</p><p><code>caller</code>: 调用者类，用于权限检查。</p></blockquote><p>类加载器获取</p><p>类加载 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="hljs-type">boolean</span> initialize,<br>                                        ClassLoader loader,<br>                                        Class&lt;?&gt; caller)<br></code></pre></td></tr></table></figure><p>forName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。</p><p>主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ClassLoader</span> loader,<br></code></pre></td></tr></table></figure><p>ClassLoader 探究</p><p>探究-&gt;loadClass</p><ol><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>     <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-literal">false</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>-&gt;调用了loadClass(name,false);-&gt;一个小小的双亲委派机制 -</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-comment">// 使用类加载锁来确保线程安全</span><br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先检查类是否已经被加载</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime(); <span class="hljs-comment">// 记录开始时间</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果存在父类加载器，则尝试通过父类加载器加载类</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果没有父类加载器，则尝试在引导类加载器中查找</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// 如果在非空父类加载器中找不到类，则抛出 ClassNotFoundException</span><br>            &#125;<br><br>            <span class="hljs-comment">// 如果仍然未找到类，则调用 findClass 方法查找类</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime(); <span class="hljs-comment">// 记录查找类开始时间</span><br>                c = findClass(name); <span class="hljs-comment">// 查找类的具体实现</span><br><br>                <span class="hljs-comment">// 记录性能统计数据</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果需要解析类，则调用 resolveClass 方法</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c; <span class="hljs-comment">// 返回加载的类</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-类加载对象流程"><a href="#3-类加载对象流程" class="headerlink" title="3.类加载对象流程"></a>3.类加载对象流程</h5><p>下面来看<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/newInstance%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B.png" alt="newInstance实现流程">一下 <strong>newInstance</strong>() 的实现方式。</p><blockquote><ul><li><ol><li>权限检测，如果不通过直接抛出异常；</li></ol></li><li><ol><li>查找无参构造器，并将其缓存起来；</li></ol></li><li><ol><li>调用具体方法的无参构造方法，生成实例并返回；</li></ol></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java">**Constructor&lt;T&gt;**: 这是一个泛型类型，表示缓存的构造函数。通过这个字段，可以避免每次调用 `newInstance` 方法时都重新查找构造函数，提高性能。<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> Constructor&lt;T&gt; cachedConstructor;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> Class&lt;?&gt;       newInstanceCallerCache;<br>这个字段用于缓存调用 newInstance 方法的类（调用者类）。它的存在目的是为了优化安全检查，避免每次都进行昂贵的调用者检查。<br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">()</span><br><span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException<br>&#123;<br>    <span class="hljs-comment">// 检查安全管理器，如果存在则进行访问检查</span><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 注意：以下代码在当前Java内存模型下可能并不严格正确。</span><br><br>    <span class="hljs-comment">// 构造函数查找</span><br>    <span class="hljs-keyword">if</span> (cachedConstructor == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 检查是否是 java.lang.Class 的 Class 对象，不能实例化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == Class.class) &#123;<br>             <span class="hljs-comment">// 不允许调用 Class 的 newInstance() 方法</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalAccessException</span>(<br>                <span class="hljs-string">&quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span><br>            );<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt;[] empty = &#123;&#125;; <span class="hljs-comment">// 空参数数组</span><br>               <span class="hljs-comment">// 获取无参构造器</span><br><br>            <span class="hljs-keyword">final</span> Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);<br>            <span class="hljs-comment">// 禁用构造函数的可访问性检查，因为我们必须在这里进行安全检查</span><br>            <span class="hljs-comment">// （构造函数的安全检查的栈深度是错误的）</span><br>            java.security.AccessController.doPrivileged(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.security.PrivilegedAction&lt;Void&gt;() &#123;<br>                    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        c.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 设置构造函数为可访问</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;);<br>            cachedConstructor = c; <span class="hljs-comment">// 缓存构造函数</span><br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-comment">// 如果找不到构造函数，则抛出实例化异常，并将原始异常作为原因</span><br>            <span class="hljs-keyword">throw</span> (InstantiationException)<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiationException</span>(getName()).initCause(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取缓存的构造函数</span><br>    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;<br><br>    <span class="hljs-comment">// 安全检查（与 java.lang.reflect.Constructor 中的检查相同） </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> tmpConstructor.getModifiers(); <span class="hljs-comment">// 获取构造函数的修饰符 这些修饰符指示了构造函数的访问权限。</span><br>    <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(<span class="hljs-built_in">this</span>, modifiers)) &#123;<br>        <span class="hljs-comment">//通过 Reflection.quickCheckMemberAccess 方法快速检查调用者是否有权限访问这个构造函数。如果没有权限，则进入进一步的权限检查逻辑。</span><br>       <span class="hljs-comment">// 验证这个调用者是否有权访问目标构造函数</span><br>        <br>        Class&lt;?&gt; caller = Reflection.getCallerClass();<br>        <span class="hljs-comment">// 如果调用者与缓存不匹配，进行权限检查</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        如果当前调用者与缓存的调用者类不一致，</span><br><span class="hljs-comment">        调用 Reflection.ensureMemberAccess 方法进行安全检查，</span><br><span class="hljs-comment">        以确保调用者可以访问这个构造函数。如果安全检查通过，则更新 newInstanceCallerCache 为当前调用者类。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (newInstanceCallerCache != caller) &#123;<br>            <span class="hljs-comment">///进行访问权限检查，以确保调用者类 caller 对目标类（即 this）的成员（如构造函数、方法或字段）具有适当的访问权限。</span><br>            Reflection.ensureMemberAccess(caller, <span class="hljs-built_in">this</span>, <span class="hljs-literal">null</span>, modifiers);<br>            newInstanceCallerCache = caller; <span class="hljs-comment">// 更新缓存</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行构造函数</span><br>    <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// 调用无参构造器</span><br>        <span class="hljs-keyword">return</span> tmpConstructor.newInstance((Object[])<span class="hljs-literal">null</span>); <span class="hljs-comment">// 创建实例 -&gt;调用constructor</span><br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>        <span class="hljs-comment">// 如果构造函数抛出异常，抛出目标异常</span><br>        Unsafe.getUnsafe().throwException(e.getTargetException());<br>        <span class="hljs-comment">// 这里不会被执行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是获取构造器的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Constructor&lt;T&gt; <span class="hljs-title function_">getConstructor0</span><span class="hljs-params">(Class&lt;?&gt;[] parameterTypes,</span><br><span class="hljs-params">                                        <span class="hljs-type">int</span> which)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException<br>&#123;<br>    <span class="hljs-comment">// 获取所有构造器，根据访问修饰符选择</span><br>    Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));<br>    <br>    <span class="hljs-comment">// 遍历所有构造器</span><br>    <span class="hljs-keyword">for</span> (Constructor&lt;T&gt; constructor : constructors) &#123;<br>        <span class="hljs-comment">// 检查提供的参数类型数组与构造器的参数类型是否相同 a</span><br>        <span class="hljs-keyword">if</span> (arrayContentsEq(parameterTypes, constructor.getParameterTypes())) &#123;<br>            <span class="hljs-comment">// 如果匹配，则返回构造器的一个复制</span><br>            <span class="hljs-keyword">return</span> getReflectionFactory().copyConstructor(constructor);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果没有找到匹配的构造器，则抛出 NoSuchMethodException</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodException</span>(getName() + <span class="hljs-string">&quot;.&lt;init&gt;&quot;</span> + argumentTypesToString(parameterTypes));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>getConstructor0() 为获取匹配的构造方器；分三步：</p><ul><li><ol><li>先获取所有的constructors, 然后通过进行参数类型比较；</li></ol></li><li><ol><li>找到匹配后，通过 ReflectionFactory copy一份constructor返回；</li></ol></li><li><ol><li>否则抛出 NoSuchMethodException;</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 反射数据类，用于缓存类的反射信息</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionData</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 缓存类中声明的字段（私有和受保护）</span><br>    <span class="hljs-keyword">volatile</span> Field[] declaredFields;<br><br>    <span class="hljs-comment">// 缓存类中公共字段</span><br>    <span class="hljs-keyword">volatile</span> Field[] publicFields;<br><br>    <span class="hljs-comment">// 缓存类中声明的方法（私有和受保护）</span><br>    <span class="hljs-keyword">volatile</span> Method[] declaredMethods;<br><br>    <span class="hljs-comment">// 缓存类中公共方法</span><br>    <span class="hljs-keyword">volatile</span> Method[] publicMethods;<br><br>    <span class="hljs-comment">// 缓存类中声明的构造器（私有和受保护）</span><br>    <span class="hljs-keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;<br><br>    <span class="hljs-comment">// 缓存类中公共构造器</span><br>    <span class="hljs-keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;<br><br>    <span class="hljs-comment">// 中间结果用于获取字段和方法</span><br>    <span class="hljs-keyword">volatile</span> Field[] declaredPublicFields; <span class="hljs-comment">// 缓存声明的公共字段</span><br>    <span class="hljs-keyword">volatile</span> Method[] declaredPublicMethods; <span class="hljs-comment">// 缓存声明的公共方法</span><br>    <span class="hljs-keyword">volatile</span> Class&lt;?&gt;[] interfaces; <span class="hljs-comment">// 缓存类实现的接口</span><br><br>    <span class="hljs-comment">// 创建该 ReflectionData 实例时的 classRedefinedCount 值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> redefinedCount;<br><br>    <span class="hljs-comment">// 构造器，接受 classRedefinedCount 参数并初始化</span><br>    ReflectionData(<span class="hljs-type">int</span> redefinedCount) &#123;<br>        <span class="hljs-built_in">this</span>.redefinedCount = redefinedCount; <span class="hljs-comment">// 设置重定义计数</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前类所有的构造方法，通过 JVM 或缓存</span><br><span class="hljs-comment">// Returns an array of &quot;root&quot; constructors. These Constructor</span><br><span class="hljs-comment">// objects must NOT be propagated to the outside world, but must</span><br><span class="hljs-comment">// instead be copied via ReflectionFactory.copyConstructor.</span><br><br><br><br><span class="hljs-keyword">private</span> Constructor&lt;T&gt;[] privateGetDeclaredConstructors(<span class="hljs-type">boolean</span> publicOnly) &#123;<br>    checkInitted(); <span class="hljs-comment">// 检查类是否已初始化</span><br><br>    Constructor&lt;T&gt;[] res; <span class="hljs-comment">// 存储构造器数组</span><br><br>    <span class="hljs-comment">// 调用 reflectionData() 获取保存的信息，使用软引用保存，</span><br>    <span class="hljs-comment">// 从而使内存不够时可以回收</span><br>    ReflectionData&lt;T&gt; rd = reflectionData();<br>    <br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 根据 publicOnly 参数选择返回公共构造器或所有构造器</span><br>        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;<br>        <br>        <span class="hljs-comment">// 如果存在缓存，则直接返回</span><br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果没有缓存，向 JVM 请求构造器</span><br>    <span class="hljs-keyword">if</span> (isInterface()) &#123;<br>        <span class="hljs-comment">// 如果是接口，返回一个空的构造器数组</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Constructor</span>&lt;?&gt;[<span class="hljs-number">0</span>];<br>        res = temporaryRes;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 使用 native 方法从 JVM 获取构造器</span><br>        res = getDeclaredConstructors0(publicOnly);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将从 JVM 中读取的内容存入缓存</span><br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 根据 publicOnly 参数更新缓存</span><br>        <span class="hljs-keyword">if</span> (publicOnly) &#123;<br>            rd.publicConstructors = res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rd.declaredConstructors = res;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回构造器数组</span><br>&#125;<br><br><br><br><br><br><br><span class="hljs-comment">// 懒惰创建并缓存 ReflectionData</span><br><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title function_">reflectionData</span><span class="hljs-params">()</span> &#123;<br>    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="hljs-built_in">this</span>.reflectionData; <span class="hljs-comment">// 获取软引用</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">classRedefinedCount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.classRedefinedCount; <span class="hljs-comment">// 获取类重定义计数</span><br>    ReflectionData&lt;T&gt; rd; <span class="hljs-comment">// 存储 ReflectionData 对象</span><br><br>    <span class="hljs-comment">// 如果使用缓存，并且软引用未被清除且有效，检查重定义计数</span><br>    <span class="hljs-keyword">if</span> (useCaches &amp;&amp;<br>        reflectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>        (rd = reflectionData.get()) != <span class="hljs-literal">null</span> &amp;&amp;<br>        rd.redefinedCount == classRedefinedCount) &#123;<br>        <span class="hljs-keyword">return</span> rd; <span class="hljs-comment">// 返回缓存的 ReflectionData</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 否则，创建新的 ReflectionData 实例</span><br>    <span class="hljs-keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);<br>&#125;<br><br><span class="hljs-comment">// 新创建缓存，保存反射信息</span><br><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title function_">newReflectionData</span><span class="hljs-params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span><br><span class="hljs-params">                                            <span class="hljs-type">int</span> classRedefinedCount)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!useCaches) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 如果不使用缓存，返回 null</span><br><br>    <span class="hljs-comment">// 使用 CAS 保证更新的线程安全性</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 创建新的 ReflectionData 实例</span><br>        <span class="hljs-comment">///reflectionData：这是一个软引用，指向存储类反射信息的 ReflectionData 实例。通过这种方式，可以在内存紧张时被垃圾回收。</span><br>        ReflectionData&lt;T&gt; rd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectionData</span>&lt;&gt;(classRedefinedCount);<br>        <br>        <span class="hljs-comment">// 尝试 CAS 更新</span><br>        <span class="hljs-keyword">if</span> (Atomic.casReflectionData(<span class="hljs-built_in">this</span>, oldReflectionData, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(rd))) &#123;<br>            <span class="hljs-keyword">return</span> rd; <span class="hljs-comment">// 如果更新成功，返回新实例</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果更新失败，检查当前已被其他线程更新的情况</span><br>        oldReflectionData = <span class="hljs-built_in">this</span>.reflectionData; <span class="hljs-comment">// 更新软引用</span><br>        classRedefinedCount = <span class="hljs-built_in">this</span>.classRedefinedCount; <span class="hljs-comment">// 更新重定义计数</span><br>        <br>        <span class="hljs-comment">// 如果当前软引用有效且重定义计数一致，返回已缓存的对象</span><br>        <span class="hljs-keyword">if</span> (oldReflectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>            (rd = oldReflectionData.get()) != <span class="hljs-literal">null</span> &amp;&amp;<br>            rd.redefinedCount == classRedefinedCount) &#123;<br>            <span class="hljs-keyword">return</span> rd;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>获取所有构造器</p><ul><li><ol><li>先尝试从缓存中获取；</li></ol></li><li><ol><li>如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li></ol></li></ul><p>另外，使用 relactionData() 进行缓存保存；</p><p>其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">arrayContentsEq</span><span class="hljs-params">(Object[] a1, Object[] a2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a2 == <span class="hljs-literal">null</span> || a2.length == <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (a2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> a1.length == <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (a1.length != a2.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a1.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a1[i] != a2[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// sun.reflect.ReflectionFactory</span><br>    <span class="hljs-comment">/** Makes a copy of the passed constructor. The returned</span><br><span class="hljs-comment">        constructor is a &quot;child&quot; of the passed one; see the comments</span><br><span class="hljs-comment">        in Constructor.java for details. */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Constructor&lt;T&gt; <span class="hljs-title function_">copyConstructor</span><span class="hljs-params">(Constructor&lt;T&gt; arg)</span> &#123;<br>        <span class="hljs-keyword">return</span> langReflectAccess().copyConstructor(arg);<br>    &#125;<br>    <br>    <span class="hljs-comment">// java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来</span><br>    Constructor&lt;T&gt; <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// This routine enables sharing of ConstructorAccessor objects</span><br>        <span class="hljs-comment">// among Constructor objects which refer to the same underlying</span><br>        <span class="hljs-comment">// method in the VM. (All of this contortion is only necessary</span><br>        <span class="hljs-comment">// because of the &quot;accessibility&quot; bit in AccessibleObject,</span><br>        <span class="hljs-comment">// which implicitly requires that new java.lang.reflect</span><br>        <span class="hljs-comment">// objects be fabricated for each reflective call on Class</span><br>        <span class="hljs-comment">// objects.)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.root != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Can not copy a non-root Constructor&quot;</span>);<br><br>        Constructor&lt;T&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Constructor</span>&lt;&gt;(clazz,<br>                                               parameterTypes,<br>                                               exceptionTypes, modifiers, slot,<br>                                               signature,<br>                                               annotations,<br>                                               parameterAnnotations);<br>        <span class="hljs-comment">// root 指向当前 constructor</span><br>        res.root = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// Might as well eagerly propagate this if already present</span><br>        res.constructorAccessor = constructorAccessor;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>通过上面，获取到 Constructor 了。</p><p>接下来就只需调用其相应构造器的 newInstance()，即返回实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// return tmpConstructor.newInstance((Object[])null); </span><br>   <span class="hljs-comment">// java.lang.reflect.Constructor</span><br>   <span class="hljs-meta">@CallerSensitive</span><br>   <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Object ... initargs)</span><br>       <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,<br>              IllegalArgumentException, InvocationTargetException<br>   &#123;<br>       <span class="hljs-keyword">if</span> (!override) &#123;<br>           <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>               Class&lt;?&gt; caller = Reflection.getCallerClass();<br>               checkAccess(caller, clazz, <span class="hljs-literal">null</span>, modifiers);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot reflectively create enum objects&quot;</span>);<br>       <span class="hljs-type">ConstructorAccessor</span> <span class="hljs-variable">ca</span> <span class="hljs-operator">=</span> constructorAccessor;   <span class="hljs-comment">// read volatile</span><br>       <span class="hljs-keyword">if</span> (ca == <span class="hljs-literal">null</span>) &#123;<br>           ca = acquireConstructorAccessor();<br>       &#125;<br>       <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>       <span class="hljs-type">T</span> <span class="hljs-variable">inst</span> <span class="hljs-operator">=</span> (T) ca.newInstance(initargs);<br>       <span class="hljs-keyword">return</span> inst;<br>   &#125;<br>   <span class="hljs-comment">// sun.reflect.DelegatingConstructorAccessorImpl</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Object[] args)</span><br>     <span class="hljs-keyword">throws</span> InstantiationException,<br>            IllegalArgumentException,<br>            InvocationTargetException<br>   &#123;<br>       <span class="hljs-keyword">return</span> delegate.newInstance(args);<br>   &#125;<br>   <span class="hljs-comment">// sun.reflect.NativeConstructorAccessorImpl</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Object[] args)</span><br>       <span class="hljs-keyword">throws</span> InstantiationException,<br>              IllegalArgumentException,<br>              InvocationTargetException<br>   &#123;<br>       <span class="hljs-comment">// We can&#x27;t inflate a constructor belonging to a vm-anonymous class</span><br>       <span class="hljs-comment">// because that kind of class can&#x27;t be referred to by name, hence can&#x27;t</span><br>       <span class="hljs-comment">// be found from the generated bytecode.</span><br>       <span class="hljs-keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()<br>               &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;<br>           <span class="hljs-type">ConstructorAccessorImpl</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> (ConstructorAccessorImpl)<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>().<br>                   generateConstructor(c.getDeclaringClass(),<br>                                       c.getParameterTypes(),<br>                                       c.getExceptionTypes(),<br>                                       c.getModifiers());<br>           parent.setDelegate(acc);<br>       &#125;<br><br>       <span class="hljs-comment">// 调用native方法，进行调用 constructor</span><br>       <span class="hljs-keyword">return</span> newInstance0(c, args);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。</p><p>construct探究-newInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Object ... initargs)</span><br>        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,<br>               IllegalArgumentException, InvocationTargetException &#123;<br>    <span class="hljs-comment">// 检查是否覆盖访问控制</span><br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-comment">// 如果没有覆盖，快速检查成员访问权限</span><br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            <span class="hljs-comment">// 获取调用者的类</span><br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            <span class="hljs-comment">// 检查调用者是否有权访问该类</span><br>            checkAccess(caller, clazz, <span class="hljs-literal">null</span>, modifiers);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查该类是否是枚举类，枚举类不能通过反射创建实例</span><br>    <span class="hljs-keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot reflectively create enum objects&quot;</span>);<br><br>    <span class="hljs-comment">// 读取构造器访问器（构造器的底层实现），可能是 null</span><br>    <span class="hljs-type">ConstructorAccessor</span> <span class="hljs-variable">ca</span> <span class="hljs-operator">=</span> constructorAccessor;   <span class="hljs-comment">// 读取 volatile 变量</span><br>    <span class="hljs-keyword">if</span> (ca == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果构造器访问器为 null，获取一个新的构造器访问器</span><br>        ca = acquireConstructorAccessor();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用构造器访问器的 newInstance 方法创建新实例，并传入初始化参数</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">inst</span> <span class="hljs-operator">=</span> (T) ca.newInstance(initargs);<br>    <br>    <span class="hljs-keyword">return</span> inst; <span class="hljs-comment">// 返回创建的实例</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-Field字段获取解析"><a href="#4-Field字段获取解析" class="headerlink" title="4.Field字段获取解析"></a>4.Field字段获取解析</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E6%B5%81%E7%A8%8B.png" alt="获取字段流程"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> Field <span class="hljs-title function_">getField</span><span class="hljs-params">(String name)</span><br>    <span class="hljs-keyword">throws</span> NoSuchFieldException, SecurityException &#123;<br>    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-literal">true</span>); <span class="hljs-comment">//-&gt;权限判断</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> getField0(name);<span class="hljs-comment">//跟踪</span><br>    <span class="hljs-keyword">if</span> (field == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchFieldException</span>(name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> field;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Field <span class="hljs-title function_">getField0</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException &#123;<br>    <span class="hljs-comment">// 说明：这个例程使用的搜索算法应该等同于privateGetPublicFields()方法强加的排序。</span><br>    <span class="hljs-comment">// 它只为每个类获取声明的公共字段，然而，为了减少在常见情况下需要为请求的字段创建的Field对象数量，</span><br>    <span class="hljs-comment">// 这通常发生在字段在被查询的类中声明时。</span><br>    Field res;<br>    <span class="hljs-comment">// 搜索声明的公共字段</span><br>    <span class="hljs-keyword">if</span> ((res = searchFields(privateGetDeclaredFields(<span class="hljs-literal">true</span>), name)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 如果在当前类中找到字段，则返回</span><br>    &#125;<br>    <span class="hljs-comment">// 递归搜索直接的超接口</span><br>    Class&lt;?&gt;[] interfaces = getInterfaces(); <span class="hljs-comment">// 获取当前类实现的所有接口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; interfaces.length; i++) &#123;<br>        Class&lt;?&gt; c = interfaces[i]; <span class="hljs-comment">// 遍历接口</span><br>        <span class="hljs-comment">//递归搜索</span><br>        <span class="hljs-keyword">if</span> ((res = c.getField0(name)) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 递归在每个接口中搜索字段</span><br>            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 如果在接口中找到字段，则返回</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 递归搜索直接的超类</span><br>    <span class="hljs-keyword">if</span> (!isInterface()) &#123; <span class="hljs-comment">// 如果当前类不是接口</span><br>        Class&lt;?&gt; c = getSuperclass(); <span class="hljs-comment">// 获取当前类的直接超类</span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果有超类</span><br>            <span class="hljs-keyword">if</span> ((res = c.getField0(name)) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 递归在超类中搜索字段</span><br>                <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 如果在超类中找到字段，则返回</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 如果在当前类、其接口和超类中都没有找到字段，则返回null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>递归getField0 搜索超类和超接口所有字段 </p><p>privateGetDeclaredFields 函数查看</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">searchFields</span><span class="hljs-params">(privateGetDeclaredFields(true)</span></span>, name)<br></code></pre></td></tr></table></figure><ul><li><p>privateGetDeclaredFields 这个方法名表明它获取当前类中声明的所有字段，包括私有字段，但不包括继承的字段。</p></li><li><p>searchFields这个方法在提供的字段集合 <code>fields</code> 中搜索具有特定名称 <code>name</code> 的字段。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> Field[] privateGetDeclaredFields(<span class="hljs-type">boolean</span> publicOnly) &#123;<br>    <span class="hljs-comment">// 检查是否已经初始化</span><br>    checkInitted();<br>    Field[] res; <span class="hljs-comment">// 用于存储结果的数组</span><br><br>    <span class="hljs-comment">// 读取缓存的反射数据</span><br>    ReflectionData&lt;T&gt; rd = reflectionData(); <span class="hljs-comment">// 获取与当前类相关的反射数据</span><br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果只请求公共字段，则从缓存中获取公共字段数组</span><br>        <span class="hljs-comment">// 否则，从缓存中获取所有字段数组</span><br>        res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 如果缓存中有值，则直接返回</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有缓存值可用，请求VM（虚拟机）提供值</span><br>    res = Reflection.filterFields(<span class="hljs-built_in">this</span>, getDeclaredFields0(publicOnly)); <span class="hljs-comment">// 获取当前类声明的所有字段</span><br><br>    <span class="hljs-comment">// 如果之前读取到缓存数据，则更新缓存</span><br>    <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (publicOnly) &#123;<br>            rd.declaredPublicFields = res; <span class="hljs-comment">// 更新缓存中的公共字段数组</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rd.declaredFields = res; <span class="hljs-comment">// 更新缓存中的所有字段数组</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回字段数组</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-Method-获取方法"><a href="#5-Method-获取方法" class="headerlink" title="5.Method 获取方法"></a>5.Method 获取方法</h5><p>只对流程进行解析</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">//根据参数获取public的Method,包含继承自父类的方法</span><br><span class="hljs-keyword">Method</span> <span class="hljs-title function_">method</span> = <span class="hljs-title function_">clazz</span>.<span class="hljs-title function_">getMethod</span><span class="hljs-params">(&quot;draw&quot;,int.class,String.class)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">(String name, Class&lt;?&gt;... parameterTypes)</span><br>     <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException &#123;<br>     checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-literal">true</span>);<br>     <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> getMethod0(name, parameterTypes, <span class="hljs-literal">true</span>);<span class="hljs-comment">//获取方法</span><br>     <span class="hljs-keyword">if</span> (method == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodException</span>(getName() + <span class="hljs-string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));<br>     &#125;<br>     <span class="hljs-keyword">return</span> method;<br> &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getMethod0</span><span class="hljs-params">(String name, Class&lt;?&gt;[] parameterTypes, <span class="hljs-type">boolean</span> includeStaticMethods)</span> &#123;<br>       <span class="hljs-comment">// 创建一个用于存储候选方法的MethodArray对象，初始容量为2</span><br>    <span class="hljs-type">MethodArray</span> <span class="hljs-variable">interfaceCandidates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodArray</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">///获取方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span>  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates);<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-comment">// Not found on class or superclass directly</span><br>        <span class="hljs-comment">// 如果在当前类或其超类中没有找到匹配的方法</span><br><br>        interfaceCandidates.removeLessSpecifics();<br>     <span class="hljs-comment">// 返回候选列表中的第一个方法，如果没有找到任何匹配的方法，则可能返回null</span><br>        <span class="hljs-keyword">return</span> interfaceCandidates.getFirst(); <span class="hljs-comment">// may be null</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>privateGetMethodRecursive</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Method <span class="hljs-title function_">privateGetMethodRecursive</span><span class="hljs-params">(String name,</span><br><span class="hljs-params">            Class&lt;?&gt;[] parameterTypes,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> includeStaticMethods,</span><br><span class="hljs-params">            MethodArray allInterfaceCandidates)</span> &#123;<br>    <span class="hljs-comment">// 说明：这个例程使用的搜索算法应该等同于privateGetPublicMethods()方法强加的排序。</span><br>    <span class="hljs-comment">// 它只为每个类获取声明的公共方法，然而，为了减少在常见情况下需要为请求的方法创建的Method对象数量，</span><br>    <span class="hljs-comment">// 这通常发生在方法在被查询的类中声明时。</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 由于默认方法的存在，除非在超类中找到了方法，否则需要考虑在任何超接口中声明的方法。</span><br>    <span class="hljs-comment">// 在&#123;@code allInterfaceCandidates&#125;中收集所有在超接口中声明的候选方法，如果在超类中没有找到匹配，</span><br>    <span class="hljs-comment">// 则选择最具体的候选方法。</span><br><br>    <span class="hljs-comment">// 不能返回根方法</span><br>    Method res;<br>    <span class="hljs-comment">// 搜索声明的公共方法</span><br>    <span class="hljs-keyword">if</span> ((res = searchMethods(privateGetDeclaredMethods(<span class="hljs-literal">true</span>),<br>                             name,<br>                             parameterTypes)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))<br>            <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 搜索超类的方法</span><br>    <span class="hljs-keyword">if</span> (!isInterface()) &#123;<br>        Class&lt;? <span class="hljs-built_in">super</span> T&gt; c = getSuperclass();<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-literal">true</span>)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 搜索超接口的方法</span><br>    Class&lt;?&gt;[] interfaces = getInterfaces();<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; c : interfaces)<br>        <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-literal">false</span>)) != <span class="hljs-literal">null</span>)<br>            allInterfaceCandidates.add(res);<br>    <span class="hljs-comment">// 未找到</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">privateGetDeclaredMethods</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Method[] privateGetDeclaredMethods(<span class="hljs-type">boolean</span> publicOnly) &#123;<br>      checkInitted();<br>      Method[] res;<br>      ReflectionData&lt;T&gt; rd = reflectionData();<br>      <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>          res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;<br>          <span class="hljs-keyword">if</span> (res != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>      &#125;<br>      <span class="hljs-comment">// No cached value available; request value from VM</span><br>      res = Reflection.filterMethods(<span class="hljs-built_in">this</span>, getDeclaredMethods0(publicOnly));<br>      <span class="hljs-keyword">if</span> (rd != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (publicOnly) &#123;<br>              rd.declaredPublicMethods = res;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              rd.declaredMethods = res;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="0-反射"><a href="#0-反射" class="headerlink" title="0.反射"></a>0.反射</h4><p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。</p><p>在反射包中，我们常用的类主要有<strong>Constructor</strong>类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、</p><p><strong>Field</strong>表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)</p><p><strong>Method</strong>表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。</p><h4 id="1-class类"><a href="#1-class类" class="headerlink" title="1.class类"></a>1.class类</h4><h6 id="1-认识class类"><a href="#1-认识class类" class="headerlink" title="1..认识class类"></a>1..认识class类</h6><p>在类加载的时候，jvm会创建一个class对象</p><p>class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种</p><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全限定类名)</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030170655165.png" alt="image-20241030170655165"></p><p><code>Class</code> 类是反射机制的核心，代表一个类或接口的运行时类型信息。每个 Java 类都有一个与之对应的 <code>Class</code> 对象，这个对象由 Java 虚拟机（JVM）自动创建和管理。</p><p><code>Class</code> 对象提供有关类或接口的详细信息，例如名称、父类、实现的接口、字段、方法和构造器等。</p><p><strong>Class 类的性质</strong>：<code>Class</code> 类本身也是一种类，与使用 <code>class</code> 关键字定义的类是不同的。手动编写的类在编译后会生成一个 <code>Class</code> 对象，这个对象表示该类的类型信息，并保存在同名的 <code>.class</code> 字节码文件中。</p><p><strong>唯一性</strong>：对于每个通过 <code>class</code> 关键字定义的类，在内存中只会存在一个对应的 <code>Class</code> 对象。这意味着无论创建多少个该类的实例，所有实例都共享同一个 <code>Class</code> 对象。</p><p><strong>构造函数的私有性</strong>：<code>Class</code> 类的构造函数是私有的，因此只有 JVM 能够创建和加载 <code>Class</code> 对象。</p><p><strong>提供类型信息</strong>：<code>Class</code> 对象在运行时提供或获取某个对象的类型信息，这对反射技术非常重要。反射允许程序在运行时查询和操作对象的属性和行为。</p><p>类记载过程</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030170944205.png" alt="image-20241030170944205" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030171053820.png" alt="image-20241030171053820" style="zoom: 50%;" /><h6 id="2-class使用"><a href="#2-class使用" class="headerlink" title="2.class使用"></a>2.class使用</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> classTest() throws <span class="hljs-keyword">Exception</span> &#123;<br>    // 获取<span class="hljs-keyword">Class</span>对象的三种方式<br>    logger.<span class="hljs-keyword">info</span>(&quot;根据类名:  \t&quot; + <span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>);<br>    logger.<span class="hljs-keyword">info</span>(&quot;根据对象:  \t&quot; + <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>().getClass());<br>    logger.<span class="hljs-keyword">info</span>(&quot;根据全限定类名:\t&quot; + <span class="hljs-keyword">Class</span>.forName(&quot;com.test.User&quot;));<br>    // 常用的方法<br>    logger.<span class="hljs-keyword">info</span>(&quot;获取全限定类名:\t&quot; + userClass.getName());<br>    logger.<span class="hljs-keyword">info</span>(&quot;获取类名:\t&quot; + userClass.getSimpleName());<br>    logger.<span class="hljs-keyword">info</span>(&quot;实例化:\t&quot; + userClass.newInstance());<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-Constructor"><a href="#2-Constructor" class="headerlink" title="2.Constructor"></a>2.Constructor</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E5%9B%9B%E7%A7%8D%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png" alt="四种获取构造函数调用"></p><h6 id="1-了解"><a href="#1-了解" class="headerlink" title="1.了解"></a>1.了解</h6><blockquote><p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030171530856.png" alt="image-20241030171530856"></p><h6 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructionTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        Class&lt;?&gt; clazz = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">//获取Class对象的引用</span><br>        clazz = Class.forName(<span class="hljs-string">&quot;com.example.javabase.User&quot;</span>);<br><br>        <span class="hljs-comment">//第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) clazz.newInstance();<br>        user.setAge(<span class="hljs-number">20</span>);<br>        user.setName(<span class="hljs-string">&quot;Jack&quot;</span>);<br>        System.out.println(user);<br><br>        System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);<br><br>        <span class="hljs-comment">//获取带String参数的public构造函数</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">cs1</span> <span class="hljs-operator">=</span>clazz.getConstructor(String.class);<br>        <span class="hljs-comment">//创建User</span><br>        User user1= (User) cs1.newInstance(<span class="hljs-string">&quot;hiway&quot;</span>);<br>        user1.setAge(<span class="hljs-number">22</span>);<br>        System.out.println(<span class="hljs-string">&quot;user1:&quot;</span>+user1.toString());<br><br>        System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);<br><br>        <span class="hljs-comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span><br>        Constructor cs2=clazz.getDeclaredConstructor(<span class="hljs-type">int</span>.class,String.class);<br>        <span class="hljs-comment">//由于是private必须设置可访问</span><br>        cs2.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//创建user对象</span><br>        User user2= (User) cs2.newInstance(<span class="hljs-number">25</span>,<span class="hljs-string">&quot;hiway2&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user2:&quot;</span>+user2.toString());<br><br>        System.out.println(<span class="hljs-string">&quot;--------------------------------------------&quot;</span>);<br><br>        <span class="hljs-comment">//获取所有构造包含private</span><br>        Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors();<br>        <span class="hljs-comment">// 查看每个构造方法需要的参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cons.length; i++) &#123;<br>            <span class="hljs-comment">//获取构造函数参数类型</span><br>            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();<br>            System.out.println(<span class="hljs-string">&quot;构造函数[&quot;</span>+i+<span class="hljs-string">&quot;]:&quot;</span>+cons[i].toString() );<br>            System.out.print(<span class="hljs-string">&quot;参数类型[&quot;</span>+i+<span class="hljs-string">&quot;]:(&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; clazzs.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j == clazzs.length - <span class="hljs-number">1</span>)<br>                    System.out.print(clazzs[j].getName());<br>                <span class="hljs-keyword">else</span><br>                    System.out.print(clazzs[j].getName() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有构造</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> age</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">/* output <br><span class="hljs-section">User&#123;age=20, name=&#x27;Jack&#x27;&#125;</span><br><span class="hljs-section">--------------------------------------------</span><br><span class="hljs-section">user1:User&#123;age=22, name=&#x27;hiway&#x27;&#125;</span><br><span class="hljs-section">--------------------------------------------</span><br><span class="hljs-section">user2:User&#123;age=25, name=&#x27;hiway2&#x27;&#125;</span><br><span class="hljs-section">--------------------------------------------</span><br>构造函数[0]:private com.example.javabase.User(int,java.lang.String)<br>参数类型[0]:(int,java.lang.String)<br>构造函数[1]:public com.example.javabase.User(java.lang.String)<br>参数类型[1]:(java.lang.String)<br>构造函数[2]:public com.example.javabase.User()<br>参数类型[2]:()<br><span class="hljs-code">------</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030171707141.png" alt="image-20241030171707141"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Constructor</span> <span class="hljs-variable">cs3</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(<span class="hljs-type">int</span>.class,String.class);<br>System.out.println(<span class="hljs-string">&quot;-----getDeclaringClass-----&quot;</span>);<br>Class uclazz=cs3.getDeclaringClass();<br><span class="hljs-comment">//Constructor对象表示的构造方法的类</span><br>System.out.println(<span class="hljs-string">&quot;构造方法的类:&quot;</span>+uclazz.getName());<br><br>System.out.println(<span class="hljs-string">&quot;-----getGenericParameterTypes-----&quot;</span>);<br><span class="hljs-comment">//对象表示此 Constructor 对象所表示的方法的形参类型</span><br>Type[] tps=cs3.getGenericParameterTypes();<br><span class="hljs-keyword">for</span> (Type tp:tps) &#123;<br>    System.out.println(<span class="hljs-string">&quot;参数名称tp:&quot;</span>+tp);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;-----getParameterTypes-----&quot;</span>);<br><span class="hljs-comment">//获取构造函数参数类型</span><br>Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();<br><span class="hljs-keyword">for</span> (Class claz:clazzs) &#123;<br>    System.out.println(<span class="hljs-string">&quot;参数名称:&quot;</span>+claz.getName());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;-----getName-----&quot;</span>);<br><span class="hljs-comment">//以字符串形式返回此构造方法的名称</span><br>System.out.println(<span class="hljs-string">&quot;getName:&quot;</span>+cs3.getName());<br><br>System.out.println(<span class="hljs-string">&quot;-----getoGenericString-----&quot;</span>);<br><span class="hljs-comment">//返回描述此 Constructor 的字符串，其中包括类型参数。</span><br>System.out.println(<span class="hljs-string">&quot;getoGenericString():&quot;</span>+cs3.toGenericString());<br>------<br><br></code></pre></td></tr></table></figure><h4 id="3-Field"><a href="#3-Field" class="headerlink" title="3.Field"></a>3.Field</h4><h6 id="1-了解-1"><a href="#1-了解-1" class="headerlink" title="1.了解"></a>1.了解</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030171803749.png" alt="image-20241030171803749"></p><h6 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2.使用"></a>2.使用</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E6%B5%81%E7%A8%8B.png" alt="获取字段流程"></p><p>下面的代码演示了上述方法的使用过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectField</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;<br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;reflect.Student&quot;</span>);<br>        <span class="hljs-comment">//获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span><br>        <span class="hljs-comment">// 否则抛NoSuchFieldException</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;field:&quot;</span>+field);<br><br>        <span class="hljs-comment">//获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span><br>        Field fields[] = clazz.getFields();<br>        <span class="hljs-keyword">for</span> (Field f:fields) &#123;<br>            System.out.println(<span class="hljs-string">&quot;f:&quot;</span>+f.getDeclaringClass());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;================getDeclaredFields====================&quot;</span>);<br>        <span class="hljs-comment">//获取当前类所字段(包含private字段),注意不包含父类的字段</span><br>        Field fields2[] = clazz.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field f:fields2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;f2:&quot;</span>+f.getDeclaringClass());<br>        &#125;<br>        <span class="hljs-comment">//获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field2</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;desc&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;field2:&quot;</span>+field2);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      输出结果: </span><br><span class="hljs-comment">     field:public int reflect.Person.age</span><br><span class="hljs-comment">     f:public java.lang.String reflect.Student.desc</span><br><span class="hljs-comment">     f:public int reflect.Person.age</span><br><span class="hljs-comment">     f:public java.lang.String reflect.Person.name</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     ================getDeclaredFields====================</span><br><span class="hljs-comment">     f2:public java.lang.String reflect.Student.desc</span><br><span class="hljs-comment">     f2:private int reflect.Student.score</span><br><span class="hljs-comment">     field2:public java.lang.String reflect.Student.desc</span><br><span class="hljs-comment">     */</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-comment">//省略set和get方法</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> String desc;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-comment">//省略set和get方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField&#x2F;getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField&#x2F;getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Class对象引用</span><br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;reflect.Student&quot;</span>);<br><br>Student st= (Student) clazz.newInstance();<br><span class="hljs-comment">//获取父类public字段并赋值</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>ageField.set(st,<span class="hljs-number">18</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>nameField.set(st,<span class="hljs-string">&quot;Lily&quot;</span>);<br><br><span class="hljs-comment">//只获取当前类的字段,不获取父类的字段</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">descField</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;desc&quot;</span>);<br>descField.set(st,<span class="hljs-string">&quot;I am student&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">scoreField</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;score&quot;</span>);<br><span class="hljs-comment">//设置可访问，score是private的</span><br>scoreField.setAccessible(<span class="hljs-literal">true</span>);<br>scoreField.set(st,<span class="hljs-number">88</span>);<br>System.out.println(st.toString());<br><br><span class="hljs-comment">//输出结果：Student&#123;age=18, name=&#x27;Lily ,desc=&#x27;I am student&#x27;, score=88&#125; </span><br><br><span class="hljs-comment">//获取字段值</span><br>System.out.println(scoreField.get(st));<br><span class="hljs-comment">// 88</span><br>------<br><br></code></pre></td></tr></table></figure><p>其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下：</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030171931704.png" alt="image-20241030171931704"></p><h4 id="4-Method"><a href="#4-Method" class="headerlink" title="4.Method"></a>4.Method</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030172403150.png" alt="image-20241030172403150"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectMethod</span>  &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;reflect.Circle&quot;</span>);<br><br>        <span class="hljs-comment">//根据参数获取public的Method,包含继承自父类的方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;draw&quot;</span>,<span class="hljs-type">int</span>.class,String.class);<br><br>        System.out.println(<span class="hljs-string">&quot;method:&quot;</span>+method);<br><br>        <span class="hljs-comment">//获取所有public的方法:</span><br>        Method[] methods =clazz.getMethods();<br>        <span class="hljs-keyword">for</span> (Method m:methods)&#123;<br>            System.out.println(<span class="hljs-string">&quot;m::&quot;</span>+m);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;=========================================&quot;</span>);<br><br>        <span class="hljs-comment">//获取当前类的方法包含private,该方法无法获取继承自父类的method</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method1</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;drawCircle&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;method1::&quot;</span>+method1);<br>        <span class="hljs-comment">//获取当前类的所有方法包含private,该方法无法获取继承自父类的method</span><br>        Method[] methods1=clazz.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method m:methods1)&#123;<br>            System.out.println(<span class="hljs-string">&quot;m1::&quot;</span>+m);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;draw&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> count , String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;draw &quot;</span>+ name +<span class="hljs-string">&quot;,count=&quot;</span>+count);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;drawCircle&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAllCount</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino">method:<span class="hljs-keyword">public</span> <span class="hljs-type">void</span> reflect.Shape.<span class="hljs-built_in">draw</span>(<span class="hljs-type">int</span>,java.lang.<span class="hljs-type">String</span>)<br><br>m::<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> reflect.Circle.<span class="hljs-built_in">getAllCount</span>()<br>m::<span class="hljs-keyword">public</span> <span class="hljs-type">void</span> reflect.Shape.<span class="hljs-built_in">draw</span>()<br>m::<span class="hljs-keyword">public</span> <span class="hljs-type">void</span> reflect.Shape.<span class="hljs-built_in">draw</span>(<span class="hljs-type">int</span>,java.lang.<span class="hljs-type">String</span>)<br>m::<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> java.lang.Object.<span class="hljs-built_in">wait</span>(<span class="hljs-type">long</span>,<span class="hljs-type">int</span>) throws java.lang.InterruptedException<br>m::<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> native <span class="hljs-type">void</span> java.lang.Object.<span class="hljs-built_in">wait</span>(<span class="hljs-type">long</span>) throws java.lang.InterruptedException<br>m::<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> java.lang.Object.<span class="hljs-built_in">wait</span>() throws java.lang.InterruptedException<br>m::<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> java.lang.Object.<span class="hljs-built_in">equals</span>(java.lang.Object)<br>m::<span class="hljs-keyword">public</span> java.lang.<span class="hljs-type">String</span> java.lang.Object.<span class="hljs-built_in">toString</span>()<br>m::<span class="hljs-keyword">public</span> native <span class="hljs-type">int</span> java.lang.Object.<span class="hljs-built_in">hashCode</span>()<br>m::<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> native java.lang.Class java.lang.Object.<span class="hljs-built_in">getClass</span>()<br>m::<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> native <span class="hljs-type">void</span> java.lang.Object.<span class="hljs-built_in">notify</span>()<br>m::<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> native <span class="hljs-type">void</span> java.lang.Object.<span class="hljs-built_in">notifyAll</span>()<br><br>=========================================<br>method1::<span class="hljs-keyword">private</span> <span class="hljs-type">void</span> reflect.Circle.<span class="hljs-built_in">drawCircle</span>()<br><br>m1::<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> reflect.Circle.<span class="hljs-built_in">getAllCount</span>()<br>m1::<span class="hljs-keyword">private</span> <span class="hljs-type">void</span> reflect.Circle.<span class="hljs-built_in">drawCircle</span>()<br><br></code></pre></td></tr></table></figure><p>在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而<code>getDeclaredMethod/getDeclaredMethods</code>方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：</p><hr><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Class clazz = Class.forName(<span class="hljs-string">&quot;reflect.Circle&quot;</span>);<br><span class="hljs-comment">//创建对象</span><br>Circle circle = (Circle) clazz.<span class="hljs-built_in">newInstance</span>();<br><br><span class="hljs-comment">//获取指定参数的方法对象Method</span><br>Method method = clazz.<span class="hljs-built_in">getMethod</span>(<span class="hljs-string">&quot;draw&quot;</span>,<span class="hljs-type">int</span>.<span class="hljs-keyword">class</span>,<span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>);<br><br><span class="hljs-comment">//通过Method对象的invoke(Object obj,Object... args)方法调用</span><br>method.<span class="hljs-built_in">invoke</span>(circle,<span class="hljs-number">15</span>,<span class="hljs-string">&quot;圈圈&quot;</span>);<br><br><span class="hljs-comment">//对私有无参方法的操作</span><br>Method method1 = clazz.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">&quot;drawCircle&quot;</span>);<br><span class="hljs-comment">//修改私有方法的访问标识</span><br>method<span class="hljs-number">1.</span><span class="hljs-built_in">setAccessible</span>(<span class="hljs-literal">true</span>);<br>method<span class="hljs-number">1.</span><span class="hljs-built_in">invoke</span>(circle);<br><br><span class="hljs-comment">//对有返回值得方法操作</span><br>Method method2 =clazz.<span class="hljs-built_in">getDeclaredMethod</span>(<span class="hljs-string">&quot;getAllCount&quot;</span>);<br>Integer count = (Integer) method<span class="hljs-number">2.</span><span class="hljs-built_in">invoke</span>(circle);<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;count:&quot;</span>+count);<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">draw</span> 圈圈,count=<span class="hljs-number">15</span><br><span class="hljs-attribute">drawCircle</span><br><span class="hljs-attribute">count</span>:<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241030172502060.png" alt="image-20241030172502060"></p><p>ps:本文大部分内容来自pdai.tech </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql 01 刷题</title>
    <link href="/2024/10/30/%E5%88%B7%E9%A2%98/mysql/mysql%20%E8%AE%AD%E7%BB%83/"/>
    <url>/2024/10/30/%E5%88%B7%E9%A2%98/mysql/mysql%20%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql训练"><a href="#Mysql训练" class="headerlink" title="Mysql训练"></a>Mysql训练</h1><h4 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h4><h5 id="1-单选"><a href="#1-单选" class="headerlink" title="1.单选"></a>1.单选</h5><p>1.不知道 考数据范围-忘记了</p><p>2.d 不知道没学过</p><p>3.a</p><p>4.c</p><p>5.c</p><p>6.c</p><p>7.d</p><p>8.b</p><p>Alter table grade change name username varchar(20);</p><p>9.b</p><p>字符串数据类型的不同  VARCHAR  CHAR</p><p>10</p><p>11c </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/422dea32c989b92b50cbc6f04d457746.png" alt="422dea32c989b92b50cbc6f04d457746"></p><p>12.c</p><p>13 d</p><p>14.b</p><p>primary key 主键约束</p><p>15.c</p><p>数据类型的保留-比如坐标</p><p>DECIMAL(6，4)</p><p>16</p><p>drop database name;</p><p>17c</p><p>varchar</p><p>text-大文本数据</p><p>18 a</p><p>固定字符串varchar</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022165644488.png" alt="image-20241022165644488"></p><p>19c</p><p>create table student(</p><p>id int primary key,</p><p>)</p><p>20 d</p><p>create table student(</p><p>id int default 0</p><p>)</p><p>21 c</p><p>修改数据库便编码</p><p>C、CREATE DATABASE itcast <strong>DEFAULT</strong> CHARACTER SET gbk <strong>COLLATE</strong> gbk_bin;</p><p>22 b</p><p>drop table name;</p><p>23  c</p><p>C、CREATE DATABASE itcast <strong>DEFAULT</strong> <strong>CHARACTER SE</strong>T utf8 <strong>COLLATE</strong> utf8_bin;</p><p>24.修改表名 b</p><p>alter table name  rename newname;</p><p>25.b</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022170412341.png" alt="image-20241022170412341"></p><p>26 b</p><p><strong>primary key</strong>(z1,z2,z3)</p><p>27 b</p><p>fulltext</p><p>28 </p><p>int  MEDIUMINT</p><p>29d</p><p>spatial</p><p>SPATIAL INDEX sp(space)</p><p>30d</p><p>31 D</p><p>二进制类型 blob</p><p>32C</p><p>33 C</p><p>ALTER TABLE <strong>ADD</strong> NAME VARCHAR(255);</p><p>34 B</p><p>DROP</p><p>35 B</p><p>CREATE</p><p>36</p><p>CHAR</p><p>37</p><p>SHOW INDEX FROM NAME;</p><p>EXPLAIN</p><p>38</p><p>CREATE TABLE STUDENT(</p><p>STU_ID INT,COURSE_ID,PRIMARY KEY(STU_ID ,COURSE_ID)</p><p>);</p><p>39</p><p>NAME 数据类型 not null;</p><p>40</p><p>blob</p><p>41 c</p><p>DECIMAL(6，2)</p><p>42</p><p>name sjlx  AUTO_INCREMENT;</p><p>43.c</p><p>索引范围</p><p>44</p><p>drop index name <strong>on</strong> table;</p><p>45c</p><p>int</p><p>46</p><p>alter table name <strong>change</strong> oldname newname varchar(255);</p><ol start="47"><li></li></ol><p>B、UNIQUE INDEX unique_id(id ASC)</p><ol start="48"><li>a</li></ol><p>show databse name;</p><p>49 a</p><p>show table name</p><p>50d</p><p>51d</p><p>blob</p><p>VARBINARY</p><p>52</p><p>text</p><p>53</p><p>varchar</p><p>54</p><p>字段 类型 unique;</p><p>55</p><p>不知道-日期类型</p><p>56</p><p>字段 类型 not null;</p><p>57</p><p>定点数据类型</p><p>58</p><p>DECIMAL(6，2)</p><p>6代表最多的整数位数，2代表小数点后的长度</p><p>59</p><p>show database itcast;</p><p>60</p><p>create table book(</p><p>id int primary key,</p><p>title varchar(50)</p><p>);</p><p>61</p><p>62</p><p>63</p><p>fullext index filltext_text(name);</p><hr><hr><hr><hr><hr><p>UNIQUE</p><p>DEFAULT</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">ENUM</span><br></code></pre></td></tr></table></figure><p> gender ENUM(‘male’, ‘female’, ‘other’),</p><blockquote><p><strong>约束性强</strong>：<code>ENUM</code> 限制了字段的取值范围，保证数据的有效性。</p><p><strong>节省空间</strong>：相比于存储字符串，<code>ENUM</code> 在数据库内部实际上以整数存储，占用的空间比直接存储字符串小。</p><p><strong>方便管理</strong>：通过 <code>ENUM</code> 类型，可以轻松在数据库层面统一管理有限的值范围。</p></blockquote><blockquote><p>如果你的枚举值是非常稳定的（比如性别、状态等不常变动的值），使用 <code>ENUM</code> 是个好选择。</p><p>如果枚举值经常需要修改或扩展，建议将这些值存储在单独的表中，通过外键关联来管理，这样在系统的扩展性和维护性上会更灵活。</p></blockquote><p>数据类型</p><p>唯一索引</p><h5 id="2-多选"><a href="#2-多选" class="headerlink" title="2.多选"></a>2.多选</h5><p>66</p><p>DESCRIBE执行结果  不知道</p><p>67</p><p>TIMESTAMP 不知道-系统的时间-数据类型</p><p>68</p><p>int </p><p>69  a b d</p><p>主键</p><p>70</p><p>time类型不知道</p><p>71</p><p>72</p><p>MySQL中表示日期和时间的数据类型</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023092525521.png" alt="image-20241023092525521"></p><p>YEAR 数据类型占用 1 个字节， YEAR 值的范围为从 1901 到 2155, 还有 0000 </p><p>74</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023092640969.png" alt="image-20241023092640969"></p><p>75</p><p>C、DESC 表名</p><p>D、Show CREATE TABLE 表名<br> 76</p><ol start="79"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023093529546.png" alt="image-20241023093529546"></p><p>80</p><p>81</p><p>D、DROP INDEX 索引名 ON 表名;</p><p>A、ALTER TABLE 表名 DROP INDEX 索引名;</p><h5 id="3-判断题"><a href="#3-判断题" class="headerlink" title="3.判断题"></a>3.判断题</h5><p>100</p><p>ALTER DATABASE 数据库名称 <strong>DEFAULT CHARACTER SET</strong> 编码方式 <strong>COLLATE</strong> 编码方式_bin;</p><p>106</p><p>ALTER TABLE 表名 ADD [UNIQUE|FULLTEXT|SPATIAL] INDEX</p><p>110</p><p>普遍索引是由KEY或INDEX定义的索引，它是MySQL中的基本索引类型，可以创建在任何数据类型中。</p><p>112</p><p>enum类型使用</p><p>117</p><p>多字段主键的语法格式是：PRIMARY KEY (字段名1,字段名2,……字段名n)，其中“字段名1,字段名2,……字段名n”指的是构成主键的多个字段的名称。</p><p>122</p><p>​                                                                                             </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023104449281.png" alt="image-20241023104449281"></p><p>124</p><p>在MySQL中，查看数据表的方式有两种，分别是SHOW CREATE TABLE语句和DESCRIBE语句。</p><h5 id="4-填空题"><a href="#4-填空题" class="headerlink" title="4.填空题"></a>4.填空题</h5><p>1． 在MySQL中，删除数据表的语法格式是【drop table 表名;】。</p><p>在MySQL中，删除字段的基本语法格式是【alter table 表名 drop 字段名;】。</p><p>在MySQL中，浮点数的类型有两种，分别是单精度浮点数类型（FLOAT）和【double】。</p><p>在MySQL中，SHOW CREATE TABLE语句不仅可以查看创建表时的定义语句，还可以查看表的【字符编码】</p><p>在MySQL中，设置表字段值自动增加的基本语法格式是【字段名 数据类型 auto_increment;】。</p><p>用于查看数据库中所有表的SQL语句是【show tables;】。</p><p>1． 在MySQL中，整数类型可分为5种，分别是TINYINT、SMALLINT、MEDIUMINT、【int】和BIGINT。</p><p>1． 在MySQL中，为了加快数据表的查询速度，可以建立【索引】来实现。</p><p>1． 在MySQL中，定义默认值约束的基本语法格式是【属性名 数据类型 default 默认值】。</p><p>1． 若想为表中插入的新记录自动生成唯一的ID，可以使用【唯一】约束来实现。-auti_increnment</p><p>空间索引是由【index】关键字定义的索引，它只能创建在空间数据类型的字段上。</p><p>1． 数据表中字段的唯一性约束是通过【unique】关键字定义的。</p><p>1． 在MySQL中，创建单字段主键的语法格式是【字段名 数据类型 primary key[默认值]；】。</p><p>非空约束指的是字段的值不能为【null】。</p><p>1． 在MySQL中，将数据表grade的username字段修改为表第一个字段的语法格式是【alter table 表名 change username first; 】。P55</p><p>1．  </p><p>在MySQL中，修改字段数据类型的基本语法格式是【alter table 表名 modify 字段名 新数据类型；】</p><p>在MySQL中，使用DESCRIBLE查看表字段信息的语法格式是【describe 数据表名】。</p><p>在MySQL中，修改字段名的基本语法格式是【alter table 表名 change 旧字段名 新字段名 新数据类型；</p><p>1． 在MySQL中，删除数据库名为itcast的命令是【drop database itcast;】。</p><p>数据表中的字段默认值是通过【default】关键字定义的</p><p>在MySQL中，查看创建好的数据库信息的语法格式是【show create database 数据库名；】。</p><p>1． 若想在book表中的authors和info字段上建立一个名称为mulitidx的索引，则SQL语句是【create index mulitidx on book (authors,info);】。</p><p>Create index 索引名 [索引类型] on 数据表名 （字段列表1，字段列表2）；</p><p>1． 在MySQL中，存储的小数都是使用【浮点数】和定点数来表示的。</p><p>1． 在MySQL中，修改表名的基本语法格式【alter table 旧表名 rename 新表名；】。</p><p>MySQL中，查看已经存在数据库的基本语法格式是【show database;】。</p><p>1． 在MySQL的整数类型中，INT类型占用的字节数是【4】个。</p><p>若想在book表中的bookid字段上建立一个名称为uniqueidx的唯一性索引，则SQL语句是【alter table book add unique uniqueidx(bookid);】</p><p>1． 若想在book表的info字段上创建名称为fulltextidx的全文索引，则SQL语句是【alter table book add fulltext index fulltextidx(info);】。</p><h5 id="5-简答题"><a href="#5-简答题" class="headerlink" title="5.简答题"></a>5.简答题</h5><p>168</p><p>唯一约束，数据库默认可以保存重复的值，唯一约束可以确保字段唯一性，如果字段设置唯一约束，那么它字段值不能重复</p><p>name 类型 unique;</p><p>169</p><p>char 不是变长。固定长度</p><p>varchar 变长</p><p>170</p><p>create table tb_qrade(</p><p>id int(11),</p><p>name varchar(20),</p><p>grade float</p><p>);</p><p>180</p><p>数据库默认允许字段空值，当你设置字段为非空约束。那么插入就不能是null值</p><p>属性名 字段类型 not null;</p><p>181</p><p>主键用于唯一标识表中每条记录，作为主键的字段值不能为空且是唯一的，可以是单一字段，也可以是多个字段的组合，每个表最多只能有一个主键约束。</p><p>182</p><p>单 由一个字段主从主键 primary key</p><p>多 多个字段组成主键 primary key</p><ol start="183"><li></li></ol><p>简述什么是索引</p><p> 索引是数据库中为提高数据查询效率而常用的数据库对象，索引在数据表中一列或多列的值与记录行之间按照一定的顺序建立关系，以提高对数据表中数据的查询速度。</p><ol start="184"><li></li></ol><p>默认值约束用于给数据表中的字段指定默认值。即当在表中插入一条新纪录时，如果没有给这个字段赋值，那么数据库系统会自动为这个字段插入指定的默认值。</p><p>基本语法格式：属性名 数据类型 default 默认值；</p><h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h5><p>考察</p><p>数据库 数据表的查看方式</p><p><strong>考察数据类型</strong> </p><p>例如</p><p>字符串数据类型</p><p>日期类型</p><p>二进制类型</p><p>浮点数类型</p><p><strong>考察数据库的创建 删除 数据库编码方式更改</strong></p><p><strong>考察数据表-的</strong></p><p>创建-(约束) -考察添加字段</p><p>修改表名</p><p><strong>考察修改</strong></p><p>修改字段数据类型</p><p>修改字段名和数据类型</p><p><strong>考察删除</strong></p><p>删除表 删除字段 </p><p>考察约束</p><p>考察常用约束</p><p>not null </p><p>default</p><p>primary key</p><p>unique</p><p>分别考察建表指定约束和建表后指定约束</p><p>考察索引</p><p>mysql内的</p><p>1.考察索引的类型-和范围-作用</p><p>2.考察索引的创建 查看 删除</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023231324541.png" alt="image-20241023231324541"></p><h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><h5 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h5><ol><li></li></ol><p>delete from name where id&#x3D;1;</p><ol start="3"><li></li></ol><p>update student set grade&#x3D;100 where id&lt;4;</p><ol start="4"><li></li></ol><p>update student set grade&#x3D;grade+20 ;</p><p>update stundent set grade&#x3D;100 where grade&gt;100;</p><ol start="5"><li></li></ol><p>delete</p><ol start="6"><li></li></ol><p>update name set id&#x3D;100 where;</p><ol start="8"><li></li></ol><p>delete from user where id&gt;5;</p><ol start="9"><li></li></ol><p>insert into student (id,name,grade) values(5,’boya’,99);</p><ol start="10"><li></li></ol><p>update student set name&#x3D;youjun,grade&#x3D;98.5 where id&#x3D;1;</p><p><strong>11.</strong></p><p>TRUNCATE</p><p>考察数据库的操作-</p><ol start="12"><li></li></ol><p>错误考察</p><p>13</p><p>truncate考察-删除指定表 并重新创建表</p><p>truncate:通常被视为数据定义语句，只能删除表中的所有数据和直接删除表，再重新创建一个一模一样的表</p><p>14</p><p>delete from name where</p><p>15</p><p>insert into student (id,name)values (1,”小王);</p><p>16</p><p>insert into student  values(1,”小王)</p><p>17</p><p>insert into student values(1,2,3)（2，3，4）；</p><p>21</p><p>能用于删除表中的所有数据</p><p>B、TRUNCATE比DELETE语句效率更高</p><ol start="22"><li></li></ol><p>update student set grade&#x3D;80 ;</p><p>23</p><p>update</p><h5 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h5><ol start="28"><li></li></ol><p>update account set money&#x3D;money +50 where money&gt;&#x3D;100 and money  &lt;&#x3D;200;</p><p>update account set money&#x3D;money  +50 where money  <strong>between</strong> 100 and 200</p><h5 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h5><p>使用TRUNCATE删除表中的记录，它是先删除数据表，然后重新创建表，所以效率更高。(<strong>√</strong> )</p><h5 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h5><p>写出UPDATE语句的语法格式：【update 数据表名 set 字段名1&#x3D;值1[,字段名2&#x3D;值2，…][where 条件表达式]；】。</p><p>delete from name where;</p><p>insert into name values(),();</p><p>truncate table name;</p><p>insert into ()values(),();</p><h5 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h5><ol start="53"><li></li></ol><p>create database chapter03;</p><p>use chapter-3;</p><p>create table student (</p><p>id int(6) <strong>prim****a</strong>ry key,</p><p>name varechar(255) not null,</p><p>grade float</p><p>);</p><p>insert into student (id,name,grade)values(1,”zhangsan”,98.5);</p><p>update student set grade&#x3D;grade+100;</p><p>update student set grade&#x3D;100 where gade&gt;100;</p><p>delete from student;</p><p>truncate table studnet;</p><ol start="56"><li></li></ol><p>简述DELETE语句与TRUNCATE语句的区别</p><p>（1）delete语句是数据操纵语句，truncate语句是数据定义语句；</p><p>（2）delete语句后面跟where子句，通过指定where子句中的条件表达式只删满足条件的部分数据，而truncate语句只能删除表中的所有数据；</p><p>3）delete语句是逐行删除记录，而truncate语句是直接删除数据表，再创建一个一模一样的数据表，truncate语句效率比delete语句效率高；</p><p>（4）使用truncate语句删除表中数据后，再次向表中添加数据时，自动增加字段的默认初始值重新由1开始，而delete语句删除删除表中所有数据后，再次向表中添加数据时，自动增加字段的值为删除时该字段的最大值加1。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>考察对数据库数据的操作-</p><p>增加 单条 多条 insert into table ()values();</p><p>更新 修改 update table set id&#x3D;id where id&#x3D;1;</p><p>删除 -</p><p>1.delete删除 delete from name where id&#x3D;1;</p><p>truncate删除 truncate from table;</p><p>3.区别</p><p>4.约束的作用</p><h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><h5 id="1-单选题"><a href="#1-单选题" class="headerlink" title="1.单选题"></a>1.单选题</h5><p>1.b</p><ol start="2"><li></li></ol><p>select *from student where not between 2and5;</p><ol start="3"><li>d</li></ol><ul><li><input disabled="" type="checkbox"> 考察函数</li></ul><p>TRIM(str)</p><p>4.a</p><p>select *from test limit 10,20;</p><p>select *from test limit 11,20;</p><ul><li><input disabled="" type="checkbox"> 分页考察</li></ul><ol start="5"><li>c</li></ol><p>select *from srudent  order by grade  desc;</p><ul><li><input disabled="" type="checkbox"> 排序</li></ul><p>6.b</p><ul><li><input disabled="" type="checkbox"> 聚合函数</li></ul><p>7.b</p><ul><li><input disabled="" type="checkbox"> 分组统计</li></ul><p>8.b</p><ul><li><input disabled="" type="checkbox"> 通配符考察</li></ul><p>9.A</p><p>分组-部门编号分组-部门平均工资-工资小于3000</p><p>select deptno,avg(sal) from emp group by  depton where having avg(sal)&lt;3000;</p><ul><li><input disabled="" type="checkbox"> 分组查找</li></ul><p>10</p><p>order by</p><h5 id="2-多选题"><a href="#2-多选题" class="headerlink" title="2.多选题"></a>2.多选题</h5><ol start="11"><li></li></ol><p>select id.name from student;</p><p>SELECT name,id FROM student;</p><ol start="2"><li>b a</li></ol><ul><li><input disabled="" type="checkbox"> like考察匹配</li></ul><p>13 b</p><p>14</p><p>select name as a from user;</p><blockquote><p>如果您省略 <code>AS</code> 关键字，某些数据库系统可能也会接受使用空格来指定别名，像这样：SELECT name a FROM user;</p></blockquote><p>select *from table as u;</p><p>select *from table u;</p><ul><li><input disabled="" type="checkbox"> 设置别名</li></ul><p>15</p><p> a b c </p><ul><li><input disabled="" type="checkbox"> 逻辑运算符号</li></ul><p>16 a d</p><ul><li><input disabled="" type="checkbox"> 关键字LIMIT</li></ul><h5 id="3-判断题-1"><a href="#3-判断题-1" class="headerlink" title="3.判断题"></a>3.判断题</h5><ol><li>7x</li></ol><p>18.1</p><ul><li><input disabled="" type="checkbox"> DISTINCT</li><li><input disabled="" type="checkbox"> 当DISTINCT作用多个字段时，只有DISTINCT关键字后指定的多个字段值都相同，才会被认作是重复记录</li></ul><p>19.1</p><p>20.1</p><ul><li><input disabled="" type="checkbox"> BETWEEN AND</li></ul><p>21.1</p><ul><li><input disabled="" type="checkbox"> 字符串排序</li></ul><p>22.x</p><p>23 1</p><p>24 x</p><p>25不知道</p><h5 id="4-填空题-1"><a href="#4-填空题-1" class="headerlink" title="4.填空题"></a>4.填空题</h5><p>26.Having</p><p>27.AVG</p><p>28AES</p><p>29 LIMIT</p><p>30LIKE</p><p>31DISTINCT</p><p>32</p><p>ORDER BY</p><p>33 TRIM(str)</p><p>34   group by</p><p>35 DISTINCT</p><h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h5><p>自己看</p><h4 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h4><h5 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h5><p>ps:先复习多表查询</p><p>1.a</p><ul><li><input disabled="" type="checkbox"> 内链接 子查询</li></ul><p>2.b</p><p>3.c</p><p>4.b</p><ul><li><input disabled="" type="checkbox"> 外键</li></ul><p>foringn key</p><p>5.c</p><ol start="6"><li></li></ol><p>外键输出</p><p> alter table from  drop foreign key name;</p><p>7 </p><p>drop</p><p>8</p><p>20</p><p>9</p><p>inner join  on条件</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询每一个员工的姓名 , 及关联的部门的名称 <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name,d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span>  （<span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span>）,dept d （<span class="hljs-keyword">on</span>)<span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><p>10 b</p><p>11 a</p><p>12  in</p><p>any </p><p>in </p><p>all</p><p>13</p><h5 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h5><p>14</p><p>alter table name add constraint wjname</p><p>foreign key (zbname) references fname(fzdname);</p><p>C.ALTER TABLE 从表名 ADD CONSTRAINT FOREIGN KEY (外键字段名) REFERENCES 主表名(主键字段名);</p><p>15</p><p>a </p><p>b </p><p>c</p><p>d</p><p>16</p><p>可以在子查询中使用的比较运算符有</p><p>&#x3D; !&#x3D; </p><p>17</p><p>a c</p><h5 id="判断题-1"><a href="#判断题-1" class="headerlink" title="判断题"></a>判断题</h5><p>省</p><p>填空题、1.any</p><p>2.exists-判断子查询的结果集是否为空</p><p>3.笛卡尔积</p><p>4.主键</p><p>5.匹配条件</p><p>6.left join</p><p>请简述左连接查询和右连接查询的区别。</p><p>左 left join </p><p>右right join</p><p>左-返回左表所有结果和右表符合的结果</p><p>右 右表所有结果和左表返回的结果</p><h4 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h4><h5 id="单选-1"><a href="#单选-1" class="headerlink" title="单选"></a>单选</h5><ol start="2"><li></li></ol><p>fulltext</p><p>3.b</p><p>alter table name add index name_index(zdmz);</p><ul><li><input disabled="" type="checkbox"> 索引</li></ul><ol start="4"><li></li></ol><p>查看试图</p><p>show create  view name;</p><p>DESCRIBE stu_glass;</p><p>5.a</p><p>update view_stu set chinese&#x3D;100;</p><ol start="6"><li></li></ol><p>b</p><p>7.d</p><ol start="8"><li></li></ol><p>show index from tablename;</p><ol start="9"><li></li></ol><p>create view view_stu as setlect *from student;</p><ol start="10"><li></li></ol><p>create index name on table(ziduan1);</p><ul><li><input disabled="" type="checkbox"> 索引失效问题</li></ul><p>11</p><p>show create view name;</p><p>视图状态</p><p>DESCRIBE stu_glass</p><p>C.SHOW TABLE STATUS LIKE ‘视图名’;</p><p>12</p><p>show index from name;</p><p>1.需要数据表内数据的有from 更新 插入查看</p><p>2.非数据基本数据的 show展示 视图 </p><h5 id="多选-1"><a href="#多选-1" class="headerlink" title="多选"></a>多选</h5><p>13</p><p>abcd</p><p>14</p><p>show index from emp;</p><p>15</p><ul><li><input disabled="" type="checkbox"> 视图的优点</li><li><input disabled="" type="checkbox"> </li></ul><p>create unique index  stu_name on table(name)</p><p>p index name on;</p><h5 id="判断题-2"><a href="#判断题-2" class="headerlink" title="判断题"></a>判断题</h5><ul><li><p><input disabled="" type="checkbox"> EXPAIN</p></li><li><p><input disabled="" type="checkbox"> DESCRIBE</p></li></ul><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>考察存储过程</p><h4 id="单选-2"><a href="#单选-2" class="headerlink" title="单选"></a>单选</h4><ol><li></li></ol><p>02 not found -考察02报错</p><ul><li><input disabled="" type="checkbox"> 条件处理程序</li></ul><ol start="2"><li></li></ol><ul><li><input disabled="" type="checkbox"> close 游标</li></ul><p>3.c</p><p>4.c</p><p>5.d</p><p><strong>6.c</strong></p><p><strong>存储过程参数传递</strong></p><p>7.b</p><p>set select user into user from name;</p><ol start="8"><li></li></ol><p>call</p><ol start="9"><li></li></ol><p>declare @num;</p><p>call name(20,@num);</p><p>10</p><ul><li><input disabled="" type="checkbox"> 不知道</li></ul><ol start="11"><li></li></ol><p>declare val;</p><p><strong>if val is null</strong></p><p><strong>then</strong></p><p>select ‘val is null’;</p><p><strong>else</strong> </p><p>select ‘val not null’;</p><p><strong>end if;</strong></p><p>了解一下if快，跟lua脚本一样</p><p>12</p><p>drop procedure  if exists name;</p><ul><li><input disabled="" type="checkbox"> 存储过程的删除1</li></ul><p>13</p><p>累加10</p><p>declare i int default 0;</p><p>while i&lt;10 </p><p>do</p><p>set i&#x3D;i+1;</p><p>end while; </p><p>14  alter</p><ul><li><input disabled="" type="checkbox"> 修改存储过程</li></ul><p>15 d</p><p>select</p><p>drop </p><p>16 b</p><p>声明 打开 使用 关闭</p><p>17</p><p>dropp 记不到 if exists  nbame;</p><p>PROCEDURE </p><p>18</p><p>do while循环配套</p><p>repeat  </p><p>until 条件</p><p>end repeat</p><p>语句回快</p><p>19 a</p><ul><li><input disabled="" type="checkbox"> 删除存储过程警告</li></ul><p>20 </p><p>loop死循环必备-无条件</p><p>21</p><ul><li><input disabled="" type="checkbox"> 不知道</li></ul><p>22</p><p>所有存储过程的信息存放在下列哪个数据库中</p><ul><li><input disabled="" type="checkbox"> information_schema</li><li><input disabled="" type="checkbox"> information_schema数据库下的Routines表存储所有存储过程的定义</li></ul><p>23</p><p>存放在哪个表</p><blockquote><ul><li><input disabled="" type="checkbox"> information_schema. Routines</li></ul></blockquote><p>24</p><ul><li><input disabled="" type="checkbox"> 代码阅读</li><li><input disabled="" type="checkbox"> c 异常捕获后进行的操作</li></ul><p>25</p><p>fetch name into a,n;</p><p>26</p><p>跳过本轮循环</p><p>、LEAVE语句(终止当前循环，跳出循环体）</p><p>ITERATE语句（结束本次循环，开始下一轮循环的执行）</p><p>loop</p><p>27</p><p>错误处理</p><p>sqlwarnih</p><p>28</p><p>声明游标</p><p>declare name cursor for 查询语句；</p><p>29</p><p>1． 一个流程控制语句（如 <code>IF</code>、<code>CASE</code>、<code>LOOP</code>、<code>REPEAT</code>、<code>WHILE</code> 等）可以保护或包含任意数量的SQL语句</p><p>30a</p><p>CREATE PROCEDURE Myproc () BEGIN SELECT * FROM student; END;</p><p>31 b</p><p>32d</p><p>D、UNDO<br> 指的是撤销或回滚操作，它允许你撤销之前执行的事务所做的更改。</p><p>33d</p><p>34 a</p><p>leave</p><p>45</p><p>declare name int default 1;</p><p>36declare </p><p>37</p><p>declare name cursor for select;</p><p>38</p><p>create procedure</p><p>39 </p><p>exit</p><p>40</p><p>open</p><p>41a</p><p>in</p><p>out</p><p>42</p><p>inout</p><p>43</p><p>exit</p><p>44</p><p>A、SHOW PROCEDURE STATUS LIKE’C%’\G</p><p>45</p><p>delimiter &#x2F;&#x2F;</p><h4 id="多选-2"><a href="#多选-2" class="headerlink" title="多选"></a>多选</h4><p>46</p><p>不知道、INVOKER</p><p>DEFINER</p><p>47</p><p>查看存储过程</p><p>A、SHOW PROCEDURE STATUS name</p><p>B、SHOW CREATE PROCEDURE name</p><p>48-50</p><p>光标的定义位置</p><p>光标操作关键字</p><p>51</p><p>错误类型</p><p>52</p><p>流程控制语句</p><p>53</p><p>1． 在MySQL中，存储过程要修改的部分的取值包括</p><p>A、CONTAINS SQL - 这通常指的是存储过程包含SQL语句，但不一定修改数据。</p><p>B、NO SQL - 表示存储过程不包含任何SQL语句</p><p>C、READS SQL DATA - 表示存储过程包含读取数据的SQL语句，但不包含修改数据的语句</p><p>D、MODIFIES SQL DATA  表示存储过程包含修改数据的SQL语句，如INSERT、UPDATE、DELETE等。</p><p>54</p><p>create  procedure name </p><p>begin</p><p>语句;</p><p>end</p><p>55</p><p>case month </p><p>when 1 then</p><p>;</p><p>when 2 then</p><p>;</p><p>else </p><p>;</p><p>ebd case;</p><p>CASE case_expr WHEN when_value THEN statement_list [WHEN when_value THEN statement_list]… [ELSE statement_list] END CASE</p><p>CASE WHEN expr_condition THEN statement_list [WHEN expr_condition THEN statement_list] [ELSE statement_list] END CASE;</p><p>case case_expt when when value then  ;when when_value then end case;</p><p>56</p><p>loop</p><p>while</p><p>if</p><p>case</p><p>repeat</p><p>57</p><p>declare cmd_not_allow condition for SQLSTATE’42000’;</p><p>DECLARE cmd_not_allow CONDITION FOR 1148;</p><p>58</p><p>59</p><p>exit</p><p>continue</p><p>undo 不处理</p><p>60</p><p>if case</p><p>61</p><p>存储过程优点</p><p>效率高</p><p>安全性号 增强程序的可重用性</p><p>减少网络链接次数</p><p>62</p><p>1． LOOP 循环 <strong>repeat</strong>,while</p><p>63 </p><p>1 2 3 4 5 6 10</p><p>64</p><p>if case</p><p>判断题</p><h4 id="简答题-1"><a href="#简答题-1" class="headerlink" title="简答题"></a>简答题</h4><ol><li></li></ol><p>都可以用于创建一个带有条件判断的循环过程</p><p>While在语句执行时，先对指定的表达式进行判断，符合条件在执行循环体；</p><p>而repeat先执行循环体，然后在进行条件判断。</p><p>2． 简述什么是存储过程。</p><p>存储过程是一条或多条SQL语句的集合，他可以将常用或复杂的操作封装成一个代码块存储在数据库服务器中，以便重复使用，大大减少了数据库开发人员的工作量。</p><ol start="3"><li></li></ol><p>简述调用存储过程的优点有哪些？（写出至少3点）<br> A、使程序执行效率更高</p><p>B、安全性更好</p><p>C、增强程序的可重用性和维护性</p><p>D、实现了一次编写存储过程，多次调用的目标</p><ol start="4"><li></li></ol><p>简述存储过程中流程控制语句的作用？<br> 流程控制语句用于将多个SQL语句划分或组成符合业务逻辑的代码块，用来根据条件控制语句的执行</p><ol start="5"><li></li></ol><p>.简述操作光标的基本步骤。（写出四个步骤）<br> 定义光标、打开光标、利用光标、关闭</p><ol start="6"><li></li></ol><p>简述存储过程中的定义条件和处理程序分别是什么。</p><p> 定义条件是事先定义程序执行过程中遇到的问题，处理程序定义了在遇到这些问题应当采取的处理方式，并且保证存储过程在遇到警告或错误时能继续执行。</p><ol start="7"><li></li></ol><p>declare id int default 0;</p><p>while id&lt;&#x3D;10</p><p>set id&#x3D;id+1;</p><p>select id;</p><p>end while;</p><ol start="8"><li></li></ol><p>create procedure d()</p><p>begin</p><p>declare p1 int default 0;</p><p>My_loop;LOOP</p><p>SET P1&#x3D;P1+1;</p><p>If P1&lt;10 THEN ITERATE my_loop;</p><p>ElSECT p1&gt;20 then leave my_loop;</p><p>End if;</p><p>Select ‘pl is between 10 AND 20’;</p><p>End LOOP my_loop;</p><p>end;</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>掌握触发器的创建删除</p><p>1.创建</p><p>create  trigger test age </p><p>before&#x2F;after insert&#x2F;update&#x2F;delete</p><p>on name for each row </p><p>begin</p><p>-sel;</p><p>end</p><p>drop trigger name;</p><p>show trigger name;</p><p>触发器中的SQL语句不能出现 SELECT * FROM TABLE 形式的查询 ，因为其会返回一个结果集 ，使用时会抛出错误Not allowed to return a result set from a trigger，可以使用SELECT INTO 为变量设置值</p><p>create trigger user_insert</p><p>after insert onuser for each row</p><p>begin</p><ul><li></li></ul><p>&#x2F;&#x2F;插入日志表</p><p>insert into user_logs(id, operation, operate_time, operate_id, operate_params)</p><p>valies</p><p>(null, ‘insert’, now(), new.id, concat(‘插入的数据内容为: id&#x3D;’,new.id,’,name&#x3D;’,new.name, ‘, phone&#x3D;’,NEW.phone, ‘, email&#x3D;’, NEW.email, ‘, profession&#x3D;’, NEW.profession))</p><p>end</p><p>**new **</p><p>获取数据</p><h1 id="数据库的管理和维护"><a href="#数据库的管理和维护" class="headerlink" title="数据库的管理和维护"></a>数据库的管理和维护</h1><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ol><li>a</li></ol><p>show grants for ‘root‘@’’localhost’’</p><p>2.c</p><p>mysqldump -u root -p1234  mydata1 mydata2 &gt; backup_file.sql;</p><p>mysqldump -uroot -pitcast mydb1 mydb2&gt;d:&#x2F;chapter08.sql</p><p>3.a</p><p>create user ‘username‘@’host’ identified by ‘123’;</p><p>4.c</p><p>5.c</p><p>6.d</p><p>7.b</p><p>revoke</p><p>8.a</p><p>show grants for ‘root‘@’localhost’;</p><p>9.d</p><p>10 a</p><p>11.b</p><p>12 c</p><p>13 <strong>c</strong> B</p><h4 id="多选题-1"><a href="#多选题-1" class="headerlink" title="多选题"></a>多选题</h4><p>14</p><p>a   d</p><p>15 A b</p><p>16 a b c d</p><p>17 a b c d</p><h4 id="判断题-3"><a href="#判断题-3" class="headerlink" title="判断题"></a>判断题</h4><p>1</p><p>1</p><p>1</p><p>1</p><p>0</p><p>1</p><p>0</p><p>0</p><h4 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h4><p>26.mysql_user</p><p>27.source</p><p>28.show</p><p>29.mysqldump</p><p>30 GRANT</p><p>31   * . *</p><p>32  revoke</p><p>33 空格</p><h4 id="简答题-2"><a href="#简答题-2" class="headerlink" title="简答题"></a>简答题</h4><p>1.关闭mysql服务</p><p>2.使用–skip&#x3D;grant-tables登录mysql服务</p><p>3.登录mysql</p><p>4.加载权限表</p><p>5.修改密码</p><p>6.启动mysql服务登录</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔小仙开发日志1-3</title>
    <link href="/2024/10/30/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%85%94%E5%B0%8F%E9%B2%9C01/"/>
    <url>/2024/10/30/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%85%94%E5%B0%8F%E9%B2%9C01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>前端项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构概论 01 刷题</title>
    <link href="/2024/10/30/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0/1/"/>
    <url>/2024/10/30/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0/1/</url>
    
    <content type="html"><![CDATA[<h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><p><strong>选择题</strong></p><p>1.d</p><p><strong>线性结构</strong>：所有数据元素之间存在一对一的关系。</p><p>2.c</p><p><strong>3.a c</strong>*错</p><p>4.a</p><p>5.c</p><p>6.b</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241021144808969.png" alt="image-20241021144808969"></p><p>7.c</p><p>8.a</p><p>算法特性和算法分析不一样</p><p>9.c</p><p>10.b</p><p><strong>填空题</strong></p><p>1  数据结构包括数据逻辑结构、数据存储结构和数据运算。</p><p>2 线性结构和非线性结构</p><p>3.不知道 *</p><p>4.没有 没有</p><p>5.头 1  子  n个         <strong>前驱  1 后驱 任意多个</strong>  错-</p><p>6.超纲了-忘记了  <strong>任意多个</strong></p><p>7顺序存储、链式存储、索引存储和哈希存储。</p><p>8 时间复杂度 空间复杂度</p><p><strong>9规模为n</strong></p><p>10 额外内存空间</p><p><strong>简答题</strong></p><ol><li></li></ol><blockquote><p>运算描述是从抽象层面对数据结构的操作定义。它是算法设计时的理论框架，侧重于说明在该数据结构上可以进行哪些操作，以及这些操作的输入、输出和效果。运算描述强调操作的功能而不是具体实现</p></blockquote><blockquote><p>运算实现是运算描述的具体实现方式，涉及到算法如何在特定的数据结构中执行操作。它需要考虑到算法的时间复杂度、空间复杂度和具体的编程语言实现。运算实现是通过具体的编程代码来完成的</p></blockquote><ol start="2"><li></li></ol><p>1.不知道</p><p>2.省掉1000log2N</p><p>3.n2</p><p>4.不知道</p><p>3.4次</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241021150125927.png" alt="image-20241021150125927"></p><ol start="4"><li></li></ol><blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241021150331365.png" alt="image-20241021150331365"></p></blockquote><p>5.头炸了</p><p>6.头炸了</p><p>…..对于这种计算后续针对训练一下</p><h1 id="第2节"><a href="#第2节" class="headerlink" title="第2节"></a>第2节</h1><p>选择题</p><p>1.a</p><p><strong>2.b</strong>  c没看见随机存取</p><p>3.a</p><p>4.b</p><p>5.c</p><p>6.d</p><p>7.c</p><p>8.b</p><p>9.a</p><p>10.c * </p><p>11.c</p><p>12 a</p><p>13.a c        *B 不知道</p><p>14  d 是循环单链表</p><p>15 d</p><p>16 d</p><p>17 a</p><p>18 c</p><p>19 a</p><p>20b </p><p><strong>填空题</strong></p><p>初始化linkList()</p><p>o1</p><p>*<em>o1 <em>看错字了</em></em></p><p>不知道 2&#x2F;n</p><p>下标  指针域  物理存储位置 链域的指针</p><p>前驱节点 0 1</p><p>7 8 省</p><p>9 on</p><p><strong>10 l-&gt;next&#x3D;&#x3D;head –看错了</strong></p><p>简答题</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022162359792.png" alt="image-20241022162359792"></p><p>2不知道</p><p>3便于算法设计</p><ol start="4"><li>2 4</li></ol><p>5  4</p><p>回去找答案</p><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>1.a</p><p>2.D</p><blockquote><p>1.进栈后立即出栈在进栈 A   a b c d</p><p>2.顺序出栈 b</p><ol start="3"><li><p>a b c 1.bc 2.b 3.bd 4.b</p><p>弹栈 a c  d b</p></li><li><p>a b c d  a b c-&gt;出错</p></li></ol></blockquote><p>3.c</p><p>4.c  *D  我就说我看不懂ai *</p><blockquote></blockquote><p>5.a</p><p>6.d</p><p>7.a</p><p>方便出栈-栈顶必须在数组尾部-</p><p><strong>8.b A忘记了</strong> *</p><p><strong>9.A</strong> D 我感觉答案有问题 *</p><p>10 B 看错了以为是栈 A</p><p>11 C</p><p><strong>12 A D</strong></p><p>考察队列的逻辑结构 忘记了</p><p><strong>13 b</strong></p><p>单队列 遵循先进先出</p><p>双端队列就有五线可能</p><p>14 a</p><p>不知道</p><p>15</p><p>16</p><p>17</p><p>18</p><p>循环队列 回去学习</p><p>19 b</p><p>20  b</p><p>填空题</p><p>栈顶 栈底、</p><p>n&#x2F;</p><p>立即出栈</p><p> c d b a   e   cd be a</p><p><strong>data[top]&#x3D;x;&#x2F; top++.data[top]&#x3D;x</strong></p><p><strong>data[top]&#x3D;0;top–</strong></p><p>top到底指针栈顶-还是栈顶上面+1</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 假设栈大小为 n，数组 data 用于存储栈元素，top 为栈顶指针</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> top</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (top &lt; n) &#123;<br>        data[top] = x;  <span class="hljs-comment">// 将元素 x 放入栈顶</span><br>        top++;          <span class="hljs-comment">// 栈顶指针加 1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;栈满，无法进栈&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> top</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>) &#123;<br>        top--;            <span class="hljs-comment">// 栈顶指针减 1</span><br>        <span class="hljs-built_in">int</span> x = data[top]; <span class="hljs-comment">// 取出栈顶元素</span><br>        <span class="hljs-keyword">return</span> x;         <span class="hljs-comment">// 返回出栈的元素</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;栈空，无法出栈&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 表示栈为空时的错误返回值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>队列</p><p>8</p><p>9</p><p>10</p><p>不知道，没学过循环队列</p><ol start="3"><li></li></ol><p>栈-先进后出-只允许一端操作</p><p>队列-先进先出 一端添加-一端删除</p><ol start="2"><li></li></ol><p>一般设置在数组的开端-这是为了栈顶在数组末端方便删除数据，而不需要移动数组</p><ol start="3"><li></li></ol><p>1</p><ol start="4"><li></li></ol><p>没学过</p><ol start="5"><li></li></ol><blockquote><p>顺序队列使用数组作为存储结构，当进行元素的入队和出队操作时，数组的起始位置是固定的。随着出队操作的进行，数组的前面部分空间被释放，但由于队首指针只向后移动，不会将元素搬移到数组的前端，这就导致了所谓的“假溢出”现象——即数组的后端已经满了，但前端还有空余位置。这时我们无法再进行入队操作，虽然数组并没有真正被填满，但由于指针的原因，无法有效利用这些空余的空间。</p></blockquote><p>ps:循环队列</p><p>还要算法表示的结构</p><blockquote><p>在栈的操作中，<code>top</code> 通常指的是 <strong>栈顶指针</strong>，而不是栈顶元素。它表示栈顶元素在数组中的位置。在大多数实现中，<code>top</code> 指向的是下一个可以存放元素的位置（即当前栈顶元素的下一个位置）。例如：</p><ul><li>如果 <code>top = 0</code>，说明栈是空的，栈中还没有元素。</li><li>如果 <code>top = n</code>（n 是栈的大小），则说明栈已经满了。</li></ul><p>因此，<code>top - 1</code> 通常是栈顶元素在数组中的位置。</p><p>总结：</p><ul><li><strong>栈顶指针</strong>：<code>top</code> 表示下一个可以存放元素的位置。</li><li><strong>栈顶元素</strong>：<code>data[top - 1]</code> 表示栈顶的实际元素。</li></ul></blockquote><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><p>1.d</p><p>2.d</p><ol start="3"><li>a b d-我觉得题目可以改成不是</li></ol><p>4.b</p><p>5.b</p><p>填空题</p><p>1含有零个字符的串，由一个或多个空格组成的串</p><p><strong>2删除 3位置的2个字符–abcdg   abefg</strong> </p><p>这种题就有歧义 这个3的位置是对于数组还是对于我们心中3的位置</p><p>3 o n</p><p>4.指针域为空 s-&gt;ne&#x3D;&#x3D;null;</p><ol start="5"><li>on</li></ol><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>1.b </p><p>2.c</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024145208200.png" alt="image-20241024145208200"></p><p><strong>3.c</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024145907374.png" alt="image-20241024145907374"></p><p>a[11] a[12] a[13] a[14] a[15] a[16] a[17] a[18]</p><p>8*3&#x3D;24+5&#x3D;29</p><p><strong>4 c</strong></p><p>计公式</p><p><strong>5.c</strong></p><p>计公式</p><p>6.A</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024174054509.png" alt="image-20241024174054509"></p><ol start="7"><li>b</li></ol><p><strong>8.b</strong></p><p>考察矩阵从0开始i+1</p><p>9.c</p><p>10</p><p>11d</p><p><strong>12 a</strong></p><p>13  c</p><p>14  b</p><p>不知道</p><p>15d</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024153403282.png" alt="image-20241024153403282"></p><p>不知道</p><p><strong>学习对此矩阵稀疏矩阵的一些知识–学习广义表</strong></p><h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h5 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h5><p>1 c</p><ol start="2"><li>a      2 a  3 c</li></ol><p>3.c</p><p>**<strong>4.a</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/801021d1130c2d06689ee6fd40df4363.png" alt="801021d1130c2d06689ee6fd40df4363"></p><p>梯子坏了，看不了笔记</p><p><strong>5.c(计算错了)</strong> </p><p>6.d</p><p>7.b</p><p>8.c</p><p>满二叉树</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241026152444645.png" alt="image-20241026152444645"></p><p>9.d </p><ul><li><input disabled="" type="checkbox"> 满二叉树的计算</li></ul><p>10  d</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241026152855635.png" alt="image-20241026152855635"></p><p>完全二叉树考察</p><p>11 b</p><ul><li><input disabled="" type="checkbox"> 完全二叉树考察</li></ul><p> h&#x3D;10</p><p>2 10-1&#x2F;2</p><p>512&#x2F;2&#x3D;256错误</p><p>12 b</p><p><strong>13 c</strong>    不会</p><p>中序和后序序列确定二叉树</p><p>14 d</p><p>15 d</p><ul><li><input disabled="" type="checkbox"> 无法理解</li></ul><p>只能确定根节点</p><p>16  b</p><p>17</p><p>18</p><p>19</p><p>ps:崩溃了休息</p><h5 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h5><p>​    3</p><p>n-3</p><p>5</p><p>  31         32</p><p>分支节点- 度大于0的节点  63-1-32&#x3D;63-33&#x3D;30+1</p><p>5.350</p><ol start="6"><li>500 499  1</li></ol><p>7.2 i-1次方</p><p>8</p><p>2 h-1   2h  -1         2h-1</p><p>9</p><p>a的左递归节点     根的右节点的最右下节点</p><p>10</p><p>34</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h4 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h4><ol><li><p>c</p></li><li><p>b</p></li></ol><p>3.c</p><p>4.c</p><p>5.b  d</p><p>6.d</p><p>7.a</p><p>8.c</p><p>9.a</p><p>10.c</p><p>11.b</p><p>12 b</p><p>13 a</p><p>14 d</p><p>15 d</p><p>16  a</p><p>17 d</p><p>18 c</p><p>19 b</p><p>20 c</p><p><strong>21</strong></p><p><strong>22</strong></p><h4 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h4><p>1.n-1</p><ol start="2"><li>邻接矩阵 邻接表</li><li>n-1  9</li><li>2(n-1)</li><li>n2</li><li>n+e</li><li>n2  n+e</li><li>n2  n+e</li></ol><p>9</p><p>10</p><p>11 -极小连通子图</p><p>12 n2  nlog2n  kruskal prim</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础笔记</title>
    <link href="/2024/10/28/java/2024-9-6%20Java%20%E5%AE%9E%E4%B9%A0%E5%A4%8D%E4%B9%A0%E7%AF%87%20172056/"/>
    <url>/2024/10/28/java/2024-9-6%20Java%20%E5%AE%9E%E4%B9%A0%E5%A4%8D%E4%B9%A0%E7%AF%87%20172056/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-复习篇-1"><a href="#Java-复习篇-1" class="headerlink" title="Java 复习篇 1"></a>Java 复习篇 1</h1><h2 id="0-java特性"><a href="#0-java特性" class="headerlink" title="0.java特性"></a>0.java特性</h2><h5 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h5><blockquote><p>封装是面向对象编程的一个基本特性，它指的是将对象的状态（属性）和行为（方法）封装在一起，并控制对这些状态的访问。通过封装，可以保护对象的内部状态，避免直接访问和修改，从而提高代码的安全性和可维护性。</p><hr><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">**访问控制**：通过访问修饰符（如 `private`、`protected` 和 `public`）来控制对类成员的访问。<br><br>**数据隐藏**：将对象的内部状态隐藏在类的外部，防止外部直接访问。<br><br>**提供公共方法**：通过公共方法（如 getter 和 setter）来允许外部访问和修改对象的属性。<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> gender;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> gender == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;man&quot;</span> : <span class="hljs-string">&quot;woman&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="hljs-number">50</span>) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(name + <span class="hljs-string">&quot; is working very hard!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(name + <span class="hljs-string">&quot; can&#x27;t work any more!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h5 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h5><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p><p>向下转型</p><p>  Dog dog &#x3D; (Dog) animal; &#x2F;&#x2F;        </p><p>dog.dogsu()-&gt;出现访问错误 不安全</p><h5 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h5><p>多态分为编译时多态和运行时多态:</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li><strong>继承</strong></li><li><strong>覆盖(重写)</strong></li><li><strong>向上转型</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Instrument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Instrument is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Music</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Instrument&gt; instruments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wind</span>());<br>        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Percussion</span>());<br>        <span class="hljs-keyword">for</span>(Instrument instrument : instruments) &#123;<br>            instrument.play();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1.基础篇"></a>1.基础篇</h2><h4 id="1-Jvave开发环境"><a href="#1-Jvave开发环境" class="headerlink" title="1.Jvave开发环境"></a>1.Jvave开发环境</h4><p>Java应用程序通常被编译为可在任何Java虚拟机（JVM）上运行的<strong>字节码</strong></p><p>Jdk-&gt;Java开发工具包 jre 运行环境 Jvm java虚拟机-&gt;转换字节码文件-&gt;本地机器码</p><h4 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2.基本数据类型"></a>2.基本数据类型</h4><h5 id="1-内置"><a href="#1-内置" class="headerlink" title="1.内置"></a>1.内置</h5><p>byte -short-int-long  float-double  <strong>boolean</strong>   char</p><blockquote><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p></blockquote><h5 id="2-缓冲池"><a href="#2-缓冲池" class="headerlink" title="2.缓冲池"></a>2.缓冲池</h5><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hcc</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer x=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>        Integer y=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>        System.out.println(x==y);<span class="hljs-comment">//-&gt;false</span><br>        System.out.println(x.equals(y));<span class="hljs-comment">//-&gt;true</span><br>        Integer X1=Integer.valueOf(<span class="hljs-number">1</span>);<br>        Integer Y1=Integer.valueOf(<span class="hljs-number">1</span>);<br>        System.out.println(X1==Y1);<span class="hljs-comment">//-&gt;true</span><br>        System.out.println(X1.equals(Y1));<span class="hljs-comment">//-&gt;true</span><br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果再缓冲池就之间返回对象引用-如果不在就new一个</p><h5 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h5><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">String str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(String original)</span> &#123;<br>     <span class="hljs-built_in">this</span>.value = original.value;<br>     <span class="hljs-built_in">this</span>.hash = original.hash;<br> &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-comment">//本质就是被常量修饰的char数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br></code></pre></td></tr></table></figure><h6 id="1-不可变特性探究"><a href="#1-不可变特性探究" class="headerlink" title="1.不可变特性探究"></a>1.不可变特性探究</h6><p>我们有可变的字符串了，那么对比不可变的好处</p><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f76067a5-7d5f-4135-9549-8199c77d8f1c.jpg" alt="img"></p><p>3.安全性</p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><hr><p>4.线程安全</p><p>string不可变</p><h6 id="2-String-StringBuffer-and-StringBuilder"><a href="#2-String-StringBuffer-and-StringBuilder" class="headerlink" title="2.String, StringBuffer and StringBuilder"></a>2.String, StringBuffer and StringBuilder</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241028105843615.png" alt="image-20241028105843615"></p><h6 id="3-string-intern"><a href="#3-string-intern" class="headerlink" title="3.string.intern"></a>3.string.intern</h6><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p><blockquote><p>s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String s1 <span class="hljs-operator">=</span> new String(<span class="hljs-string">&quot;aaa&quot;</span>)<span class="hljs-comment">;</span><br>String s2 <span class="hljs-operator">=</span> new String(<span class="hljs-string">&quot;aaa&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(s1 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> s2)<span class="hljs-comment">;           // false</span><br>String s3 <span class="hljs-operator">=</span> s1.intern()<span class="hljs-comment">;</span><br>System.out.println(s1.intern() <span class="hljs-operator">=</span><span class="hljs-operator">=</span> s3)<span class="hljs-comment">;  // true</span><br>------<br><br></code></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><ul><li><strong>HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区</strong>？</li></ul><p> <img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241028112903516.png" alt="image-20241028112903516"></p><h5 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h5><p>类似CPP的指针-&gt;指向了存储的真实地址 -对象 数组</p><h6 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h6><p>1.常量-final -指定后无法更改</p><p>2.类型转换-大转小-精度丢失–强制转 小转大-自动</p><h4 id="2-1标识符"><a href="#2-1标识符" class="headerlink" title="2.1标识符"></a>2.1标识符</h4><p>java中规定只能使用数字 ，字母 ，美元符号， 下划线作为标识符。     </p><p>不能重复。所以关键字、预定义标识符不能作为用户标识符。<br>允许的长度是由具体的编译器决定。<br>区分大小写。<br>不推荐用双下划线开头因为预定义标识符一般用双下划线开头。关键字你能背下来但是预定义标识符没人会去背。万一重了不好办。</p><h4 id="3-Jave变量类型"><a href="#3-Jave变量类型" class="headerlink" title="3.Jave变量类型"></a>3.Jave变量类型</h4><ul><li>类变量：独立于方法之外的变量，用 static 修饰。-静态存储区-</li><li>示例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：类的方法中的变量。–堆栈中开辟</li></ul><p>什么时候销毁-</p><h4 id="4-Java运算符"><a href="#4-Java运算符" class="headerlink" title="4.Java运算符"></a>4.Java运算符</h4><ul><li><p>算术运算符</p><table><thead><tr><th>+</th></tr></thead><tbody><tr><td>-</td></tr><tr><td>*</td></tr><tr><td>&#x2F;</td></tr><tr><td>％</td></tr><tr><td>++</td></tr><tr><td>–</td></tr></tbody></table></li><li><p>关系运算符</p><table><thead><tr><th>&#x3D;&#x3D;</th></tr></thead><tbody><tr><td>!&#x3D;</td></tr><tr><td>&gt;</td></tr><tr><td>&lt;</td></tr><tr><td>&gt;&#x3D;</td></tr><tr><td>&lt;&#x3D;</td></tr></tbody></table></li><li><p>位运算符</p><table><thead><tr><th>＆</th><th>如果相对应位都是1，则结果为1，否则为0</th><th>（A＆B），得到12，即0000 1100</th></tr></thead><tbody><tr><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr><tr><td>^</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr><tr><td>〜</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table></li><li><p>逻辑运算符</p><table><thead><tr><th>&amp;&amp;</th></tr></thead><tbody><tr><td>| |</td></tr><tr><td>！</td></tr></tbody></table></li><li><p>赋值运算符</p></li><li><p>省</p></li><li><p>其他运算符</p><p>1.三元运算符</p></li><li><pre><code class="hljs">variable x = (expression) ? value if true : value if false<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>2.类型比对<br><br></code></pre></td></tr></table></figure>String name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### <span class="hljs-number">5.</span>Java输入和输出<br><br></code></pre></td></tr></table></figure>System.out.println();<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>//创建Scanner对象Scanner input = new Scanner(System.in);</code></pre></li></ul><p>&#x2F;&#x2F;接受用户的输入<br>int number &#x3D; input.nextInt();</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### <span class="hljs-number">6.</span>Java 表达式 语句 代码块<br><br>#### <span class="hljs-number">7.</span>Java注释<br><br>#### <span class="hljs-number">8.</span> 逻辑控制语句<br><br><span class="hljs-keyword">if</span> -switch<br><br>ps-<br><br>```java<br>      int week = <span class="hljs-number">4</span>; <br>       String day;<br>     switch (week) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                day = <span class="hljs-string">&quot;Sunday&quot;</span>;<br>                break;<br>            default:<br>                day = <span class="hljs-string">&quot;Invalid day&quot;</span>;<br>                break;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="9-循环语句"><a href="#9-循环语句" class="headerlink" title="9.循环语句"></a>9.循环语句</h4><p>for -for -each -while</p><p>for -each</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">char</span> item: vowels) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(item);<br>     &#125;<br>     <span class="hljs-comment">//内置迭代器写法</span><br></code></pre></td></tr></table></figure><p>break-跳出循环语句</p><p>也就是直接跳出jmp–走到下行代码地址</p><p>continue-当前循环跳过语句</p><h4 id="10-数组"><a href="#10-数组" class="headerlink" title="10.数组"></a>10.数组</h4><p>1.数组</p><p>数组是相似类型数据的集合。它是一个容器，用于保存单一类型的数据（值）。例如，您可以创建一个数组，它可以保存100个int类型的值。 </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">data</span> <span class="hljs-operator">=</span> new Double[<span class="hljs-number">10</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2.多维数组</p><p>3.数组复制</p><p>省</p><h4 id="11-关键字探究"><a href="#11-关键字探究" class="headerlink" title="11.关键字探究"></a>11.关键字探究</h4><h5 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h5><p>1.数据</p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><hr><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">final int x <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>// x <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;  // cannot assign value to final variable &#x27;x&#x27;</span><br>final A y <span class="hljs-operator">=</span> new A()<span class="hljs-comment">;</span><br>y.a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">y</span><span class="hljs-operator">=</span>x//错误<br>------<br><br></code></pre></td></tr></table></figure><hr><p>2.方法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">声明方法不能被子类重写。<span class="hljs-keyword">private</span> 方法隐式地被指定为 <span class="hljs-keyword">final</span>，如果在子类中定义的方法和基类中的一个 <span class="hljs-keyword">private</span> 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。<br><br>可以重载不能重写<br></code></pre></td></tr></table></figure><p>3.类</p><p>类不能继承</p><blockquote><p> <code>final</code> 关键字不能用来修饰接口</p><p> 被final关键字修饰的类不能被继承，但抽象类存在的意义在于被其它类继承然后实现其内部方法的，这样final和抽象类之间就产生了矛盾。因此，final并不能修饰抽象类，选项A错误，选项B正确。</p><p>C选项，重载的实现是编译器根据函数的不同的参数表，对同名函数的名称做修饰，那么对于编译器而言，这些同名函数就成了不同的函数。但重写则是子类方法对父类的方法的延申，即子类不仅继承了父类的方法，还向父类的方法中添加了属于自己的内容，改变了父类方法原本的内容，而final代表了一种不可变，这明显与重写形成了冲突。因此被final修饰的类可以被重载但不能被重写，选项C错误。</p></blockquote><h5 id="2-static"><a href="#2-static" class="headerlink" title="2.static"></a>2.static</h5><h6 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a><strong>1. 静态变量</strong></h6><ul><li>静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</li><li>实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><hr><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;         <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> y;  <span class="hljs-comment">// 静态变量</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span><br>        A a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>        <span class="hljs-type">int</span> x = a.x;<br>        <span class="hljs-type">int</span> y = A.y;<br>    &#125;<br>&#125;<br>------<br><br></code></pre></td></tr></table></figure><h6 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h6><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>&#123;<br>        <span class="hljs-built_in">int</span> a = x;<br>        <span class="hljs-comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span><br>        <span class="hljs-comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-静态语句块"><a href="#3-静态语句块" class="headerlink" title="3.静态语句块"></a>3.静态语句块</h6><p>静态语句块在类初始化时运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h6><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;<br>    &#125;<br><br>    static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>&#123;<br>    &#125;<br><br>    public static void main(String[] args) &#123;<br>        <span class="hljs-regexp">//</span> InnerClass innerClass = new InnerClass(); <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;OuterClass.this&#x27;</span> cannot be referenced from a static context<br>        OuterClass outerClass = new OuterClass();<br>        InnerClass innerClass = outerClass.new InnerClass();<br>        StaticInnerClass staticInnerClass = new StaticInnerClass();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-静态导包"><a href="#5-静态导包" class="headerlink" title="5.静态导包"></a>5.静态导包</h6><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.xxx.ClassName.*<br></code></pre></td></tr></table></figure><h6 id="6-初始化顺序"><a href="#6-初始化顺序" class="headerlink" title="6.初始化顺序"></a>6.初始化顺序</h6><p><strong>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">staticField</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;静态变量&quot;</span>;<br><span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;静态语句块&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;实例变量&quot;</span>;<br>&#123;<br>    System.out.println(<span class="hljs-string">&quot;普通语句块&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最后才是构造函数的初始化。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">InitialOrderTest</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为:</p><ul><li>父类(静态变量、静态语句块)</li><li>子类(静态变量、静态语句块)</li><li>父类(实例变量、普通语句块)</li><li>父类(构造函数)</li><li>子类(实例变量、普通语句块)</li><li>子类(构造函数</li></ul><hr><h2 id="2-面向对象篇"><a href="#2-面向对象篇" class="headerlink" title="2.面向对象篇"></a>2.面向对象篇</h2><h5 id="1-Java类和对象"><a href="#1-Java类和对象" class="headerlink" title="1.Java类和对象"></a>1.Java类和对象</h5><p>类–一个抽象的东西–由一些数据类型组成的抽象东西</p><p>对象–实例化后在内存中(堆)中开辟的一块空间</p><p>类方法探究</p><blockquote><p>下列说法错误的有（ a c  d） </p><p>A 在类方法中可用this来调用本类的类方法</p><p><code>this</code> 是用来引用当前对象的，只有在实例方法中才能使用。类方法（<code>static</code> 方法）是属于类的，而不是某个对象的，因此在类方法中不能使用 <code>this</code>。</p><p>B 在类方法中调用本类的类方法时可直接调用</p><p>C 在类方法中只能调用本类中的类方法</p><p>D 在类方法中绝对不能调用实例方法 </p><p>类方法不能直接调用实例方法，因为实例方法需要通过具体的对象来调用，而类方法没有绑定到任何对象。</p><p>虽然类方法（<code>static</code> 方法）不能直接调用实例方法，但并不意味着类方法完全无法调用实例方法。如果类方法中创建了该类的实例对象，通过该对象是可以调用实例方法的。因此，这一说法并不完全正确。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">instanceMethod</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;这是实例方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">classMethod</span>()</span> &#123;<br>        MyClass obj = <span class="hljs-keyword">new</span> MyClass();  <span class="hljs-comment">// 创建对象</span><br>        obj.instanceMethod();  <span class="hljs-comment">// 通过对象调用实例方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h5><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">modifier</span> <span class="hljs-keyword">static</span> returnType <span class="hljs-title function_">nameOfMethod</span> (<span class="hljs-variable">parameters</span>) &#123;<br>    <span class="hljs-comment">// method body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法到底是什么–方法也是抽象的-也只有在程序运行时 转换为字节码文件</p><p>call-oxxxxx-&gt;这个地址内就存储着我们方法代码转换的字节码文件</p><h5 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h5><p>当类的对象被创建时，该构造函数将被自动调用-并且不返回任何值</p><h5 id="4-修饰符"><a href="#4-修饰符" class="headerlink" title="4.修饰符"></a>4.修饰符</h5><ul><li>访问修饰符</li><li>非访问修饰符 static  <strong>final</strong> abstract  synchronized -无需锁 transient   volatile -无需锁</li><li>abstract-抽象类和抽象方法定义</li></ul><h5 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h5><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-built_in">String</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;java programming&quot;</span>; 该字符串是<span class="hljs-built_in">String</span>类的实例。<span class="hljs-comment">--指向了字符串的地址</span><br></code></pre></td></tr></table></figure><table><thead><tr><th><a href="https://www.cainiaojc.com/java/java-library-string-concat.html">concat()</a></th><th>将两个字符串连接在一起</th></tr></thead><tbody><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-equals.html">equals()</a></td><td>比较两个字符串的值</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-charat.html">charAt()</a></td><td>返回存在于指定位置的字符</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-getbytes.html">getBytes()</a></td><td>将字符串转换为字节数组</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-indexOf.html">indexOf()</a></td><td>返回字符串中指定字符的位置</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-length.html">length()</a></td><td>返回指定字符串的大小</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-replace.html">replace()</a></td><td>将指定的旧字符替换为指定的新字符</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-substring.html">substring()</a></td><td>返回字符串的子字符串</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-split.html">split()</a></td><td>将字符串分成字符串数组</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-tolowercase.html">toLowerCase()</a></td><td>将字符串转换为小写</td></tr><tr><td><a href="https://www.cainiaojc.com/404.html">toUpperCase()</a></td><td>将字符串转换为大写</td></tr><tr><td><a href="https://www.cainiaojc.com/java/java-library-string-valueof.html">valueOf()</a></td><td>返回指定数据的字符串表示形式</td></tr></tbody></table><h5 id="6-this关键字"><a href="#6-this关键字" class="headerlink" title="6.this关键字"></a>6.this关键字</h5><p>在Java中，this关键字用于引用方法或构造函数中的当前对象</p><p>–this-&gt;指向当前对象地址的一个引用-指针</p><h5 id="7-final关键字"><a href="#7-final关键字" class="headerlink" title="7.final关键字"></a>7.final关键字</h5><p>在Java中，final关键字用于表示常量。它可以与变量，方法和类一起使用。</p><p>任何实体（变量，方法或类）一旦被声明final后，只能分配一次。也就是，</p><ul><li>final变量不能用另一个值重新初始化</li><li>final方法不能被重写</li><li>final类不能被继承</li></ul><h5 id="8-instanceof关键字"><a href="#8-instanceof关键字" class="headerlink" title="8.instanceof关键字"></a>8.instanceof关键字</h5><p>在Java中，instanceof关键字是二进制运算符。它用于检查对象是否是特定类的实例。</p><h5 id="9-递归"><a href="#9-递归" class="headerlink" title="9.递归"></a>9.递归</h5><p>在Java中，调用自身的<a href="https://www.cainiaojc.com/java/java-methods.html">方法</a>称为递归方法。并且，此过程称为递归。</p><p>递归优点-简单</p><p>缺点–疯狂开堆栈–又疯狂置空</p><h2 id="3-面向对象下"><a href="#3-面向对象下" class="headerlink" title="3.面向对象下"></a>3.面向对象下</h2><h5 id="1-继承-方法重写-super关键字-抽象类和方法"><a href="#1-继承-方法重写-super关键字-抽象类和方法" class="headerlink" title="1.继承 方法重写 super关键字 抽象类和方法"></a>1.继承 方法重写 super关键字 抽象类和方法</h5><p>Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p><strong>继承</strong></p><p>类只能有一个父类，但可以有多个接口</p><p>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</p><p>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</p><p>方法重写–重写覆盖</p><p><strong>抽象类</strong></p><p>abstract  抽象类是无法实例化的类 abstract-</p><p>抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>继承抽象类的类 必须实习抽象方法</p><blockquote><p>抽象类可以包含方法的声明和具体实现，可以有构造函数、字段等。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022220912758.png" alt="image-20241022220912758"></p></blockquote><blockquote><blockquote><p>在 Java 中，抽象类中的抽象方法的默认访问权限并不是 <code>public</code>，而是包私有（default），即没有显式指定访问修饰符时，这些方法的访问权限是包内可见的。如果需要将抽象方法设为 <code>public</code>，需要明确使用 <code>public</code> 修饰符。</p></blockquote><blockquote><p>关于访问权限的说法，分析如下：</p><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 </p></blockquote></blockquote><h5 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h5><p>接口中的方法可以有任何合法的参数类型和返回类型，只要它们是 <code>public</code> 或默认访问权限。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105170742679.png" alt="image-20241105170742679"></p><blockquote><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p></blockquote><p>interface-接口声明</p><p>-implements -实现实现接口类的方法</p><p>接口可以继承其他接口</p><blockquote><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员(字段 + 方法)默认都是 public 的，<strong>并且不允许定义为 private 或者 protected。</strong></p><p>接口的字段默认都是 static 和 final 的</p><hr></blockquote><blockquote><p>接口只能包含方法的声明（默认是 <code>public</code>），不能包含具体实现（Java 8 及以后的版本允许有默认方法和静态方法）。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022221314373.png" alt="image-20241022221314373"></p></blockquote><blockquote><p>抽象类可以有构造方法，接口不能有（1，8）</p><p>抽象类可以包含普通的成员变量，而在 Java 1.8 之前，接口只能包含 <code>public static final</code> 常量，即只能有静态常量，不能有普通的成员变量。</p><p>在 Java 1.8 之前，接口中不能包含静态方法，静态方法是在 Java 1.8 引入的特性。而抽象类是可以包含静态方法的。</p><p>Java 中的类可以实现多个接口，但由于 Java 是单继承的，一个类只能继承一个抽象类。</p></blockquote><h5 id="2-1比较"><a href="#2-1比较" class="headerlink" title="2.1比较"></a>2.1比较</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241028113435807.png" alt="image-20241028113435807"></p><h5 id="3-多态-方法重载"><a href="#3-多态-方法重载" class="headerlink" title="3.多态-方法重载"></a>3.多态-方法重载</h5><p>同一实体（方法，运算符或对象）在不同情况下的行为会有所不同。</p><p>多态在汇编中来看-call-函数<br>这个call是动态计算的-</p><p>这也就是动态绑定</p><p>在程序执行期间确定将要调用的方法。因此<strong>，方法重写是运行时多态。</strong></p><blockquote><p>方法的重写要求方法签名必须一致，包括方法名称、参数列表、返回类型（可以是协变类型，即子类返回类型）。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241028113609139.png" alt="image-20241028113609139"></p></blockquote><p><strong>方法重载</strong><br><strong>在Java类中，如果参数不同，则可以使用相同的名称创建方法。</strong></p><blockquote><p>方法重载要求方法名相同，且参数的数量、类型或顺序不同。</p><p><strong>参数数量不同</strong>：可以通过参数的数量来区分重载的方法。</p><p><strong>参数类型不同</strong>：可以通过参数的类型来区分重载的方法。</p><p><strong>参数顺序不同</strong>：即使参数类型相同，但如果它们的顺序不同，也可以重载。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p></blockquote><p>方法的重载。因此，编译可以成功。</p><p>也就是编译器。根据参数判断-对呀call</p><p>也就是编译阶段把对应call写进去</p><p>在方法重写的情况下，方法应该在不同的类中。然而，在方法重载的情况下，方法应该在同一个类中。</p><p> 方法重写在运行时执行，而方法重载在编译时执行。</p><p>向上 子转父 安全<br>向下 父转子<br>看范围把</p><p>向上 子转父 安全  指针范围调控<br>向下 父转子 指针范围扩大。访问到不能访问</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022220219768.png" alt="image-20241022220219768"></p><p><strong>通过子类对父类方法的覆盖（Override）实现多态</strong>：这是最常见的形式。当子类重写（覆盖）父类中的方法时，通过父类的引用调用子类的方法，就体现了多态性。选项 <strong>A</strong> 是正确的。</p><p><strong>利用重载（Overload）来实现多态</strong>：在同一个类中定义多个同名但参数不同的方法，也可以被认为是一种多态形式，虽然与覆盖的多态不同。这是编译时多态的一种形式。选项 <strong>B</strong> 是正确的。</p><p><strong>D</strong>：错误，子类无法通过重载父类的方法实现多态，重载是在同一个类中进行的。</p><h5 id="4-封装"><a href="#4-封装" class="headerlink" title="4.封装"></a>4.封装</h5><p>。封装是指将字段和方法绑定在单个类中。</p><h5 id="5-嵌套类"><a href="#5-嵌套类" class="headerlink" title="5.嵌套类"></a>5.嵌套类</h5><p>另一个类中定义一个类</p><h5 id="6-嵌套静态类"><a href="#6-嵌套静态类" class="headerlink" title="6.嵌套静态类"></a>6.嵌套静态类</h5><p>&#x2F;&#x2F;静态嵌套类的对象创建<br>      Animal.Mammal mammal &#x3D; new Animal.Mammal();</p><h5 id="7-Java-匿名类"><a href="#7-Java-匿名类" class="headerlink" title="7.Java 匿名类"></a>7.Java 匿名类</h5><p>匿名内部类的作用主要是<strong>用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">polygon</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;在 Polygon 类内部&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">AnonymousDemo</span> &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">createClass</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        polygon p1=<span class="hljs-keyword">new</span> <span class="hljs-title function_">polygon</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;在匿名类内部。&quot;</span>);<br>            &#125;<br>        &#125;;<br>        p1.<span class="hljs-title function_">display</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span>  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">AnonymousDemo</span> a1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnonymousDemo</span>();<br>        a1.<span class="hljs-title function_">createClass</span>();<br>        a1.<span class="hljs-title function_">display</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们可以在类的方法中定义匿名类重写匿名类的方法-</p><p>若匿名类是接口-我们也需要实现接口</p><p>实现-我们匿名类内部有很多逻辑-不想给你看。我们就可以直接对外暴露一个给你让你重写。简单-不需要看其他代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Thread</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">getName</span>());<br>            &#125;<br>        &#125;);<br>        t.<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上-如果我们没有匿名类-我们就需要继承或者接口 Thread来重写run_但匿名类就不需要</p><p><em>匿名类减少了我们代码的复杂程度-用匿名类可以方便对方法或者接口进行重写-(不需要用类继承重写)</em></p><h5 id="8-单例模式"><a href="#8-单例模式" class="headerlink" title="8.单例模式"></a>8.单例模式</h5><p>它确保只创建一个类的实例。</p><p>设计模式就像我们的代码库一样，其中包含世界各地程序员共享的各种编码技术。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Database</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Database dbObject;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Database</span>()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Database <span class="hljs-title">getInstance</span>()</span> &#123;<br><br>        <span class="hljs-comment">//创建对象（如果尚未创建）</span><br>        <span class="hljs-keyword">if</span>(dbObject == <span class="hljs-literal">null</span>) &#123;<br>            dbObject = <span class="hljs-keyword">new</span> Database();<br>        &#125;<br><br>        <span class="hljs-comment">//返回单例对象</span><br>        <span class="hljs-keyword">return</span> dbObject;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getConnection</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;现在已经连接到数据库。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Database db1;<br><br>        <span class="hljs-comment">//引用Database的唯一对象</span><br>        db1= Database.getInstance();<br><br>        db1.getConnection();<br><br>        Main.test2();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span>()</span><br>    &#123;<br>        Database db1;<br><br>        <span class="hljs-comment">//引用Database的唯一对象</span><br>        db1= Database.getInstance();<br>        db1.getConnection();<br>    &#125;<br>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Database</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Database dbObject;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Database</span>()</span> &#123;      <br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Database <span class="hljs-title">getInstance</span>()</span> &#123;<br><br>      <span class="hljs-comment">//创建对象（如果尚未创建）</span><br>      <span class="hljs-keyword">if</span>(dbObject == <span class="hljs-literal">null</span>) &#123;<br>         dbObject = <span class="hljs-keyword">new</span> Database();<br>      &#125;<br><br>       <span class="hljs-comment">//返回单例对象</span><br>       <span class="hljs-keyword">return</span> dbObject;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getConnection</span>()</span> &#123;<br>       System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;现在已经连接到数据库。&quot;</span>);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>      Database db1;<br><br>      <span class="hljs-comment">//引用Database的唯一对象</span><br>      db1= Database.getInstance();<br>      <br>      db1.getConnection();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例模式<br>确保只有一个实例化的对象<br>也就是需要静态方法 返回已经实例好的对象</p><p>返回的对象就可以调用该调用的了</p><h5 id="9-枚举"><a href="#9-枚举" class="headerlink" title="9.枚举"></a>9.枚举</h5><p>enum Size {<br>   SMALL, MEDIUM, LARGE, EXTRALARGE<br>}</p><p>class Size {<br>   public final static int SMALL &#x3D; 1;<br>   public final static int MEDIUM &#x3D; 2;<br>   public final static int LARGE &#x3D; 3;<br>   public final static int EXTRALARGE &#x3D; 4;<br>}</p><p>代码多用枚举</p><h4 id="10-反射"><a href="#10-反射" class="headerlink" title="10.反射"></a>10.反射</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022220351287.png" alt="image-20241022220351287"></p><blockquote><p>反射在 Java 中主要有以下几个作用：</p><ol><li><strong>动态访问类信息</strong>：可以在运行时获取类的结构，包括类名、方法、字段和构造函数等。</li><li><strong>动态实例化对象</strong>：可以根据类的名称动态创建对象，而不需要在编译时就确定具体的类。</li><li><strong>调用方法</strong>：能够在运行时调用对象的方法，支持对私有方法的访问。</li><li><strong>修改字段</strong>：可以直接访问和修改对象的属性，即使是私有字段。</li><li><strong>框架和库支持</strong>：许多 Java 框架（如 <strong>Spring</strong> 和 Hibernate）使用反射来动态处理对象，增强灵活性和可扩展性。</li></ol></blockquote><p>反射允许我们在运行时检查和<strong>操作类、接口、构造函数、方法和字段。</strong></p><p>Java中有一个名为Class的类，该类在运行时保留有关对象和类的所有信息。</p><p>Class对象描述了特定类的属性。该对象用于执行反射。</p><p>class 反射-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Class.forName(<span class="hljs-string">&quot;Dog&quot;</span>)<span class="hljs-comment">;</span><br>Dog d1 <span class="hljs-operator">=</span> new Dog()<br>Class c1 <span class="hljs-operator">=</span> d1.getClass()<span class="hljs-comment">;</span><br>Class c1 <span class="hljs-operator">=</span> Dog.class<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="1-反射作用"><a href="#1-反射作用" class="headerlink" title="1.反射作用"></a>1.反射作用</h5><h6 id="1-获取接口"><a href="#1-获取接口" class="headerlink" title="1.获取接口 -"></a>1.获取接口 -</h6><p>我们可以使用Class的<strong>getInterfaces</strong>()方法来收集类实现的接口的信息。此方法返回一个接口数组</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Dog d1 = <span class="hljs-keyword">new</span> Dog()<br><span class="hljs-keyword">Class</span> obj = d1.getClass();<br>        <br>          <span class="hljs-comment">//查找由Dog实现的接口</span><br>          <span class="hljs-keyword">Class</span>[] objInterface = obj.getInterfaces();<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">Class</span> c : objInterface) &#123;<br><br>              <span class="hljs-comment">//打印接口名称</span><br>              System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Interface Name: &quot;</span> + c.getName());<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><h6 id="2-获取超类和访问修饰符"><a href="#2-获取超类和访问修饰符" class="headerlink" title="2.获取超类和访问修饰符"></a>2.获取超类和访问修饰符</h6><p>获取超类和访问修饰符<br>类Class的方法<strong>getSuperclass</strong>()可用于获取有关特定类的超类的信息。</p><p>而且，Class提供了一种getModifier()方法，该方法以整数形式返回class的修饰符。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//找到Dog的超类</span><br>           <span class="hljs-keyword">Class</span> superClass = obj.getSuperclass();<br>           System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Superclass: &quot;</span> + superClass.getName());<br>       &#125;<br></code></pre></td></tr></table></figure><h6 id="3-反射字段，方法和构造函数"><a href="#3-反射字段，方法和构造函数" class="headerlink" title="3.反射字段，方法和构造函数"></a>3.反射字段，方法和构造函数</h6><p>该软件包java.lang.<strong>reflect</strong>提供了可用于操作类成员的类。例如，</p><p>方法类 - 提供有关类中方法的信息</p><p>字段类 - 提供有关类中字段的信息</p><p>构造函数类  - 提供有关类中构造函数的信息</p><p>Java 反射与字段<br> 我们可以使用<strong>Field</strong>类提供的各种方法检查和修改类的不同字段。</p><p>getFields() - 返回该类及其超类的所有公共字段</p><p>getDeclaredFields()  - 返回类的所有字段</p><p>getModifier() - 以整数形式返回字段的修饰符</p><p>set(classObject,value) - 使用指定的值设置字段的值</p><p>get(classObject) - 获取字段的值</p><p>setAccessible(boolean) - 使私有字段可访问</p><p>注意：如果我们知道字段名称，则可以使用</p><p>getField(“fieldName”） - 从类返回名称为fieldName的公共字段。</p><p>getDeclaredField(“fieldName”） - 从类返回名称为fieldName的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">示例：访问私有字段<br><span class="hljs-keyword">import</span> java.lang.Class;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br> <span class="hljs-keyword">private</span> String color;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Dog</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>      <span class="hljs-comment">//创建类Class对象</span><br>      <span class="hljs-type">Class</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> d1.getClass();<br><br>      <span class="hljs-comment">//访问私有字段</span><br>      <span class="hljs-type">Field</span> <span class="hljs-variable">field2</span> <span class="hljs-operator">=</span> obj.getDeclaredField(<span class="hljs-string">&quot;color&quot;</span>);<br>     <br>      <span class="hljs-comment">//使私有字段可访问</span><br>      field2.setAccessible(<span class="hljs-literal">true</span>);<br>      <span class="hljs-comment">//设置color值</span><br>      field2.set(d1, <span class="hljs-string">&quot;brown&quot;</span>);<br>      <span class="hljs-comment">// get the value of type converting in String</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">colorValue</span> <span class="hljs-operator">=</span> (String)field2.get(d1);<br>      System.out.println(<span class="hljs-string">&quot;color: &quot;</span> + colorValue);<br><br>      <span class="hljs-comment">//获取color的访问修饰符</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">mod2</span> <span class="hljs-operator">=</span> field2.getModifiers();<br>      <span class="hljs-type">String</span> <span class="hljs-variable">modifier2</span> <span class="hljs-operator">=</span> Modifier.toString(mod2);<br>      System.out.println(<span class="hljs-string">&quot;modifier: &quot;</span> + modifier2);<br>   &#125;<br>   <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>      e.printStackTrace();<br>   &#125;<br> &#125;<br>&#125;<br>输出结果<br><br>color: brown<br>modifier: <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure><h6 id="5-反射-方法"><a href="#5-反射-方法" class="headerlink" title="5.反射 方法"></a>5.反射 方法</h6><p>Java <strong>反射与方法</strong><br>像字段一样，我们可以使用<em><strong>Method</strong></em>类提供的各种方法来检查类的不同方法。</p><p>getMethods() - 返回该类及其超类的所有公共方法</p><p>getDeclaredMethod() - 返回该类的所有方法</p><p>getName() - 返回方法的名称</p><p>getModifiers() - 以整数形式返回方法的访问修饰符</p><p>getReturnType() - 返回方法的返回类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs csharp">示例：方法反射<br>import java.lang.Class;<br>import java.lang.reflect.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;I am a dog.&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span> &#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;I eat dog food.&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeSound</span>()</span> &#123;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Bark Bark&quot;</span>);<br>   &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectionDemo</span> &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>          Dog d1 = <span class="hljs-keyword">new</span> Dog();<br><br>          <span class="hljs-comment">//创建一个Class对象</span><br>          Class obj = d1.getClass();<br>          <br>          <span class="hljs-comment">//使用getDeclaredMethod()获取所有方法</span><br>          Method[] methods = obj.getDeclaredMethods();<br><br>          <span class="hljs-comment">//获取方法的名称</span><br>          <span class="hljs-keyword">for</span>(Method m : methods) &#123;<br>               <br>             System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;方法名称： &quot;</span> + m.getName());<br>              <br>             <span class="hljs-comment">//获取方法的访问修饰符</span><br>             <span class="hljs-built_in">int</span> modifier = m.getModifiers();<br>             System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;修饰符： &quot;</span> + Modifier.toString(modifier));<br>              <br>             <span class="hljs-comment">//获取方法的返回类型</span><br>             System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Return Types: &quot;</span> + m.getReturnType());<br>             System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot; &quot;</span>);<br>          &#125;<br>       &#125;<br>       <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br>&#125;<br>输出结果<br><br>方法名称： display<br>修饰符： <span class="hljs-keyword">public</span><br>Return type: <span class="hljs-keyword">void</span><br><br>方法名称： eat<br>修饰符： <span class="hljs-keyword">protected</span><br>返回类型： <span class="hljs-keyword">void</span><br><br>方法名称： makeSound<br>修饰符： <span class="hljs-keyword">private</span><br>返回类型： <span class="hljs-keyword">void</span><br></code></pre></td></tr></table></figure><h6 id="6-Java-反射与构造函数"><a href="#6-Java-反射与构造函数" class="headerlink" title="6.Java 反射与构造函数"></a>6.Java 反射与构造函数</h6><p>我们还可以使用<em><strong>Constructor</strong></em>类提供的各种方法检查类的不同构造函数。</p><p>getConstructors() - 返回该类的所有公共构造函数以及该类的超类</p><p>getDeclaredConstructor() -返回所有构造函数</p><p>getName() - 返回构造函数的名称</p><p>getModifiers() - 以整数形式返回构造函数的访问修饰符</p><p>getParameterCount() - 返回构造函数的参数数量</p><p>示例：构造函数反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java">示例：构造函数反射<br><span class="hljs-keyword">import</span> java.lang.Class;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br>      <br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>      <br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String sound, String type)</span> &#123;<br>      <br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionDemo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">Dog</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>           <span class="hljs-type">Class</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> d1.getClass();<br><br>           <span class="hljs-comment">//使用getDeclaredConstructor()获取一个类中的所有构造函数</span><br>           Constructor[] constructors = obj.getDeclaredConstructors();<br><br>           <span class="hljs-keyword">for</span>(Constructor c : constructors) &#123;<br>               <span class="hljs-comment">//获取构造函数的名称</span><br>               System.out.println(<span class="hljs-string">&quot;构造函数名称： &quot;</span> + c.getName());<br><br>               <span class="hljs-comment">//获取构造函数的访问修饰符</span><br>               <span class="hljs-type">int</span> <span class="hljs-variable">modifier</span> <span class="hljs-operator">=</span> c.getModifiers();<br>               System.out.println(<span class="hljs-string">&quot;修饰符： &quot;</span> + Modifier.toString(modifier));<br><br>               <span class="hljs-comment">//获取构造函数中的参数数量</span><br>               System.out.println(<span class="hljs-string">&quot;参数个数： &quot;</span> + c.getParameterCount());<br>          &#125;<br>       &#125;<br>       <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>    &#125;<br>&#125;<br>输出结果<br><br>构造函数名称： Dog<br>修饰符： <span class="hljs-keyword">public</span><br>参数个数： <span class="hljs-number">0</span><br><br>构造函数名称： Dog<br>修饰符： <span class="hljs-keyword">public</span><br>参数个数： <span class="hljs-number">1</span><br><br>构造函数名称： Dog<br>修饰符： <span class="hljs-keyword">private</span><br>参数个数： <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="11-包"><a href="#11-包" class="headerlink" title="11.包"></a>11.包</h4><p>package pkg1[．pkg2[．pkg3…]];</p><p>那么它的路径应该是 net&#x2F;java&#x2F;util&#x2F;Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。</p><p>也就是命名空间 这样变量可以重名</p><p>以下是一些 Java 中的包：</p><p>java.lang-打包基础的类</p><p>java.io-包含输入输出功能的函数</p><p>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p><p>由于包创建了新的命名空间(namespace)，所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p><p><strong>import 关键字<br>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。</strong></p><h2 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h2><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022220527864.png" alt="image-20241022220527864"></p><h5 id="1-异常认识"><a href="#1-异常认识" class="headerlink" title="1.异常认识"></a>1.异常认识</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022220613149.png" alt="image-20241022220613149"></p><p><img src="https://www.cainiaojc.com/run/images/ExceptionHierarchy.png" alt="Java中的异常层次结构"></p><p>Throwable-根类</p><p>Error</p><p><strong>Error</strong>表示不可恢复的情况，例如Java虚拟机（JVM）内存不足，内存泄漏，堆栈溢出错误，库不兼容，无限递归等</p><p>Exception</p><p>程序可以捕获并处理<strong>异常</strong>。</p><p>当方法内发生异常时，它将创建一个对象。该对象称为异常对象。</p><p>它包含有关异常的信息，例如异常的名称和说明以及发生异常时的程序状态。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022220620503.png" alt="image-20241022220620503"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022220629279.png" alt="image-20241022220629279"></p><h5 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2.异常处理"></a>2.异常处理</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123; <br>  <span class="hljs-comment">// 捕获块</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-comment">//finally块</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-异常抛出"><a href="#3-异常抛出" class="headerlink" title="3.异常抛出"></a>3.异常抛出</h5><p>1.异常层层抛出 throws </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">accessModifier returnType <span class="hljs-title">methodName</span>() throws ExceptionType1, ExceptionType2 …</span> &#123;<br>  <span class="hljs-comment">// code</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//可能产生IOException的代码</span><br>    File newFile=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    FileInputStream stream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(newFile);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>      findFile();<span class="hljs-comment">//内部异常抛出 MAIN捕获</span><br>    &#125; <span class="hljs-keyword">catch</span>(IOException e)&#123;<br>      System.out.println(e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-自动抛出异常"><a href="#2-自动抛出异常" class="headerlink" title="2.自动抛出异常"></a>2.自动抛出异常</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">throw throwableObject<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">divideByZero</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">&quot;试图除以0&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>    <span class="hljs-title function_">divideByZero</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;文件未找到&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      findFile();<br>      System.out.println(<span class="hljs-string">&quot;try块中的其余代码&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      System.out.println(e.getMessage());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-try-with-resources"><a href="#3-try-with-resources" class="headerlink" title="3.try with resources"></a>3.try with resources</h5><p>–释放资源还是自己操作– 省</p><p>try(new的东西)-当有异常自动给你释放掉</p><h5 id="4-注解"><a href="#4-注解" class="headerlink" title="4.注解"></a>4.注解</h5><p>—Java注解是我们程序源代码的元数据（有关数据的数据）。</p><p>它们向编译器提供关于程序的附加信息，但不是程序本身的一部分</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@AnnotationName</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@AnnotationName(elementName = <span class="hljs-string">&quot;elementValue&quot;</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@AnnotationName(element1 = <span class="hljs-string">&quot;value1&quot;</span>, element2 = <span class="hljs-string">&quot;value2&quot;</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">List&lt;<span class="hljs-symbol">@NonNull</span> <span class="hljs-built_in">String</span>&gt; newList<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>该声明指定String类型的非空值的列表。</p><h5 id="5-日志-Logging-省"><a href="#5-日志-Logging-省" class="headerlink" title="5.日志-Logging-省"></a>5.日志-Logging-省</h5><p>Java允许我们通过日志记录过程来创建和捕获日志消息和文件。</p><p>在Java中，日志记录需要框架和API。Java在java.util.logging程序包中具有内置的日志记录框架。</p><p>我们还可以将第三方框架（如Log4j，Logback等）用于日志记录。</p><h5 id="6-断言"><a href="#6-断言" class="headerlink" title="6.断言"></a>6.断言</h5><p>Java中的断言通过测试我们认为是正确的代码来帮助检测错误。</p><p>使用assert关键字进行断言</p><p>-默认关闭需要启用-</p><p>启用断言且条件为时true，程序将正常执行。</p><p>但是，如果在启用断言时条件计算为false, JVM会抛出AssertionError，程序会立即停止。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> args[]</span>) &#123;<br>    <span class="hljs-title class_">String</span>[] weekends = &#123;<span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>, <span class="hljs-string">&quot;Sunday&quot;</span>&#125;;<br>    assert weekends.<span class="hljs-property">length</span>==<span class="hljs-number">2</span> : <span class="hljs-string">&quot;There are only 2 weekends in a week&quot;</span>;<br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;There are &quot;</span> + weekends.<span class="hljs-property">length</span> + <span class="hljs-string">&quot;  weekends in a week&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Object通用方法"><a href="#4-Object通用方法" class="headerlink" title="4.Object通用方法"></a>4.Object通用方法</h2><p>来自包体</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105170601561.png" alt="image-20241105170601561"></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">clone</span>():</span><br><span class="hljs-function"></span><br><span class="hljs-function">是 <span class="hljs-variable"><span class="hljs-class">Object</span></span> 类中的方法。它用于创建并返回当前对象的副本（即浅拷贝）。不过，<span class="hljs-title">clone</span>() 方法是 <span class="hljs-variable">protected</span> 的，所以只能在当前类或其子类中直接调用。</span><br><span class="hljs-function"><span class="hljs-title">toString</span>():</span><br><span class="hljs-function"></span><br><span class="hljs-function">也是 <span class="hljs-variable"><span class="hljs-class">Object</span></span> 类中的方法。它返回对象的字符串表示，默认返回的是对象的类名和哈希码的组合。很多类会覆盖此方法，以提供更有意义的字符串表示。</span><br><span class="hljs-function"><span class="hljs-title">wait</span>():</span><br><span class="hljs-function"></span><br><span class="hljs-function">是 <span class="hljs-variable"><span class="hljs-class">Object</span></span> 类中的方法。它用于使当前线程在对象上等待，直到其他线程调用该对象的 <span class="hljs-title">notify</span>() 或 <span class="hljs-title">notifyAll</span>() 方法来唤醒它。<span class="hljs-title">wait</span>() 方法是用来进行线程间通信的。</span><br><span class="hljs-function"><span class="hljs-title">finalize</span>():</span><br><span class="hljs-function"></span><br><span class="hljs-function">是 <span class="hljs-variable"><span class="hljs-class">Object</span></span> 类中的方法。它在对象被垃圾回收器回收之前由垃圾回收器调用，可以用于执行清理工作（比如关闭文件、释放资源等）。不过，这个方法已经不推荐使用（自 <span class="hljs-variable">Java</span> <span class="hljs-number">9</span> 起被标记为过时），因为垃圾回收的时机是不确定的。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">package</span> <span class="hljs-variable">java.lang</span>;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4c08f71d2960abc064ff408b5e1d3b9b.png" alt="4c08f71d2960abc064ff408b5e1d3b9b"></p><h4 id="1-equals探究"><a href="#1-equals探究" class="headerlink" title="1.equals探究"></a>1.equals探究</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">equals</span>(<span class="hljs-type">Object</span> obj)<br></code></pre></td></tr></table></figure><p><strong>目的</strong>：该方法用于判断当前对象是否与另一个对象相等。</p><p><strong>默认实现</strong>：在 <code>Object</code> 类中，<code>equals</code> 方法通过比较对象的引用来判断两个对象是否相同。</p><p>说明文档</p><ul><li><p><strong>等价关系</strong>：<code>equals</code> 方法实现了一种等价关系，符合以下性质：</p><ol><li><p><strong>自反性</strong>（reflexive）：任何非空引用 <code>x</code>，<code>x.equals(x)</code> 应返回 <code>true</code>。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>对称性</strong>（symmetric）：对于任何非空引用 <code>x</code> 和 <code>y</code>，<code>x.equals(y)</code> 如果返回 <code>true</code>，则 <code>y.equals(x)</code> 也应返回 <code>true</code>。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == y.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>传递性</strong>（transitive）：对于任何非空引用 <code>x</code>、<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 都返回 <code>true</code>，那么 <code>x.equals(z)</code> 也应返回 <code>true</code>。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))<br>    x.equals(z); <span class="hljs-comment">// true;</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>一致性</strong>（consistent）：对于任何非空引用 <code>x</code> 和 <code>y</code>，多次调用 <code>x.equals(y)</code> 应始终返回相同的结果，前提是用于比较的对象没有被修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == x.equals(y); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不等于 null</strong>：对于任何非空引用 <code>x</code>，<code>x.equals(null)</code> 应返回 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(<span class="hljs-literal">null</span>); <span class="hljs-comment">// false;</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>默认行为</strong>：<code>Object</code> 类中的 <code>equals</code> 方法返回 <code>true</code> 仅当两个对象的引用相同（即 <code>x == y</code> 为 <code>true</code>）。</p></li><li><p><strong>重写时注意</strong>：如果重写 <code>equals</code> 方法，通常需要同时重写 <code>hashCode</code> 方法，以保持哈希码的一般约定：相等的对象必须有相等的哈希码。</p></li><li></li></ul><p><strong>equals() 与 &#x3D;&#x3D;</strong></p><ul><li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br>System.out.println(x == y);      <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p><strong>代码实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EqualExample</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        EqualExample e1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualExample</span>();<br>        e1.x=<span class="hljs-number">1</span>;<br>        e1.y=<span class="hljs-number">2</span>;<br>        System.out.println(e1.equals(e1));<br>        EqualExample e2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualExample</span>();<br>        e2.x=<span class="hljs-number">13</span>;<br>        e2.y=<span class="hljs-number">2</span>;<br>        System.out.println(e1.equals(e2));<br>    &#125;<br><br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">//检查是否为同一个对象的引用，如果是直接返回 true；</span><br>        <span class="hljs-comment">//检查是否是同一个类型，如果不是，直接返回 false；</span><br>        <span class="hljs-comment">//将 Object 对象进行转型；</span><br>        <span class="hljs-comment">//判断每个关键域是否相等。</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>==o)<br>        &#123;<br>            <span class="hljs-comment">//引用相同</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//类型判断和空判断</span><br>        <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">null</span> || getClass()!=o.getClass())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br>        <span class="hljs-comment">//对象深度判断</span><br>        <span class="hljs-comment">//可以通过反射拿</span><br>        Class&lt;?&gt; aClass=o.getClass();<br>        Field[] declaredFields = aClass.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : declaredFields)<br>        &#123;<br>            field.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 允许访问私有字段</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span>  field.get(o);<br>                Object value2= field.get(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">if</span>(value1==<span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(value2!=<span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!value1.equals(value2))<br>                    &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br><br><br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                e.printStackTrace(); <span class="hljs-comment">// 处理异常</span><br>            &#125;<br><br><br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-hashCode"><a href="#2-hashCode" class="headerlink" title="2.hashCode"></a>2.hashCode</h4><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EqualExample</span> <span class="hljs-variable">e1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualExample</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-type">EqualExample</span> <span class="hljs-variable">e2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EqualExample</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>System.out.println(e1.equals(e2)); <span class="hljs-comment">// true</span><br>HashSet&lt;EqualExample&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set.add(e1);<br>set.add(e2);<br>System.out.println(set.size());   <span class="hljs-comment">// 2</span><br><br><br></code></pre></td></tr></table></figure><h4 id="3-toString"><a href="#3-toString" class="headerlink" title="3.toString"></a>3.toString</h4><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ToStringExample &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">number</span>;<br><br>    <span class="hljs-keyword">public</span> ToStringExample(<span class="hljs-built_in">int</span> <span class="hljs-keyword">number</span>) &#123;<br>        this.<span class="hljs-keyword">number</span> = <span class="hljs-keyword">number</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ToStringExample example <span class="hljs-operator">=</span> new ToStringExample(<span class="hljs-number">123</span>)<span class="hljs-comment">;</span><br>System.out.println(example.toString())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">ToStringExample@4554617c<br></code></pre></td></tr></table></figure><h4 id="4-clone"><a href="#4-clone" class="headerlink" title="4.clone"></a>4.clone</h4><p>返回当前副本 </p><p>注意浅拷贝和深拷贝即可</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>匿名 -反射-</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础笔记-注解</title>
    <link href="/2024/10/28/java/java%E6%B3%A8%E8%A7%A3/java%E5%9F%BA%E7%A1%80%E6%B3%A8%E8%A7%A3/"/>
    <url>/2024/10/28/java/java%E6%B3%A8%E8%A7%A3/java%E5%9F%BA%E7%A1%80%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础-注解"><a href="#java基础-注解" class="headerlink" title="java基础 注解"></a>java基础 注解</h1><h4 id="0-注解认识"><a href="#0-注解认识" class="headerlink" title="0.注解认识"></a>0.注解认识</h4><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241029144225973.png" alt="image-20241029144225973"></p><p>注解分类</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241029144240709.png" alt="image-20241029144240709"></p><h4 id="java内置注解"><a href="#java内置注解" class="headerlink" title="java内置注解"></a>java内置注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testa</span> &#123;<br>    <span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">b</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span><br>    &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 重载父类的test方法</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;<br>          <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 被弃用的方法</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-meta">@Deprecated</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;B2&quot;</span>);<br>        &#125;<br>        <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 忽略告警</span><br><span class="hljs-comment">        * </span><br><span class="hljs-comment">        * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;rawtype&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print3</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;B3&quot;</span>);<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        b b1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">b</span>();<br>        b1.print();<br>        b1.print2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">// A a=new testa().new b();</span><br>        testa t=<span class="hljs-keyword">new</span>  <span class="hljs-title class_">testa</span>();<br>        t.test();<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p><ul><li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li><li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li></ul><p>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解</p><hr><h5 id="1-Override"><a href="#1-Override" class="headerlink" title="1.Override"></a>1.Override</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-comment">//修饰方法</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.SOURCE)<br><span class="hljs-comment">//编译适有效</span><br>public <span class="hljs-variable">@interface</span> Override &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同报错</p><h5 id="2-Deprecated"><a href="#2-Deprecated" class="headerlink" title="2.Deprecated"></a>2.Deprecated</h5><p>弃用方法-只要不直接引用 字节码文件就不会生成他的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span> <span class="hljs-comment">//文档</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//编译期</span><br><span class="hljs-meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><span class="hljs-comment">//谁使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议使用</p><h5 id="3-SuppressWarnings"><a href="#3-SuppressWarnings" class="headerlink" title="3.SuppressWarnings"></a>3.SuppressWarnings</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241029145157922.png" alt="image-20241029145157922"></p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing&#x2F;unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241029145350197.png" alt="image-20241029145350197"></p><p>这些元注解的使用为自定义注解提供了更加灵活和明确的行为控制。</p><h5 id="1-Target"><a href="#1-Target" class="headerlink" title="1.@Target"></a>1.@Target</h5><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ElementType</span> &#123;<br> <br>    TYPE, <span class="hljs-comment">// 类、接口、枚举类</span><br> <br>    FIELD, <span class="hljs-comment">// 成员变量（包括：枚举常量）</span><br> <br>    METHOD, <span class="hljs-comment">// 成员方法</span><br> <br>    PARAMETER, <span class="hljs-comment">// 方法参数</span><br> <br>    CONSTRUCTOR, <span class="hljs-comment">// 构造方法</span><br> <br>    LOCAL_VARIABLE, <span class="hljs-comment">// 局部变量</span><br> <br>    ANNOTATION_TYPE, <span class="hljs-comment">// 注解类</span><br> <br>    PACKAGE, <span class="hljs-comment">// 可用于修饰：包</span><br> <br>    TYPE_PARAMETER, <span class="hljs-comment">// 类型参数，JDK 1.8 新增</span><br> <br>    TYPE_USE <span class="hljs-comment">// 使用类型的任何地方，JDK 1.8 新增</span><br> <br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2-Retention-RetentionTarget"><a href="#2-Retention-RetentionTarget" class="headerlink" title="2.@Retention &amp; @RetentionTarget"></a>2.@Retention &amp; @RetentionTarget</h5><p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p><p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RetentionPolicy</span> &#123;<br> <br>    SOURCE,    <span class="hljs-comment">// 源文件保留</span><br>    CLASS,       <span class="hljs-comment">// 编译期保留，默认值</span><br>    RUNTIME   <span class="hljs-comment">// 运行期保留，可通过反射去获取注解信息</span><br>&#125;<br>------<br><br></code></pre></td></tr></table></figure><h5 id="3-Documented"><a href="#3-Documented" class="headerlink" title="3.@Documented"></a>3.@Documented</h5><p>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><p>以下代码在使用Javadoc工具可以生成<code>@TestDocAnnotation</code>注解信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br> <br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TestDocAnnotation &#123;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;default&quot;</span>;<br>&#125;<br>------<br><br></code></pre></td></tr></table></figure><h5 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4.Inherited"></a>4.Inherited</h5><p>Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TestInheritedAnnotation &#123;<br>    String [] values();<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">number</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestInheritedAnnotation(values = &#123;&quot;value&quot;&#125;, number = 10)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Student.class;<br>        Annotation[] annotations = clazz.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(annotation.toString());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">xxxxxxx.TestInheritedAnnotation(values=[value], number=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>即使Student类没有显示地被注解<code>@TestInheritedAnnotation</code>，但是它的父类Person被注解，而且<code>@TestInheritedAnnotation</code>被<code>@Inherited</code>注解，因此Student类自动有了该注解</p><hr><h4 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h4><h5 id="1-AnnotatedElement-探究"><a href="#1-AnnotatedElement-探究" class="headerlink" title="1.AnnotatedElement 探究"></a>1.AnnotatedElement 探究</h5><blockquote><p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p><hr></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable,<br>                              GenericDeclaration,<br>                              Type,<br>                              AnnotatedElement <br></code></pre></td></tr></table></figure><p>AnnotatedElement</p><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。</p><hr><p>注解在 Java 中被视为一种特殊的接口，用于为代码提供元数据。它们本身并不是类，但可以使用 <code>@interface</code> 关键字定义，并在编译时生成相应的 <code>.class</code> 文件。因此，注解确实会生成类文件。</p><ol><li><strong>生成类</strong>：每个注解在编译时会生成一个对应的类文件，文件名为注解名加上 <code>.class</code> 后缀。</li><li><strong>反射访问</strong>：注解可以通过反射机制访问。例如，可以使用 <code>Class.getAnnotations()</code> 方法获取类上定义的所有注解。通过 <code>getAnnotation(Class&lt;T&gt; annotationClass)</code> 方法可以获取特定类型的注解。</li><li><strong>元数据</strong>：注解用于提供额外的信息，编译器、工具或者框架可以根据这些信息执行特定的逻辑。</li></ol><p>1.判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">default</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAnnotationPresent</span>(<span class="hljs-params"><span class="hljs-title class_">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationClass</span>) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAnnotation</span>(annotationClass) != <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d9902b46848208dc9099f7186847c03e.png" alt="d9902b46848208dc9099f7186847c03e"></p><p>调用 getAnnotation</p><p>2.返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">&lt;<span class="hljs-built_in">T</span> extends Annotation&gt; <span class="hljs-built_in">T</span> getAnnotation(Class&lt;<span class="hljs-built_in">T</span>&gt; annotationClass);<br></code></pre></td></tr></table></figure><p>3.返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p><ul><li><pre><code class="hljs">`Annotation[] getAnnotations()`<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><br><br><span class="hljs-number">4</span>.返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为<span class="hljs-number">0</span>的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。`getAnnotationsByType`方法与 `getAnnotation`的区别在于，`getAnnotationsByType`会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。<br><br>------<br><br><span class="hljs-title">![image-20241031142038651](https:</span>//raw.githubusercontent.com/Xlan-cell/tupian/master/image-<span class="hljs-number">20241031142038651</span>.png)<br><br></code></pre></td></tr></table></figure>default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;&#125;<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><br><span class="hljs-number">5</span>.返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回<span class="hljs-literal">null</span><span class="hljs-punctuation">-</span><br><br></code></pre></td></tr></table></figure>default &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass) &#123;&#125;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>![image-<span class="hljs-number">20241031142140052</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Xlan-cell/</span>tupian<span class="hljs-regexp">/master/im</span>age-<span class="hljs-number">20241031142140052</span>.png)<br><br>Inherited 不考虑继承注解<br><br><span class="hljs-number">6</span>.返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释<br><br></code></pre></td></tr></table></figure>default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) &#123;&#125;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><br>!<span class="hljs-selector-attr">[image-20241031142315880]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241031142315880.png)</span><br><br><span class="hljs-number">7</span>.返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<br><br><br><br>![image-<span class="hljs-number">20241031142331860</span>](<span class="hljs-attribute">https</span>:<span class="hljs-comment">//raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241031142331860.png)</span><br><br>类-&gt;class-&gt;annotatedElement-&gt;实现注解的或者<br><br>##### <span class="hljs-number">2</span>.自定义注解<br><br>当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：<br><br>定义注解<br><br><span class="hljs-built_in">``</span>`java<br><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-variable">@interface</span> MyMethodAnnotation &#123;<br>    public String <span class="hljs-built_in">title</span>() default <span class="hljs-string">&quot;&quot;</span>;<br><br>    public String <span class="hljs-built_in">description</span>() default <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>类使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMethodAnnotation</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@MyMethodAnnotation(title = &quot;toStringMethod&quot;, description = &quot;override toString method&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Override toString method&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-meta">@MyMethodAnnotation(title = &quot;old static method&quot;, description = &quot;deprecated old static method&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;old method, don&#x27;t use it.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span><br>    <span class="hljs-meta">@MyMethodAnnotation(title = &quot;test method&quot;, description = &quot;suppress warning static method&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">genericsTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        l.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        oldMethod();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>注解的获取实现定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testa</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.TestMethodAnnotation.class.getClassLoader().loadClass 获取类加载器加载类</span><br><span class="hljs-comment">        2. Class.forName() -&gt;forName()加载信息后-&gt;loadClass-&gt;类加载由双亲委派记者决定</span><br><span class="hljs-comment">         */</span><br>        Method[] method = TestMethodAnnotation.class.getClassLoader().loadClass(<span class="hljs-string">&quot;TestMethodAnnotation&quot;</span>).getMethods();<br><br>        <span class="hljs-keyword">for</span> (Method m:method)<br>        &#123;<br>            <span class="hljs-comment">//是否包含自定义注解</span><br>            <span class="hljs-keyword">if</span> (m.isAnnotationPresent(MyMethodAnnotation.class))<br>            &#123;<br>                <span class="hljs-comment">// 获取并遍历方法上的所有注解</span><br>                <span class="hljs-keyword">for</span> (Annotation a:m.getDeclaredAnnotations())<br>                &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Annotation in Method &#x27;&quot;</span><br>                            + method + <span class="hljs-string">&quot;&#x27; : &quot;</span> + a);<br>                &#125;<br><br>                <span class="hljs-comment">// 获取MyMethodAnnotation对象信息</span><br>                <span class="hljs-type">MyMethodAnnotation</span> <span class="hljs-variable">methodAnno</span> <span class="hljs-operator">=</span> m<br>                        .getAnnotation(MyMethodAnnotation.class);<br><br>                System.out.println(methodAnno.title());<br><br>            &#125;<br>        &#125;<br><br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如上，我们可以获取该类所有方法上的注解，如果有我们写的注解，我们就可以进行注解功能的实现，注解解释注解</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">Annotation <span class="hljs-keyword">in</span> <span class="hljs-keyword">Method</span> <span class="hljs-string">&#x27;[Ljava.lang.reflect.Method;@5e2de80c&#x27;</span> : <span class="hljs-variable">@MyMethodAnnotation</span>(title<span class="hljs-operator">=</span>toStringMethod, description<span class="hljs-operator">=</span>override toString <span class="hljs-keyword">method</span>)<br>toStringMethod<br>Annotation <span class="hljs-keyword">in</span> <span class="hljs-keyword">Method</span> <span class="hljs-string">&#x27;[Ljava.lang.reflect.Method;@5e2de80c&#x27;</span> : <span class="hljs-variable">@MyMethodAnnotation</span>(title<span class="hljs-operator">=</span>test <span class="hljs-keyword">method</span>, description<span class="hljs-operator">=</span>suppress warning <span class="hljs-keyword">static</span> <span class="hljs-keyword">method</span>)<br>test <span class="hljs-keyword">method</span><br>Annotation <span class="hljs-keyword">in</span> <span class="hljs-keyword">Method</span> <span class="hljs-string">&#x27;[Ljava.lang.reflect.Method;@5e2de80c&#x27;</span> : <span class="hljs-variable">@java</span>.lang.Deprecated()<br>Annotation <span class="hljs-keyword">in</span> <span class="hljs-keyword">Method</span> <span class="hljs-string">&#x27;[Ljava.lang.reflect.Method;@5e2de80c&#x27;</span> : <span class="hljs-variable">@MyMethodAnnotation</span>(title<span class="hljs-operator">=</span><span class="hljs-keyword">old</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">method</span>, description<span class="hljs-operator">=</span>deprecated <span class="hljs-keyword">old</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">method</span>)<br><span class="hljs-keyword">old</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">method</span><br></code></pre></td></tr></table></figure><h3 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h3><h5 id="1-jav-8注解"><a href="#1-jav-8注解" class="headerlink" title="1.jav 8注解"></a>1.jav 8注解</h5><ul><li><p><code>ElementType.TYPE_PARAMETER</code></p></li><li><p><code>ElementType.TYPE_USE</code></p></li></ul><p><code>ElementType.TYPE_USE</code>(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了<code>ElementType.TYPE</code>(类、接口（包括注解类型）和枚举的声明)和<code>ElementType.TYPE_PARAMETER</code>(类型参数声明), 不妨再看个例子</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义ElementType.TYPE_PARAMETER注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE_PARAMETER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyNotEmpty &#123;<br>&#125;<br><br><span class="hljs-comment">// 自定义ElementType.TYPE_USE注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE_USE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyNotNull &#123;<br>&#125;<br><br><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeParameterAndTypeUseAnnotation</span>&lt;<span class="hljs-meta">@MyNotEmpty</span> T&gt;&#123;<br><br>  <span class="hljs-comment">//使用TYPE_PARAMETER类型，会编译不通过</span><br><span class="hljs-comment">//public @MyNotEmpty T test(@MyNotEmpty T a)&#123;</span><br><span class="hljs-comment">//new ArrayList&lt;@MyNotEmpty String&gt;();</span><br><span class="hljs-comment">//return a;</span><br><span class="hljs-comment">//&#125;</span><br><br>  <span class="hljs-comment">//使用TYPE_USE类型，编译通过</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@MyNotNull</span> T <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-meta">@MyNotNull</span> T a)</span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-meta">@MyNotNull</span> String&gt;();<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2-注解支持继承吗"><a href="#2-注解支持继承吗" class="headerlink" title="2.注解支持继承吗"></a>2.注解支持继承吗</h5><p>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.</p><p>虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p><p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解</p><hr><h5 id="3-注解实现的原理"><a href="#3-注解实现的原理" class="headerlink" title="3.注解实现的原理"></a>3.注解实现的原理</h5><p><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></p><h3 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h3><h6 id="1-配置化到注解化"><a href="#1-配置化到注解化" class="headerlink" title="1.配置化到注解化"></a>1.配置化到注解化</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Spring</span> 框架 配置化到注解化的转变。<br><br><br></code></pre></td></tr></table></figure><h6 id="2-继承实现到注解实现"><a href="#2-继承实现到注解实现" class="headerlink" title="2.继承实现到注解实现"></a>2.继承实现到注解实现</h6><p>Junit3到Junit4</p><p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p><h6 id="3-Aop-注解"><a href="#3-Aop-注解" class="headerlink" title="3.Aop 注解"></a>3.Aop 注解</h6><p>通过注解+AOP最终的目标是为了实现模块的解耦</p><p>权限管理</p><p>被 测试类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> &#123;<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span>()</span>&#123;<br> System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello....&quot;</span>);<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException();<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayWorld</span>()</span>&#123;<br> System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;world....&quot;</span>);<br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span>()</span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span>;<br> &#125;<br> <br>&#125;<br>------<br>著作权归@pdai所有<br>原文链接：https:<span class="hljs-comment">//pdai.tech/md/java/basic/java-basic-x-annotation.html</span><br></code></pre></td></tr></table></figure><ul><li>Junit 3 实现UT</li></ul><p>通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestCase</span>&#123;<br> <span class="hljs-keyword">private</span> HelloWorld hw;<br> <br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-built_in">super</span>.setUp();<br> hw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorld</span>();<br> &#125;<br> <br> <span class="hljs-comment">//1.测试没有返回值</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHello</span><span class="hljs-params">()</span>&#123;<br> <span class="hljs-keyword">try</span> &#123;<br> hw.sayHello();<br> &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br> System.out.println(<span class="hljs-string">&quot;发生异常.....&quot;</span>);<br> &#125;<br> <br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWorld</span><span class="hljs-params">()</span>&#123;<br> hw.sayWorld();<br> &#125;<br> <span class="hljs-comment">//2.测试有返回值的方法</span><br> <span class="hljs-comment">// 返回字符串</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSay</span><span class="hljs-params">()</span>&#123;<br> assertEquals(<span class="hljs-string">&quot;测试失败&quot;</span>, hw.say(), <span class="hljs-string">&quot;hello world!&quot;</span>);<br> &#125;<br> <span class="hljs-comment">//返回对象</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testObj</span><span class="hljs-params">()</span>&#123;<br> assertNull(<span class="hljs-string">&quot;测试对象不为空&quot;</span>, <span class="hljs-literal">null</span>);<br> assertNotNull(<span class="hljs-string">&quot;测试对象为空&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>());<br> &#125;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-built_in">super</span>.tearDown();<br> hw=<span class="hljs-literal">null</span>;<br> &#125;<br>&#125;<br>------<br>著作权归<span class="hljs-meta">@pdai</span>所有<br>原文链接：https:<span class="hljs-comment">//pdai.tech/md/java/basic/java-basic-x-annotation.html</span><br></code></pre></td></tr></table></figure><ul><li>Junit 4 实现UT</li></ul><p>通过定义@Before，@Test，@After等等注解来实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldTest</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-title class_">HelloWorld</span> hw;<br> <br> <span class="hljs-meta">@Before</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params"></span>) &#123;<br> hw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorld</span>();<br> &#125;<br> <br> <span class="hljs-meta">@Test</span>(expected=<span class="hljs-title class_">NumberFormatException</span>.<span class="hljs-property">class</span>)<br> <span class="hljs-comment">// 1.测试没有返回值,有别于junit3的使用，更加方便</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testHello</span>(<span class="hljs-params"></span>) &#123;<br> hw.<span class="hljs-title function_">sayHello</span>();<br> &#125;<br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testWorld</span>(<span class="hljs-params"></span>) &#123;<br> hw.<span class="hljs-title function_">sayWorld</span>();<br> &#125;<br> <br> <span class="hljs-meta">@Test</span><br> <span class="hljs-comment">// 2.测试有返回值的方法</span><br> <span class="hljs-comment">// 返回字符串</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testSay</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">assertEquals</span>(<span class="hljs-string">&quot;测试失败&quot;</span>, hw.<span class="hljs-title function_">say</span>(), <span class="hljs-string">&quot;hello world!&quot;</span>);<br> &#125;<br> <br> <span class="hljs-meta">@Test</span><br> <span class="hljs-comment">// 返回对象</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testObj</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">assertNull</span>(<span class="hljs-string">&quot;测试对象不为空&quot;</span>, <span class="hljs-literal">null</span>);<br> <span class="hljs-title function_">assertNotNull</span>(<span class="hljs-string">&quot;测试对象为空&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>());<br> &#125;<br> <br> <span class="hljs-meta">@After</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">tearDown</span>() throws <span class="hljs-title class_">Exception</span> &#123;<br> hw = <span class="hljs-literal">null</span>;<br> &#125;<br> <br>&#125;<br>------<br>著作权归<span class="hljs-meta">@pdai</span>所有<br>原文链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//pdai.tech/md/java/basic/java-basic-x-annotation.html</span><br></code></pre></td></tr></table></figure><p>JUnit4源码分析运行原理</p><p><a href="https://blog.csdn.net/weixin_34043301/article/details/91799261">https://blog.csdn.net/weixin_34043301/article/details/91799261</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java刷题0-20</title>
    <link href="/2024/10/27/%E5%88%B7%E9%A2%98/java/java/"/>
    <url>/2024/10/27/%E5%88%B7%E9%A2%98/java/java/</url>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h4 id="1-20"><a href="#1-20" class="headerlink" title="1-20"></a>1-20</h4><ol><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241021103807715.png" alt="image-20241021103807715"></p><p>HashMap</p><blockquote><p><code>HashMap 首先根据 hashCode 来查找存储桶，但如果两个对象的 hashCode 相同，HashMap</code> 会进一步调用 <code>equals()</code> 方法来判断它们是否真的相等。因此，尽管两个对象的 <code>hashCode</code> 相同，但如果 <code>equals()</code> 返回 <code>false</code>，它们还是会被认为是不同的 key，并可能对应不同的值。</p></blockquote><blockquote><p><code>hashCode()</code> 相同的对象不一定是相等的对象，<code>hashCode()</code> 相同只能保证它们在哈希表中可能被分配到相同的桶中，但不能保证它们是相等的。只有当 <code>equals()</code> 返回 <code>true</code> 时，两个对象才被认为是相等的。</p></blockquote><blockquote><p>哈希冲突（即不同对象生成相同的 <code>hashCode</code>）是允许的，并且在某些情况下不可避免。因此，不需要每个对象的 <code>hashCode</code> 都唯一，关键是 <code>equals()</code> 方法要正确工作来判断对象的实际相等性。</p></blockquote><blockquote><p> <code>hashCode()</code> 和 <code>equals()</code> 的基本约定之一。Java 中的约定是：如果两个对象通过 <code>equals()</code> 被认为是相等的，那么它们的 <code>hashCode</code> 必须相同。</p></blockquote><ol start="2"><li></li></ol><blockquote><p>下列说法错误的有（ a c  d） </p><p>A 在类方法中可用this来调用本类的类方法</p><p> B 在类方法中调用本类的类方法时可直接调用</p><p> C 在类方法中只能调用本类中的类方法</p><p>D 在类方法中绝对不能调用实例方法 </p></blockquote><blockquote><p><code>this</code> 是用来引用当前对象的，只有在实例方法中才能使用。类方法（<code>static</code> 方法）是属于类的，而不是某个对象的，因此在类方法中不能使用 <code>this</code>。</p></blockquote><blockquote><p>类方法不能直接调用实例方法，因为实例方法需要通过具体的对象来调用，而类方法没有绑定到任何对象。</p></blockquote><blockquote><p>虽然类方法（<code>static</code> 方法）不能直接调用实例方法，但并不意味着类方法完全无法调用实例方法。如果类方法中创建了该类的实例对象，通过该对象是可以调用实例方法的。因此，这一说法并不完全正确。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">instanceMethod</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;这是实例方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">classMethod</span>()</span> &#123;<br>        MyClass obj = <span class="hljs-keyword">new</span> MyClass();  <span class="hljs-comment">// 创建对象</span><br>        obj.instanceMethod();  <span class="hljs-comment">// 通过对象调用实例方法</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li></li></ol><p>下面的程序会打印什么结果（）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestIncr</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span> args[])</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        i = i++ + i;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;I =&quot;</span> +i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逆天后置</p><ol start="4"><li></li></ol><p>标识符不合法</p><p>C语言里标识符分为三类：关键字、预定义标识符、用户定义标识符 。</p><blockquote><p>由字母（A-Z、a-z）、数字（0-9）、下划线（“_”）组成，并且首字符不能是数字。</p><p>java中规定只能使用数字 ，字母 ，美元符号， 下划线作为标识符。     </p><p>不能重复。所以关键字、预定义标识符不能作为用户标识符。<br>允许的长度是由具体的编译器决定。<br>区分大小写。<br>不推荐用双下划线开头因为预定义标识符一般用双下划线开头。关键字你能背下来但是预定义标识符没人会去背。万一重了不好办。</p></blockquote><ol start="5"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241021105426407.png" alt="image-20241021105426407"></p><p><strong>通过子类对父类方法的覆盖（Override）实现多态</strong>：这是最常见的形式。当子类重写（覆盖）父类中的方法时，通过父类的引用调用子类的方法，就体现了多态性。选项 <strong>A</strong> 是正确的。</p><p><strong>利用重载（Overload）来实现多态</strong>：在同一个类中定义多个同名但参数不同的方法，也可以被认为是一种多态形式，虽然与覆盖的多态不同。这是编译时多态的一种形式。选项 <strong>B</strong> 是正确的。</p><p><strong>D</strong>：错误，子类无法通过重载父类的方法实现多态，重载是在同一个类中进行的。</p><ol start="6"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022111220950.png" alt="image-20241022111220950"></p><p>得复习复习</p><ol start="7"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022112221889.png" alt="image-20241022112221889"></p><p>需要复习jvm了</p><p>8.<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022112406654.png" alt="image-20241022112406654"></p><p>忘记了</p><p>答案B</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/242025553_1554208710443_D38DDD45D9F37641D8A1175FB792B313" alt="img"></p><ol start="9"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022112824965.png" alt="image-20241022112824965"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/140047_1447376765880_373DC390B08E99ABC340DB1F78F35FCB" alt="img"></p><ol start="10"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022113003868.png" alt="image-20241022113003868"></p><p>网络编程需要学习 c</p><blockquote><p><code>HttpServletResponse</code> 接口的主要功能是处理向客户端发送响应，它负责设置 HTTP 头标、设置 cookie、输出返回数据等。而读取路径信息属于 <code>HttpServletRequest</code> 的职责，它负责从客户端请求中获取相关的信息，包括路径、请求参数等。</p></blockquote><ol start="11"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022113053522.png" alt="image-20241022113053522"></p><p>忘记了</p><blockquote><p><strong>复制算法</strong>是一种将内存空间分为两部分，每次只使用其中一部分，当这一部分的内存用完时，将存活的对象复制到另一部分，接着清空已使用的部分。复制算法通常用于新生代的垃圾回收，因为新生代中的对象通常生命周期较短，存活对象较少，复制开销较小。</p><p><strong>A. 新生代串行收集器</strong></p><ul><li>新生代串行收集器（Serial Collector）使用的是<strong>复制算法</strong>，因为它只作用于新生代，典型的垃圾回收算法是复制算法。</li></ul><p><strong>D. 新生代并行回收收集器</strong></p><ul><li>新生代并行回收收集器（Parallel Scavenge）也作用于新生代，同样使用的是<strong>复制算法</strong>，目的是通过并行回收提高效率。</li></ul><p>其他选项：</p><ul><li><strong>B. 老年代串行收集器</strong>：老年代通常使用的是标记-整理（Mark-Compact）算法。</li><li><strong>C. 并行收集器</strong>：并行收集器是一个广义的术语，具体算法要看是否针对新生代或老年代，若是新生代部分会使用复制算法。</li><li><strong>E. 老年代并行回收收集器</strong>：老年代的并行收集器一般使用的是标记-整理（Mark-Compact）或标记-清除（Mark-Sweep）算法，而非复制算法。</li></ul></blockquote><ol start="12"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022113113449.png" alt="image-20241022113113449"></p><p>不知道需不需要学习 acd</p><ol start="13"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022113312190.png" alt="image-20241022113312190"></p><p>14</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022113457551.png" alt="image-20241022113457551"></p><p>对线程状态的熟悉</p><p><code>start()</code> 方法的执行结束仅表示线程的启动过程完成，线程本身仍在运行中，不会导致线程销毁。</p><p>当 <code>run()</code> 方法执行结束时，线程的生命周期就结束了，此时线程将被标记为“死亡”，可以被垃圾回收。因此，这个事件会导致线程销毁。</p><ol start="15"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022113607663.png" alt="image-20241022113607663"></p><p>考的很细致</p><blockquote><p>在 Java 中，抽象类中的抽象方法的默认访问权限并不是 <code>public</code>，而是包私有（default），即没有显式指定访问修饰符时，这些方法的访问权限是包内可见的。如果需要将抽象方法设为 <code>public</code>，需要明确使用 <code>public</code> 修饰符。</p></blockquote><blockquote><p>关于访问权限的说法，分析如下：</p><p> 在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。 </p></blockquote><p>成员内部类</p><p><strong>特性：</strong></p><ul><li><p>（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）； </p></li><li><p>成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；</p></li><li><p>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问； </p></li><li><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象； </p></li><li><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。<strong>外部类只能被public和包访问两种权限修饰。</strong></p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> outerField = <span class="hljs-string">&quot;外部类字段&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> staticOuterField = <span class="hljs-string">&quot;外部类静态字段&quot;</span>;<br><br>    <span class="hljs-comment">// 成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> innerField = <span class="hljs-string">&quot;内部类字段&quot;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;访问外部类字段: &quot;</span> + outerField);<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;访问外部类静态字段: &quot;</span> + staticOuterField);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">accessOuterMembers</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">// 访问外部类同名成员变量</span><br>            <span class="hljs-title class_">String</span> outerField = <span class="hljs-string">&quot;内部类字段遮蔽外部类字段&quot;</span>;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;内部类字段: &quot;</span> + innerField);<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;外部类字段: &quot;</span> + <span class="hljs-title class_">OuterClass</span>.<span class="hljs-property">this</span>.<span class="hljs-property">outerField</span>); <span class="hljs-comment">// 访问外部类字段</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">createInnerClass</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">InnerClass</span> inner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>();<br>        inner.<span class="hljs-title function_">display</span>();<br>        inner.<span class="hljs-title function_">accessOuterMembers</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">OuterClass</span> outer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>();<br>        outer.<span class="hljs-title function_">createInnerClass</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>局部内部类</li></ol><p><strong>特性：</strong></p><ul><li><p>（1）局部内部类是定义在一个方法或者一个作用域里面的类，<strong>它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；</strong> </p><p>  （2）局部内部类就像是方法里面的一个局部变量一样，<strong>是不能有public、protected、private以及static修饰符的。</strong> </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> outerMethod() &#123;<br>        <span class="hljs-keyword">final</span> String message = <span class="hljs-string">&quot;Hello from局部内部类&quot;</span>;<br><br>        <span class="hljs-comment">// 局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalInnerClass</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">display</span>() &#123;<br>                System.out.println(message);<br>            &#125;<br>        &#125;<br><br>        LocalInnerClass localInner = <span class="hljs-keyword">new</span> LocalInnerClass();<br>        localInner.<span class="hljs-keyword">display</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        OuterClass <span class="hljs-keyword">outer</span> = <span class="hljs-keyword">new</span> OuterClass();<br>        <span class="hljs-keyword">outer</span>.outerMethod();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>3.匿名内部类 </p><p>（1）一般使用匿名内部类的方法来编写事件监听代码； </p><p>（2）匿名内部类是不能有访问修饰符和static修饰符的； </p><p>（3）匿名内部类是唯一一种没有构造器的类； </p><p>（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-comment">// 创建匿名内部类实现 Runnable 接口</span><br>        <span class="hljs-title class_">Runnable</span> runnable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;这是匿名内部类的方法&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 使用线程执行匿名类</span><br>        <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>        thread.<span class="hljs-title function_">start</span>(); <span class="hljs-comment">// 输出: 这是匿名内部类的方法</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>  4.内部静态类 </p><p>  （1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似； </p><p>  （2）不能使用外部类的非static成员变量或者方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> staticOuterField = <span class="hljs-string">&quot;外部类静态字段&quot;</span>;<br><br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInnerClass</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;访问外部类静态字段: &quot;</span> + staticOuterField);<br>            <span class="hljs-comment">// 不能访问外部类的非静态成员</span><br>            <span class="hljs-comment">// System.out.println(&quot;访问外部类非静态字段: &quot; + outerField); // 这行会导致错误</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">OuterClass</span>.<span class="hljs-property">StaticInnerClass</span> staticInner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>.<span class="hljs-title class_">StaticInnerClass</span>();<br>        staticInner.<span class="hljs-title function_">display</span>(); <span class="hljs-comment">// 输出: 访问外部类静态字段: 外部类静态字段</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>16</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022114730847.png" alt="image-20241022114730847"></p><p>考验方法的重写-重载</p><p><strong>注意：</strong></p><ol><li>方法的重写要求方法签名必须一致，包括方法名称、参数列表、返回类型（可以是协变类型，即子类返回类型）。</li><li>Java 支持协变返回类型，即子类的重写方法可以返回比父类方法更具体的类型。</li></ol><p>这是一个有效的方法，因为参数列表和父类方法的不同，这并不算是重写，而是方法的重载。因此，编译可以成功。</p><ol start="17"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022114925535.png" alt="image-20241022114925535"></p><p><code>abstract class</code>（抽象类）和 <code>interface</code>（接口）之间存在以下几个重要的区别。分析各个选项：</p><p>抽象类可以有构造方法，虽然它不能被直接实例化，但其子类可以通过构造方法调用。接口不能有构造方法，因为接口本身不能被实例化。</p><p>抽象类可以包含普通的成员变量，而在 Java 1.8 之前，接口只能包含 <code>public static final</code> 常量，即只能有静态常量，不能有普通的成员变量。</p><p>在 Java 1.8 之前，接口中不能包含静态方法，静态方法是在 Java 1.8 引入的特性。而抽象类是可以包含静态方法的。</p><p>Java 中的类可以实现多个接口，但由于 Java 是单继承的，一个类只能继承一个抽象类。</p><p>18</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022115153487.png" alt="image-20241022115153487"></p><p>得仔细学习 java和cpp记混了-其实也不重要。。。</p><p>19</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022115239995.png" alt="image-20241022115239995"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20210312080851.png" alt="img">c</p><p>抽时间学呗</p><h4 id="20-40"><a href="#20-40" class="headerlink" title="20-40"></a>20-40</h4><p>20</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024141014992.png" alt="image-20241024141014992"></p><p>21</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024141212311.png" alt="image-20241024141212311"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String outerField = <span class="hljs-string">&quot;Outer Class Field&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String staticOuterField = <span class="hljs-string">&quot;Static Outer Class Field&quot;</span>;<br><br>    <span class="hljs-comment">// 非静态内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessOuterFields</span>()</span> &#123;<br>            <span class="hljs-comment">// 可以访问外部类的非静态字段</span><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Accessing non-static outer field: &quot;</span> + outerField);<br>            <span class="hljs-comment">// 也可以访问外部类的静态字段</span><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Accessing static outer field: &quot;</span> + staticOuterField);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessOuterFields</span>()</span> &#123;<br>            <span class="hljs-comment">// 静态内部类不能访问外部类的非静态字段</span><br>            <span class="hljs-comment">// System.out.println(outerField); // 编译错误</span><br><br>            <span class="hljs-comment">// 但是可以访问外部类的静态字段</span><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Accessing static outer field: &quot;</span> + staticOuterField);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 创建外部类实例</span><br>        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();<br><br>        <span class="hljs-comment">// 创建非静态内部类实例</span><br>        InnerClass inner = outer.<span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">InnerClass</span>()</span>;<br>        inner.accessOuterFields(); <span class="hljs-comment">// 访问外部类的成员</span><br><br>        <span class="hljs-comment">// 创建静态内部类实例</span><br>        StaticInnerClass staticInner = <span class="hljs-keyword">new</span> StaticInnerClass();<br>        staticInner.accessOuterFields(); <span class="hljs-comment">// 只能访问外部类的静态成员</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>静态内部类不能直接访问外围类的非静态成员，因为静态内部类与外围类的实例没有直接联系。而非静态内部类可以直接访问外围类的所有成员，包括私有成员，因为非静态内部类持有外围类的实例引用，可以通过这个引用来访问外围类的成员。</p></blockquote><p>22</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024141424102.png" alt="image-20241024141424102"></p><blockquote><p><strong>A. abstract 可以与 final 并列修饰同一个类</strong>：错误。<code>abstract</code> 类是允许被继承的，而 <code>final</code> 类是不能被继承的，因此它们是矛盾的，不能同时修饰一个类。</p><p><strong>B. abstract 类中不可以有 private 的成员</strong>：错误。<code>abstract</code> 类中是可以有 <code>private</code> 的成员变量或方法的。<code>abstract</code> 类只要求至少有一个抽象方法，但它也可以包含具体方法和私有成员。</p><p><strong>C. abstract 类中必须全部是 abstract 方法</strong>：错误。<code>abstract</code> 类中可以包含具体实现的方法，不要求所有方法都必须是抽象的。抽象类中可以有抽象方法和具体方法的混合。</p><p><strong>D. abstract 方法必须在 abstract 类或接口中</strong>：正确。<code>abstract</code> 方法必须在 <code>abstract</code> 类或接口中定义，普通类中不能有抽象方法。</p></blockquote><p><code>final</code> 关键字可以修饰类、方法和变量，在不同的上下文中有不同的含义：</p><blockquote><p><code>final</code> 修饰<strong>类</strong>时，类不可被继承；</p><p><code>final</code> 修饰<strong>方法</strong>时，方法不可被重写；</p><p><code>final</code> 修饰<strong>变量</strong>时，变量只能被赋值一次，不能被修改。</p></blockquote><ol start="23"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024141749553.png" alt="image-20241024141749553"></p><blockquote><p><strong>A. 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的</strong>：</p><ul><li>正确。程序计数器是每个线程独有的，线程切换时可以通过程序计数器恢复到正确的执行位置。</li></ul><p><strong>B. 虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的</strong>：</p><ul><li>正确。Java 虚拟机栈是线程私有的，记录方法的调用信息，每个线程都有自己的虚拟机栈。</li></ul><p><strong>C. 方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程隔离的</strong>：</p><ul><li>错误。<strong>方法区是线程共享的内存区域</strong>，所有线程都可以访问其中的数据。它存储的是 JVM 加载的类信息、常量、静态变量和编译后的代码。</li></ul><p><strong>D. 原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的</strong>：</p><ul><li>正确。堆区是 JVM 中用于存储对象实例的内存区域，线程之间共享的。</li></ul></blockquote><ol start="24"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024141912766.png" alt="image-20241024141912766"></p><blockquote><blockquote><p>使用字符串常量给String变量赋值，这个字符串常量会被存进内存的常量池里面，供整个程序使用，所以s1和s2实际是引用了同一个字符串对象，地址相同，</p><p>而new出来的是在存在堆内存中，单独的一份，所以s3和另外两个地址不同</p></blockquote></blockquote><p>jvm没复习，忘记了</p><ol start="25"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241103115901179.png" alt="image-20241103115901179"></p><p>26</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241103120620496.png" alt="image-20241103120620478"></p><p>27</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241103121011985.png" alt="image-20241103121011965"></p><p>28</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105165251407.png" alt="image-20241105165251407"></p><ol><li><strong>选项 A</strong>: <code>class InnerClass&#123; public static float func()&#123;return f;&#125; &#125;</code><ul><li>错误：<code>f</code> 是 <code>OuterClass</code> 的实例字段，在 <code>InnerClass</code> 中直接引用时，会因为 <code>func</code> 是静态方法而导致编译错误。静态方法无法直接访问非静态成员。</li></ul></li><li><strong>选项 B</strong>: <code>abstract class InnerClass&#123; public abstract float func()&#123;&#125; &#125;</code><ul><li>错误：<code>func()</code> 是一个抽象方法，但方法体（<code>&#123;&#125;</code>）是不合法的，因为抽象方法不能有实现。应该去掉方法体。</li></ul></li><li><strong>选项 C</strong>: <code>static class InnerClass&#123; protected static float func()&#123;return f;&#125; &#125;</code><ul><li>错误：<code>f</code> 是实例字段，而 <code>func()</code> 是静态方法。静态方法无法访问实例字段 <code>f</code>，因此这段代码会报错。</li></ul></li><li><strong>选项 D</strong>: <code>public class InnerClass&#123; static float func()&#123;return f;&#125; &#125;</code><ul><li>错误：同样，<code>f</code> 是实例字段，而 <code>func()</code> 是静态方法。静态方法不能直接访问实例字段 <code>f</code>，这段代码也会报错。</li></ul></li></ol><p>总结：所有选项都有问题，原因基本都是静态方法无法访问实例字段 <code>f</code>。</p><p>静态类不能访问实例字段-接口不能有方法体</p><p>29</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105165642936.png" alt="image-20241105165642936"></p><blockquote><p><strong>. Hashtable允许null值作为key和value，而HashMap不可以</strong> —— 这是错误的。实际上，<code>HashMap</code> 允许 <code>null</code> 作为 <code>key</code> 和 <code>value</code>，而 <code>Hashtable</code> <strong>不允许</strong> <code>null</code> 作为 <code>key</code> 或 <code>value</code>。尝试在 <code>Hashtable</code> 中插入 <code>null</code> 会抛出 <code>NullPointerException</code>。</p><p>其他选项分析：</p><ul><li><strong>A. 两者都是用key-value方式获取数据</strong>：这是真的。<code>HashMap</code> 和 <code>Hashtable</code> 都是基于哈希表实现的，存储数据的方式是 <code>key-value</code> 对。</li><li><strong>C. HashMap不是同步的，而Hashtable是同步的</strong>：这也是真的。<code>HashMap</code> 是非同步的，因此不适合多线程环境；而 <code>Hashtable</code> 是同步的，适用于多线程环境。</li><li><strong>D. 迭代HashMap采用快速迭代机制，而Hashtable不是</strong>：这也是真的。<code>HashMap</code> 在迭代时采用了快速迭代机制（fail-fast），在迭代过程中，如果发生了结构变化（如插入或删除元素），会抛出 <code>ConcurrentModificationException</code>。而 <code>Hashtable</code> 没有这种机制。</li></ul></blockquote><p>30</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105165903628.png" alt="image-20241105165903628"></p><p>在序列化时，<code>word</code> 会被序列化到文件中，因为它是实例变量。而静态变量 <code>i</code> 不会被序列化，因为静态变量属于类，而不属于某个实例。所以，反序列化时，<code>i</code> 的值将恢复为它的默认值 <code>0</code>。</p><p><code>word</code> 在序列化时被写入文件，因此反序列化时它会被恢复为 <code>&quot;123&quot;</code>。</p><p><code>i</code> 是静态变量，在序列化和反序列化过程中不会被存储，因此在反序列化时它会保持其类的默认值 <code>0</code>。</p><p>31</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105170034955.png" alt="image-20241105170034955"></p><blockquote><p>  A.StringBuilder线程不安全，StringBuffer线程安全。 </p><p>  B.同时用 abstract和final就会自相矛盾。 </p><p>  C.Hashmap中的value可以之null，get(key)&#x3D;&#x3D;null有两种情况，一是key不存在，二是该key中存的是null，所以应该使用map.containskey(key)返回的true&#x2F;false来判断是否存在这个key。 </p><p>  D.volatile关键字有两个作用： </p><p>  1.并发环境可见性：volatile修饰后的变量能够保证该变量在线程间的可见性，线程进行数据的读写操作时将绕开工作内存（CPU缓存）而直接跟主内存进行数据交互，即线程进行读操作时直接从主内存中读取，写操作时直接将修改后端变量刷新到主内存中，这样就能保证其他线程访问到的数据是最新数据 </p><p>  2.并发环境有序性：通过对volatile变量采取内存屏障（Memory barrier）的方式来防止编译重排序和CPU指令重排序，具体方式是通过在操作volatile变量的指令前后加入内存屏障，来实现happens-before关系，保证在多线程环境下的数据交互不会出现紊乱。</p></blockquote><p>32</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105170353952.png" alt="image-20241105170353952"></p><blockquote><ul><li>B 初始化块在构造器执行之前执行，类初始化阶段先执行最顶层父类的静态初始化块，依次向下执行，最后执行当前类的静态初始化块；创建对象时，先调用顶层父类的构造方法，依次向下执行，最后调用本类的构造方法。</li></ul></blockquote><p>33</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105170824625.png" alt="image-20241105170824625"></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>34</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241105170919349.png" alt="image-20241105170919349"></p><blockquote><p><strong>A. <code>float f[][] = new float[6][6];</code></strong></p><ul><li><strong>合法</strong>：这是创建一个二维数组的正确方式。这里 <code>f</code> 是一个二维浮点数组，数组的大小为 6 行 6 列。</li></ul><p><strong>B. <code>float []f[] = new float[6][6];</code></strong></p><ul><li><strong>合法</strong>：这种写法与选项 A 等价，虽然书写顺序不同，但效果相同。先声明 <code>f</code> 为一个二维数组，<code>new float[6][6]</code> 用于创建 6x6 的二维数组。</li></ul><p><strong>C. <code>float f[][] = new float[][6];</code></strong></p><ul><li><strong>不合法</strong>：这是不合法的语法。数组的第一个维度必须在声明时指定，而第二个维度可以在初始化时指定，不能只给第二个维度。</li></ul><p><strong>D. <code>float [][]f = new float[6][6];</code></strong></p><ul><li><strong>合法</strong>：这是另一种合法的写法，数组 <code>f</code> 被声明为二维数组并初始化为 6x6 的数组。这里，数组的声明和初始化方式是完全合法的。</li></ul><p><strong>E. <code>float [][]f = new float[6][];</code></strong></p><ul><li><strong>合法</strong>：这是合法的语法。你可以先指定一个维度（这里是 6），然后使用 <code>null</code> 来初始化第二个维度（即每一行的列数可以不同）。这</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java IO 1</title>
    <link href="/2024/10/26/java/javaIo/javaio2/"/>
    <url>/2024/10/26/java/javaIo/javaio2/</url>
    
    <content type="html"><![CDATA[<h1 id="InputStream源码-2"><a href="#InputStream源码-2" class="headerlink" title="InputStream源码(2)"></a>InputStream源码(2)</h1><h2 id="类实现关系"><a href="#类实现关系" class="headerlink" title="类实现关系"></a>类实现关系</h2><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/io-inputstream-1.png" alt="img"></p><h2 id="抽象类解读"><a href="#抽象类解读" class="headerlink" title="抽象类解读"></a>抽象类解读</h2><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b283d7953048cced732f0b45b346fa23.png" alt="b283d7953048cced732f0b45b346fa23"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(OutputStream out)</span><br></code></pre></td></tr></table></figure><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><h4 id="1-inputStream"><a href="#1-inputStream" class="headerlink" title="1.inputStream"></a>1.inputStream</h4><blockquote><p>梳理部分InputStream及其实现类的源码分析。</p></blockquote><p>源码解读-jdk8</p><p><a href="https://gitee.com/laomaodu/myinput-stream/blob/master/src/main/java/MyInputStream.java">https://gitee.com/laomaodu/myinput-stream/blob/master/src/main/java/MyInputStream.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Closeable;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> &#123;<br>    <span class="hljs-comment">// MAX_SKIP_BUFFER_SIZE 用于确定跳过时使用的最大缓冲区大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SKIP_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2048</span>;<br>    <span class="hljs-comment">// 默认的buffer size</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;<br>    <span class="hljs-comment">// JDK11中增加了一个nullInputStream，即空模式实现，以便可以直接调用而不用判空（可以看如下的补充说明）</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从输入流中读取下一个字节的数据。值作为范围为 0 到 255 的 int 返回。</span><br><span class="hljs-comment">     * 如果由于到达流的末尾而没有可用的字节，则返回 -1。</span><br><span class="hljs-comment">     * 此方法将阻塞，直到有输入数据可用、检测到流的末尾或引发异常。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; 子类必须提供此方法的实现。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回下一个字节数据，如果到达流末尾则返回 -1。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IOException 如果发生 I/O 错误。</span><br><span class="hljs-comment">     * 读取下一个字符数据，没有返回-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从输入流中读取若干字节并将其存储到缓冲区数组 b 中。</span><br><span class="hljs-comment">     * 返回读取的字节数。如果 b 的长度为 0，则不读取任何字节并返回 0。</span><br><span class="hljs-comment">     * 如果没有可用的字节，因为流到达文件的末尾，则返回 -1。</span><br><span class="hljs-comment">     * 否则，将至少读取一个字节并存储到 b 中。</span><br><span class="hljs-comment">     *将读取到的数据放在 byte 数组中，该方法实际上调用read(byte b[], int off, int len)方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> b 将数据读取到其中的缓冲区。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回读取到缓冲区的总字节数，如果到达流末尾则返回 -1。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IOException 如果由于任何原因第一个字节无法读取，流已关闭，或发生其他 I/O 错误。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> NullPointerException 如果 b 为 null。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从输入流中读取最多 len 个字节的数据到字节数组中。</span><br><span class="hljs-comment">     * 此方法将阻塞，直到有输入数据可用、检测到文件结束或引发异常。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> b 将数据读取到其中的缓冲区。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> off 在数组 b 中开始写入数据的偏移量。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> len 要读取的最大字节数。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回读取到缓冲区的总字节数，如果到达流末尾则返回 -1。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IOException 如果由于任何原因第一个字节无法读取，流已关闭，或发生其他 I/O 错误。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> NullPointerException 如果 b 为 null。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IndexOutOfBoundsException 如果 off 或 len 为负数，或 len 大于 b.length - off。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 检查边界</span><br>        <span class="hljs-comment">//Objects.checkFromIndexSize(off, len, b.length);</span><br>        <span class="hljs-comment">//读取最大字节数为0返回</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 读取下一个字节</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> read();<span class="hljs-comment">//</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里的设计可以提前判断流状态，提前返回，提高效率</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 读到stream末尾，则返回读取的字节数量为-1</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">///off 作为偏移量参数，指定了数据在数组 b 中的起始存储位置</span><br>        b[off] = (<span class="hljs-type">byte</span>)c;<span class="hljs-comment">// 将读取到的字节转换为byte类型，存入指定的数组位置b[off]</span><br><br>        <span class="hljs-comment">// i用来记录取了多少个字节</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 循环读取</span><br>            <span class="hljs-keyword">for</span> (; i &lt; len ; i++) &#123;<br>                c = read();<br>                <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 读到stream末尾，则break</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                b[off + i] = (<span class="hljs-type">byte</span>)c;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>        &#125;<br>        <span class="hljs-comment">// 返回读取到的字节个数</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 跳过并丢弃此输入流中的 n 个字节。</span><br><span class="hljs-comment">     * 该方法可能跳过更少的字节（甚至为 0），负数返回 0。返回实际跳过的字节数。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 要跳过的字节数。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 实际跳过的字节数。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IOException 如果流不支持跳过操作，或发生其他 I/O 错误。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 剩余要跳过的字节数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> n;<br><br>        <span class="hljs-type">int</span> nr;<br>        <span class="hljs-comment">// 如果请求跳过的字节数小于等于0，则直接返回0</span><br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 设置缓冲区大小，取最小值</span><br>        <span class="hljs-comment">// 使得最大不超过MAX_SKIP_BUFFER_SIZE，避免过大消耗内存</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);<br>        <span class="hljs-comment">// 用于跳过字节的缓冲区</span><br>        <span class="hljs-type">byte</span>[] skipBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>        <span class="hljs-comment">// 循环读取，直到跳过指定字节数或到达流末尾</span><br>        <span class="hljs-keyword">while</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 从流中读取最多size或remaining字节，读入skipBuffer，偏移量从0开始</span><br>            nr = read(skipBuffer, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)Math.min(size, remaining));<br>            <span class="hljs-comment">// 如果读取结果为负，表示流已结束，跳出循环</span><br>            <span class="hljs-keyword">if</span> (nr &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 更新剩余字节数</span><br>            remaining = remaining - nr;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回实际跳过的字节数（即总字节数n减去剩余字节数remaining）</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">假设 n = 15，MAX_SKIP_BUFFER_SIZE = 8，并且输入流中共有 10 个字节可供读取。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第一次循环：remaining = 15，缓冲区大小 size = 8。调用 read(skipBuffer, 0, 8)，假设读取 8 个字节，remaining 变为 15 - 8 = 7。</span><br><span class="hljs-comment">第二次循环：remaining = 7，缓冲区大小 size = 7。调用 read(skipBuffer, 0, 7)，假设读取了 2 个字节（流中只剩 2 个字节），remaining 变为 7 - 2 = 5。</span><br><span class="hljs-comment">第三次循环：remaining = 5，调用 read(skipBuffer, 0, 5)，此时返回 -1（流末尾），循环终止。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">也就是read读到了文件末尾了，你remaining都没读到n的大小-就有了实际跳过数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> n - remaining;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回在不阻塞的情况下可以从此输入流中读取的字节数的估计值。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 可读取（或跳过）字节数的估计值，当到达输入流末尾时为 0。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IOException 如果发生 I/O 错误。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭此输入流并释放与流关联的任何系统资源。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IOException 如果发生 I/O 错误。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 标记输入流中的当前位置。后续调用 reset 方法将重新定位此流。</span><br><span class="hljs-comment">     * mark 方法不进行任何操作。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> readlimit 在标记位置失效之前可以读取的最大字节数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将流重新定位到最后一次调用 mark 方法时的位置。</span><br><span class="hljs-comment">     * 此方法对 InputStream 类无效，仅抛出 IOException。</span><br><span class="hljs-comment">     *  标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span> IOException 如果未标记或标记已失效。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// 重置读取位置为上次 mark 标记的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;mark/reset not supported&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 判断当前流是否支持标记流，和上面两个方法配套使用。默认是false，由子类方法重写</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试此输入流是否支持 mark 和 reset 方法。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果此流实例支持 mark 和 reset 方法则返回 true；否则返回 false。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-jdk9更新"><a href="#2-jdk9更新" class="headerlink" title="2.jdk9更新"></a>2.jdk9更新</h4><h6 id="1-具体更新"><a href="#1-具体更新" class="headerlink" title="1.具体更新"></a>1.具体更新</h6><p>InputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK9新增：读取 InputStream 中的所有剩余字节，调用readNBytes(Integer.MAX_VALUE)方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] readAllBytes()<br><span class="hljs-comment">// JDK11更新：读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] readNBytes(<span class="hljs-type">int</span> len)<br><br><span class="hljs-comment">// JDK9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readNBytes</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span><br><br><span class="hljs-comment">// JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(OutputStream out)</span><br>    <br>   注<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A constant holding the maximum value an &#123;<span class="hljs-doctag">@code</span> int&#125; can</span><br><span class="hljs-comment">     * have, 2&lt;sup&gt;31&lt;/sup&gt;-1.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Native</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>   <span class="hljs-variable">MAX_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x7fffffff</span>;<br>    <br></code></pre></td></tr></table></figure><h6 id="2-空模式"><a href="#2-空模式" class="headerlink" title="2.空模式"></a>2.空模式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK11中增加了一个nullInputStream，即空模式实现，以便可以直接调用而不用判空（可以看如下的补充说明）</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputStream <span class="hljs-title function_">nullInputStream</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStream</span>() &#123;<br>           <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> closed;<br><br>           <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureOpen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               <span class="hljs-keyword">if</span> (closed) &#123;<br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Stream closed&quot;</span>);<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               Objects.checkFromIndexSize(off, len, b.length);<br>               <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>               &#125;<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] readAllBytes() <span class="hljs-keyword">throws</span> IOException &#123;<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readNBytes</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span><br>               <span class="hljs-keyword">throws</span> IOException &#123;<br>               Objects.checkFromIndexSize(off, len, b.length);<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] readNBytes(<span class="hljs-type">int</span> len) <span class="hljs-keyword">throws</span> IOException &#123;<br>               <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;len &lt; 0&quot;</span>);<br>               &#125;<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               Objects.requireNonNull(out);<br>               ensureOpen();<br>               <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>;<br>           &#125;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>               closed = <span class="hljs-literal">true</span>;<br>           &#125;<br>       &#125;;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-读取所有字节"><a href="#3-读取所有字节" class="headerlink" title="3.读取所有字节"></a>3.读取所有字节</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 分配的最大数组大小。</span><br>   <span class="hljs-comment">// 由于一些VM在数组中保留一些头字，所以尝试分配较大的阵列可能会导致OutOfMemoryError（请求的阵列大小超过VM限制）</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_BUFFER_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK9新增：读取 InputStream 中的所有剩余字节，调用readNBytes(Integer.MAX_VALUE)方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] readAllBytes() <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-keyword">return</span> readNBytes(Integer.MAX_VALUE);<br>   &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK11更新：读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] readNBytes(<span class="hljs-type">int</span> len) <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">// 边界检查</span><br>      <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;len &lt; 0&quot;</span>);<br>      &#125;<br><br>      List&lt;<span class="hljs-type">byte</span>[]&gt; bufs = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 缓存每次读取到的内容放到bufs，最后组装成result</span><br>      <span class="hljs-type">byte</span>[] result = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 最后读取到的内容</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> len; <span class="hljs-comment">// 剩余字节长度</span><br>      <span class="hljs-type">int</span> n;<br>      <span class="hljs-keyword">do</span> &#123;<br>          <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[Math.min(remaining, DEFAULT_BUFFER_SIZE)];<br>          <span class="hljs-type">int</span> <span class="hljs-variable">nread</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>          <span class="hljs-comment">// 读取到结束为止，读取大小n可能大于或小于缓冲区大小</span><br>          <span class="hljs-keyword">while</span> ((n = read(buf, nread,<br>                  Math.min(buf.length - nread, remaining))) &gt; <span class="hljs-number">0</span>) &#123;<br>              nread += n; <br>              remaining -= n;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (nread &gt; <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">if</span> (MAX_BUFFER_SIZE - total &lt; nread) &#123;<br>                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>(<span class="hljs-string">&quot;Required array size too large&quot;</span>);<br>              &#125;<br>              total += nread;<br>              <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>                  result = buf;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-keyword">if</span> (bufs == <span class="hljs-literal">null</span>) &#123;<br>                      bufs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                      bufs.add(result);<br>                  &#125;<br>                  bufs.add(buf);<br>              &#125;<br>          &#125;<br>          <span class="hljs-comment">// 如果读不到内容（返回-1）或者没有剩余的字节，则跳出循环</span><br>      &#125; <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">0</span> &amp;&amp; remaining &gt; <span class="hljs-number">0</span>);<br><br>      <span class="hljs-keyword">if</span> (bufs == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>          &#125;<br>          <span class="hljs-keyword">return</span> result.length == total ?<br>              result : Arrays.copyOf(result, total);<br>      &#125;<br><br>      <span class="hljs-comment">// 组装最后的result</span><br>      result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[total];<br>      <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      remaining = total;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span>[] b : bufs) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> Math.min(b.length, remaining);<br>          System.arraycopy(b, <span class="hljs-number">0</span>, result, offset, count);<br>          offset += count;<br>          remaining -= count;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-阻塞读取字节保存数组"><a href="#3-阻塞读取字节保存数组" class="headerlink" title="3.阻塞读取字节保存数组"></a>3.阻塞读取字节保存数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readNBytes</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    Objects.checkFromIndexSize(off, len, b.length);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &lt; len) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> read(b, off + n, len - n);<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        n += count;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-inputstream到outputstream"><a href="#4-inputstream到outputstream" class="headerlink" title="4.inputstream到outputstream"></a>4.inputstream到outputstream</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Objects.requireNonNull(out, <span class="hljs-string">&quot;out&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">transferred</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[DEFAULT_BUFFER_SIZE];<br>        <span class="hljs-type">int</span> read;<br>        <span class="hljs-keyword">while</span> ((read = <span class="hljs-built_in">this</span>.read(buffer, <span class="hljs-number">0</span>, DEFAULT_BUFFER_SIZE)) &gt;= <span class="hljs-number">0</span>) &#123;<br>            out.write(buffer, <span class="hljs-number">0</span>, read);<br>            transferred += read;<br>        &#125;<br>        <span class="hljs-keyword">return</span> transferred;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241026110518661.png" alt="image-20241026110518661"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInputStream</span> &#123;<br>    <span class="hljs-keyword">private</span> InputStream inputStream;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONTENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">this</span>.inputStream =<br>            TestInputStream.class.getResourceAsStream(<span class="hljs-string">&quot;/input.txt&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReadAllBytes</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-built_in">this</span>.inputStream.readAllBytes());<br>        <span class="hljs-comment">//assertEquals 方法验证读取的内容是否与 CONTENT 相等。</span><br>        assertEquals(CONTENT, content);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReadNBytes</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">this</span>.inputStream.readNBytes(data, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        assertEquals(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTransferTo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-built_in">this</span>.inputStream.transferTo(outputStream);<br>        assertEquals(CONTENT, outputStream.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过三种方法验证 <code>InputStream</code> 的读取功能，确保能够正确读取数据并处理流操作。每个测试方法都使用 <code>assertEquals</code> 进行断言，确保期望值与实际值一致。</p><h6 id="6-read-readnbytes探究"><a href="#6-read-readnbytes探究" class="headerlink" title="6.read readnbytes探究"></a>6.read readnbytes探究</h6><p>在java中，<code>InputStream</code>类有方法<code>read(byte[], int, int)</code>和<code>readNBytes(byte[], int, int)</code>。看起来这两个方法具有完全相同的功能，所以我想知道它们之间有什么区别。</p><blockquote><ul><li><code>read()</code>表示它尝试读取*“最多<code>len</code>字节…<strong>但可能读取较少的数字</strong>。此方法会阻塞，直到输入数据可用、检测到文件末尾或引发异常。”*</li><li><code>readNBytes()</code>说<em>“阻塞直到<code>len</code>读取输入数据的字节，检测到流的末尾，或者抛出异常。”</em></li></ul><p>尽管<em>JDK 的实现</em>可能会为<code>InputStream</code>这两种方法提供相同的结果，但记录的差异意味着从它继承的其他类可能会表现不同。</p><p>例如，给定流<code>&#39;12345&lt;end&gt;&#39;</code>，<code>read(s,0,10)</code>允许返回<code>&#39;123&#39;</code>，而<code>readNbytes()</code>更有可能继续寻找流的末尾并提供整个内容。</p></blockquote><p>举个例子：如果文本内容是<code>12345&lt;end&gt;</code>, read(s,0,10)是允许返回<code>123</code>的, 而readNbytes(s,0,10)会一直（while循环）查找直到stream尾为止，并返回<code>12345</code>.</p><hr><h6 id="7-空对空模式"><a href="#7-空对空模式" class="headerlink" title="7.空对空模式"></a>7.空对空模式</h6><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyParser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parser</span> &#123;<br>  <span class="hljs-comment">// 创建一个空对象，代表“无操作”</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Action</span> <span class="hljs-variable">NO_ACTION</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Action</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* do nothing */</span> &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 根据用户输入查找动作</span><br>  <span class="hljs-keyword">public</span> Action <span class="hljs-title function_">findAction</span><span class="hljs-params">(String userInput)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-comment">/* we can&#x27;t find any actions */</span> ) &#123;<br>      <span class="hljs-keyword">return</span> NO_ACTION; <span class="hljs-comment">// 如果找不到任何动作，返回空对象</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后便可以始终可以这么调用，而不用再判断空了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ParserFactory.getParser().findAction(someInput).doSomething();<br></code></pre></td></tr></table></figure><blockquote><p>在这里，调用者不需要检查返回的 <code>Action</code> 是否为 <code>null</code>。无论如何，调用 <code>doSomething</code> 方法都不会引发 <code>NullPointerException</code>。如果找到了有效的动作，则执行相应的操作；如果没有找到动作，则 <code>doSomething</code> 什么都不做。</p></blockquote><h4 id="3-输入输出缓冲区"><a href="#3-输入输出缓冲区" class="headerlink" title="3.输入输出缓冲区"></a>3.输入输出缓冲区</h4><p>如同管道一样</p><blockquote><p>在 Java 的输入输出流实现中，<strong>缓冲区</strong>用于在读取和写入数据时提供临时存储，以提高数据传输的效率。<code>skip</code> 方法的设计通过缓冲区实现对输入流字节的跳过，但并不会将这些字节存储在主程序的实际变量中。</p></blockquote><blockquote><p><strong>输入缓冲区</strong>：这是指从外部数据源（如文件或网络）读取数据时使用的临时存储区域。读取数据时，输入流会将数据批量加载到缓冲区中，而不是逐字节加载，优化了读取速度。</p><p><strong>输出缓冲区</strong>：在输出数据（如写入文件或网络）时，数据首先会被存储到缓冲区，然后批量写入目标输出。</p></blockquote><blockquote><p>在 <code>skip</code> 方法中，<code>skipBuffer</code> 充当了一个 <strong>临时输入缓冲区</strong>，用于存放读取到的字节。这些字节不是直接存储到主程序的内存，而是立即舍弃，从而实现“跳过”的效果。</p></blockquote><p>为什么需要缓冲区</p><blockquote><p><strong>提高效率</strong>：<code>skip</code> 方法不能直接跳过任意数量的字节，尤其是流类型不支持随意定位的情况下。比如在网络流中，不支持直接定位到某个字节位置，因此必须通过逐个读取字节的方式跳过。</p><p><strong>批量读取减少 I&#x2F;O 操作</strong>：<code>skipBuffer</code> 的存在使得方法可以批量读取指定字节数，而不是逐字节读取。相比逐字节读取，这种方式减少了 I&#x2F;O 操作的次数，提升了性能。</p></blockquote><h4 id="4-FilterInputStream"><a href="#4-FilterInputStream" class="headerlink" title="4.FilterInputStream"></a>4.FilterInputStream</h4><p>FilterInputStream 源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <br>    <span class="hljs-comment">// 被装饰的inputStream</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br>    <br>    <span class="hljs-comment">// 构造函数，注入被装饰的inputStream</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br><br>    <span class="hljs-comment">// 本质是调用被装饰的inputStream的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.read();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>     &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.read(b, off, len);<br>     &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.skip(n);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> in.available();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        in.close();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;<br>        in.mark(readlimit);<br>     &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        in.reset();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> in.markSupported();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="5-ByteArrayInputStream"><a href="#5-ByteArrayInputStream" class="headerlink" title="5.ByteArrayInputStream"></a>5.ByteArrayInputStream</h4><p>ByteArrayInputStream源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteArrayInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <br>    <span class="hljs-comment">// 内部保存的byte 数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span> buf[];<br>    <br>    <span class="hljs-comment">// 读取下一个字节的数组下标，byte[pos]就是read获取的下个字节</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> pos;<br>    <br>    <span class="hljs-comment">// mark的数组下标位置</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 保存的有效byte的个数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ByteArrayInputStream</span><span class="hljs-params">(<span class="hljs-type">byte</span> buf[])</span> &#123;<br>        <span class="hljs-built_in">this</span>.buf = buf;              <br>        <span class="hljs-built_in">this</span>.pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.count = buf.length;<br>     &#125;<br>    <br>    <span class="hljs-comment">// 构造方法，带offset的</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">ByteArrayInputStream</span><span class="hljs-params">(<span class="hljs-type">byte</span> buf[], <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;                <br>        <span class="hljs-built_in">this</span>.buf = buf;<br>        <span class="hljs-built_in">this</span>.pos = offset;<br>        <span class="hljs-built_in">this</span>.count = Math.min(offset + length, buf.length);<br>        <span class="hljs-built_in">this</span>.mark = offset;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从流中读取下一个字节，没有读取到返回 -1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="hljs-number">0xff</span>) : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从第 off 位置读取&lt;b&gt;最多(实际可能小于)&lt;/b&gt; len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> &#123;<br>        <span class="hljs-comment">// 边界检查</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || len &gt; b.length - off) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pos &gt;= count) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">avail</span> <span class="hljs-operator">=</span> count - pos;<br>        <span class="hljs-keyword">if</span> (len &gt; avail) &#123;<br>            len = avail;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 从buf拷贝到byte 数组b中</span><br>        System.arraycopy(buf, pos, b, off, len);<br>        pos += len;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br><br>    <span class="hljs-comment">// 跳过指定个数的字节不读取</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> count - pos;<br>        <span class="hljs-keyword">if</span> (n &lt; k) &#123;<br>            k = n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : n;<br>        &#125;<br><br>        pos += k;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br><br>    <span class="hljs-comment">// 还有稍稍byte在buffer中未读取，即总的count 减去 当前byte位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count - pos;<br>    &#125;<br><br>    <span class="hljs-comment">// 支持mark所以返回true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;  <br><br>    <span class="hljs-comment">// 在流中当前位置mark, readAheadLimit参数未使用    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readAheadLimit)</span> &#123;            <br>        mark = pos;<br>    &#125;<br><br>    <span class="hljs-comment">// 重置流，即回到mark的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br>        pos = mark;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭ByteArrayInputStream不会产生任何动作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123; <br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="6-BufferedInputStream"><a href="#6-BufferedInputStream" class="headerlink" title="6.BufferedInputStream"></a>6.BufferedInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br><br>    <span class="hljs-comment">// 默认的buffer大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;<br><br>    <span class="hljs-comment">// 分配的最大数组大小。</span><br>    <span class="hljs-comment">// 由于一些VM在数组中保留一些头字，所以尝试分配较大的阵列可能会导致OutOfMemoryError（请求的阵列大小超过VM限制）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_BUFFER_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">// 内部保存在byte 数组中</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br><br>    <span class="hljs-comment">// 关闭流的方法可能是异步的，所以使用原子AtomicReferenceFieldUpdater提供CAS无锁方式（可以解决CAS的ABA问题）来保证</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicReferenceFieldUpdater&lt;BufferedInputStream, <span class="hljs-type">byte</span>[]&gt; bufUpdater =<br>        AtomicReferenceFieldUpdater.newUpdater(BufferedInputStream.class,  <span class="hljs-type">byte</span>[].class, <span class="hljs-string">&quot;buf&quot;</span>);<br><br>    <span class="hljs-comment">// 有效byte的大小</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-comment">// 当前位置</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> pos;<br><br>    <span class="hljs-comment">// 最后一次，调用mark方法，标记的位置</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">markpos</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 该变量惟一入口就是mark(int readLimit)，好比调用方法mark(1024)，那么后面读取的数据若是</span><br><span class="hljs-comment">     * 超过了1024字节，那么这次mark就为无效标记，子类能够选择抛弃该mark标记，从头开始。不过具体实现</span><br><span class="hljs-comment">     * 跟具体的子类有关，在BufferedInputStream中，会抛弃mark标记，从新将markpos赋值为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> marklimit;<br><br>    <span class="hljs-comment">// 获取被装饰的stream</span><br>    <span class="hljs-keyword">private</span> InputStream <span class="hljs-title function_">getInIfOpen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> in;<br>        <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Stream closed&quot;</span>);<br>        <span class="hljs-keyword">return</span> input;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取实际内部的buffer数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getBufIfOpen() <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">byte</span>[] buffer = buf;<br>        <span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Stream closed&quot;</span>);<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数，buffer是8kb</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数，指定buffer大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用更多的数据填充缓冲区,考虑到shuffling和其他处理标记的技巧，</span><br><span class="hljs-comment">     * 假设它是由同步方法调用的。该方法还假设所有数据已经被读入，因此pos &gt;count。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 得到内部缓冲区buffer</span><br>        <span class="hljs-type">byte</span>[] buffer = getBufIfOpen();<br>        <span class="hljs-comment">// 没有mark的情况下， pos为0</span><br>        <span class="hljs-keyword">if</span> (markpos &lt; <span class="hljs-number">0</span>)<br>            pos = <span class="hljs-number">0</span>;            <span class="hljs-comment">/* no mark: throw away the buffer */</span><br>        <span class="hljs-comment">// pos &gt;= buffer.length  buffer已经被读取完了 </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pos &gt;= buffer.length)  <span class="hljs-comment">/* no room left in buffer */</span><br>        <span class="hljs-comment">// markpos &gt; 0  有标记，标记处在缓存中间</span><br>            <span class="hljs-keyword">if</span> (markpos &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">/* can throw away early part of the buffer */</span><br>            <span class="hljs-comment">// 把buffer中，markpos到pos的部分移动到0-sz处，pos设置为sz，markpos为0</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> pos - markpos;<br>                System.arraycopy(buffer, markpos, buffer, <span class="hljs-number">0</span>, sz);<br>                pos = sz;<br>                markpos = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// markpos已经为0了，marklimit比buffer.length小，再读取buffer已经没有地方了</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer.length &gt;= marklimit) &#123;<br>            <span class="hljs-comment">// 清空缓存，清空标记，markpos为-1，pos为0</span><br>                markpos = -<span class="hljs-number">1</span>;   <span class="hljs-comment">/* buffer got too big, invalidate mark */</span><br>                pos = <span class="hljs-number">0</span>;        <span class="hljs-comment">/* drop buffer contents */</span><br>                <span class="hljs-comment">// markpos已经为0了，marklimit比buffer.length大，而buffer.length已经最大了，不能扩容</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer.length &gt;= MAX_BUFFER_SIZE) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>(<span class="hljs-string">&quot;Required array size too large&quot;</span>);<br>               <span class="hljs-comment">// markpos已经为0了，marklimit比buffer.length大</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">/* grow buffer */</span><br>            <span class="hljs-comment">// 建立一个长度为min(2*pos,marklimit,MAX_BUFFER_SIZE),的缓存数组，然后把原来0-pos移动到新数组的0-pos处</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">nsz</span> <span class="hljs-operator">=</span> (pos &lt;= MAX_BUFFER_SIZE - pos) ?<br>                        pos * <span class="hljs-number">2</span> : MAX_BUFFER_SIZE;<br>                <span class="hljs-keyword">if</span> (nsz &gt; marklimit)<br>                    nsz = marklimit;<br>                <span class="hljs-type">byte</span> nbuf[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[nsz];<br>                System.arraycopy(buffer, <span class="hljs-number">0</span>, nbuf, <span class="hljs-number">0</span>, pos);<br>                <span class="hljs-comment">// 用bufUpdater替换buffer</span><br>                <span class="hljs-keyword">if</span> (!bufUpdater.compareAndSet(<span class="hljs-built_in">this</span>, buffer, nbuf)) &#123;<br>                    <span class="hljs-comment">// Can&#x27;t replace buf if there was an async close.</span><br>                    <span class="hljs-comment">// Note: This would need to be changed if fill()</span><br>                    <span class="hljs-comment">// is ever made accessible to multiple threads.</span><br>                    <span class="hljs-comment">// But for now, the only way CAS can fail is via close.</span><br>                    <span class="hljs-comment">// assert buf == null;</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Stream closed&quot;</span>);<br>                &#125;<br>                buffer = nbuf;<br>            &#125;<br>        <span class="hljs-comment">// 当前读取上限count为pos</span><br>        count = pos;<br>        <span class="hljs-comment">// 从内部的输入流，读取pos到buffer.length部分，读取的字节数加到count</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> getInIfOpen().read(buffer, pos, buffer.length - pos);<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>            count = n + pos;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取byte</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 说明当前buf[]数组大小不够了，须要fill()</span><br>        <span class="hljs-keyword">if</span> (pos &gt;= count) &#123;<br>            fill();<br>            <span class="hljs-comment">// 说明没有读取到任何数据</span><br>            <span class="hljs-keyword">if</span> (pos &gt;= count)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="hljs-number">0xff</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Read characters into a portion of an array, reading from the underlying</span><br><span class="hljs-comment">     * stream at most once if necessary.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read1</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">avail</span> <span class="hljs-operator">=</span> count - pos;<br>        <span class="hljs-keyword">if</span> (avail &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 当写入指定数组b的长度大小超过BufferedInputStream中核心缓存数组buf[]的大小而且 markpos &lt; 0，那么就直接从数据流中读取数据给b数组，而不经过buf[]缓存数组，避免buf[]数组急剧增大</span><br>            <span class="hljs-keyword">if</span> (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> getInIfOpen().read(b, off, len);<br>            &#125;<br>            fill();<br>            avail = count - pos;<br>            <span class="hljs-keyword">if</span> (avail &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> (avail &lt; len) ? avail : len;<br>        System.arraycopy(getBufIfOpen(), pos, b, off, cnt);<br>        pos += cnt;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取到byte数组b中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span><br>        <span class="hljs-keyword">throws</span> IOException<br>    &#123;<br>        getBufIfOpen(); <span class="hljs-comment">// Check for closed stream</span><br>        <span class="hljs-keyword">if</span> ((off | len | (off + len) | (b.length - (off + len))) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nread</span> <span class="hljs-operator">=</span> read1(b, off + n, len - n);<br>            <span class="hljs-keyword">if</span> (nread &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> (n == <span class="hljs-number">0</span>) ? nread : n;<br>            n += nread;<br>            <span class="hljs-keyword">if</span> (n &gt;= len)<br>                <span class="hljs-keyword">return</span> n;<br>            <span class="hljs-comment">// if not closed but no bytes available, return</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> in;<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span> &amp;&amp; input.available() &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> n;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 跳过n个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        getBufIfOpen(); <span class="hljs-comment">// Check for closed stream</span><br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">avail</span> <span class="hljs-operator">=</span> count - pos;<br><br>        <span class="hljs-keyword">if</span> (avail &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// If no mark position set then don&#x27;t keep in buffer</span><br>            <span class="hljs-keyword">if</span> (markpos &lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> getInIfOpen().skip(n);<br><br>            <span class="hljs-comment">// Fill in buffer to save bytes for reset</span><br>            fill();<br>            avail = count - pos;<br>            <span class="hljs-keyword">if</span> (avail &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">skipped</span> <span class="hljs-operator">=</span> (avail &lt; n) ? avail : n;<br>        pos += skipped;<br>        <span class="hljs-keyword">return</span> skipped;<br>    &#125;<br><br>    <span class="hljs-comment">// buf[]数组剩余字节数+输入流中剩余字节数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> count - pos;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">avail</span> <span class="hljs-operator">=</span> getInIfOpen().available();<br>        <span class="hljs-keyword">return</span> n &gt; (Integer.MAX_VALUE - avail)<br>                    ? Integer.MAX_VALUE<br>                    : n + avail;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">// 标记位置，marklimit只有在这里才可以被赋值，readlimit表示mark()方法执行后，最多可以从流中读取的数据</span><br>    <span class="hljs-comment">// 若是超过该字节大小，那么在fill()的时候，就会认为此mark()标记无效，从新将 markpos = -1，pos = 0</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;<br>        marklimit = readlimit;<br>        markpos = pos;<br>    &#125;<br><br>    <span class="hljs-comment">// 重置位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        getBufIfOpen(); <span class="hljs-comment">// 如果已经close, 则直接报错</span><br>        <span class="hljs-keyword">if</span> (markpos &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Resetting to invalid mark&quot;</span>);<br>        pos = markpos;<br>    &#125;<br><br>    <span class="hljs-comment">// 支持mark, 所以返回true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过AtomicReferenceFieldUpdater的CAS无锁方式close</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">byte</span>[] buffer;<br>        <span class="hljs-keyword">while</span> ( (buffer = buf) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (bufUpdater.compareAndSet(<span class="hljs-built_in">this</span>, buffer, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> in;<br>                in = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span>)<br>                    input.close();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// Else retry in case a new buf was CASed in fill()</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="7-ps"><a href="#7-ps" class="headerlink" title="7.ps"></a>7.ps</h4><p>5 6源码没细看，先去过java基础，后续再回来研究喜喜</p><h1 id="OutputStream-3"><a href="#OutputStream-3" class="headerlink" title="OutputStream(3)"></a>OutputStream(3)</h1><blockquote><p>OutputStream是输出字节流，具体的实现类层次结构如下：</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/io-outputstream-1.png" alt="img"></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>OutputStream 类重要方法设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span><br><br><span class="hljs-comment">// 将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span><br><br><span class="hljs-comment">// 将 byte 数组从 off 位置开始，len 长度的字节写入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span><br><br><span class="hljs-comment">// 强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">// 关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span><br><br></code></pre></td></tr></table></figure><h4 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h4><blockquote><p>梳理部分OutputStream及其实现类的源码分析。</p></blockquote><p>OutputStream抽象类源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span>, Flushable &#123;<br>    <br><span class="hljs-comment">// JDK11中增加了一个nullOutputStream，即空模式实现，以便可以直接调用而不用判空（可以看如下的补充说明）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OutputStream <span class="hljs-title function_">nullOutputStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStream</span>() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> closed;<br><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureOpen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-keyword">if</span> (closed) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Stream closed&quot;</span>);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                ensureOpen();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                Objects.checkFromIndexSize(off, len, b.length);<br>                ensureOpen();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>                closed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>    <span class="hljs-comment">// 将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        write(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br><br>    <span class="hljs-comment">// 将 byte 数组从 off 位置开始，len 长度的字节写入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 检查边界合理性</span><br>        Objects.checkFromIndexSize(off, len, b.length);<br>        <span class="hljs-comment">// len == 0 的情况已经在如下的for循环中隐式处理了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; len ; i++) &#123;<br>            write(b[off + i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    &#125;<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ps:不读了，嘻嘻。就这丫</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java IO 1</title>
    <link href="/2024/10/25/java/javaIo/javaIo1/"/>
    <url>/2024/10/25/java/javaIo/javaIo1/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-IO-1"><a href="#Java-IO-1" class="headerlink" title="Java IO 1"></a>Java IO 1</h1><h2 id="1-传输方式"><a href="#1-传输方式" class="headerlink" title="1.传输方式"></a>1.传输方式</h2><p>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:</p><ul><li>字节流</li><li>字符流</li></ul><p><code>字节</code>是个计算机看的，<code>字符</code>才是给人看的</p><h4 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1.字节流"></a>1.字节流</h4><p>(整体结构如下，部分派生类有缺失)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/java-io-category-1-1.png" alt="img"></p><h4 id="2-字符流"><a href="#2-字符流" class="headerlink" title="2.字符流"></a>2.字符流</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/java-io-category-2-1.png" alt="img"></p><h4 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h4><p>字符 读取文件内容-是从字节流到字符流的桥梁，它将字节流转换为字符流。–字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</p><p>字节 读取图片 视频文件-主要用于读取二进制数据，比如图片、音频、视频等文件。</p><blockquote><p>简而言之，字节是给计算机看的，字符才是给人看的。</p></blockquote><h4 id="4-字节转换"><a href="#4-字节转换" class="headerlink" title="4.字节转换"></a>4.字节转换</h4><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><p><strong>从字节流转换到字符流</strong></p><p>使用<code>InputStreamReader</code>。它读取字节并将它们解码为字符，通常需要指定字符集来进行正确的解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<span class="hljs-comment">//字节流</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis, <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//转换-指定编码</span><br></code></pre></td></tr></table></figure><p><strong>从字符流转换到字节流</strong>：</p><p>使用<code>OutputStreamWriter</code>。它将字符编码为字节并写入到输出流，通常也需要指定字符集。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>)<span class="hljs-comment">;</span><br>osw.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<span class="hljs-comment">;</span><br>osw.<span class="hljs-keyword">close</span>()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="2-数据操作"><a href="#2-数据操作" class="headerlink" title="2.数据操作"></a>2.数据操作</h2><p>从数据来源或者说是操作对象角度看，IO 类可以分为:</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/java-io-category-3.png" alt="img"></p><h4 id="1-文件"><a href="#1-文件" class="headerlink" title="1.文件"></a>1.文件</h4><h5 id="1-InputStream"><a href="#1-InputStream" class="headerlink" title="1.InputStream"></a>1.InputStream</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241025101621055.png" alt="image-20241025101621055"></p><p>文件读取 -字节读取-序列化读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<span class="hljs-comment">//字节流</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis, <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//转换-指定编码</span><br></code></pre></td></tr></table></figure><h5 id="2-outputstream"><a href="#2-outputstream" class="headerlink" title="2.outputstream"></a>2.outputstream</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241025101726427.png" alt="image-20241025101726427"></p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>)<span class="hljs-comment">;</span><br>osw.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<span class="hljs-comment">;</span><br>osw.<span class="hljs-keyword">close</span>()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="3-writer"><a href="#3-writer" class="headerlink" title="3.writer"></a>3.writer</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241025101855244.png" alt="image-20241025101855244"></p><p>Writer类提供了由其子类实现的不同方法。 以下是一些方法： 字符操作</p><h5 id="4-reade"><a href="#4-reade" class="headerlink" title="4.reade"></a>4.reade</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241025101930026.png" alt="image-20241025101930026"></p><h5 id="5-小节"><a href="#5-小节" class="headerlink" title="5.小节"></a>5.小节</h5><p>不带writer和reade的是字节操作-带的是字符操作</p><h4 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h4><p>字节数组(byte[]): ByteArrayInputStream、ByteArrayOutputStream</p><p>字符数组(char[]): CharArrayReader、CharArrayWriter</p><hr><h4 id="3-管道"><a href="#3-管道" class="headerlink" title="3.管道"></a>3.管道</h4><p>PipedInputStream、PipedOutputStream、PipedReader、PipedWriter</p><h4 id="4-基本数据类型"><a href="#4-基本数据类型" class="headerlink" title="4.基本数据类型"></a>4.基本数据类型</h4><p>DataInputStream、DataOutputStream</p><h4 id="5-缓存操作"><a href="#5-缓存操作" class="headerlink" title="5.缓存操作"></a>5.缓存操作</h4><p>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</p><h4 id="6-打印"><a href="#6-打印" class="headerlink" title="6.打印"></a>6.打印</h4><p>PrintStream、PrintWriter</p><h4 id="7-对象序列化反序列化"><a href="#7-对象序列化反序列化" class="headerlink" title="7.对象序列化反序列化"></a>7.对象序列化反序列化</h4><p>ObjectInputStream、ObjectOutputStream</p><h4 id="8-转换"><a href="#8-转换" class="headerlink" title="8.转换"></a>8.转换</h4><p>inputstreamreader</p><p>outputstreamwriter</p><h2 id="3-装饰者模式"><a href="#3-装饰者模式" class="headerlink" title="3.装饰者模式"></a>3.装饰者模式</h2><h6 id="1-了解装饰者模式"><a href="#1-了解装饰者模式" class="headerlink" title="1.了解装饰者模式"></a>1.了解装饰者模式</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241025103133584.png" alt="image-20241025103133584"></p><p>如图-</p><p>我们对于机器人两种更新方法功能</p><p>1.继承机制</p><p>厂商继承第一代研发</p><p>2.关联机制-<br>箱子嵌入以前机器人，我们做研发</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/85968cca1dec2fb7d5b202dc33c9c613.png" alt="85968cca1dec2fb7d5b202dc33c9c613"></p><p>类图</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/49f394cb8ed5bef0b96b4ace390be858.png" alt="49f394cb8ed5bef0b96b4ace390be858"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><br>    <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">Robota</span><br>    &#123;<br>        <span class="hljs-built_in">void</span> <span class="hljs-title function_">sayHello</span>();<br>    &#125;<br>   <span class="hljs-keyword">class</span>  <span class="hljs-title class_">RobotImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Robota</span><br>    &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;唱歌跳舞&quot;</span>);<br>        &#125;<br>    &#125;<br>   <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tirtest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Robota</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-title class_">Robota</span> robot;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title class_">Tirtest</span>(<span class="hljs-title class_">Robota</span> robot) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">robot</span> = robot;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>          robot.<span class="hljs-title function_">sayHello</span>();<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saypp</span>(<span class="hljs-params"></span>)<br>        &#123;<br>            robot.<span class="hljs-title function_">sayHello</span>();<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;pp&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Tirtest</span>&#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="hljs-title class_">Robota</span> robot</span>) &#123;<br>            <span class="hljs-variable language_">super</span>(robot);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">decorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Robota</span> robot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RobotImpl</span>();<br>        test t = <span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>(robot);<br>        t.<span class="hljs-title function_">saypp</span>();<br>    &#125;<br><br><br>&#125;<br><br><br><br><br><br><br></code></pre></td></tr></table></figure><blockquote><p>装饰器模式是在原有类的基础上动态添加新的功能，这种添加功能的方式不同于继承，它是在对象层面实现功能扩展，而不是继承的类层面，因此说装饰器模式比继承更加灵活。另外，装饰器模式属于结构型设计模式。之前讲的都是创建型设计模式。创建型可以理解为生成新的对象，而结构型可以理解为构建更大的类或类对象。</p></blockquote><h6 id="2-解读inputStream"><a href="#2-解读inputStream" class="headerlink" title="2.解读inputStream"></a>2.解读inputStream</h6><p>InputStream 是抽象组件；</p><p>FileInputStream 是 InputStream 的子类<strong>，属于具体组件，提供了字节流的输入操作；</strong></p><p>FilterInputStream <strong>属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能</strong>。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/DP-Decorator-java.io.png" alt="image"></p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FileInputStream fileInputStream <span class="hljs-operator">=</span>newFileInputStream(filePath)<span class="hljs-comment">;BufferedInputStream bufferedInputStream =newBufferedInputStream(fileInputStream);</span><br></code></pre></td></tr></table></figure><hr><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><br><span class="hljs-keyword">interface</span>  inputStreama<br>    &#123;<br>        <span class="hljs-built_in">void</span> <span class="hljs-title function_">sayHello</span>();<br>    &#125;<br>   <span class="hljs-keyword">class</span>  <span class="hljs-title class_">FileInputStreama</span>  <span class="hljs-keyword">implements</span> inputStreama<br>    &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;文件操作&quot;</span>);<br>        &#125;<br><br>    &#125;<br>   <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterInputStreamq</span>  <span class="hljs-keyword">implements</span> inputStreama &#123;<br>        <span class="hljs-keyword">private</span> inputStreama robot;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title class_">FilterInputStreamq</span>(inputStreama robot) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">robot</span> = robot;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>          robot.<span class="hljs-title function_">sayHello</span>();<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saypp</span>(<span class="hljs-params"></span>)<br>        &#123;<br>            robot.<span class="hljs-title function_">sayHello</span>();<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;文件传输增强&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_ inherited__">FilterInputStreamq</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">inputStreama robot</span>) &#123;<br>            <span class="hljs-variable language_">super</span>(robot);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">decorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        inputStreama robot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStreama</span>();<br>        test t = <span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>(robot);<br>        t.<span class="hljs-title function_">saypp</span>();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-常见类的使用"><a href="#4-常见类的使用" class="headerlink" title="4.常见类的使用"></a>4.常见类的使用</h2><p>本文主要介绍Java IO常见类的使用，包括：磁盘操作，字节操作，字符操作，对象操作和网络操作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241104140007947.png" alt="image-20241104140007947"></p><h4 id="IO常见类"><a href="#IO常见类" class="headerlink" title="IO常见类"></a>IO常见类</h4><h5 id="file相关"><a href="#file相关" class="headerlink" title="file相关"></a>file相关</h5><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p><p>递归地列出一个目录下所有文件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listAllFiles</span><span class="hljs-params">(File dir)</span> &#123;<br>    <span class="hljs-keyword">if</span> (dir == <span class="hljs-literal">null</span> || !dir.exists()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dir.isFile()) &#123;<br>        System.out.println(dir.getName());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>        listAllFiles(file);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h5 id="字节流相关"><a href="#字节流相关" class="headerlink" title="字节流相关"></a>字节流相关</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">(String src, String dist)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dist);<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">20</span> * <span class="hljs-number">1024</span>];<br><br>    <span class="hljs-comment">// read() 最多读取 buffer.length 个字节</span><br>    <span class="hljs-comment">// 返回的是实际读取的个数</span><br>    <span class="hljs-comment">// 返回 -1 的时候表示读到 eof，即文件尾</span><br>    <span class="hljs-keyword">while</span> (in.read(buffer, <span class="hljs-number">0</span>, buffer.length) != -<span class="hljs-number">1</span>) &#123;<br>        out.write(buffer);<br>    &#125;<br><br>    in.close();<br>    out.close();<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="实现逐行输出文本文件"><a href="#实现逐行输出文本文件" class="headerlink" title="实现逐行输出文本文件"></a>实现逐行输出文本文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFileContent</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fileReader);<br><br>    String line;<br>    <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(line);<br>    &#125;<br><br>    <span class="hljs-comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span><br>    <span class="hljs-comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span><br>    <span class="hljs-comment">// 因此只要一个 close() 调用即可</span><br>    bufferedReader.close();<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="序列化-Serializable-transient"><a href="#序列化-Serializable-transient" class="headerlink" title="序列化  Serializable &amp; transient"></a>序列化  Serializable &amp; transient</h5><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化: ObjectOutputStream.writeObject()</li><li>反序列化: ObjectInputStream.readObject()</li></ul><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p><p><strong>Serializable</strong></p><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>   <span class="hljs-comment">// 序列化编码</span><br>    <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">objectFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;file/a1&quot;</span>;<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(objectFile));<br>    objectOutputStream.writeObject(a1);<br>    objectOutputStream.close();<br>     <span class="hljs-comment">//序序列化解码</span><br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(objectFile));<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> (A) objectInputStream.readObject();<br>    objectInputStream.close();<br>    System.out.println(a2);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> String y;<br><br>    A(<span class="hljs-type">int</span> x, String y) &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;x = &quot;</span> + x + <span class="hljs-string">&quot;  &quot;</span> + <span class="hljs-string">&quot;y = &quot;</span> + y;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>transient</strong></p><p>transient 关键字可以使一些属性不会被序列化。</p><p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><hr><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-built_in">Object</span>[] elementData;<br><br></code></pre></td></tr></table></figure><h5 id="java网络支持"><a href="#java网络支持" class="headerlink" title="java网络支持"></a>java网络支持</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241104140528036.png" alt="image-20241104140528036"></p><h6 id="inetAdress"><a href="#inetAdress" class="headerlink" title="inetAdress"></a>inetAdress</h6><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">InetAddress.getByName(String host);<br>InetAddress.getByAddress(<span class="hljs-type">byte</span>[] address);<br></code></pre></td></tr></table></figure><h6 id="url"><a href="#url" class="headerlink" title="url"></a>url</h6><p>可以直接从 URL 中读取字节流数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>);<br><br>    <span class="hljs-comment">/* 字节流 */</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> url.openStream();<br><br>    <span class="hljs-comment">/* 字符流 */</span><br>    <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is, <span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>    <span class="hljs-comment">/* 提供缓存功能 */</span><br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br><br>    String line;<br>    <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(line);<br>    &#125;<br><br>    br.close();<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="sockets"><a href="#sockets" class="headerlink" title="sockets"></a>sockets</h6><ul><li>ServerSocket: 服务器端类</li><li>Socket: 客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ClienteServidorSockets1521731145260.jpg" alt="image"></p><h6 id="datagram"><a href="#datagram" class="headerlink" title="datagram"></a>datagram</h6><ul><li>DatagramSocket: 通信类</li><li>DatagramPacket: 数据包类</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-栈与队列</title>
    <link href="/2024/10/23/data%20structure/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2024/10/23/data%20structure/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023113739303.png" alt="image-20241023113739303"></p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023113907357.png" alt="image-20241023113907357"></p><h4 id="栈的基本运算"><a href="#栈的基本运算" class="headerlink" title="栈的基本运算"></a>栈的基本运算</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023114809056.png" alt="image-20241023114809056"></p><h4 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h4><h5 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023115228661.png" alt="image-20241023115228661"></p><h6 id="1-初始化栈运算算法"><a href="#1-初始化栈运算算法" class="headerlink" title="1.初始化栈运算算法"></a>1.初始化栈运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023115728234.png" alt="image-20241023115728234"></p><h6 id="2-销毁栈运算算法"><a href="#2-销毁栈运算算法" class="headerlink" title="2.销毁栈运算算法"></a>2.销毁栈运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023115755209.png" alt="image-20241023115755209"></p><h6 id="3-进栈运算算法"><a href="#3-进栈运算算法" class="headerlink" title="3.进栈运算算法"></a>3.进栈运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023115819086.png" alt="image-20241023115819086"></p><h6 id="4-出栈运算算法"><a href="#4-出栈运算算法" class="headerlink" title="4.出栈运算算法"></a>4.出栈运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023115914639.png" alt="image-20241023115914639"></p><h6 id="5-取栈顶元素运算算法"><a href="#5-取栈顶元素运算算法" class="headerlink" title="5.取栈顶元素运算算法"></a>5.取栈顶元素运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023120135839.png" alt="image-20241023120135839"></p><h6 id="6-判断栈空运算算法"><a href="#6-判断栈空运算算法" class="headerlink" title="6.判断栈空运算算法"></a>6.判断栈空运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023120210321.png" alt="image-20241023120210321"></p><h5 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023120311001.png" alt="image-20241023120311001"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023120629120.png" alt="image-20241023120629120"></p><h6 id="1-初始化栈运算算法-1"><a href="#1-初始化栈运算算法-1" class="headerlink" title="1.初始化栈运算算法"></a>1.初始化栈运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023121532608.png" alt="image-20241023121532608"></p><h6 id="2-销毁栈运算算法-1"><a href="#2-销毁栈运算算法-1" class="headerlink" title="2.销毁栈运算算法"></a>2.销毁栈运算算法</h6><p><img src="C:\Users\nixg\AppData\Roaming\Typora\typora-user-images\image-20241023121704509.png" alt="image-20241023121704522"></p><p>3.进栈运算算法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023121857690.png" alt="image-20241023121857690"></p><p>4.出栈运算算法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023122043771.png" alt="image-20241023122043771"></p><h6 id="5-取栈顶运算算法"><a href="#5-取栈顶运算算法" class="headerlink" title="5.取栈顶运算算法"></a>5.取栈顶运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023122216213.png" alt="image-20241023122216213"></p><h6 id="6-判断栈空"><a href="#6-判断栈空" class="headerlink" title="6.判断栈空"></a>6.判断栈空</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023122339320.png" alt="image-20241023122339320"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="1-队列概念"><a href="#1-队列概念" class="headerlink" title="1.队列概念"></a>1.队列概念</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023122512281.png" alt="image-20241023122512281"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023122624348.png" alt="image-20241023122624348"></p><h4 id="2-队列基本算法"><a href="#2-队列基本算法" class="headerlink" title="2.队列基本算法"></a>2.队列基本算法</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5d2239afedb051abb91cf47dd6bc311d.png" alt="5d2239afedb051abb91cf47dd6bc311d"></p><h4 id="3-队列存储结构"><a href="#3-队列存储结构" class="headerlink" title="3.队列存储结构"></a>3.队列存储结构</h4><h5 id="栈式"><a href="#栈式" class="headerlink" title="栈式"></a>栈式</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023123134354.png" alt="image-20241023123134354"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023123141802.png" alt="image-20241023123141802"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023123238700.png" alt="image-20241023123238700"></p><p>队尾 </p><p><strong>队头 front</strong></p><p>初始化 front&#x3D;&#x3D;&#x3D;real&#x3D;&#x3D;&#x3D;-1</p><p>满栈</p><p>rear&#x3D;maxsize-1</p><p>会出现假溢出-哪怕满足条件了但是还存在可以放的地方</p><p>如题p e</p><h5 id="循环栈式队列"><a href="#循环栈式队列" class="headerlink" title="循环栈式队列"></a>循环栈式队列</h5><h6 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023163354729.png" alt="image-20241023163354729"></p><p>队列满解决</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/afe901bcd44a32cfc2169f440004b483.png" alt="afe901bcd44a32cfc2169f440004b483"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/abbad95fd00c7a766c5378d879cc80c6.png" alt="abbad95fd00c7a766c5378d879cc80c6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164045889.png" alt="image-20241023164045889"></p><h6 id="循环队列算法"><a href="#循环队列算法" class="headerlink" title="循环队列算法"></a>循环队列算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023163535225.png" alt="image-20241023163535225"></p><p>2.销毁队列算法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023163640769.png" alt="image-20241023163640769"></p><p>3.进队运算算法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023163702944.png" alt="image-20241023163702944"></p><p>4.出队运算算法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023163801962.png" alt="image-20241023163801962"></p><p>5.取队头元素运算算法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164002890.png" alt="image-20241023164002890"></p><p>6.判断队空</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164257792.png" alt="image-20241023164257792"></p><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><h5 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164341179.png" alt="image-20241023164341179"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164436817.png" alt="image-20241023164436817"></p><h5 id="链式存储算法"><a href="#链式存储算法" class="headerlink" title="链式存储算法"></a>链式存储算法</h5><h6 id="1-初始化队列运算算法"><a href="#1-初始化队列运算算法" class="headerlink" title="1.初始化队列运算算法"></a>1.初始化队列运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164529878.png" alt="image-20241023164529878"></p><h6 id="2-销毁队列算法"><a href="#2-销毁队列算法" class="headerlink" title="2.销毁队列算法"></a>2.销毁队列算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164552150.png" alt="image-20241023164552150"></p><h6 id="3-进队运算算法"><a href="#3-进队运算算法" class="headerlink" title="3.进队运算算法"></a>3.进队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164635030.png" alt="image-20241023164635030"></p><h6 id="4-出队运算算法"><a href="#4-出队运算算法" class="headerlink" title="4.出队运算算法"></a>4.出队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164703822.png" alt="image-20241023164703822"></p><h6 id="5-取队头元素运算算法"><a href="#5-取队头元素运算算法" class="headerlink" title="5.取队头元素运算算法"></a>5.取队头元素运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164724387.png" alt="image-20241023164724387"></p><h6 id="6-判断队空"><a href="#6-判断队空" class="headerlink" title="6.判断队空"></a>6.判断队空</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023164738717.png" alt="image-20241023164738717"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java 高阶-并发探究02</title>
    <link href="/2024/10/23/java/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%912/"/>
    <url>/2024/10/23/java/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%912/</url>
    
    <content type="html"><![CDATA[<h2 id="Java线程基础"><a href="#Java线程基础" class="headerlink" title="Java线程基础"></a>Java线程基础</h2><blockquote><p>线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?</p><p>通常线程有哪几种使用方式?</p><p>基础线程机制有哪些?</p><p>线程的中断方式有哪些?</p><p>线程的互斥同步方式有哪些? 如何比较和选择?</p><p>线程之间有哪些协作方式?</p></blockquote><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ace830df-9919-48ca-91b5-60b193f593d2.png" alt="image"></p><p>如上描述了java线程的生命周期状态</p><h6 id="1-New"><a href="#1-New" class="headerlink" title="1.New"></a>1.New</h6><blockquote><p>线程对象已经创建，但还没有调用 <code>start()</code> 方法。</p><p>线程处于 “New” 状态，直到 <code>Thread.start()</code> 方法被调用。</p></blockquote><h6 id="2-Runnable（就绪-运行状态）"><a href="#2-Runnable（就绪-运行状态）" class="headerlink" title="2.Runnable（就绪&#x2F;运行状态）"></a>2.<strong>Runnable（就绪&#x2F;运行状态）</strong></h6><p>当调用 <code>Thread.start()</code> 方法时，线程进入 “Runnable” 状态。</p><p>此状态意味着<strong>线程准备运行，可能已经在运行，也可能正在等待 CPU 调度。</strong></p><p>线程有机会获得 CPU 并执行其任务，但并不意味着线程一定正在执行。</p><h6 id="3-Blocked"><a href="#3-Blocked" class="headerlink" title="3.Blocked"></a>3.Blocked</h6><p>阻塞状态</p><p>当线程试图获取一个锁（如通过 <code>synchronized</code> 关键字）时，线程进入 “Blocked” 状态。</p><p>线程进入阻塞状态是因为某些资源（如锁）被其他线程占用，当前线程无法继续执行。</p><h6 id="4-Time-Waiting（超时等待状态）"><a href="#4-Time-Waiting（超时等待状态）" class="headerlink" title="4..Time Waiting（超时等待状态）"></a>4..Time Waiting（超时等待状态）</h6><p>当线程调用 <code>Thread.sleep()</code> 方法时，它进入 “Time Waiting” 状态。</p><p>线程会在指定时间内暂停执行，直到时间到达或被其他线程中断。</p><h6 id="5-Waiting（等待状态）"><a href="#5-Waiting（等待状态）" class="headerlink" title="5.Waiting（等待状态）"></a>5.Waiting（等待状态）</h6><p>当线程调用 <code>Object.wait()</code> 方法时，它进入 “Waiting” 状态，等待其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code>。</p><p>线程将一直处于等待状态，直到被显式唤醒。</p><h6 id="6-Terminated（终止状态）"><a href="#6-Terminated（终止状态）" class="headerlink" title="6.Terminated（终止状态）"></a>6.Terminated（终止状态）</h6><p>当线程执行完成或由于异常而终止时，线程进入 “Terminated” 状态。</p><p>这个状态表示线程的生命周期结束，不能再重新启动。</p><h6 id="7-图状态转换"><a href="#7-图状态转换" class="headerlink" title="7.图状态转换"></a>7.图状态转换</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.start()：将线程从 <span class="hljs-string">&quot;New&quot;</span> 状态转为 <span class="hljs-string">&quot;Runnable&quot;</span> 状态。<br><span class="hljs-keyword">synchronized</span>：获取锁失败时，线程进入 <span class="hljs-string">&quot;Blocked&quot;</span> 状态。<br>Thread.sleep()：使线程进入 <span class="hljs-string">&quot;Time Waiting&quot;</span> 状态。<br>    <br>Object.wait()：使线程进入 <span class="hljs-string">&quot;Waiting&quot;</span> 状态。<br>Object.notify() / notifyAll()：唤醒等待状态中的线程，转到 <span class="hljs-string">&quot;Runnable&quot;</span>。<br>    <br>    <br>线程执行结束 或 异常：线程进入 <span class="hljs-string">&quot;Terminated&quot;</span> 状态。<br></code></pre></td></tr></table></figure><h3 id="线程使用方法"><a href="#线程使用方法" class="headerlink" title="线程使用方法"></a>线程使用方法</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241023224050918.png" alt="image-20241023224050918"></p><h6 id="1-Runnable"><a href="#1-Runnable" class="headerlink" title="1.Runnable"></a>1.Runnable</h6><p><code>Runnable</code> 是一个功能性接口，定义了一个 <code>run()</code> 方法，任务逻辑写在这个方法中。</p><p>它不返回任何结果，也不能抛出检查型异常。</p><p>虽然实现了 <code>Runnable</code> 的类可以封装任务逻辑，但它本身不是线程，最后需要通过 <code>Thread</code> 对象来驱动任务执行。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">runa</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Runnable is running&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        runa r = <span class="hljs-keyword">new</span> <span class="hljs-title function_">runa</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">runa</span>()).<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h6 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h6><p><code>Callable</code> 接口类似于 <code>Runnable</code>，但它的 <code>call()</code> 方法可以返回一个结果并且可以抛出异常。</p><p>由于 <code>Callable</code> 可以有返回值，一般会通过 <code>FutureTask</code> 来包装并通过线程运行。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> runa <span class="hljs-keyword">implements</span> Runnable&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-keyword">call</span> <span class="hljs-keyword">implements</span> Callable&lt;Integer&gt; &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-keyword">call</span>() <span class="hljs-keyword">throws</span> Exception &#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;call is call&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Runnable is running&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> mainQ(String[] args) &#123;<br>        <span class="hljs-comment">///</span><br>        FutureTask&lt;Integer&gt; <span class="hljs-keyword">task</span> = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">call</span>());<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">task</span>).start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>.get());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        runa r = <span class="hljs-keyword">new</span> runa();<br>        r.mainQ(args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-Thread"><a href="#3-Thread" class="headerlink" title="3.Thread"></a>3.Thread</h6><p>直接继承 <code>Thread</code> 类并重写其 <code>run()</code> 方法，将任务逻辑写入其中。</p><p>这种方式相比实现接口，耦合性更高，因为继承 <code>Thread</code> 限制了类的多继承性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void run() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Thread is running&quot;</span>);<br>    &#125;<br>&#125;<br>public void mainto(<span class="hljs-type">String</span>[] args) &#123;<br>    myThread t = <span class="hljs-keyword">new</span> myThread();<br>    t.start();<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;main is running&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现 <code>Runnable</code> 和 <code>Callable</code> 接口的类并不是线程本身，它们是定义了任务逻辑的类，必须通过 <code>Thread</code> 对象或线程池来执行。</p><p><code>Runnable</code> 是没有返回值的，而 <code>Callable</code> 可以返回结果并抛出异常。</p><p>继承 <code>Thread</code> 是直接将类本身变为线程，但通常推荐使用 <code>Runnable</code> 或 <code>Callable</code>，以避免不必要的类继承。</p></blockquote><h3 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h3><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><blockquote><p><code>Executor</code> 是 Java 中用于管理和控制线程执行的一个接口，它是 Java 并发框架的一部分，简化了线程的使用和管理。</p><p><strong><code>Executor</code> 是一个简单的接口，定义了一个 <code>execute(Runnable command)</code> 方法，用于接受一个 <code>Runnable</code> 任务并将其执行。它并不负责任务的调度和管理，只是负责将任务提交给线程执行。</strong></p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ExecutorService</span><br></code></pre></td></tr></table></figure><p><code>ExecutorService</code> 是 <code>Executor</code> 的一个子接口，提供了更高级的功能，包括：</p><ul><li>提交任务并获取结果。</li><li>任务的调度和管理。</li><li>优雅地关闭服务。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024102900042.png" alt="image-20241024102900042"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorServiceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">//创建可缓存线程池</span><br><br>        ExecutorService service = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = i;<br>            service.submit(()-&gt;&#123;<br>                System.out.println(<span class="hljs-string">&quot;Executing task &quot;</span> + <span class="hljs-keyword">index</span> + <span class="hljs-string">&quot; by &quot;</span> + Thread.currentThread().getName());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务耗时</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 关闭线程池</span><br>        service.shutdown();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h5><p>守护线程是程序运行时在后台提供服务的线程，<strong>不属于程序中不可或缺的部分。</strong></p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>使用 setDaemon() 方法将一个</p><p>线程设置为守护线程。</p><hr><p>守护线程（Daemon Thread）是 Java 中的一种特殊线程，它的主要特性是：当所有用户线程（非守护线程）结束时，JVM 会自动退出，守护线程不会阻止 JVM 的退出。，即使还有守护线程在运行，JVM 也不会等待守护线程完成。。这种线程通常用于执行一些后台任务，如垃圾回收、监控等。</p><hr><blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DaemonThreadExample</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Thread is running...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务执行</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread.setDaemon(<span class="hljs-literal">true</span>);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;主线程正在运行...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟任务执行</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;主线程结束.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">try</span> &#123;<br>                  Thread.<span class="hljs-title function_ invoke__">sleep</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务执行</span><br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(e);<br>              &#125;<br></code></pre></td></tr></table></figure><h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h5><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是<strong>建议</strong>具有相同优先级的其它线程可以运行。</p><hr><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>    Thread.<span class="hljs-keyword">yield</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p><strong>中断的目的</strong>：中断机制允许一个线程通知另一个线程停止执行或执行某些操作。线程可以在适当的时候检查中断状态，并决定是否响应中断。</p><p><strong>中断标志</strong>：<strong>每个线程都有一个中断状态，表示该线程是否被请求中断。可以通过调用 <code>Thread.interrupt()</code> 方法来设置一个线程的中断标志。</strong></p><p><strong>检查中断状态</strong>：</p><ul><li>使用 <code>Thread.currentThread().isInterrupted()</code> 方法检查当前线程的中断状态。</li><li>使用 <code>Thread.interrupted()</code> 方法检查并清除当前线程的中断状态。</li></ul><h6 id="1-InterruptedException"><a href="#1-InterruptedException" class="headerlink" title="1.InterruptedException"></a>1.InterruptedException</h6><p>当一个线程正在执行某些阻塞操作（如 <code>Thread.sleep()</code>、<code>Object.wait()</code> 或 <code>LockSupport.park()</code> 等）时，如果它被中断，会抛出 <code>InterruptedException</code> 异常。处理这个异常是非常重要的，因为这通常意味着线程应该停止执行。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</p><p><code>InterruptedException</code> 是一个检查型异常，表示线程在等待或阻塞状态时被中断。</p><p><strong>在 <code>Thread.sleep()</code> 中</strong>：如果线程在调用 <code>Thread.sleep()</code> 时被中断，会抛出 <code>InterruptedException</code>。</p><p><strong>在 <code>Object.wait()</code> 中</strong>：如果线程在等待某个对象的监视器时被中断，也会抛出此异常。</p><p><strong>在 <code>Lock</code> 的 <code>lockInterruptibly()</code> 方法中</strong>：如果线程尝试获取锁但被中断，同样会抛出 <code>InterruptedException</code>。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</span><br><span class="hljs-section">------</span><br><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaemonThreadExample</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span>  </span>&#123;<br><br>        Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>           <br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Thread is running...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务执行</span><br>                &#125; <span class="hljs-built_in">catch</span> (InterruptedException e) &#123;<br>                    e.<span class="hljs-built_in">printStackTrace</span>();<br>                    <span class="hljs-comment">// 进行清理操作</span><br>                    <span class="hljs-comment">// 可能需要保存状态、释放资源等</span><br><br>                &#125;<br>            <br>        &#125;);<br><br>        thread.<span class="hljs-built_in">start</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>            <span class="hljs-comment">//线程阻塞阶段被打断</span><br>            thread.<span class="hljs-built_in">interrupt</span>();<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h6><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 <strong>interrupt() 方法就无法使线程提前结束。</strong></p><p>但是调用 interrupt() 方法会设<strong>置线程的中断标记</strong>，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><hr><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaemonThreadExample</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span>  </span>&#123;<br><br>        Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//可以判断是否被中断了-可以提前结束线程</span><br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Thread is running...&quot;</span>);<br>            <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">interrupted</span>())<br>            &#123;<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Thread is running...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务执行</span><br>                &#125; <span class="hljs-built_in">catch</span> (InterruptedException e) &#123;<br>                    e.<span class="hljs-built_in">printStackTrace</span>();<br>                    <span class="hljs-comment">// 进行清理操作</span><br>                    <span class="hljs-comment">// 可能需要保存状态、释放资源等</span><br><br>                &#125;<br>            &#125;<br><br>        &#125;);<br><br>        thread.<span class="hljs-built_in">start</span>();<br><br><br>            <span class="hljs-comment">//线程阻塞阶段被打断</span><br>            thread.<span class="hljs-built_in">interrupt</span>();<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h6><p>调用 Executor 的 shutdown() 方法会等待<strong>线程都执行完毕之后再关闭</strong>，但<strong>是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</strong>&#x2F;&#x2F;全部进入线程中继</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaemonThreadExample</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        executorService.execute<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                Thread.sleep(<span class="hljs-number">2000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                System.out.println(<span class="hljs-string">&quot;Thread run&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">executorService</span>.<span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;Main run&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Main run<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span>: sleep interrupted<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.sleep</span>(Native Method)<br>at DaemonThreadExample.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(DaemonThreadExample<span class="hljs-selector-class">.java</span>:<span class="hljs-number">11</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.runWorker</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1142</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span><span class="hljs-selector-class">.run</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">617</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)<br></code></pre></td></tr></table></figure><h3 id="线程互斥同步"><a href="#线程互斥同步" class="headerlink" title="线程互斥同步"></a>线程互斥同步</h3><blockquote><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p></blockquote><h6 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1.synchronized"></a>1.synchronized</h6><p><code>Synchronized</code> 关键字是 Java 中最简单的实现互斥的方式。<strong>它自动加锁和解锁</strong>，确保同一时刻只有一个线程可以执行同步方法。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">synchronized</span>   <span class="hljs-type">void</span>  <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>synchronized</code> 保证了隐式锁定当前对象实例 (<code>this</code>)，从而确保了线程安全。</p><p><strong>同步代码块</strong></p><p>果你不想整个方法都被锁住，而只是想对某一部分代码进行同步，可以使用同步代码块。在 Java 中，使用 <code>synchronized</code> 关键字对某个特定的对象或类进行加锁</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object o= <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  increment() &#123;<br><span class="hljs-keyword">synchronized</span> (o)<br>&#123;<br>    <span class="hljs-keyword">count</span>++;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p>这里使用了 <code>synchronized(lock)</code> 对代码块进行加锁，而不是整个方法。这样可以更灵活地控制锁的粒度，提升程序性能。</p></blockquote><h6 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h6><p>ReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeCounter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> Lock lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            count++;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-type">SafeCounter</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeCounter</span>();<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br><br>                    s.increment();<br><br>            &#125;;<br>        Thread[] threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">1000</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)<br>            &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>                threads[i]=thread1;<br>                thread1.start();<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            threads[i].join();  <span class="hljs-comment">// 等待每个线程结束</span><br>        &#125;<br><br><br>        System.out.println(s.getCount());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-比较"><a href="#3-比较" class="headerlink" title="3.比较"></a>3.比较</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024110328270.png" alt="image-20241024110328270"></p><h3 id="线程之间协作"><a href="#线程之间协作" class="headerlink" title="线程之间协作"></a>线程之间协作</h3><h5 id="1-join"><a href="#1-join" class="headerlink" title="1.join"></a>1.join</h5><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><blockquote><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DaemonThreadExample</span><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaemonThreadExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        public void run() &#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">A</span> a;<br><br>        <span class="hljs-type">B</span>(<span class="hljs-type">A</span> a) &#123;<br>            <span class="hljs-keyword">this</span>.a = a;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        public void run() &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                a.join();<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">InterruptedException</span> e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    public  void test() &#123;<br>        <span class="hljs-type">A</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>();<br>        <span class="hljs-type">B</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>(a);<br>        b.start();<br>        a.start();<br>    &#125;<br><br>    public static void main(<span class="hljs-type">String</span>[] args) &#123;<br>        <span class="hljs-type">DaemonThreadExample</span> d = <span class="hljs-keyword">new</span> <span class="hljs-type">DaemonThreadExample</span>();<br>        d.test();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-wait-notify-notifyAll"><a href="#2-wait-notify-notifyAll" class="headerlink" title="2.wait() notify() notifyAll()"></a>2.wait() notify() notifyAll()</h5><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><hr><blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DaemonThreadExample</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">before</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;before&quot;</span>);<br>        notifyAll();<span class="hljs-comment">// 唤醒所有线程</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">after</span>()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            wait();<span class="hljs-comment">// 等待被唤醒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;after&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        DaemonThreadExample example = <span class="hljs-keyword">new</span> DaemonThreadExample();<br>        executorService.execute(() -&gt; example.after());<br>        executorService.execute(() -&gt; example.before());<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h5 id="3-await-signal-signalAll"><a href="#3-await-signal-signalAll" class="headerlink" title="3.await() signal() signalAll()"></a>3.await() signal() signalAll()</h5><p>ava.util.concurrent 类库中提供了 <strong>Condition</strong> 类来实现线程之间的协调，可以在 Condition 上调用 <strong>await</strong>() 方法使线程等待，其它线程调用 signal() <strong>或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</strong></p><p>使用 Lock 来获取一个 Condition 对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DaemonThreadExample</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> Condition condition = <span class="hljs-keyword">lock</span>.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span>()</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;before&quot;</span>);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span>()</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.<span class="hljs-keyword">await</span>();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;after&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        DaemonThreadExample example = <span class="hljs-keyword">new</span> DaemonThreadExample();<br>        executorService.execute(() -&gt; example.after());<br>        executorService.execute(() -&gt; example.before());<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java 高阶-并发探究01</title>
    <link href="/2024/10/21/java/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91%E6%8E%A2%E7%A9%B61/"/>
    <url>/2024/10/21/java/java%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91%E6%8E%A2%E7%A9%B61/</url>
    
    <content type="html"><![CDATA[<h1 id="并发探究-01"><a href="#并发探究-01" class="headerlink" title="并发探究 01"></a>并发探究 01</h1><p>ps:<br>2024&#x2F;10&#x2F;21 2h</p><p>我对并发的了解-再解决线程安全的问题下-利用线程池来解决各种问题实现，高并发</p><p>之前的学习都是基于c++ 现在来系统的学习一下java的并发问题</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.png" alt="并发基础"></p><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><h5 id="0-目录"><a href="#0-目录" class="headerlink" title="0.目录"></a>0.目录</h5><p>0.什么是线程和进程</p><blockquote><p>一个程序 在硬盘中存储着 就是一堆数据 在内存中加载后 便是进程 进程拥有四GB 然后会有一个线程执行工作</p></blockquote><p>1.为什么需要多线程</p><blockquote><p><strong>并发处理：</strong> <strong>通过在多线程中执行不同的任务</strong>，程序可以同时处理多个用户请求，提高应用程序的响应能力。</p><p><strong>提高性能：</strong> 在多核处理器上，多线程程序可以真正实现并行处理，不同的线程可以同时在不同的CPU核心上执行，从而提高整个程序的执行速度。</p></blockquote><p><strong>2.多线程安全示例</strong></p><p>如果多个线程对同一个<strong>共享数据</strong>进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p><strong>3.并发出现问题根源</strong></p><p>操作共享资源</p><p><strong>4.java解决并发</strong></p><p><strong>5.线程安全问题探究</strong></p><p><strong>6.线程安全实现</strong></p><h5 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h5><ul><li>多线程的出现是要解决什么问题的?</li><li>线程不安全是指什么? 举例说明</li><li>并发出现线程不安全的本质什么? 可见性，原子性和有序性。</li><li>Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before</li><li>线程安全是不是非真即假? 不是</li><li>线程安全有哪些实现思路?</li><li>如何理解并发和并行的区别?</li></ul><h5 id="2-操作系统进行线程切换"><a href="#2-操作系统进行线程切换" class="headerlink" title="2.操作系统进行线程切换"></a>2.操作系统进行线程切换</h5><blockquote><p>一个程序 在硬盘中存储着 就是一堆数据 在内存中加载后 便是进程 进程拥有四GB 然后会有一个线程执行工作</p></blockquote><p>CONTEXT：结构<br>当一个程序有很多线程的时候 CPU给每个线程都分配了运行时间<br>例如 线程1 -》线程2-》-》线程1<br>必须有一个结构保存了线程1的寄存器的值</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3001071-20230224122342767-1429005970.png" alt="image"></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br>CONTEXT：<br><br>该结构包含了特定处理器的寄存器数据。<br><br><br>typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">_CONTEXT</span> &#123;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The flags values within this flag control the contents of</span><br>    <span class="hljs-comment">// a CONTEXT record.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// If the context record is used as an input parameter, then</span><br>    <span class="hljs-comment">// for each portion of the context record controlled by a flag</span><br>    <span class="hljs-comment">// whose value is set, it is assumed that that portion of the</span><br>    <span class="hljs-comment">// context record contains valid context. If the context record</span><br>    <span class="hljs-comment">// is being used to modify a threads context, then only that</span><br>    <span class="hljs-comment">// portion of the threads context will be modified.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// If the context record is used as an IN OUT parameter to capture</span><br>    <span class="hljs-comment">// the context of a thread, then only those portions of the thread&#x27;s</span><br>    <span class="hljs-comment">// context corresponding to set flags will be returned.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The context record is never used as an OUT only parameter.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD ContextFlags;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is</span><br>    <span class="hljs-comment">// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT</span><br>    <span class="hljs-comment">// included in CONTEXT_FULL.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   Dr0;<br>    DWORD   Dr1;<br>    DWORD   Dr2;<br>    DWORD   Dr3;<br>    DWORD   Dr6;<br>    DWORD   Dr7;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.</span><br>    <span class="hljs-comment">//</span><br><br>    FLOATING_SAVE_AREA FloatSave;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_SEGMENTS.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   SegGs;<br>    DWORD   SegFs;<br>    DWORD   SegEs;<br>    DWORD   SegDs;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_INTEGER.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   Edi;<br>    DWORD   Esi;<br>    DWORD   Ebx;<br>    DWORD   Edx;<br>    DWORD   Ecx;<br>    DWORD   Eax;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_CONTROL.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   Ebp;<br>    DWORD   Eip;<br>    DWORD   SegCs;              <span class="hljs-comment">// MUST BE SANITIZED</span><br>    DWORD   EFlags;             <span class="hljs-comment">// MUST BE SANITIZED</span><br>    DWORD   Esp;<br>    DWORD   SegSs;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the ContextFlags word</span><br>    <span class="hljs-comment">// contains the flag CONTEXT_EXTENDED_REGISTERS.</span><br>    <span class="hljs-comment">// The format and contexts are processor specific</span><br>    <span class="hljs-comment">//</span><br><br>    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];<br><br>&#125; CONTEXT;<br><br><br>获取线程CONTEXT结构：<br><br><span class="hljs-comment">//挂起线程</span><br><span class="hljs-built_in">SuspendThread</span>(线程句柄);<br><br>CONTEXT context<br><br><span class="hljs-comment">//设置要获取的类型</span><br><br>context.ContextFlags = CONTEXT_CONTROL;<br><br><span class="hljs-comment">//获取</span><br><br><span class="hljs-keyword">BOOL</span> ok = ::<span class="hljs-built_in">GetThreadContext</span>(hThread,&amp;context);<br><br><span class="hljs-comment">//设置</span><br><br>context.Eip = <span class="hljs-number">0x401000</span>;<span class="hljs-comment">//修改下次执行的地址</span><br><br><span class="hljs-built_in">SetThreadContext</span>(hThread,&amp;context);<br><br>![image](https:<span class="hljs-comment">//img2023.cnblogs.com/blog/3001071/202302/3001071-20230224122406132-1628217277.png)</span><br><br><br></code></pre></td></tr></table></figure><h5 id="3-线程不安全示例"><a href="#3-线程不安全示例" class="headerlink" title="3.线程不安全示例"></a>3.线程不安全示例</h5><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafeExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>()</span> &#123;<br>        cnt++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">get</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>        final <span class="hljs-built_in">int</span> threadSize = <span class="hljs-number">1000</span>;<br>        ThreadUnsafeExample example = <span class="hljs-keyword">new</span> ThreadUnsafeExample();<br>        <span class="hljs-comment">// 用于等待所有线程执行完毕</span><br>        <span class="hljs-comment">/*CountDownLatch</span><br><span class="hljs-comment">        用于确保主线程等待所有子线程执行完毕。</span><br><span class="hljs-comment">        它的计数器从 1000 开始，每当一个线程完成工作后，</span><br><span class="hljs-comment">        调用 countDown()，计数器减1，直到变为0，主线程才继续执行。</span><br><span class="hljs-comment">         */</span><br>        final CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);<br>        <span class="hljs-comment">//使用线程池管理线程。newCachedThreadPool() 会根据需要动态创建线程，但如果已有空闲线程，则重用这些线程。</span><br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                example.<span class="hljs-keyword">add</span>();<br>                countDownLatch.countDown();<br>                <span class="hljs-comment"><span class="hljs-doctag">///</span>每个线程结束时都会调用 countDownLatch.countDown() 来通知主线程该线程已完成。</span><br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span>主线程在这一行阻塞，等待所有 1000 个线程执行完毕，直到计数器归零。</span><br>        countDownLatch.<span class="hljs-keyword">await</span>();<br>        <span class="hljs-comment">//关闭线程池</span><br>        executorService.shutdown();<br>        <span class="hljs-comment">//打印</span><br>        System.<span class="hljs-keyword">out</span>.println(example.<span class="hljs-keyword">get</span>());<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-并发安全问题探究"><a href="#4-并发安全问题探究" class="headerlink" title="4.并发安全问题探究"></a>4.并发安全问题探究</h5><p>cpu分时切换问题</p><blockquote><p>线程不安全问题的出现是由于多个因素交织在一起，主要体现在<strong>可见性、原子性和有序性</strong>方面。</p></blockquote><h6 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h6><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>CPU缓存引起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1执行的代码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>i = <span class="hljs-number">10</span>;<br> <br><span class="hljs-comment">//线程2执行的代码</span><br>j = i;<br></code></pre></td></tr></table></figure><p>线程执行完毕了-但是数据没写入主存-被cpu打断-线程2开始执行</p><p>j&#x3D;i–这个时候的线程值还是0(从主存读到缓存)</p><p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h6 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2.原子性"></a>2.原子性</h6><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><blockquote><p><strong>示例</strong>：<code>cnt++</code> 操作实际上分为读取、修改和写入三个步骤。如果两个线程同时执行这个操作，可能会出现如下情况：</p><ul><li>线程A读取 <code>cnt</code> 的值为0。</li><li>线程B也读取 <code>cnt</code> 的值为0。</li><li>线程A将 <code>cnt</code> 加1并写入1。</li><li>线程B也将 <code>cnt</code> 加1并写入1。</li><li>最终结果变成了1，而不是预期的2。</li></ul></blockquote><h6 id="3-有序性问题"><a href="#3-有序性问题" class="headerlink" title="3.有序性问题"></a>3.有序性问题</h6><p>编译器优化</p><p><strong>概念</strong>：编译器和 CPU 优化可能导致指令执行顺序与代码书写顺序不一致，这种现象称为指令重排序。在多线程情况下，这种重排序可能会导致某个线程在读取共享变量时，未能获得最新的值。</p><p><strong>示例</strong>：如果线程A在执行时对某个变量进行了修改，线程B在执行时可能读取的是该变量修改前的值。这种情况在缺乏合适的同步机制时尤为常见。</p><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/java-jmm-3.png" alt="img"></p><h5 id="Java-Memory-Model"><a href="#Java-Memory-Model" class="headerlink" title="Java Memory Model"></a>Java Memory Model</h5><blockquote><p>Java 内存模型（Java Memory Model, JMM）是 Java 语言规范的一部分，定义了 Java 程序中变量的读写规则，特别是在多线程环境下，确保程序的可见性、原子性和有序性。JMM 是解决并发问题的重要基础</p></blockquote><p>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p><h6 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h6><p><strong>概念</strong>：原子性指操作要么完全成功，要么完全失败，不会被其他线程干扰。</p><blockquote><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 </p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = <span class="hljs-number">10</span>;        //语句<span class="hljs-number">1</span>: 直接将数值<span class="hljs-number">10</span>赋值给x，也就是说线程执行这个语句的会直接将数值<span class="hljs-number">10</span>写入到工作内存中<br><span class="hljs-attribute">y</span> = x;         //语句<span class="hljs-number">2</span>: 包含<span class="hljs-number">2</span>个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这<span class="hljs-number">2</span>个操作都是原子性操作，但是合起来就不是原子性操作了。<br><span class="hljs-attribute">x</span>++;           //语句<span class="hljs-number">3</span>： x++包括<span class="hljs-number">3</span>个操作：读取x的值，进行加<span class="hljs-number">1</span>操作，写入新的值。<br><span class="hljs-attribute">x</span> = x + <span class="hljs-number">1</span>;     //语句<span class="hljs-number">4</span>： 同语句<span class="hljs-number">3</span><br><br><br></code></pre></td></tr></table></figure><p>上面4个语句只有语句1的操作具备原子性。</p><blockquote><p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p></blockquote><p>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过<strong>synchronized</strong>和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><hr><p><strong>synchronized 关键字</strong>：将方法或代码块声明为 <code>synchronized</code>，保证在同一时刻只有一个线程可以执行该部分代码，从而确保对共享变量的操作是原子的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h6><p><strong>概念</strong>：可见性是指一个线程对共享变量的修改，其他线程能够及时看到。</p><p><strong>解决方案</strong>：</p><ul><li><strong>volatile 关键字</strong>：使用 <code>volatile</code> 修饰的变量保证所有线程对该变量的读写都直接作用于主内存，而不是线程的工作内存。这样，当一个线程修改 <code>volatile</code> 变量时，其他线程会立即看到这个变化。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>()</span> &#123;<br>    cnt++;  <span class="hljs-comment">// 这里 cnt 仍然需要保证原子性</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote></blockquote><blockquote></blockquote><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在<strong>释放锁之前会将对变量的修改刷新到主存当中</strong>。因此可以保证可见性。</p><hr><p><code>volatile</code> 确保所有线程读取 <code>cnt</code> 时，都能看到其他线程对 <code>cnt</code> 的最新写入值。</p><p>它避免了线程从自己的<strong>工作内存</strong>中读取缓存值，而是直接从<strong>主内存</strong>中读取变量的最新值。</p><p>cpu切换-导致的线程安全还是无法解决</p><h6 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h6><p><strong>概念</strong>：有序性指程序中操作的执行顺序可能与代码的书写顺序不同。编译器和 CPU 会优化代码，使其执行效率更高，但这可能导致线程看到的执行顺序与预期不一致。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241021142509540.png" alt="image-20241021142509540"></p><h5 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h5><p>ps:该规则保证了代码的有序性</p><h6 id="1-单一线程原则"><a href="#1-单一线程原则" class="headerlink" title="1.单一线程原则"></a>1.单一线程原则</h6><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><p>一个线程中的操作按照代码顺序执行。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/single-thread-rule.png" alt="image"></p><h6 id="2-锁规则"><a href="#2-锁规则" class="headerlink" title="2.锁规则"></a>2.锁规则</h6><p>一个线程对锁的解锁操作 先行于下一个线程对同一锁的加锁操作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/monitor-lock-rule.png" alt="image"></p><h6 id="3-volatile-变量规则"><a href="#3-volatile-变量规则" class="headerlink" title="3.volatile 变量规则"></a>3.volatile 变量规则</h6><p>对 <code>volatile</code> 变量的<strong>写操作先行于后续对该变量的读操作。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/volatile-variable-rule.png" alt="image"></p><h6 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4.线程启动规则"></a>4.线程启动规则</h6><p>主线程对 <code>Thread.start()</code> 的调用先行于新线程的任何动作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/thread-start-rule.png" alt="image"></p><p>5.线程终止规则</p><p>线程的所有操作先行于线程的终止。</p><h5 id="线程安全问题探究"><a href="#线程安全问题探究" class="headerlink" title="线程安全问题探究"></a>线程安全问题探究</h5><p>一个类在可以被多个线程安全调用时就是线程安全的。</p><p><strong>线程安全不是一个非真即假的命题</strong>，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h6 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1.不可变"></a>1.不可变</h6><p>不可变对象的状态一旦创建就不能改变，因此是最简单的线程安全形式。所有线程可以同时访问不可变对象而不需要担心数据竞争问题。</p><blockquote><p>final 关键字修饰的基本数据类型</p><p>String</p><p>枚举类型</p><p>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</p></blockquote><h6 id="2-绝对线程安全问题"><a href="#2-绝对线程安全问题" class="headerlink" title="2.绝对线程安全问题"></a>2.绝对线程安全问题</h6><p>绝对线程安全的类或对象在任何情况下都能确保线程安全，无论客户端程序员如何调用它，都不需要采取额外的同步措施。</p><p>例如：Java 标准库中的 <code>ConcurrentHashMap</code>，它提供了完整的线程安全保证，在多线程环境中使用时无需额外的同步。</p><h6 id="3-相对线程安全问题"><a href="#3-相对线程安全问题" class="headerlink" title="3.相对线程安全问题"></a>3.相对线程安全问题</h6><blockquote><p>某个对象在大多数情况下是线程安全的，但在特定条件下，可能仍然会出现竞争条件。它允许在通常情况下，多个线程可以安全地访问对象或方法，但在某些特定场景下，需要开发者额外关注以避免问题。</p></blockquote><p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p><p>例子</p><p><strong>例子</strong>： Java 中的 <code>Vector</code> 类被认为是线程安全的，因为其所有的关键方法都进行了同步控制。</p><p>对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorUnsafeExample</span> &#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>            &#123;<br>                vector.add(i);<br>            &#125;<br>            <span class="hljs-comment">///  //使用线程池管理线程。newCachedThreadPool() 会根据需要动态创建线程</span><br>            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>            executorService.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>                &#123;<br>                    vector.remove(i);<br>                &#125;<br>            &#125;);<br>            executorService.shutdown();<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上-</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;pool-1-thread-1&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArrayIndexOutOfBoundsException</span>: Array index out of range: <span class="hljs-number">53</span><br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Vector</span><span class="hljs-selector-class">.remove</span>(Vector<span class="hljs-selector-class">.java</span>:<span class="hljs-number">831</span>)<br>at VectorUnsafeExample.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(VectorUnsafeExample<span class="hljs-selector-class">.java</span>:<span class="hljs-number">19</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.runWorker</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1142</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span><span class="hljs-selector-class">.run</span>(ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">617</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)<br></code></pre></td></tr></table></figure><p><code>Vector</code> 的 <code>add</code> 和 <code>remove</code> 操作本身是线程安全的，它们各自通过同步块控制了并发访问，但是它们之间没有同步。但问题在于，<code>for</code> 循环的遍历和删除是一个复合操作</p><blockquote><p><strong>线程A</strong> 开始遍历 <code>Vector</code>，<code>i = 0</code>，<code>size()</code> 返回 100。</p><p><strong>线程B</strong> 在某一时刻删除或添加了元素，使 <code>Vector</code> 的大小发生变化（比如减少或增加）。</p><p><strong>线程A</strong> 继续执行 <code>remove(i)</code> 时，可能会发生以下两种情况：</p><ol><li><strong>索引越界</strong>：<code>remove(i)</code> 尝试访问一个已不存在的索引，触发 <code>ArrayIndexOutOfBoundsException</code>。</li><li><strong>删除错误的元素</strong>：由于 <code>remove</code> 操作会使元素向前移动，下一个 <code>i</code> 对应的元素可能已经发生了改变，导致删除了错误的元素。</li></ol></blockquote><p>如线程池执行任务-那一块的删除就会出现问题-出现线程安全问题</p><p>解决方法-手动同步</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorUnsafeExample</span> &#123;<br>    private  <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector=<span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>            &#123;<br>                vector.add(i);<br>            &#125;<br>            <span class="hljs-regexp">///  //</span>使用线程池管理线程。newCachedThreadPool() 会根据需要动态创建线程<br>            ExecutorService executorService = Executors.newCachedThreadPool();<br>            executorService.execute<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                synchronized (vector) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        vector.remove(i);</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">executorService</span>.<span class="hljs-title">execute</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                synchronized (vector) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        vector.get(i);</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">executorService</span>.<span class="hljs-title">shutdown</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h6 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4.线程兼容"></a>4.线程兼容</h6><p><strong>线程兼容</strong>表示一个对象或方法本身不是线程安全的，但可以在多线程环境中安全使用，前提是开发者在外部使用正确的同步机制进行保护。换句话说，这种对象不是天然线程安全的，但可以通过外部措施使其安全。</p><p><strong>例子</strong>： Java 中的 <code>ArrayList</code> 不是线程安全的，但如果你在多线程环境下使用时，在外部加锁进行同步，它也可以安全地工作。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">List&lt;Integer&gt; list <span class="hljs-operator">=</span> new ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br>synchronized (list) &#123;<br>    list.add(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5.线程对立"></a>5.线程对立</h6><p>示某个对象或方法在多线程环境中是危险的，它没有任何内置的线程安全保障，也无法通过外部的同步措施轻易解决这个问题。多个线程同时访问时，可能会导致不可预知的结果，甚至可能引发致命的错误。</p><p><strong>例子</strong>： 假设一个对象<strong>依赖线程本地的状态或使用全局变量</strong>，而不加控制。这种设计会导致严重的线程冲突问题。比如，<strong>某个对象在多个线程间共享****，而对象内部大量使用非线程安全的全局变量来存储状态，这会导致竞态条件和错误的结果。</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeCounter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> increment() &#123;<br>        <span class="hljs-keyword">count</span>++;  <span class="hljs-comment">// 这个操作在多线程下不是原子的，会导致数据错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这个问题可以通过加锁来解决，但有些情况下，当对象依赖线程本地状态或使用全局变量时，光靠外部加锁并不能解决线程冲突问题。比如：</p><p><strong>非线程安全的全局变量</strong>：即使你对某个方法加锁，<strong>如果多个线程共享的全局状态没有同步保护</strong>，仍然可能导致线程间的冲突。</p><p><strong>对象的设计导致难以加锁</strong>：有些对象的操作流程过于复杂，单靠简单的加锁可能会导致性能问题，或者难以确保所有相关的操作都在锁的保护下完成。</p><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><h5 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h5><p>实现线程安全的方法主要通过控制共享资源的访问方式来防止竞态条件。互斥方法通过加锁机制（如 <code>synchronized</code>、<code>Lock</code>）来确保同一时刻只有一个线程访问共享资源，从而避免冲突。选择合适的线程安全实现方法要根据具体应用场景和性能要求，常见的方法有：</p><ol><li><strong>锁机制</strong>（如 <code>synchronized</code>、<code>ReentrantLock</code>）</li><li><strong>原子类</strong>（如 <code>AtomicInteger</code>）</li><li><strong>读写锁</strong>（如 <code>ReadWriteLock</code>）</li><li><strong>线程局部变量</strong>（如 <code>ThreadLocal</code>）</li></ol><h6 id="1-互斥锁-Lock"><a href="#1-互斥锁-Lock" class="headerlink" title="1.互斥锁 Lock"></a>1.互斥锁 Lock</h6><blockquote><p>互斥锁是一种保证线程安全的基本机制。通过加锁，确保某个临界区的代码在同一时间只能被一个线程执行，从而避免多个线程同时操作共享资源。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeCounter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> Lock lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            count++;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-type">SafeCounter</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeCounter</span>();<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br><br>                    s.increment();<br><br>            &#125;;<br>        Thread[] threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">1000</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)<br>            &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>                threads[i]=thread1;<br>                thread1.start();<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            threads[i].join();  <span class="hljs-comment">// 等待每个线程结束</span><br>        &#125;<br><br><br>        System.out.println(s.getCount());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>ReentrantLock</code> 是 Java 中常用的锁，允许线程多次进入锁定的代码段。</p><h6 id="2-同步方法-Synchronized-Method"><a href="#2-同步方法-Synchronized-Method" class="headerlink" title="2.同步方法(Synchronized Method)"></a>2.同步方法(Synchronized Method)</h6><p><code>Synchronized</code> 关键字是 Java 中最简单的实现互斥的方式。<strong>它自动加锁和解锁</strong>，确保同一时刻只有一个线程可以执行同步方法。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">synchronized</span>   <span class="hljs-type">void</span>  <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>synchronized</code> 保证了隐式锁定当前对象实例 (<code>this</code>)，从而确保了线程安全。</p><h6 id="3-同步代码块-（Synchronized-Block）"><a href="#3-同步代码块-（Synchronized-Block）" class="headerlink" title="3.同步代码块 （Synchronized Block）"></a>3.同步代码块 （Synchronized Block）</h6><p>如果你不想整个方法都被锁住，而只是想对某一部分代码进行同步，可以使用同步代码块。在 Java 中，使用 <code>synchronized</code> 关键字对某个特定的对象或类进行加锁。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object o= <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  increment() &#123;<br><span class="hljs-keyword">synchronized</span> (o)<br>&#123;<br>    <span class="hljs-keyword">count</span>++;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p>这里使用了 <code>synchronized(lock)</code> 对代码块进行加锁，而不是整个方法。这样可以更灵活地控制锁的粒度，提升程序性能。</p></blockquote><h6 id="4-原子类操作-非互斥"><a href="#4-原子类操作-非互斥" class="headerlink" title="4.原子类操作-非互斥"></a>4.原子类操作-非互斥</h6><blockquote><p>Java 提供了一些原子类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，它们通过底层硬件指令保证线程安全，并且性能优于 <code>synchronized</code> 或显式的锁机制。使用这些类可以在不加锁的情况下实现线程安全的自增或自减操作。</p></blockquote><p>类似于-redis的操作</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> AtomicInteger count=<span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  <span class="hljs-title">increment</span>()</span> &#123;<br>        <span class="hljs-comment">//原子性操作</span><br>        count.incrementAndGet();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> count.<span class="hljs-keyword">get</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>原子性操作-就是不可被打断的操作-当我+的时候，线程不会被切换(理论上)</p><h6 id="5-线程局部变量-非互斥"><a href="#5-线程局部变量-非互斥" class="headerlink" title="5.线程局部变量-非互斥"></a>5.线程局部变量-非互斥</h6><p><code>ThreadLocal</code> 是一种避免线程之间共享变量的机制。每个线程都维护一个自己的局部变量副本，这样就不需要使用锁来保证线程安全。</p><p>每个线程都会有自己的 <code>threadLocalCount</code>，不同线程之间的副本互不干扰，因此没有线程安全问题。</p><p><code>ThreadLocal</code> 适用于数据只在线程内访问、不需要跨线程共享的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocalCount = ThreadLocal.withInitial(() -&gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        threadLocalCount.set(threadLocalCount.get() + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> threadLocalCount.get();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-读写锁"><a href="#6-读写锁" class="headerlink" title="6.读写锁"></a>6.读写锁</h6><p>对于那些读多写少的场景，使用 <code>ReadWriteLock</code> 可以提高并发性能。<code>ReadWriteLock</code> 提供了读锁和写锁：</p><ul><li><strong>读锁</strong>允许多个线程同时读取资源。</li><li><strong>写锁</strong>则是独占的，确保只有一个线程可以进行写操作。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> final ReentrantReadWriteLock <span class="hljs-keyword">lock</span>=<span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br><span class="hljs-function"><span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  <span class="hljs-title">increment</span>()</span> &#123;<br>    <span class="hljs-comment">//原子性操作</span><br>    <span class="hljs-keyword">lock</span>.writeLock().<span class="hljs-keyword">lock</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        count++;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">lock</span>.writeLock().unlock();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>    <span class="hljs-keyword">lock</span>.readLock().<span class="hljs-keyword">lock</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">lock</span>.readLock().unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="7-无锁算法-非互斥"><a href="#7-无锁算法-非互斥" class="headerlink" title="7.无锁算法 非互斥"></a>7.无锁算法 非互斥</h6><blockquote><p>无锁算法通过使用底层的原子操作，如 CAS（Compare-And-Swap），来避免显式加锁。无锁算法可以提高并发性能，减少上下文切换的开销。</p></blockquote><p>Java 的 <code>ConcurrentHashMap</code>、<code>AtomicReference</code> 就是使用无锁机制的例子。</p><p><code>compareAndSet()</code> 是 CAS 操作，它不依赖锁来保证线程安全。</p><p>无锁算法适合高并发场景，减少了线程阻塞。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SafeCounter</span> &#123;<br>  <span class="hljs-keyword">private</span> AtomicReference&lt;Integer&gt; <span class="hljs-keyword">value</span>=<span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  <span class="hljs-title">increment</span>()</span> &#123;<br>        Integer currentValue;<br>        Integer newValue;<br>        <span class="hljs-keyword">do</span> &#123;<br>            currentValue = <span class="hljs-keyword">value</span>.<span class="hljs-keyword">get</span>();       <span class="hljs-comment">// 获取当前值</span><br>            newValue = currentValue + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 计算新值</span><br>        &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">value</span>.compareAndSet(currentValue, newValue));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>.<span class="hljs-keyword">get</span>().intValue();<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote></blockquote><blockquote><p><code>while</code> 循环的存在是为了确保操作成功。如果多个线程同时访问共享变量，可能会有线程在 <code>compareAndSet</code> 期间修改了该变量的值，从而导致当前线程的 CAS 操作失败。这时，线程必须重新获取最新的值，再次尝试更新，直到成功为止。</p></blockquote><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。</p><h6 id="1-Cas"><a href="#1-Cas" class="headerlink" title="1.Cas"></a>1.Cas</h6><blockquote><p><strong>CAS</strong>（Compare-And-Swap，比较并交换）是一种用于实现多线程同步的原子操作，它的主要特点是无锁的，并通过硬件指令直接支持，能够有效避免传统锁机制带来的性能开销。</p></blockquote><blockquote><p>CAS 操作包含三个参数：</p><ul><li><strong>内存位置</strong>：表示要操作的变量地址。</li><li><strong>预期值（Expected Value）</strong>：期望的当前值。</li><li><strong>新值（New Value）</strong>：希望更新为的新值。</li></ul></blockquote><p>无锁算法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SafeCounter</span> &#123;<br>  <span class="hljs-keyword">private</span> AtomicReference&lt;Integer&gt; <span class="hljs-keyword">value</span>=<span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  <span class="hljs-title">increment</span>()</span> &#123;<br>        Integer currentValue;<br>        Integer newValue;<br>        <span class="hljs-keyword">do</span> &#123;<br>            currentValue = <span class="hljs-keyword">value</span>.<span class="hljs-keyword">get</span>();       <span class="hljs-comment">// 获取当前值</span><br>            newValue = currentValue + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 计算新值</span><br>        &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">value</span>.compareAndSet(currentValue, newValue));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>.<span class="hljs-keyword">get</span>().intValue();<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>while</code> 循环的存在是为了确保操作成功。如果多个线程同时访问共享变量，可能会有线程在 <code>compareAndSet</code> 期间修改了该变量的值，从而导致当前线程的 CAS 操作失败。这时，线程必须重新获取最新的值，再次尝试更新，直到成功为止。</p></blockquote><h6 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2.AtomicInteger"></a>2.AtomicInteger</h6><p>J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 <strong>Unsafe</strong> 类的 CAS 操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> AtomicInteger count=<span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  <span class="hljs-title">increment</span>()</span> &#123;<br>        <span class="hljs-comment">//原子性操作</span><br>        count.incrementAndGet();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> count.<span class="hljs-keyword">get</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 <strong>unsafe</strong> 的 getAndAddInt() 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">incrementAndGet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，<strong>var1 指示对象内存地址</strong>，<strong>var2 指示该字段相对对象内存地址的偏移</strong>，<strong>var4 指示操作需要加的数值</strong>，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<span class="hljs-comment">//拿到旧值</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br> <span class="hljs-comment">// CAS 比较：如果内存地址中的值等于 var5，则更新为 var5 + var4；否则重试，直到成功</span><br><br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解释了 CAS 操作的重试机制和自旋锁的工作原理。</p><p>类似于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeCounter</span> &#123;<br>  <span class="hljs-keyword">private</span> AtomicReference&lt;Integer&gt; value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span>     <span class="hljs-keyword">void</span>  <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        Integer currentValue;<br>        Integer newValue;<br>        <span class="hljs-keyword">do</span> &#123;<br>            currentValue = value.get();       <span class="hljs-comment">// 获取当前值</span><br>            newValue = currentValue + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 计算新值</span><br>        &#125; <span class="hljs-keyword">while</span> (!value.compareAndSet(currentValue, newValue));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value.get().intValue();<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="3-aba"><a href="#3-aba" class="headerlink" title="3.aba"></a>3.aba</h6><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h6 id="1-栈封闭"><a href="#1-栈封闭" class="headerlink" title="1.栈封闭"></a>1.栈封闭</h6><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><h6 id="2-线程共享"><a href="#2-线程共享" class="headerlink" title="2.线程共享"></a>2.线程共享</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241022110821411.png" alt="image-20241022110821411"></p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExample</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        ThreadLocal threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();<br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            threadLocal.set(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                Thread.sleep(<span class="hljs-number">1000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            System.out.println(threadLocal.get());</span></span><br><span class="hljs-params"><span class="hljs-function">            threadLocal.remove();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">thread2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            threadLocal.set(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            threadLocal.remove();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">thread1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">thread2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">------</span><br><span class="hljs-function">著作权归@<span class="hljs-title">pdai</span>所有</span><br><span class="hljs-function">原文链接：<span class="hljs-title">https</span>://<span class="hljs-title">pdai</span>.<span class="hljs-title">tech</span>/<span class="hljs-title">md</span>/<span class="hljs-title">java</span>/<span class="hljs-title">thread</span>/<span class="hljs-title">java-thread-x-theorty</span>.<span class="hljs-title">html</span></span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3646544a-cb57-451d-9e03-d3c4f5e4434a.png" alt="image"></p><h6 id="3-可重入代码"><a href="#3-可重入代码" class="headerlink" title="3.可重入代码"></a>3.可重入代码</h6><p>这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue</title>
    <link href="/2024/10/19/%E5%89%8D%E7%AB%AF/vue/Vue/"/>
    <url>/2024/10/19/%E5%89%8D%E7%AB%AF/vue/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h2><h4 id="vue了解"><a href="#vue了解" class="headerlink" title="vue了解"></a>vue了解</h4><p>Vue.js 是一个专注于构建用户界面的渐进式 JavaScript 框架，主要用于<strong>视图层</strong>的开发。以下是关于 Vue.js 视图层的几个核心特点：</p><p>1.声明式渲染</p><p>Vue 使用模板语法，允许你以声明式的方式将数据与 DOM 显示绑定。数据发生变化时，视图会自动更新。常见的绑定包括文本插值 <code>&#123;&#123;&#125;&#125;</code> 和指令，如 <code>v-bind</code>、<code>v-if</code>、<code>v-for</code> 等。</p><p>2.组件化</p><p>Vue 的一个重要特性是组件系统，视图可以被拆分成多个独立的、可复用的组件。每个组件都有自己的 HTML 模板、JavaScript 逻辑和 CSS 样式，从而实现视图的模块化开发。</p><p>3.响应式数据绑定</p><p>Vue 的核心是一个响应式系统，当数据对象中的属性发生变化时，Vue 能自动跟踪这些变化并触发视图的更新。你无需手动操作 DOM，Vue 会自动处理视图更新。</p><p>4.单文件组件 (SFC)</p><p>Vue 支持将模板、脚本和样式都写在 <code>.vue</code> 文件中，这种单文件组件形式提高了开发的可维护性。</p><p>5.指令系统</p><p>Vue 提供了一系列内置指令，用于操作 DOM，如 <code>v-model</code> 实现表单双向数据绑定，<code>v-for</code> 用于列表渲染，<code>v-if</code> 用于条件渲染等。</p><p>6.虚拟 DOM</p><p>Vue 使用虚拟 DOM 机制，在每次数据变化时，不会直接操作真实 DOM，而是<strong>更新一个轻量级的虚拟 DOM</strong>，最后通过最小化的操作将变化应用到实际 DOM，提升性能。</p><h4 id="vue使用"><a href="#vue使用" class="headerlink" title="vue使用"></a>vue使用</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./vue3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//引入vue3</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;counter&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--vue的语法，告诉vue，这个里面放了一个变量 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">num</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">uname</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Counter</span>=&#123;</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="hljs-comment">//配置对象--数据会传入</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">data</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">num</span>:<span class="hljs-number">0</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">uname</span>:<span class="hljs-string">&quot;张三&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">///.mount进行了数据绑定</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">///创建并挂载一个 Vue 应用，并通过控制台输出应用的实例对象</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">let</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">Counter</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#counter&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(app);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>这一部分表示通过 <code>Vue.createApp()</code> 方法创建了一个新的 Vue 应用实例，并将 <code>Counter</code> 组件作为这个应用的根组件。<code>Counter</code> 通常是一个定义好的 Vue 组件对象，可能包括模板、数据和方法等。</p></blockquote><blockquote><p><code>mount()</code> 方法的作用是将创建的 Vue 应用挂载到 DOM 中指定的元素上。在这个例子中，它会找到页面中 ID 为 <code>#counter</code> 的元素，并将 Vue 应用的内容渲染到这个元素中。页面中的 <code>#counter</code> 可能是这样的一个元素：</p></blockquote><h4 id="vite安装"><a href="#vite安装" class="headerlink" title="vite安装"></a>vite安装</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> create vue@latest<br>输入项目名字<br>是否安装一堆插件<br>生产完毕<br></code></pre></td></tr></table></figure><h4 id="目录导航"><a href="#目录导航" class="headerlink" title="目录导航"></a>目录导航</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241019154109301.png" alt="image-20241019154109301"></p><p>index.html</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    //引入mainjs<br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>main.js</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br>createApp(App).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>创建vue示例*app.vue。绑定了app.vue</p><p>app.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br> <br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> &gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="Dom介绍"><a href="#Dom介绍" class="headerlink" title="Dom介绍"></a>Dom介绍</h4><blockquote><p>前端页面的数据最终需要通过 DOM（文档对象模型，Document Object Model）来显示到网页上。DOM 是浏览器用来表示和操作 HTML 或 XML 文档的一种编程接口。前端开发中，无论是纯 HTML、JavaScript、Vue、React 还是其他前端框架，最终都是通过 DOM 来将数据呈现在网页上。</p></blockquote><p>DOM 与数据的关系</p><ul><li><p><strong>HTML 定义结构</strong>：最初，页面的内容是通过 HTML 标记定义的静态 DOM 结构。</p></li><li><pre><code class="java">&lt;div&gt;  &lt;p&gt;这是静态的文本&lt;/p&gt;&lt;/div&gt;<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>**JavaScript 操作 DOM**：通过 JavaScript，可以动态操作 DOM，改变页面中的内容，比如添加、删除或修改元素。这种操作是手动的。<br><br>```java<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> data = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>).<span class="hljs-property">innerText</span> = data;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure>**Vue/React 等框架的虚拟 DOM**：现代前端框架如 Vue 和 React 引入了虚拟 DOM（Virtual DOM）的概念，这是一种抽象层，框架首先在虚拟 DOM 中更新数据，最后将必要的变化应用到真实 DOM 中。这样做大大提高了性能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>&lt;/div&gt;<br><br>&lt;script&gt;<br>  <span class="hljs-type">const</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> Vue.createApp(&#123;<br>    data() &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        message: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h4><blockquote><p>声明式渲染的核心在于<strong>数据的响应式特性</strong>。在Vue.js中，响应式系统确保当数据变化时，视图（DOM）会自动更新以反映这些变化。这种机制使得开发者可以专注于数据本身，而不是数据如何影响DOM。Vue 将根据数据的变化自动更新视图</p></blockquote><p>dom监测数据变化-更新视图-vue实现了这个自动的过程</p><h6 id="1-数据驱动"><a href="#1-数据驱动" class="headerlink" title="1.数据驱动"></a>1.数据驱动</h6><blockquote><p>Vue 的核心理念是<strong>数据驱动的视图更新</strong>。你只需定义数据，并在模板中使用该数据，Vue 会自动将数据绑定到视图中。例如：</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">num</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">uname</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">它将数据对象中的 `message` 自动渲染在 DOM 元素中。当 `message` 的值改变时，Vue 会自动更新页面中的文本内容，而无需手动修改 DOM。</span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">///数据导出-进行绑定</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)</span></span><br><span class="language-javascript"><span class="language-xml">&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">num</span>:<span class="hljs-number">0</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">uname</span>:<span class="hljs-string">&quot;张三&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241019161001285.png" alt="image-20241019161001285"></p><h6 id="2-双向绑定"><a href="#2-双向绑定" class="headerlink" title="2.双向绑定"></a>2.双向绑定</h6><p>Vue 提供了双向数据绑定，通过 <code>v-model</code> 指令可以将输入的值直接与数据绑定。当用户在输入框中输入内容时，数据会自动更新，视图也会相应变化：–将数据与dom绑定了</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span> </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h6 id="3-指令与模板语法"><a href="#3-指令与模板语法" class="headerlink" title="3.指令与模板语法"></a>3.指令与模板语法</h6><p>Vue 的声明式渲染还包含一系列常用的指令，比如：</p><ul><li><code>v-bind</code>: 动态绑定属性。</li><li><code>v-if</code> &#x2F; <code>v-show</code>: 条件渲染。</li><li><code>v-for</code>: 列表渲染。</li><li><code>v-on</code>: 事件绑定。</li></ul><p>这些指令允许开发者通过数据来控制 DOM 的显示和行为。</p><h4 id="声明式渲染实现"><a href="#声明式渲染实现" class="headerlink" title="声明式渲染实现"></a>声明式渲染实现</h4><p>Vue 的声明式渲染基于其<strong>响应式系统</strong>与<strong>虚拟 DOM</strong>，它通过跟踪数据变化来自动更新视图</p><h6 id="1-响应式系统"><a href="#1-响应式系统" class="headerlink" title="1.响应式系统"></a>1.响应式系统</h6><p>Vue 创建了一个<strong>响应式数据模型</strong>，通过 <code>Object.defineProperty</code>（Vue 2）或 <code>Proxy</code>（Vue 3）实现对数据的劫持。每当数据发生变化时，Vue 能够检测到这个变化，并自动触发视图更新。</p><p>Vue 会<strong>为每个数据属性创建依赖追踪机制</strong>，当数据改变时当数据（如 <code>message</code>）发生变化时，Vue 记录这个变化，并将其标记为“需要更新”</p><h6 id="2-模板编译"><a href="#2-模板编译" class="headerlink" title="2.模板编译"></a>2.模板编译</h6><p>Vue 将模板编译为一个渲染函数，这个函数可以动态生成虚拟 DOM。它根据数据创建一个抽象的虚拟 DOM 树，而不是直接修改实际的 DOM。</p><h6 id="3-虚拟dom"><a href="#3-虚拟dom" class="headerlink" title="3.虚拟dom"></a>3.虚拟dom</h6><p>当数据变化时，Vue 会通过重新执行渲染函数生成新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行比较（Diff 算法）。这个过程确保了 Vue 只更新必要的 DOM 节点，而不是重新渲染整个页面，极大地提高了性能。</p><h6 id="4-dom更新"><a href="#4-dom更新" class="headerlink" title="4.dom更新"></a>4.dom更新</h6><p>最后，Vue 会将虚拟 DOM 的变化应用到真实的 DOM 中。通过最小化的 DOM 操作（只更新变化部分），Vue 能够在性能和开发效率之间找到平衡。</p><h6 id="5-自动更新视图"><a href="#5-自动更新视图" class="headerlink" title="5.自动更新视图"></a>5.自动更新视图</h6><p>最终，用户在浏览器中看到的视图就会自动根据数据的变化进行更新，开发者不需要手动操作 DOM。</p><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><p>Vue 的模板语法是一种声明式的 HTML 扩展，它允许你将数据绑定到 DOM 结构中。通过 Vue 的模板语法，你可以轻松地将数据、属性、事件等与 HTML 模板绑定，完成动态更新。</p><h5 id="1-插值"><a href="#1-插值" class="headerlink" title="1.插值"></a>1.插值</h5><h6 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h6><p>最常见的用法是将 JavaScript 表达式的值插入到 HTML 中。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><h6 id="绑定-HTML"><a href="#绑定-HTML" class="headerlink" title="绑定 HTML"></a>绑定 HTML</h6><p>可以使用 <code>v-html</code> 指令将 HTML 内容插入到元素中。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-html=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br><br></code></pre></td></tr></table></figure><p>如果 <code>rawHtml</code> 是 <code>&#39;&lt;span&gt;Bold&lt;/span&gt;&#39;</code>，那么页面会显示 <code>Bold</code> 作为内嵌 HTML，而不仅仅是普通文本。</p><h5 id="2-指令"><a href="#2-指令" class="headerlink" title="2.指令"></a>2.指令</h5><p>指令是带有 <code>v-</code> 前缀的特殊属性，用来动态地绑定 DOM 的功能。</p><h6 id="1-条件渲染"><a href="#1-条件渲染" class="headerlink" title="1.条件渲染"></a>1.条件渲染</h6><p>条件渲染（<code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>）</p><p>根据条件动态渲染元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>当 <code>seen</code> 为 <code>true</code> 时，<code>&lt;p&gt;</code> 标签会显示，否则不会显示。</p><h6 id="2-循环渲染"><a href="#2-循环渲染" class="headerlink" title="2.循环渲染"></a>2.循环渲染</h6><p>循环遍历一个数组或者对象并渲染出相应的 DOM 结构。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.text</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>items</code> 是一个数组，<code>item.text</code> 被插值显示在列表项中。</p><h6 id="3-事件监听"><a href="#3-事件监听" class="headerlink" title="3.事件监听"></a>3.事件监听</h6><p><code>v-on</code> 用于监听 DOM 事件，并在事件触发时执行 JavaScript 代码。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> v-<span class="hljs-keyword">on</span>:click=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;点击我&lt;/<span class="hljs-keyword">button</span>&gt;<br><br></code></pre></td></tr></table></figure><p>简写形式：<code>@click=&quot;doSomething&quot;</code>。</p><h6 id="4-双向数据绑定"><a href="#4-双向数据绑定" class="headerlink" title="4.双向数据绑定"></a>4.双向数据绑定</h6><p><code>v-model</code> 实现了表单元素的双向数据绑定，它会自动同步用户输入与 JavaScript 数据。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>当用户在输入框中输入时，<code>message</code> 的值会自动更新，并实时反映在 <code>&lt;p&gt;</code> 中。</p><h4 id="3-属性绑定"><a href="#3-属性绑定" class="headerlink" title="3.属性绑定"></a>3.属性绑定</h4><p><code>v-bind</code> 用于动态地绑定 HTML 属性。它可以让你根据数据动态更改属性值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img v-bind:<span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;imageSrc&quot;</span>&gt;<br><br></code></pre></td></tr></table></figure><p>简写形式：<code>:src=&quot;imageSrc&quot;</code>。如果 <code>imageSrc</code> 是图片的 URL，它会被绑定到 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性。</p><h4 id="4-计算属性"><a href="#4-计算属性" class="headerlink" title="4.计算属性"></a>4.计算属性</h4><p>当模板中的表达式过于复杂时，可以使用计算属性来简化。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">reversedMessage</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">computed: &#123;<br>  <span class="hljs-built_in">reversedMessage</span>() &#123;<br>    return this<span class="hljs-selector-class">.message</span><span class="hljs-selector-class">.split</span>(<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-selector-class">.reverse</span>()<span class="hljs-selector-class">.join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>计算属性会基于其依赖进行缓存，只有依赖的数据变化时，才会重新计算。</p><h4 id="5-侦听器"><a href="#5-侦听器" class="headerlink" title="5.侦听器"></a>5.侦听器</h4><p>vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。 更适合异步操作</p><h6 id="1-监听普通变化数据"><a href="#1-监听普通变化数据" class="headerlink" title="1.监听普通变化数据"></a>1.监听普通变化数据</h6><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">watch:&#123;<br>  <span class="hljs-comment">//监听数据变化</span><br>  message:<span class="hljs-keyword">function</span>(<span class="hljs-params">newValue,oldValue</span>)<br>  &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newValue);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(oldValue);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">message: &#123;<br>   <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//初始化的时候调用函数</span><br>   handler: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newValue);<br>   &#125;,<br> &#125;,<br></code></pre></td></tr></table></figure><h6 id="2-对象监听"><a href="#2-对象监听" class="headerlink" title="2.对象监听"></a>2.对象监听</h6><p>深度监听</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">  user:&#123;<br>    <span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">handler</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>)&#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newValue);<br>     &#125;,<br><span class="hljs-comment">//深度遍历根值-给每个值上侦听器</span><br><br>  &#125;,<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//单个侦听器</span><br><span class="hljs-string">&quot;user.name&quot;</span>:&#123;<br>  <span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">handler</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>)<br>  &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newValue);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-事件修饰符"><a href="#6-事件修饰符" class="headerlink" title="6.事件修饰符"></a>6.事件修饰符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- .stop 阻止事件冒泡 --&gt;<br>   &lt;div <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;divClick&quot;</span>&gt;<br>     &lt;button <span class="hljs-meta">@click</span>.stop=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;按钮&lt;/button&gt;<br>   &lt;/div&gt;<br>    <span class="hljs-comment">//默认点击会直接调用两个函数-但是阻止后只会执行btnClick</span><br>   &lt;!-- .prevent 阻止默认行为 --&gt;<br>   &lt;form action=<span class="hljs-string">&quot;&quot;</span>&gt;<br>     &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span> <span class="hljs-meta">@click</span>.prevent=<span class="hljs-string">&quot;submitClick&quot;</span>&gt;<br>   &lt;/form&gt;<br>    <span class="hljs-comment">//修改表单提交后的代码</span><br>   &lt;!-- .once 只触发一次回调--&gt;<br>   &lt;button <span class="hljs-meta">@click</span>.once=<span class="hljs-string">&quot;onceClick&quot;</span>&gt;只触发一次once&lt;/button&gt;<br>    <span class="hljs-comment">//防止多次点击</span><br>   &lt;!-- .&#123;keyCode（键盘编码） | keyAlias （键盘的简写）&#125;监听键盘的某个键帽 --&gt;<br>   &lt;input type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-meta">@keyup</span>.enter=<span class="hljs-string">&quot;keyUp&quot;</span>&gt;<br>    <span class="hljs-comment">//回车提交</span><br></code></pre></td></tr></table></figure><h4 id="7-Data"><a href="#7-Data" class="headerlink" title="7.Data"></a>7.Data</h4><p><code>data</code> 是一个组件选项，用于定义组件实例的初始数据。 它返回一个对象-这个对象有内部数据</p><p>作用 1.存储组件数据2.方便数据响应式3.初始化数据</p><h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a><strong>缩写</strong></h4><p>Vue 为常用的指令提供了缩写形式：</p><ul><li><code>v-bind</code> 缩写为 <code>:</code></li><li><code>v-on</code> 缩写为 <code>@</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img :<span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;imageSrc&quot;</span>&gt;<br>&lt;button @<span class="hljs-attribute">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;点击我&lt;/button&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> v-<span class="hljs-keyword">on</span>:click=<span class="hljs-string">&quot;changeUname&quot;</span>&gt;更改名字<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">button</span>&gt;<br>&lt;<span class="hljs-keyword">button</span> @click=<span class="hljs-string">&quot;changeUname&quot;</span>&gt;更改名字&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。</p><p>例子-:id&#x3D;:”id”</p><p>id就是动态参数 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;p :<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;v-binde绑定&lt;/p&gt;<br> <span class="hljs-built_in">id</span>:<span class="hljs-string">&quot;xxs&quot;</span><br>// 语法糖 :=v-bind<br> &lt;p v-bind:<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;id + 1&quot;</span>&gt;v-bind绑定&lt;/p&gt;<br></code></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="1-计算属性-监听器"><a href="#1-计算属性-监听器" class="headerlink" title="1.计算属性  监听器"></a>1.计算属性  监听器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br>&lt;script &gt;<br><span class="hljs-comment">///数据导出-进行绑定</span><br>export <span class="hljs-keyword">default</span>&#123;<br>data()<br>&#123;<br>  <span class="hljs-keyword">return</span>&#123;<br>    message: <span class="hljs-string">&quot;helloWorld&quot;</span>,<br>    user:&#123;<br>      name: <span class="hljs-string">&quot;张三&quot;</span>,<br>        age: <span class="hljs-number">18</span>,<br>        sex: <span class="hljs-string">&quot;男&quot;</span>,<br>    &#125;<br>  &#125;<br>&#125;,<br>methods:&#123;<br>  setmessage:function()<br>  &#123;<br>    <span class="hljs-built_in">this</span>.message=<span class="hljs-string">&quot;你以&quot;</span><br>  &#125;<br><br><br>&#125;,<br>computed:&#123;<br>  reverseMsg:&#123;<br>    <span class="hljs-comment">//有set和get方法</span><br><br>    get: function ()&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;,<br>    set : function()&#123;<br>   <span class="hljs-comment">//在设置或者更改计算属性的时候调用</span><br>   console.log(newValue);<span class="hljs-comment">//你好</span><br>        <span class="hljs-built_in">this</span>.message=newValue<br>    &#125;<br>  &#125;<br><br><br>&#125;,<br>watch:&#123;<br>  <span class="hljs-comment">//监听数据变化</span><br>  message:function(newValue,oldValue)<br>  &#123;<br><br>    console.log(newValue);<br>    console.log(oldValue);<br>  &#125;,<br>  user:&#123;<br>    deep:<span class="hljs-literal">true</span>,<br>    handler:function(newValue)&#123;<br>            console.log(newValue);<br>     &#125;,<br><span class="hljs-comment">//深度遍历根值-给每个值上侦听器</span><br><br>  &#125;,<br>  <span class="hljs-comment">//单个侦听器</span><br>  <span class="hljs-string">&quot;user.name&quot;</span>:&#123;<br>    deep:<span class="hljs-literal">true</span>,<br>    handler:function(newValue)<br>    &#123;<br>      console.log(newValue);<br>    &#125;<br>  &#125;<br><br><br>&#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br> &lt;div&gt;<br>&lt;P&gt;&#123;&#123;reverseMsg&#125;&#125;&lt;/P&gt;<br>&lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;setmessage&quot;</span>&gt;改变message&lt;/button&gt;<br> &lt;/div&gt;<br>    <br>&lt;/template&gt;<br><br>&lt;style &gt;<br><br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><h5 id="2-模板语法插值"><a href="#2-模板语法插值" class="headerlink" title="2.模板语法插值"></a>2.模板语法插值</h5><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">///数据导出-进行绑定</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)</span></span><br><span class="language-javascript"><span class="language-xml">&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">num</span>:<span class="hljs-number">0</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">uname</span>:<span class="hljs-string">&quot;张三&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;&lt;h2&gt;标题&lt;/h2&gt;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">id</span>:<span class="hljs-string">&quot;1&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">dtcs</span>:<span class="hljs-string">&quot;id&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">mouseEvent</span>:<span class="hljs-string">&quot;click&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">changeUname</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uname</span>=<span class="hljs-string">&quot;李四&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">num</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">uname</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>  <span class="hljs-attr">v-once</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">uname</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeUname&quot;</span>&gt;</span>更改名字<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>v-binde绑定<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">//语法糖</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;changeUname&quot;</span>&gt;</span>更改名字2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;id + 1&quot;</span>&gt;</span>v-bind绑定<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">dtcs</span>]=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>动态参数<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @[<span class="hljs-attr">mouseEvent</span>]=<span class="hljs-string">&quot;changeUname&quot;</span>&gt;</span> 动态事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;mouseEvent=&#x27;mouseover&#x27;&quot;</span>&gt;</span>改变事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> &gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><h2 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h2><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>Vue.js 组件是构建用户界面的基本单元，它允许我们将应用程序分割为独立的、可复用的模块。每个组件本质上是一个具有特定功能的 Vue 实例，可以包含 HTML 模板、CSS 样式和 JavaScript 逻辑。通过这种方式，我们可以构建模块化、可维护的代码。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241019202515650.png" alt="image-20241019202515650"></p><p>例如一个页面-有导航-有侧边-我们只需要单独写组件-达到分模块开发</p><h5 id="1-编写一个组件"><a href="#1-编写一个组件" class="headerlink" title="1.编写一个组件"></a>1.编写一个组件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">P</span>&gt;</span>女孩<span class="hljs-tag">&lt;/<span class="hljs-name">P</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用组件–局部组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">WelcomeItem</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/WelcomeItem.vue&#x27;</span>;<br><span class="hljs-comment">//导入组件</span><br><br><span class="hljs-comment">//2.注册组件</span><br><span class="hljs-attr">components</span>:&#123;<br>  <span class="hljs-title class_">WelcomeItem</span><br>&#125;<br><br><span class="hljs-comment">///3.使用</span><br>&lt;template&gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>ww<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WelcomeItem</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">WelcomeItem</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>    <br>&lt;/template&gt;<br><br><br></code></pre></td></tr></table></figure><p>全局组件</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Vue</span><span class="hljs-selector-class">.component</span>(<span class="hljs-string">&#x27;MyComponent&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 组件定义</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><h5 id="2-组件父子关系探究"><a href="#2-组件父子关系探究" class="headerlink" title="2.组件父子关系探究"></a>2.组件父子关系探究</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241019203254583.png" alt="image-20241019203254583"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">///3.使用<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>ww<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">WelcomeItem</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">WelcomeItem</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <br>//假设组件未APP.VUE<br></code></pre></td></tr></table></figure><p>那么APP.VUE的子组件就是<WelcomeItem></p><h5 id="3-父子组件通信探究"><a href="#3-父子组件通信探究" class="headerlink" title="3.父子组件通信探究"></a>3.父子组件通信探究</h5><h6 id="1-父传子"><a href="#1-父传子" class="headerlink" title="1.父传子"></a>1.父传子</h6><p>父组件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;<span class="hljs-title class_">WelcomeItem</span> <span class="hljs-symbol">:message=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/WelcomeItem&gt;</span><br>message 是 <span class="hljs-title class_">WelcomeItem</span> 组件的一个 props 名称。<br>msg 是一个父组件中的数据属性，它的值会被动态地传递给 <span class="hljs-title class_">WelcomeItem</span> 组件的 message props。<br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;template&gt;<br>&lt;P&gt;女孩&lt;/P&gt;<br>&lt;h2&gt;&#123;&#123; messaget &#125;&#125;&lt;/h2&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br> export <span class="hljs-keyword">default</span>&#123;<br>props:&#123;<span class="hljs-comment">//这里接受数据</span><br>    messaget:&#123;<br>    typE:String,<br>  <br>    required:<span class="hljs-literal">true</span><br>  &#125;<br>  &#125;<br>  <span class="hljs-comment">//对象</span><br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h6 id="2-props特性"><a href="#2-props特性" class="headerlink" title="2.props特性"></a>2.props特性</h6><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">props:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-comment">//这里接受数据</span><br><span class="hljs-symbol">    messaget:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    typE:</span>String,<span class="hljs-comment">//传递的数据类型</span><br><span class="hljs-symbol">      default:</span><span class="hljs-string">&quot;你好&quot;</span>,<br><span class="hljs-symbol">    required:</span>true<span class="hljs-comment">//是否未必传</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>向下数据流–父传子数据-父数据改变数据会随之改变-</p><p>但如果在子数据内发生改变 数据不会具有响应性</p><p>ps：思考怎么写</p><p>传递数据 -&gt;传递的是指针数据-父组件</p><p>子组件拿到数据-进行拷贝一份展示-同时监听真实的指针数据-如果更改就修改拷贝数据</p><h6 id="3-子传父-emit"><a href="#3-子传父-emit" class="headerlink" title="3.子传父 emit"></a>3.子传父 emit</h6><p>通过自定义事件向父组件传值</p><p>子组件传递数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>发送数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span>&#123;<br>     <span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;xxw1w1s&quot;</span><br>   &#125;<br> &#125;,<br> <span class="hljs-attr">methods</span>:&#123;<br><br>   <span class="hljs-attr">sendMessage</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)<br>   &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>);<br>     <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;inMeg&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>)<span class="hljs-comment">//点击子组件的按钮-触发inMEg,传递参数</span><br>     <span class="hljs-comment">////$emit 是一个实例方法，用于在 Vue 实例上触发自定义事件。</span><br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>–父组件中监听该事件</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&lt;WelcomeItem @inMeg=<span class="hljs-string">&quot;getme&quot;</span>&gt;&lt;<span class="hljs-regexp">/WelcomeItem&gt;/</span>/监听事件<br><span class="hljs-comment">///////</span><br>methods:&#123;<br><span class="hljs-attr">getme</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)<br>&#123;<br>      this.msg=value<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value)<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="4-父组件拿取子组件数据-ref"><a href="#4-父组件拿取子组件数据-ref" class="headerlink" title="4.父组件拿取子组件数据 ref"></a>4.父组件拿取子组件数据 ref</h6><p>props-是父传递给子-现在是主动拿 -</p><blockquote><p>采取refs特性</p><p>注册组件-将组件的空间首地址or(指向空间首地址)保存下来给父组件留一份</p><p>父组件通过该地址访问数据</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>//勾起引用-hello<br><br><span class="hljs-tag">&lt;<span class="hljs-name">WelcomeItem</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">WelcomeItem</span>&gt;</span><br>//将子组件的地址引用拿到-&gt;编译器拿取<br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>数据访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)<br>&#123;<br>  <span class="hljs-comment">///$refs是一个对象，其中包含了注册在组件上的所有引用。</span><br>  <span class="hljs-comment">///这些引用可以是子组件或者是具有ref特性的DOM元素。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">hello</span>.<span class="hljs-property">msg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="子组件访问父组件和根组件"><a href="#子组件访问父组件和根组件" class="headerlink" title="子组件访问父组件和根组件"></a>子组件访问父组件和根组件</h6><p>访问方式-子组件开辟-保持了父组件和根组件的指向</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//对象</span><br><span class="hljs-function"><span class="hljs-title">mounted</span><span class="hljs-params">()</span></span><br>&#123;<br>  console<span class="hljs-selector-class">.log</span>(this.<span class="hljs-variable">$parent</span>.msg)<br>  console<span class="hljs-selector-class">.log</span>(this.<span class="hljs-variable">$root</span>)<br>&#125;直接访问即可<br></code></pre></td></tr></table></figure><h4 id="组件跨级通信"><a href="#组件跨级通信" class="headerlink" title="组件跨级通信"></a>组件跨级通信</h4><h5 id="1-跨级通信问题"><a href="#1-跨级通信问题" class="headerlink" title="1.跨级通信问题"></a>1.跨级通信问题</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241019210620933.png" alt="image-20241019210620933"></p><p>数据从-父组件-子组件</p><p>1.props传递</p><p>2.子组件一次访问嵌套下去</p><p>都浪费资源</p><p>跨级通信-不能嵌套传</p><p>解决方法1</p><p>父组件有一个<strong>provide</strong>选项来提供数据  子组件接收 <strong>inject</strong></p><p>1.父组件提供数据 provide inject</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)<br>&#123;<br>  <span class="hljs-comment">///$refs是一个对象，其中包含了注册在组件上的所有引用。</span><br>  <span class="hljs-comment">///这些引用可以是子组件或者是具有ref特性的DOM元素。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">hello</span>.<span class="hljs-property">msg</span>);<br>&#125;,<br><span class="hljs-attr">provide</span>:&#123;<br><span class="hljs-attr">messageqq</span>:<span class="hljs-string">&quot;wsum&quot;</span><br>        <br>    &#125;<span class="hljs-comment">//提供数据</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>2.n子组件接受数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)</span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span>&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">message</span>:<span class="hljs-string">&quot;sumsumsum&quot;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">inject</span>:[<span class="hljs-string">&#x27;messageqq&#x27;</span>]</span><br><span class="language-javascript"> </span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-data传递"><a href="#2-data传递" class="headerlink" title="2.data传递"></a>2.data传递</h5><p>–访问组件实例属性–要根据函数形式返回对象–返回对象传递给子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span>&#123;<br>    <span class="hljs-attr">messageqq</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">msgto</span><br>  &#125;<br>  <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-传递响应式"><a href="#3-传递响应式" class="headerlink" title="3.传递响应式"></a>3.传递响应式</h5><p>provide-inject传递的数据非响应式-我们如何让他具有响应式呢</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">data</span><span class="hljs-params">()</span></span><br>&#123;return &#123;<br><br>  msgto:<span class="hljs-string">&quot;我APP&quot;</span>,<br>  obj:&#123;<br>                message:<span class="hljs-string">&quot;我是你&quot;</span><br>            &#125;<br>    &#125;<br>    listq:<span class="hljs-selector-attr">[1,2,3,4]</span><br>&#125;,<br><br><span class="hljs-function"><span class="hljs-title">provide</span><span class="hljs-params">()</span></span>&#123;<br>  return&#123;<br>    obj:this<span class="hljs-selector-class">.obj</span>,<span class="hljs-comment">//传递对象过去-&gt;指针传递</span><br>  &#125;<br><br>        <br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"> inject:[&#x27;obj&#x27;,&#x27;messa&#x27;]</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">obj.message</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">messa</span>()&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>方法2.函数返回</p><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>)&#123;<br><br> <span class="hljs-keyword">return</span>&#123;<br>  <span class="hljs-attr">messa</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">msgto</span><br> &#125;<br><br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>子</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"> inject:[&#x27;obj&#x27;,&#x27;messa&#x27;]</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">messa</span>()&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>多个页面共用一个组件-需要展示的各不相同-</p><p>就可以使用插槽</p><blockquote><p><strong>插槽</strong>（Slots）是一种允许组件的使用者传递内容到组件内部的机制。这使得组件在结构上更加灵活和可复用。插槽的主要作用是让组件可以接受任意外部传递的模板内容，而不局限于组件自身的模板定义。</p></blockquote><h5 id="插槽的使用"><a href="#插槽的使用" class="headerlink" title="插槽的使用"></a>插槽的使用</h5><h6 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h6><blockquote><p>具名插槽可以让我们定义多个插槽，并根据名称向不同的插槽中插入不同的内容。</p></blockquote><p>组件内附带插槽</p><!-- 子组件 --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">P</span>&gt;</span>女孩<span class="hljs-tag">&lt;/<span class="hljs-name">P</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮text<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>//备用插槽<br><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;h2&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插槽显示</p><!-- 父组件 --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>//勾起引用-hello<br><br><span class="hljs-tag">&lt;<span class="hljs-name">WelcomeItem</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:text</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>占领插槽<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>h2插槽<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">WelcomeItem</span>&gt;</span><br><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h6><p>作用域插槽允许<strong>子组件将数据传递给父组件，并由父组件决定如何渲染这些数据。这种模式特别适合需要高度自定义的组件，如列表或卡片等。</strong></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>User: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.name</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ChildComponent</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 作用域插槽，子组件传递数据给父组件 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:user</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">user</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><h2 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h2><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>自行配图-整个vue的特性围绕此展开<br>虚拟dom和dom的交换</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020102751407.png" alt="image-20241020102751407">Vue.js 组件的生命周期包括一系列的钩子函数，它们可以让我们<strong>在组件的不同阶段执行自定义的逻辑</strong>。这些生命周期钩子函数可以分为三大类：<strong>创建阶段、更新阶段和销毁阶段</strong>。<br>创建阶段</p><p>创建阶段</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">beforeCreate</span>：<br>    在实例初始化之后，数据观测 (<span class="hljs-class"><span class="hljs-keyword">data</span> observer) 和 event/watcher 事件配置之前被调用。</span><br>    此时组件实例还未初始化完成，无法访问 <span class="hljs-class"><span class="hljs-keyword">data</span>、methods、computed、watch 等数据和方法。</span><br><br><span class="hljs-title">created</span>：<br>    在实例创建完成后被立即调用。<br>    可以访问 <span class="hljs-class"><span class="hljs-keyword">data</span>、methods、computed、watch 等数据和方法，但 <span class="hljs-type">DOM</span> 元素尚未被挂载。</span><br></code></pre></td></tr></table></figure><p>挂载阶段</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">beforeMount：<br>    在挂载开始之前被调用：相关的 render 函数首次被调用。<br><br>mounted：<br>    <span class="hljs-keyword">el</span> 被新创建的 <span class="hljs-keyword">vm</span>.$<span class="hljs-keyword">el</span> 替换，并挂载到实例上去之后调用该钩子函数。<br>    实例已经挂载到 DOM 上，可以执行 DOM 操作。<br></code></pre></td></tr></table></figure><p>更新阶段</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">beforeUpdate：<br><span class="hljs-code">    数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</span><br><span class="hljs-code"></span><br>updated：<br><span class="hljs-code">    由于数据更改导致的虚拟 DOM 重新渲染和打补丁后调用。</span><br><span class="hljs-code">    可以执行依赖于 DOM 的操作，但大部分的 DOM 操作应该在 mounted 钩子中完成。</span><br></code></pre></td></tr></table></figure><p>销毁阶段</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">beforeDestroy：<br><span class="hljs-code">    实例销毁之前调用。在这一步，实例仍然完全可用。</span><br><span class="hljs-code"></span><br>destroyed：<br><span class="hljs-code">    实例销毁后调用。该钩子被调用时，Vue 实例指示的所有东西都会解绑定，所有事件监听器会被移除，所有子实例也会被销毁。</span><br></code></pre></td></tr></table></figure><p>激活与停用阶段</p><p>除了上述主要的生命周期钩子，Vue 还提供了<strong>激活 (activated) 和停用 (deactivated) 钩子</strong>，这些钩子是用于 Vue 实例在 keep-alive 组件中切换时调用的。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">activated</span>：<br>    被 <span class="hljs-meta">keep</span>-alive 缓存的组件激活时调用。<br><br><span class="hljs-symbol">deactivated</span>：<br>    被 <span class="hljs-meta">keep</span>-alive 缓存的组件停用时调用。<br></code></pre></td></tr></table></figure><p>错误处理阶段</p><p>另外还有一个错误捕获钩子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">errorCaptured：<br>    当捕获一个来自子孙组件的错误时被调用<br></code></pre></td></tr></table></figure><p>这些生命周期钩子函数提供了在组件生命周期不同阶段执行代码的能力，帮助我们管理组件的初始化、数据更新、销毁以及错误处理等情况。通过合理利用这些钩子，可以更好地控制和优化 Vue.js 应用的行为和性能。</p><p>使用示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>)<br>    &#123;<br><br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h4><blockquote><p>组合式 API（Composition API）是 Vue 3 中引入的一种新的代码组织方式，旨在替代 Vue 2 中的选项式 API（Options API）。它通过函数和钩子等形式，使得开发者可以更加灵活地组合和复用逻辑，尤其是在项目复杂度较高时，逻辑的拆分和复用变得更加清晰。</p><p>在组件被创建前创建-很多数据的访问只能通过挂载的方式</p></blockquote><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><h6 id="1-setUP函数"><a href="#1-setUP函数" class="headerlink" title="1.setUP函数"></a>1.setUP函数</h6><blockquote><p><strong><code>setup</code> 函数</strong>：组合式 API 的核心，组件创建时调用，在 <code>setup</code> 中定义响应式数据、计算属性、侦听器等逻辑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> &#123; reactive, ref &#125; from <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br>export <span class="hljs-keyword">default</span> &#123;<br>  setup() &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> ref(<span class="hljs-number">0</span>); <span class="hljs-comment">// 响应式数据</span><br>    <span class="hljs-type">const</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> reactive(&#123; name: <span class="hljs-string">&#x27;组合式 API&#x27;</span> &#125;); <span class="hljs-comment">// 响应式对象</span><br><br>    function <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>      count.value++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123; count, state, increment &#125;; <span class="hljs-comment">// 公开这些数据和方法给模板使用</span><br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><h6 id="2-响应式api"><a href="#2-响应式api" class="headerlink" title="2.响应式api"></a>2.响应式api</h6><p><code>ref</code>：用于定义基本类型的响应式变量。</p><p><code>reactive</code>：用于定义对象类型的响应式数据。</p><p><code>computed</code>：创建计算属性，基于现有响应式数据自动更新。</p><h6 id="3-生命周期钩子"><a href="#3-生命周期钩子" class="headerlink" title="3.生命周期钩子"></a>3.生命周期钩子</h6><p>在 <code>setup</code> 中使用 <code>onMounted</code>、<code>onUpdated</code>、<code>onUnmounted</code> 等函数来处理组件的生命周期事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件已挂载&#x27;</span>);<br>    &#125;);<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><h6 id="4-自定义组合函数"><a href="#4-自定义组合函数" class="headerlink" title="4.自定义组合函数"></a>4.自定义组合函数</h6><blockquote><p>可以将功能逻辑封装到独立的函数中，并在不同组件中复用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    count.<span class="hljs-property">value</span>++;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> &#123; count, increment &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; count, increment &#125; = <span class="hljs-title function_">useCounter</span>();<br>    <span class="hljs-keyword">return</span> &#123; count, increment &#125;;<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><h6 id="5-watch使用"><a href="#5-watch使用" class="headerlink" title="5.watch使用"></a>5.watch使用</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020104252644.png" alt="image-20241020104252644"></p><p>-———<br>对象深度监听-上面无法获取到旧值</p><p> watcheffect<br>-——–</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020104326723.png" alt="image-20241020104326723"></p><p>收集函数体内监听的数据-创建完后执行回调watcheffect方法</p><p>监听区别</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020104337713.png" alt="image-20241020104337713"></p><h6 id="6-computed"><a href="#6-computed" class="headerlink" title="6.computed"></a>6.computed</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020104430727.png" alt="image-20241020104430727"></p><p>只需要调用computed即可</p><p>特性一样</p><p>本地拿取-是对象-需要指定值<br>外部会自动解析</p><h6 id="7-props探究"><a href="#7-props探究" class="headerlink" title="7.props探究"></a>7.props探究</h6><p>接收</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020104627902.png" alt="image-20241020104627902"></p><h6 id="8-props-context"><a href="#8-props-context" class="headerlink" title="8.props context"></a>8.props context</h6><p>props-context-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020104731622.png" alt="image-20241020104731622"></p><p>context作用</p><p>1.拿到属性和id-<br>2.插槽<br>3.触发事件<br><strong>子传父-事件触发</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105131325.png" alt="image-20241020105131325"></p><p>父组件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105241638.png" alt="image-20241020105241638"></p><p>4.渲染换上</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105313336.png" alt="image-20241020105313336"></p><p>h-渲染函数<br>其余数据丢失-div-+数据-替换contect内容</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105343253.png" alt="image-20241020105343253"></p><p>替换</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105355304.png" alt="image-20241020105355304"></p><h6 id="9-setup-property"><a href="#9-setup-property" class="headerlink" title="9.setup property"></a>9.setup property</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105507358.png" alt="image-20241020105507358"></p><p>跨级通信解决</p><p>父-传子-多层级问题</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105541229.png" alt="image-20241020105541229"></p><p>父组件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105602164.png" alt="image-20241020105602164"></p><p>子组件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105621717.png" alt="image-20241020105621717"></p><p>响应式-就需要ref传递-传递name-ref的对象引用 方便监听</p><h6 id="10-set-Up语法糖"><a href="#10-set-Up语法糖" class="headerlink" title="10.set Up语法糖"></a>10.set Up语法糖</h6><p>自动导出</p><p>setup组合式语法糖<br>SFC语法模范</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105704880.png" alt="image-20241020105704880"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105716014.png" alt="image-20241020105716014"></p><p>例子<br>无需注册–vue3</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105733803.png" alt="image-20241020105733803"></p><p>内数据不需要自己导出</p><p>原因</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020105756613.png" alt="image-20241020105756613"></p><h2 id="4-0"><a href="#4-0" class="headerlink" title="4.0"></a>4.0</h2><h4 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h4><h5 id="1-了解路由"><a href="#1-了解路由" class="headerlink" title="1.了解路由"></a>1.了解路由</h5><p>Vue-Router是官方路由 它与vue.js集成-让构建单体应用更加简单</p><p>可实现页面跳转<br>核心:改变url-不会整体刷新-部分地方刷新</p><blockquote><p>路由本质上是一种<strong>路径（key）与处理逻辑（value）之间的映射</strong>。路径代表 URL 中的特定部分，而处理逻辑则决定了当用户访问该路径时应该执行的操作或显示的内容。</p></blockquote><blockquote><p>路由表是这种映射的集合，每个路由（路径）对应一种处理方式。无论是在前端还是后端，路由表的结构通常遵循类似的逻辑：</p><ul><li><strong>Key</strong>：路径（URL），例如 <code>/home</code>、<code>/profile/:id</code>，它表示用户在浏览器地址栏中访问的具体位置。</li><li><strong>Value</strong>：当用户访问该路径时，应该执行的处理逻辑。在后端，这通常是一个函数（处理请求），而在前端，它通常是一个组件（渲染页面）。</li></ul></blockquote><p>指向-<br>路由表-映射表-一个路由就是映射关系<br>key-vaule<br>key-路径<br>vaule-函数或者组件<br>后端-function<br>component-组件 -前端内容</p><h5 id="2-路由案例"><a href="#2-路由案例" class="headerlink" title="2.路由案例"></a>2.路由案例</h5><p>1.安装</p><p>2.创建路由实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> &#123; createRouter,createMemoryHistory, createWebHashHistory &#125; from <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-keyword">import</span> sumsum from <span class="hljs-string">&quot;@/components/sumsum.vue&quot;</span>;<br><span class="hljs-keyword">import</span> WelcomeItem from <span class="hljs-string">&quot;@/components/WelcomeItem.vue&quot;</span>;<br><span class="hljs-comment">//定义路由表</span><br>const routes=[<br>    &#123;path:<span class="hljs-string">&#x27;/&#x27;</span>,component:home&#125;,<br>    &#123;path:<span class="hljs-string">&#x27;about&#x27;</span>,component:About&#125;,<br>]<br><span class="hljs-comment">//创建路由实例</span><br>const router=createRouter(<br><br>    &#123;<br>        history:createWebHashHistory(),<span class="hljs-comment">//路由历史模式</span><br>        routes,<span class="hljs-comment">//路由表</span><br><br>    &#125;<br>)<br>export <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>3.路由表挂载</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> <span class="hljs-keyword">app</span>=createApp(<span class="hljs-keyword">App</span>)<br><span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(router)<br><span class="hljs-keyword">app</span>.mount(&#x27;#<span class="hljs-keyword">app</span>&#x27;)<br></code></pre></td></tr></table></figure><p>4.路由使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Go to home<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>go about<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RouterView</span>&gt;</span>//路由出口<br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><RouterLink><p>使的不重新刷新页面也能获得数据</p><h5 id="3-动态路由匹配"><a href="#3-动态路由匹配" class="headerlink" title="3.动态路由匹配"></a>3.动态路由匹配</h5><p>例子-ID不同显示的数据不同</p><p>lu.js</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">const routes=[<br>    &#123;<span class="hljs-built_in">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,component:sumsum&#125;,<br>    &#123;<span class="hljs-built_in">path</span>:<span class="hljs-string">&#x27;/about/:id&#x27;</span>,component:WelcomeItem&#125;,<br>]<br></code></pre></td></tr></table></figure><p>app.vue</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;RouterLink <span class="hljs-keyword">to</span>=<span class="hljs-string">&quot;/about/123&quot;</span>&gt;go <span class="hljs-keyword">about</span>&lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure><p>数据拿取 :WelcomeItem</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">this.$route.params.id</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>setup周期拿</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; useRoute  &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">useRoute</span>().<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="4-404规则匹配"><a href="#4-404规则匹配" class="headerlink" title="4.404规则匹配"></a>4.404规则匹配</h5><p>使用正则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;/:path(.*)&#x27;</span> ,component:NotFound&#125;,<br>:动态<br></code></pre></td></tr></table></figure><h5 id="5-路由正则"><a href="#5-路由正则" class="headerlink" title="5.路由正则"></a>5.路由正则</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020111220037.png" alt="image-20241020111220037"></p><p>-——<br>多参数 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020111229197.png" alt="image-20241020111229197"></p><p>-———<br>参数有无</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020111252156.png" alt="image-20241020111252156"></p><h5 id="6-嵌套路由"><a href="#6-嵌套路由" class="headerlink" title="6.嵌套路由"></a>6.嵌套路由</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020111315638.png" alt="image-20241020111315638"></p><p>如图路径&#x2F;aboute&#x2F;sum展示</p><p>在路由出口后继续展示</p><p>1.main.js</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;/about/:id/&#x27;</span>,component:WelcomeItem<br>    ,children:[<br>        &#123;<br>            <span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;styleone&#x27;</span>,<br>            component:styleone<br>        &#125;,&#123;<br>            <span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;wo&#x27;</span>,<br>            component:styleTwo<br>        &#125;<br>    ]<br>&#125;,<br></code></pre></td></tr></table></figure><p>2.组件内</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">this.$route.params.id</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/12/styleone&quot;</span>&gt;</span>样式1<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/12/wo&quot;</span>&gt;</span>样式2<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RouterView</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="7-命名视图-路由"><a href="#7-命名视图-路由" class="headerlink" title="7.命名视图 路由"></a>7.命名视图 路由</h5><p>1.命名路由</p><p>直接命名路由</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,name:<span class="hljs-string">&#x27;sy&#x27;</span>,component:sumsum&#125;,<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;name:&#x27;sy&#x27;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Go to home<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2.命名试图</p><p>给对于的<strong>组件试图命名</strong>-来展示选择</p><p>一个页面展示多个路由-而不是嵌套展示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>&#123;<span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;/gogogo&#x27;</span> ,components:&#123;<br><br>    default:styleone,<br>    styleTwo:styleTwo,<br>    sumsum:sumsum<br>&#125;&#125;,<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/gogogo&quot;</span>&gt;</span>go mmm<br><span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RouterView</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;styleTwo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RouterView</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sumsum&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RouterView</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="路由编程导航"><a href="#路由编程导航" class="headerlink" title="路由编程导航"></a>路由编程导航</h4><h6 id="1-push"><a href="#1-push" class="headerlink" title="1.push"></a>1.push</h6><p>routre-link很难进行逻辑</p><p>我们通过<strong>routre</strong>实例方法来进行</p><p><strong>例如routre.push-该方法向history栈添加记录-用户可使用浏览器回退功能</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;button @<span class="hljs-attribute">click</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$router</span>.push(&#x27;/about/123&#x27;)&quot;</span>&gt;about&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>使用方式2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;goabout&quot;</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">methods:&#123;<br>  goabout:<span class="hljs-keyword">function</span><span class="hljs-params">()</span><br>  <br>  &#123;<br>    <span class="hljs-comment">//逻辑判断</span><br>    <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">&#x27;/about/123&#x27;</span>)<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>带参数方式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php">methods:&#123;<br>  goabout:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">  </span>&#123;<br>    this.<span class="hljs-variable">$router</span>.<span class="hljs-title function_ invoke__">push</span>(&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/about&quot;</span>,<span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;123&#x27;</span>&#125;&#125;)<br>  &#125;<br><br>&#125;<br><br>http:<span class="hljs-comment">//localhost:5173/#/about?id=123</span><br></code></pre></td></tr></table></figure><h6 id="2-go-前后跳"><a href="#2-go-前后跳" class="headerlink" title="2.go 前后跳"></a>2.go 前后跳</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">methods:&#123;<br>  goabout:<span class="hljs-built_in">function</span>()<br>  &#123;<br>   this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.go</span>(<span class="hljs-number">1</span>)<br>  &#125;<br><br>&#125;<br><br><span class="hljs-selector-class">.back</span> <span class="hljs-built_in">-go</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-selector-class">.forword</span> <span class="hljs-built_in">go</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>数字为正向前跳转</p><p>为负向后跳转 </p><p>必须保证栈中中有值</p><h4 id="重定向路由"><a href="#重定向路由" class="headerlink" title="重定向路由"></a>重定向路由</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;name:&#x27;sy&#x27;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Go to home<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>重定向路由-路径不会刷新-但是内容会更改属于内部操作</p><p>动态路由</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//定义路由表<br>const routes=[<br>    &#123;<span class="hljs-type">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-type">name</span>:<span class="hljs-string">&#x27;sy&#x27;</span>,<br>    <br>    redirect:(<span class="hljs-keyword">to</span>)=&gt;&#123;<br>        console.log(<span class="hljs-keyword">to</span>)<br>        <span class="hljs-keyword">return</span>&#123;<span class="hljs-type">path</span>:&quot;/about.to&quot;&#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>例如登录可以在不需要守卫的情况下写</p><h4 id="路由别名"><a href="#路由别名" class="headerlink" title="路由别名"></a>路由别名</h4><p>路由多路径</p><p>路径-&gt;映射的还是path页面</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;/gogogo&#x27;</span> ,    alias:<span class="hljs-string">&#x27;/father&#x27;</span>,components:&#123;<br><br>    default:styleone,<br>    styleTwo:styleTwo,<br>    sumsum:sumsum<br>&#125;&#125;,<br></code></pre></td></tr></table></figure><h4 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;id&#x27;</span>],</span><br><span class="language-javascript">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;/about/:id/&#x27;</span>,component:WelcomeItem,<br>props:true//开启<br>    ,children:[<br>        &#123;<br>            <span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;styleone&#x27;</span>,<br>            component:styleone<br>        &#125;,&#123;<br>            <span class="hljs-selector-tag">path</span>:<span class="hljs-string">&#x27;wo&#x27;</span>,<br>            component:styleTwo<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是-拿到路径参数-会以id_传递给子组件-子组件有对应的就接收</p><p>2.组合式api使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112441902.png" alt="image-20241020112441902"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112446164.png" alt="image-20241020112446164"></p><p>命名试图开启props</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112454784.png" alt="image-20241020112454784"></p><h4 id="不同历史模式"><a href="#不同历史模式" class="headerlink" title="不同历史模式"></a>不同历史模式</h4><p>不同的历史模式</p><h6 id="1-Hash模式"><a href="#1-Hash模式" class="headerlink" title="1.Hash模式"></a>1.Hash模式</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112520315.png" alt="image-20241020112520315"></p><p>不会向服务器发起请求</p><p>2.Html</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112537360.png" alt="image-20241020112537360"></p><p>-—-<br>设置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112545948.png" alt="image-20241020112545948"></p><p>有#的区别</p><h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><p>路由守卫<br>—-登录-验证-就需要守卫路由 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112638856.png" alt="image-20241020112638856"></p><p>1.路由全局前置守卫<br>全局拦截器 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112658230.png" alt="image-20241020112658230"></p><p>to -去 from-来字哪里<br>进入每个路由都要执行</p><p>参数next-&gt;拦截下个路径<br>next-导航守卫</p><p>next()-继续路由</p><p>———全局守卫</p><h4 id="单独守卫"><a href="#单独守卫" class="headerlink" title="单独守卫"></a>单独守卫</h4><p>单独守卫</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112745683.png" alt="image-20241020112745683"></p><p>组件内守卫 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112759086.png" alt="image-20241020112759086"></p><p>生命周期钩子</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112808400.png" alt="image-20241020112808400"></p><h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112849959.png" alt="image-20241020112849959"></p><p>全部引入-消耗过大 </p><p>当路由被访问才加载</p><p>——–静态导入改动态载入 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112917835.png" alt="image-20241020112917835"></p><ol start="2"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112925215.png" alt="image-20241020112925215"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020112931653.png" alt="image-20241020112931653"></p><h2 id="5-0"><a href="#5-0" class="headerlink" title="5.0"></a>5.0</h2><h4 id="0-Vuex-认识"><a href="#0-Vuex-认识" class="headerlink" title="0.Vuex 认识"></a>0.Vuex 认识</h4><blockquote><p>Vuex 是 Vue.js 的状态管理库，用于在 Vue 应用中集中管理多个组件共享的数据。它能有效地管理应用的全局状态，并提供统一的方式来更新和读取数据。</p></blockquote><h4 id="1-vuex-状态管理"><a href="#1-vuex-状态管理" class="headerlink" title="1.vuex 状态管理"></a>1.vuex 状态管理</h4><p>data-中设置的参数-进行集中管理-数据管理仓库</p><p>例子-发送一次请求得到的数据 不长久变化-让所有人都能拿取</p><p><strong>实现vuex</strong></p><p>1.实现响应式</p><p>ref reactive-<br>对象中存储状态</p><p>2.app提供出去-别人也能使用  仓库</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020215717314.png" alt="image-20241020215717314"></p><p>app.vue导入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020215741919.png" alt="image-20241020215741919"></p><p>拿取数据</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020215751400.png" alt="image-20241020215751400"></p><p>实现了数据共享-数据状态集中管理</p><h4 id="2-请求发送"><a href="#2-请求发送" class="headerlink" title="2.请求发送"></a>2.请求发送</h4><h5 id="1-fetch"><a href="#1-fetch" class="headerlink" title="1.fetch"></a>1.fetch</h5><p>原生JS发送请求</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220053097.png" alt="image-20241020220053097"></p><h6 id="2-axios"><a href="#2-axios" class="headerlink" title="2.axios"></a>2.axios</h6><p>自己查文档</p><p>原生的fe-的封装</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220127372.png" alt="image-20241020220127372"></p><p>1.安装<br>2.引入<br>3.使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220134869.png" alt="image-20241020220134869"></p><p>具体项目会创建请求栏</p><h6 id="3-跨域解决"><a href="#3-跨域解决" class="headerlink" title="3.跨域解决"></a>3.跨域解决</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220150604.png" alt="image-20241020220150604"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220202155.png" alt="image-20241020220202130"></p><h4 id="3-vue-cli"><a href="#3-vue-cli" class="headerlink" title="3.vue cli"></a>3.vue cli</h4><p>Vue CLI 是 Vue.js 官方提供的脚手架工具，用于快速搭建 Vue.js 项目。它的主要特性包括：</p><blockquote><p>Vue CLI 的强大之处在于其插件化系统。它内置了大量插件，可以通过命令行工具添加不同的功能，比如 Babel、TypeScript、PWA、ESLint、Vue Router 等。</p></blockquote><blockquote><p>Vue CLI 提供了一个开箱即用的开发环境，支持开发服务器、自动热更新、Lint 校验、单元测试等功能。开发者不需要手动配置 Webpack，只需要运行简单的命令即可启动开发。</p></blockquote><h6 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h6><p> 1.安装<br>2.创建项目</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220406061.png" alt="image-20241020220406061"></p><p>配置保存<br>最后一个手动配置 *选中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220412052.png" alt="image-20241020220412052"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220415545.png" alt="image-20241020220415545"></p><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><h6 id="1-vuex认识"><a href="#1-vuex认识" class="headerlink" title="1.vuex认识"></a>1.vuex认识</h6><p>vuex 是专门为vue.j开发的状态管理模式 </p><p>单向数据流 破坏问题</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220446670.png" alt="image-20241020220446670"></p><p>状态管理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220510206.png" alt="image-20241020220510206"></p><h6 id="2-vuex使用"><a href="#2-vuex使用" class="headerlink" title="2.vuex使用"></a>2.vuex使用</h6><p>1.安装</p><p>2.特性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220637799.png" alt="image-20241020220637799"></p><p>1.创建 vuex-核心仓库-state</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220653742.png" alt="image-20241020220653742"></p><p>2.main使用仓库</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220712645.png" alt="image-20241020220712645"></p><p>3.使用仓库</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220736583.png" alt="image-20241020220736583"></p><h6 id="3-mutation"><a href="#3-mutation" class="headerlink" title="3.mutation"></a>3.mutation</h6><p>唯一途径修改状态管理内数据<br>记录哪个组件改变数据</p><p>1.改变count</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220822042.png" alt="image-20241020220822042"></p><p>2.外面改变需要执行mutation函数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020220947466.png" alt="image-20241020220947466"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221018726.png" alt="image-20241020221018726"></p><p>这样根据devtools-知道谁更改了数据–</p><h6 id="4-计算属性-1"><a href="#4-计算属性-1" class="headerlink" title="4.计算属性"></a>4.计算属性</h6><p>1.添加计算属性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221127828.png" alt="image-20241020221127828"></p><p>计算属性特性<br>使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221156087.png" alt="image-20241020221156087"></p><h6 id="5-异步操作"><a href="#5-异步操作" class="headerlink" title="5.异步操作"></a>5.异步操作</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221228613.png" alt="image-20241020221228613"></p><p>vuex<br>action-vuex异步操作</p><p>1.fetch</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221240034.png" alt="image-20241020221240034"></p><p>派生触发&#x3D;dispatch</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221515299.png" alt="image-20241020221515299"></p><h6 id="5-跨域解决"><a href="#5-跨域解决" class="headerlink" title="5.跨域解决"></a>5.跨域解决</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221531442.png" alt="image-20241020221531442"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221535554.png" alt="image-20241020221535554"></p><h6 id="6-vue-x-Module"><a href="#6-vue-x-Module" class="headerlink" title="6.vue x-Module"></a>6.vue x-Module</h6><p>使用单一状态管理，整个项目的状态管理过于复杂，我们以模块化为分割</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221646942.png" alt="image-20241020221646942"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221723175.png" alt="image-20241020221723175"></p><hr><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020221748228.png" alt="image-20241020221748228"></p><p>使用需要定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020223752704.png" alt="image-20241020223752704"></p><p>包裹进入</p><p>使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020223803046.png" alt="image-20241020223803046"></p><h6 id="7-子模块获取根模块数据"><a href="#7-子模块获取根模块数据" class="headerlink" title="7.子模块获取根模块数据"></a>7.子模块获取根模块数据</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020223919232.png" alt="image-20241020223919232"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020223935500.png" alt="image-20241020223935500"></p><h6 id="8-mapState"><a href="#8-mapState" class="headerlink" title="8.mapState"></a>8.mapState</h6><p>辅助函数</p><p>将信息给导出。就可以直接使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224020666.png" alt="image-20241020224020666"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224030486.png" alt="image-20241020224030486"></p><h6 id="8-对象展开运算符"><a href="#8-对象展开运算符" class="headerlink" title="8.对象展开运算符"></a>8.对象展开运算符</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224049175.png" alt="image-20241020224049175"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224348866.png" alt="image-20241020224348866"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224354839.png" alt="image-20241020224354839"></p><p>不需要引用方式</p><h6 id="9-命名空间"><a href="#9-命名空间" class="headerlink" title="9.命名空间"></a>9.命名空间</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224411542.png" alt="image-20241020224411542"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224418492.png" alt="image-20241020224418492"></p><p>访问方法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241020224435701.png" alt="image-20241020224435701"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/400604430443dd5a23ae463ce3d0170d.png" alt="400604430443dd5a23ae463ce3d0170d"></p><p><img src="G:\360MoveData\Users\nixg\Desktop\前端学习\vue3\8.2\assets\5100a1a83cbb647b275745f92dd60e0d.png" alt="5100a1a83cbb647b275745f92dd60e0d"></p><p>命名空间。使程序更模块化<br>1.命名空间后的调用<br>2.命名空间后辅助函数导出的导出方法</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign</title>
    <link href="/2024/10/17/Middleware/feign/feign/"/>
    <url>/2024/10/17/Middleware/feign/feign/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenFeign-远程调用"><a href="#OpenFeign-远程调用" class="headerlink" title="OpenFeign-远程调用"></a>OpenFeign-远程调用</h1><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a7daefd898024466d28967eea99da8c.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a7daefd898024466d28967eea99da8c.png" alt="0a7daefd898024466d28967eea99da8c"></a></p><h6 id="1-快速入门案例"><a href="#1-快速入门案例" class="headerlink" title="1.快速入门案例"></a>1.快速入门案例</h6><p>1.导入案例</p><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png" alt="e73d3e068484e2e31915ba7653f1003c"></a></p><p>2.启动注解</p><p>快速入门案例 1.导入案例</p><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png" alt="img"></a></p><p>img</p><p>2.启动注解</p><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ed643292f8dcdbb4ff4d6e96ce00153.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ed643292f8dcdbb4ff4d6e96ce00153.png" alt="img"></a></p><p>3.代码编写</p><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8241cb4042ea1e687948cd9b6c752e4b.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8241cb4042ea1e687948cd9b6c752e4b.png" alt="8241cb4042ea1e687948cd9b6c752e4b"></a></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">private final ItemClient itemclient<span class="hljs-comment">;</span><br>List&lt;&gt;items<span class="hljs-operator">=</span>itemclient.query()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如上feign帮我们进行了 <strong>服务拉取 负载均衡 -请发送的所有工作</strong></p><h6 id="2-OpenFeign连接池"><a href="#2-OpenFeign连接池" class="headerlink" title="2.OpenFeign连接池"></a>2.OpenFeign连接池</h6><p>我们发起请求的话-需要建立连接-再销毁-但连接池可以减少这个过程产生的消耗<br>使用ok-http连接池<br>1.导入依赖<br>2.配置启用</p><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d0853161a442680c814a26edfd25d44b.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d0853161a442680c814a26edfd25d44b.png" alt="d0853161a442680c814a26edfd25d44b"></a></p><p>d0853161a442680c814a26edfd25d44b</p><p>OkHttp连接池的操作如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">连接的创建和管理: OkHttp连接池会在应用程序启动时创建一组HTTP连接，并在需要时将其保持在连接池中。这些连接可以被多个线程共享和重用，而不是每次请求都重新创建连接。</span><br><br><span class="hljs-section">连接的重用: 当一个线程需要执行一个HTTP请求时，它可以从连接池中获取一个可用的连接，而不必等待新连接的创建。如果连接池中没有可用的连接，线程可能会被阻塞，直到有连接可用为止。</span><br><br><span class="hljs-section">连接的释放: 当一个线程完成了对某个HTTP服务的请求，它会将连接放回连接池，而不是关闭连接。这样可以避免频繁地打开和关闭连接，提高了连接的重用率。</span><br>TEXT<br></code></pre></td></tr></table></figure><p>OkHttp连接池可以加快效率的原因包括：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">减少连接的创建和销毁开销：通过重用连接，可以避免频繁地创建和销毁连接，从而减少了系统资源的消耗和网络延迟。<br><br>提高并发性能：连接池可以确保连接的有效重用，从而使多个线程能够并发地共享同一个连接，提高了系统的并发处理能力。<br><br>降低网络延迟：通过重用连接和减少连接的创建次数，可以减少网络请求的等待时间，从而降低了网络延迟，提高了系统的响应速度。<br><span class="hljs-built_in">TEXT</span><br></code></pre></td></tr></table></figure><p>总的来说，OkHttp连接池的有效管理和重用HTTP连接可以显著提高应用程序的性能和效率，特别是在需要频繁进行HTTP通信的场景下。</p><p>这里的请求-是固定的 故此可以保存</p><h6 id="3-api抽取"><a href="#3-api抽取" class="headerlink" title="3.api抽取"></a>3.api抽取</h6><p>方案1 结构层次低-耦合度高<br>方案2 结构层次复杂-哦合度低<a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f85cd781db72ba5994a9b7341f64c2f.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f85cd781db72ba5994a9b7341f64c2f.png" alt="2f85cd781db72ba5994a9b7341f64c2f"></a></p><p>2f85cd781db72ba5994a9b7341f64c2f</p><h6 id="包扫描问题"><a href="#包扫描问题" class="headerlink" title="包扫描问题"></a>包扫描问题</h6><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/76f1f3f63bb3b8d05dc723f7f12117a2.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/76f1f3f63bb3b8d05dc723f7f12117a2.png" alt="76f1f3f63bb3b8d05dc723f7f12117a2"></a></p><p>76f1f3f63bb3b8d05dc723f7f12117a2</p><p>也是注册为bean-但我忘记常量注入了</p><h6 id="fegin日志配置"><a href="#fegin日志配置" class="headerlink" title="fegin日志配置"></a>fegin日志配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2e098ace474e1339c04dd1aa450c100b.png" alt="2e098ace474e1339c04dd1aa450c100b"></p><p>修改日志</p><p><a href="https://raw.githubusercontent.com/Xlan-cell/tupian/master/670ebe6e23b9c09af17b4f1e53a3f249.png"><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/670ebe6e23b9c09af17b4f1e53a3f249.png" alt="670ebe6e23b9c09af17b4f1e53a3f249"></a></p><h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><h6 id="云岚到家"><a href="#云岚到家" class="headerlink" title="云岚到家"></a>云岚到家</h6><p>配合Sentinel使用</p><p>构造API </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerClient</span>&#123;<br> <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Api Api;<br> <span class="hljs-meta">@SentinelResource(value = &quot;getAddressBookDetail&quot;, fallback = &quot;detailFallback&quot;, blockHandler = &quot;detailBlockHandler&quot;)</span><br>     <span class="hljs-keyword">public</span> AddressBookResDTO <span class="hljs-title function_">getDetail</span><span class="hljs-params">(Long id)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Api.api(id);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span>  AddressBookResDTO <span class="hljs-title function_">detailFallback</span><span class="hljs-params">(Long id, Throwable throwable)</span><br>    &#123;<br>        log.error(<span class="hljs-string">&quot;异常抛出&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  AddressBookResDTO <span class="hljs-title function_">detailBlockHandler</span><span class="hljs-params">(Long id, Throwable throwable)</span><br>    &#123;<br>        log.error(<span class="hljs-string">&quot;熔断&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>从你提供的代码来看，这是一个基于 Sentinel 进行服务熔断和降级的客户调用类 <code>CustomerClient</code>。让我为你推理一下各部分的作用和逻辑：</p><ol><li><p><strong>类定义和注解</strong></p><ul><li><code>@Component</code>：将该类注册为 Spring 的组件，使其能够被自动扫描和注入到 Spring 容器中。</li><li><code>@Resource</code>：用于注入 <code>Api</code> 接口的实现，这个 <code>Api</code> 很可能是一个远程服务的客户端，负责获取某些数据（比如地址簿信息）。</li></ul></li><li><p><strong>Sentinel 熔断与降级</strong></p><ul><li><pre><code class="hljs">@SentinelResource(value = &quot;getAddressBookDetail&quot;, fallback = &quot;detailFallback&quot;, blockHandler = &quot;detailBlockHandler&quot;)</code></pre><p>：该注解来自 Sentinel，表示这个方法会受到 Sentinel 的保护。如果服务出错或触发限流、熔断机制，将自动调用指定的降级方法和熔断处理方法。</p><ul><li><code>value = &quot;getAddressBookDetail&quot;</code>：定义该资源的名称为 <code>getAddressBookDetail</code>，用于 Sentinel 监控和保护。</li><li><code>fallback = &quot;detailFallback&quot;</code>：当方法出现异常时，会调用 <code>detailFallback</code> 方法进行降级处理。</li><li><code>blockHandler = &quot;detailBlockHandler&quot;</code>：当请求被 Sentinel 触发流控或熔断时，会调用 <code>detailBlockHandler</code> 方法进行熔断处理。</li></ul></li></ul></li><li><p><strong>核心方法 <code>getDetail(Long id)</code></strong></p><ul><li>该方法通过 <code>Api.api(id)</code> 调用外部 API 或服务，获取某个 ID 对应的地址簿详细信息。</li><li>如果该服务正常，则返回 <code>AddressBookResDTO</code> 对象（地址簿详情）。</li></ul></li><li><p><strong>降级方法 <code>detailFallback(Long id, Throwable throwable)</code></strong></p><ul><li>当 <code>getDetail</code> 方法内部抛出异常时，Sentinel 会调用此降级方法。</li><li>通过 <code>Throwable</code> 可以获取具体的异常信息，不过该示例中并未使用，而是简单记录了错误日志，并返回 <code>null</code>。</li></ul></li><li><p><strong>熔断处理方法 <code>detailBlockHandler(Long id, Throwable throwable)</code></strong></p><ul><li>当 <code>getDetail</code> 触发 Sentinel 的流控、熔断规则时，将调用此方法。</li><li>同样，该方法会记录熔断信息，并返回 <code>null</code>。</li></ul></li></ol><p>总结推理：</p><ul><li>该类通过 Sentinel 保护 <code>getDetail</code> 方法，防止因外部服务不稳定或异常而影响系统的稳定性。</li><li>如果 <code>Api.api(id)</code> 调用出错，会进入 <code>detailFallback</code> 进行降级处理。</li><li>如果该方法因流量过大或熔断规则触发，则进入 <code>detailBlockHandler</code> 方法。</li><li>Sentinel 允许开发者将异常与流控分开处理，提高了服务的健壮性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Freemarker</title>
    <link href="/2024/10/17/Middleware/freemarker/freemarker/"/>
    <url>/2024/10/17/Middleware/freemarker/freemarker/</url>
    
    <content type="html"><![CDATA[<h1 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h1><h4 id="freemarker介绍"><a href="#freemarker介绍" class="headerlink" title="freemarker介绍"></a>freemarker介绍</h4><p>FreeMarker 是模板引擎：基于 模板-数据- -生成输出文本(网页-电子邮件配置文件-源代码)</p><p> 是一嵌入开发产品的组件。</p><blockquote><p>音乐社区案例</p><p>不使用freemarker</p><p>前端-&gt;发起请求-&gt;查询数据库-&gt;拿到数据-&gt;返回数据层-&gt;视图层渲染</p></blockquote><blockquote><p>使用freemarker</p><p>发起音乐-&gt;直接访问freemarker静态网页</p></blockquote><p>在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241017102759599.png" alt="image-20241017102759599"></p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><h6 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h6><p>freemarker作为springmvc一种视图格式，默认情况下SpringMVC支持freemarker视图格式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>heima-leadnews-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>freemarker-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- lombok --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br>        <span class="hljs-comment">&lt;!-- apache 对 java io 的封装工具库 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">freemarker:</span><br>   <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#关闭模板缓存，方便测试</span><br>   <span class="hljs-attr">settings:</span><br>     <span class="hljs-attr">template_update_delay:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试</span><br>   <span class="hljs-attr">suffix:</span> <span class="hljs-string">.ftl</span>               <span class="hljs-comment">#指定Freemarker模板文件的后缀名</span><br></code></pre></td></tr></table></figure><h6 id="2-创建模型类"><a href="#2-创建模型类" class="headerlink" title="2.创建模型类"></a>2.创建模型类</h6><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">private</span> int age;<span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">private</span> Date birthday;<span class="hljs-comment">//生日</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">Float</span> money;<span class="hljs-comment">//钱包</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-创建模板"><a href="#3-创建模板" class="headerlink" title="3.创建模板"></a>3.创建模板</h6><p>在resources下创建templates，此目录为freemarker的默认模板存放目录。</p><p>在templates下创建模板文件 01-basic.ftl ，模板中的插值表达式最终会被freemarker替换成具体的数据。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>普通文本 String 展示：<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">Hello $</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>对象Student中的数据展示：<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">姓名：$</span><span class="hljs-template-variable">&#123;stu.name&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">年龄：$</span><span class="hljs-template-variable">&#123;stu.age&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FreemarkerDemotApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>      <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">FreemarkerDemotApplication</span>.<span class="hljs-property">class</span>,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br> <br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/basic&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="hljs-title class_">Model</span> model</span>) &#123;<br> <br> <br>        <span class="hljs-comment">//1.纯文本形式的参数</span><br>        model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;freemarker&quot;</span>);<br>        <span class="hljs-comment">//2.实体类相关的参数</span><br>        <br>        <span class="hljs-title class_">Student</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>        student.<span class="hljs-title function_">setAge</span>(<span class="hljs-number">18</span>);<br>        model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;stu&quot;</span>, student);<br> <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;01-basic&quot;</span>;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p><code>Model</code> 在 Spring MVC 中的作用是用于在控制器中传递数据到视图层（如 Thymeleaf、Freemarker 等模板引擎），使得视图可以通过模板语言读取并展示这些数据。</p><p>具体作用如下：</p><ol><li><strong>传递数据到视图层</strong>：<code>Model</code> 是一个容器，可以存储从控制器传递给视图的参数。通过 <code>model.addAttribute()</code> 方法，你可以将数据添加到 <code>Model</code> 中，视图层可以访问这些数据进行渲染。例如，上述代码通过 <code>model.addAttribute(&quot;name&quot;, &quot;freemarker&quot;)</code> 将 <code>&quot;freemarker&quot;</code> 传递给视图层，通过 <code>model.addAttribute(&quot;stu&quot;, student)</code> 传递 <code>Student</code> 实体对象。</li><li><strong>数据在页面展示</strong>：视图层模板通过获取 <code>Model</code> 中的数据展示在页面上。例如，Freemarker 通过 <code>$&#123;name&#125;</code> 和 <code>$&#123;stu.name&#125;</code> 可以读取并显示控制器中传递的数据。</li></ol><p>因此，<code>Model</code> <strong>作为控制器与视图之间的桥梁，负责将数据从控制器传递到视图，用于动态生成页面内容。</strong></p></blockquote><p>访问 </p><p><a href="http://localhost:8881/basic">http://localhost:8881/basic</a></p><h4 id="Freemarker基础"><a href="#Freemarker基础" class="headerlink" title="Freemarker基础"></a>Freemarker基础</h4><h6 id="1-基础语法分类"><a href="#1-基础语法分类" class="headerlink" title="1.基础语法分类"></a>1.基础语法分类</h6><p> 1、注释，即&lt;#–  –&gt;，介于其之间的内容会被freemarker忽略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs velocity">&lt;#--我是一个freemarker注释--&gt;<br></code></pre></td></tr></table></figure><p>  2、插值（Interpolation）：即 <strong><code>$&#123;..&#125;</code></strong> 部分,freemarker会用真实的值代替**<code>$&#123;..&#125;</code>**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs velocity">Hello $&#123;name&#125;<br></code></pre></td></tr></table></figure><p>  3、FTL指令：和HTML标记类似，名字前加#予以区分，Freemarker会解析标签中的表达式或逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs velocity">&lt;# &gt;FTL指令&lt;/#&gt; <br></code></pre></td></tr></table></figure><p>  4、文本，仅文本信息，这些不是freemarker的注释、插值、FTL指令的内容会被freemarker忽略解析，直接输出内容。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">&lt;<span class="hljs-comment">#</span><span class="hljs-literal">--</span><span class="hljs-comment">freemarker中的普通文本</span><span class="hljs-literal">--</span>&gt;<br><span class="hljs-comment">我是一个普通的文本</span><br></code></pre></td></tr></table></figure><h6 id="2-集合指令-List和map"><a href="#2-集合指令-List和map" class="headerlink" title="2.集合指令(List和map)"></a>2.集合指令(List和map)</h6><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">(Model model)</span>&#123;<br><span class="hljs-comment">//------------------------------------</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">stu1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>stu1.setName(<span class="hljs-string">&quot;小强&quot;</span>);<br>stu1.setAge(<span class="hljs-number">18</span>);<br>stu1.setMoney(<span class="hljs-number">1000.86f</span>);<br>stu1.setBirthday(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br><span class="hljs-comment">//小红对象模型数据</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>stu2.setName(<span class="hljs-string">&quot;小红&quot;</span>);<br>stu2.setMoney(<span class="hljs-number">200.1f</span>);<br>stu2.setAge(<span class="hljs-number">19</span>);<br><br><span class="hljs-comment">//将两个对象模型数据存放到List集合中</span><br>List&lt;Student&gt; stus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>stus.add(stu1);<br>stus.add(stu2);<br><br><span class="hljs-comment">//向model中存放List集合数据</span><br>model.addAttribute(<span class="hljs-string">&quot;stus&quot;</span>,stus);<br><br><span class="hljs-comment">//------------------------------------</span><br><br><span class="hljs-comment">//创建Map数据</span><br>HashMap&lt;String,Student&gt; stuMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>stuMap.put(<span class="hljs-string">&quot;stu1&quot;</span>,stu1);<br>stuMap.put(<span class="hljs-string">&quot;stu2&quot;</span>,stu2);<br><span class="hljs-comment">// 3.1 向model中存放Map数据</span><br>model.addAttribute(<span class="hljs-string">&quot;stuMap&quot;</span>, stuMap);<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;02-list&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">&lt;#-- list 数据的展示 --&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>展示list中的stu数据:<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>钱包<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">    &lt;#list stus as stu&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;stu_index+1&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;stu.name&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;stu.age&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;stu.money&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">    &lt;/#list&gt;</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml">&lt;#-- Map 数据的展示 --&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>map数据的展示：<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;###&quot;</span>&gt;</span>方式一：通过map[&#x27;keyname&#x27;].property<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">输出stu1的学生信息：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">姓名：$</span><span class="hljs-template-variable">&#123;stuMap[&#x27;stu1&#x27;].name&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">年龄：$</span><span class="hljs-template-variable">&#123;stuMap[&#x27;stu1&#x27;].age&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;###&quot;</span>&gt;</span>方式二：通过map.keyname.property<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">输出stu2的学生信息：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">姓名：$</span><span class="hljs-template-variable">&#123;stuMap.stu2.name&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">年龄：$</span><span class="hljs-template-variable">&#123;stuMap.stu2.age&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;###&quot;</span>&gt;</span>遍历map中两个学生信息：<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>钱包<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">    &lt;#list stuMap?keys as key &gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;key_index&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;stuMap[key].name&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;stuMap[key].age&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;stuMap[key].money&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">    &lt;/#list&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h6 id="3-if指令"><a href="#3-if指令" class="headerlink" title="3.if指令"></a>3.if指令</h6><p>freemarker在解析时遇到if会进行判断，条件为真则输出if中间的内容，否则跳过内容不再输出。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;#if &gt;</span><span class="hljs-section">&lt;/if&gt;</span><br></code></pre></td></tr></table></figure><p>指定名字为小红的为红色</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;table&gt;</span><br>    <span class="hljs-attribute">&lt;tr&gt;</span><br>        <span class="hljs-attribute">&lt;td&gt;</span>姓名<span class="hljs-attribute">&lt;/td&gt;</span><br>        <span class="hljs-attribute">&lt;td&gt;</span>年龄<span class="hljs-attribute">&lt;/td&gt;</span><br>        <span class="hljs-attribute">&lt;td&gt;</span>钱包<span class="hljs-attribute">&lt;/td&gt;</span><br>    <span class="hljs-attribute">&lt;/tr&gt;</span><br>    <span class="hljs-attribute">&lt;#list stus as stu&gt;</span><br>    <span class="hljs-attribute">&lt;#if stu.name=&#x27;小红&#x27;&gt;</span><br>    <span class="hljs-attribute">&lt;tr style=&quot;color: red&quot; &gt;</span><br>            <span class="hljs-attribute">&lt;td &gt;</span>$&#123;stu.name&#125;<span class="hljs-attribute">&lt;/td&gt;</span>  <br>    <span class="hljs-attribute">&lt;/tr&gt;</span><br>    <br>    <span class="hljs-attribute">&lt;/if&gt;</span><br>        <span class="hljs-attribute">&lt;tr&gt;</span><br>            <span class="hljs-attribute">&lt;td &gt;</span>$&#123;stu.name&#125;<span class="hljs-attribute">&lt;/td&gt;</span>  <br>        <span class="hljs-attribute">&lt;/tr&gt;</span><br>    <span class="hljs-attribute">&lt;/#list&gt;</span><br><span class="hljs-attribute">&lt;/table&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h6><p><strong>1、算数运算符</strong></p><p>FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:</p><ul><li>加法： <code>+</code></li><li>减法： <code>-</code>运算符</li><li>乘法： <code>*</code></li><li>除法： <code>/</code></li><li>求模 (求余)： <code>%</code></li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>算数运算符<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">    100+5 运算：  $</span><span class="hljs-template-variable">&#123;100 + 5 &#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">    100 - 5 * 5运算：$</span><span class="hljs-template-variable">&#123;100 - 5 * 5&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">    5 / 2运算：$</span><span class="hljs-template-variable">&#123;5 / 2&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml">    12 % 10运算：$</span><span class="hljs-template-variable">&#123;12 % 10&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>除了 + 运算以外，其他的运算只能和 number 数字类型的计算。</p><p>2.比较运算符</p><ul><li><strong><code>=</code><strong>或者</strong><code>==</code></strong>:判断两个值是否相等. </li><li><strong><code>!=</code></strong>:判断两个值是否不等. </li><li><strong><code>&gt;</code><strong>或者</strong><code>gt</code></strong>:判断左边值是否大于右边值 </li><li><strong><code>&gt;=</code><strong>或者</strong><code>gte</code></strong>:判断左边值是否大于等于右边值 </li><li><strong><code>&lt;</code><strong>或者</strong><code>lt</code></strong>:判断左边值是否小于右边值 </li><li><strong><code>&lt;=</code><strong>或者</strong><code>lte</code></strong>:判断左边值是否小于等于右边值</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;<span class="hljs-meta">#<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;xiaoming&quot;</span> == <span class="hljs-string">&quot;xiaoming&quot;</span>&gt;</span><br>               字符串的比较 <span class="hljs-string">&quot;xiaoming&quot;</span> == <span class="hljs-string">&quot;xiaoming&quot;</span><br>           &lt;/<span class="hljs-meta">#<span class="hljs-keyword">if</span>&gt;</span><br>       &lt;/dd&gt;<br>       &lt;dd&gt;<br>           &lt;<span class="hljs-meta">#<span class="hljs-keyword">if</span> 10 != 100&gt;</span><br>               数值的比较 <span class="hljs-number">10</span> != <span class="hljs-number">100</span><br>           &lt;/<span class="hljs-meta">#<span class="hljs-keyword">if</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>**<code>=</code><strong>和</strong><code>!=</code>**可以用于字符串、数值和日期来比较是否相等</li><li>**<code>=</code><strong>和</strong><code>!=</code>**两边必须是相同类型的值,否则会产生错误</li><li>字符串 <strong><code>&quot;x&quot;</code></strong> 、**<code>&quot;x &quot;</code>** 、**<code>&quot;X&quot;</code>**比较是不等的.因为FreeMarker是精确比较</li><li>其它的运行符可以作用于数字和日期,但不能作用于字符串</li><li>使用**<code>gt</code><strong>等字母运算符代替</strong><code>&gt;</code><strong>会有更好的效果,因为 FreeMarker会把</strong><code>&gt;</code>**解释成FTL标签的结束字符</li><li>可以使用括号来避免这种情况,如:<strong><code>&lt;#if (x&gt;y)&gt;</code></strong></li></ul><p>3.逻辑运算符</p><ul><li>逻辑与:&amp;&amp; </li><li>逻辑或:|| </li><li>逻辑非:!</li></ul><p>逻辑运算符只能作用于布尔值,否则将产生错误 </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;b&gt;逻辑运算符&lt;/b&gt;<br>    &lt;br/&gt;<br>    &lt;br/&gt;<br>    &lt;#if (<span class="hljs-number">10</span> <span class="hljs-literal">lt</span> <span class="hljs-number">12</span> )&amp;&amp;( <span class="hljs-number">10</span>  <span class="hljs-literal">gt</span>  <span class="hljs-number">5</span> )  &gt;<br>        (<span class="hljs-number">10</span> <span class="hljs-literal">lt</span> <span class="hljs-number">12</span> )&amp;&amp;( <span class="hljs-number">10</span>  <span class="hljs-literal">gt</span>  <span class="hljs-number">5</span> )  显示为 <span class="hljs-literal">true</span><br>    &lt;/#if&gt;<br>    &lt;br/&gt;<br>    &lt;br/&gt;<br>    &lt;#if !<span class="hljs-literal">false</span>&gt;<br>        <span class="hljs-literal">false</span> 取反为<span class="hljs-literal">true</span><br>    &lt;/#if&gt;<br>&lt;hr&gt;<br></code></pre></td></tr></table></figure><p>4.空值处理</p><p>用法为:variable??,如果该变量存在,返回true,否则返回false </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">&lt;#<span class="hljs-keyword">if</span> stus??&gt;<br> &lt;#list stus <span class="hljs-keyword">as</span> stu&gt;<br> ......<br> &lt;/#list&gt;<br> &lt;/#<span class="hljs-keyword">if</span>&gt;<br></code></pre></td></tr></table></figure><p>${name!’’}表示如果name为空显示空字符串。</p><p>${(stu.bestFriend.name)!’’}表示，如果stu或bestFriend或name为空默认显示空字符串。</p><h6 id="5-内建函数"><a href="#5-内建函数" class="headerlink" title="5.内建函数"></a>5.内建函数</h6><p>内建函数语法格式： <strong><code>变量+?+函数名称</code></strong>  </p><p>1.某个集合的大小**</p><p><strong><code>$&#123;集合名?size&#125;</code></strong></p><p>2.日期格式化</p><p>显示年月日: <strong><code>$&#123;today?date&#125;</code></strong><br>显示时分秒：**<code>$&#123;today?time&#125;</code>**<br>显示日期+时间：**<code>$&#123;today?datetime&#125;</code>**<br>自定义格式化：  <strong><code>$&#123;today?string(&quot;yyyy年MM月&quot;)&#125;</code></strong></p><p>3.内建函数<code>c</code></p><p>model.addAttribute(“point”, 102920122);</p><p>point是数字型，使用${point}会显示这个数字的值，每三位使用逗号分隔。</p><p>如果不想显示为每三位分隔的数字，可以使用c函数将数字型转成字符串输出</p><p><strong><code>$&#123;point?c&#125;</code></strong></p><p>4.将json字符串转成对象</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&lt;#assign text=<span class="hljs-string">&quot;&#123;&#x27;bank&#x27;:&#x27;工商银行&#x27;,&#x27;account&#x27;:&#x27;10101920201920212&#x27;&#125;&quot;</span> /&gt;<br>&lt;#assign <span class="hljs-class"><span class="hljs-keyword">data</span>=text?eval /&gt;</span><br>开户行：$&#123;<span class="hljs-class"><span class="hljs-keyword">data</span>.bank&#125;  账号：$&#123;<span class="hljs-title">data</span>.<span class="hljs-title">account</span>&#125;</span><br></code></pre></td></tr></table></figure><p>案例</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>inner Function<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>获得集合大小<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    集合大小：$</span><span class="hljs-template-variable">&#123;stus?size&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>获得日期<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    显示年月日: $</span><span class="hljs-template-variable">&#123;today?date&#125;</span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    显示时分秒：$</span><span class="hljs-template-variable">&#123;today?time&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    显示日期+时间：$</span><span class="hljs-template-variable">&#123;today?datetime&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    自定义格式化：  $</span><span class="hljs-template-variable">&#123;today?string(&quot;yyyy年MM月&quot;)&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>内建函数C<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">    没有C函数显示的数值：$</span><span class="hljs-template-variable">&#123;point&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    有C函数显示的数值：$</span><span class="hljs-template-variable">&#123;point?c&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>声明变量assign<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">    &lt;#assign text=&quot;</span><span class="hljs-template-variable">&#123;&#x27;bank&#x27;:&#x27;工商银行&#x27;,&#x27;account&#x27;:&#x27;10101920201920212&#x27;&#125;</span><span class="language-xml">&quot; /&gt;</span><br><span class="language-xml">    &lt;#assign data=text?eval /&gt;</span><br><span class="language-xml">    开户行：$</span><span class="hljs-template-variable">&#123;data.bank&#125;</span><span class="language-xml">  账号：$</span><span class="hljs-template-variable">&#123;data.account&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="静态化测试"><a href="#静态化测试" class="headerlink" title="静态化测试"></a>静态化测试</h4><p>不需要springmvc0将freemarker作为视图解析器</p><p>需要使用Freemarker<strong>原生Api来生成静态内容</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241017104844409.png" alt="image-20241017104844409"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">erver:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8881</span> <span class="hljs-comment">#服务端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">freemarker-demo</span> <span class="hljs-comment">#指定服务名</span><br>  <span class="hljs-attr">freemarker:</span><br>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#关闭模板缓存，方便测试</span><br>    <span class="hljs-attr">settings:</span><br>      <span class="hljs-attr">template_update_delay:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试</span><br>    <span class="hljs-attr">suffix:</span> <span class="hljs-string">.ftl</span>               <span class="hljs-comment">#指定Freemarker模板文件的后缀名</span><br>    <span class="hljs-attr">template-loader-path:</span> <span class="hljs-string">classpath:/templates</span>   <span class="hljs-comment">#模板存放位置</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = FreemarkerDemoApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FreemarkerTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Configuration configuration;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TemplateException &#123;<br>        <span class="hljs-comment">//freemarker的模板对象，获取模板</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> configuration.getTemplate(<span class="hljs-string">&quot;02-list.ftl&quot;</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> getData();<br>        <span class="hljs-comment">//合成</span><br>        <span class="hljs-comment">//第一个参数 数据模型</span><br>        <span class="hljs-comment">//第二个参数  输出流</span><br>        <br>        <span class="hljs-comment">//参数合成</span><br>        template.process(params, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;d:/list.html&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Map <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//小强对象模型数据</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        stu1.setName(<span class="hljs-string">&quot;小强&quot;</span>);<br>        stu1.setAge(<span class="hljs-number">18</span>);<br>        stu1.setMoney(<span class="hljs-number">1000.86f</span>);<br>        stu1.setBirthday(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br>        <span class="hljs-comment">//小红对象模型数据</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        stu2.setName(<span class="hljs-string">&quot;小红&quot;</span>);<br>        stu2.setMoney(<span class="hljs-number">200.1f</span>);<br>        stu2.setAge(<span class="hljs-number">19</span>);<br><br>        <span class="hljs-comment">//将两个对象模型数据存放到List集合中</span><br>        List&lt;Student&gt; stus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        stus.add(stu1);<br>        stus.add(stu2);<br><br>        <span class="hljs-comment">//向map中存放List集合数据</span><br>        map.put(<span class="hljs-string">&quot;stus&quot;</span>, stus);<br><br><br>        <span class="hljs-comment">//创建Map数据</span><br>        HashMap&lt;String, Student&gt; stuMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        stuMap.put(<span class="hljs-string">&quot;stu1&quot;</span>, stu1);<br>        stuMap.put(<span class="hljs-string">&quot;stu2&quot;</span>, stu2);<br>        <span class="hljs-comment">//向map中存放Map数据</span><br>        map.put(<span class="hljs-string">&quot;stuMap&quot;</span>, stuMap);<br><br>        <span class="hljs-comment">//返回Map</span><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h4><h5 id="音乐社区详情页面"><a href="#音乐社区详情页面" class="headerlink" title="音乐社区详情页面"></a>音乐社区详情页面</h5><p>创建模版</p><blockquote><p>炫技术项目-需要用到这个技术栈-本人前端也没写过模版很简陋</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].musicName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    &lt;#if dataModel[&quot;music&quot;].likes gt 100&gt;<br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].musicName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    &lt;/#if&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> &gt;</span>$&#123;dataModel[&quot;music&quot;].musicName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>点赞:<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].likes&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].comments&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;playMusic(music.fileLocation)&quot;</span>&gt;</span>播放音乐<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">playMusic</span>(<span class="hljs-params">fileId</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 使用接口中的文件ID拼接音乐播放地址</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> musicUrl = <span class="hljs-string">&#x27;/mp3/&#x27;</span> + fileId;</span><br><span class="language-javascript">        <span class="hljs-comment">// 创建一个音频对象，进行播放</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> audio = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audio</span>(musicUrl);</span><br><span class="language-javascript">        audio.<span class="hljs-title function_">play</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure></blockquote><p>2.生成静态页面</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">//静态化测试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Template <span class="hljs-keyword">template</span> = configuration.getTemplate(<span class="hljs-string">&quot;02-list.ftl&quot;</span>);<br>             Map&lt;String, Object&gt; dataModel = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>             dataModel.put(<span class="hljs-string">&quot;music&quot;</span>, onlineMusic);<br>             <span class="hljs-comment">///创建 `StringWriter` 来捕获模板处理后的输出。</span><br>            StringWriter <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> StringWriter();<br>            <span class="hljs-keyword">template</span>.process(dataModel, <span class="hljs-keyword">out</span>);<br>            <span class="hljs-comment">//转输入流</span><br>            InputStream <span class="hljs-keyword">is</span> = <span class="hljs-keyword">new</span> ByteArrayInputStream(<span class="hljs-keyword">out</span>.toString().getBytes());<br>            <span class="hljs-comment">//minio文件上传</span><br>            fileStorageService.uploadHtmlFile(<span class="hljs-string">&quot;&quot;</span>,onlineMusic.getMusic()+<span class="hljs-string">&quot;.html&quot;</span>,<span class="hljs-keyword">is</span>);<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;静态化失败&quot;</span>);<br>        &#125;<br><br></code></pre></td></tr></table></figure><h5 id="白菜代售详情页"><a href="#白菜代售详情页" class="headerlink" title="白菜代售详情页"></a>白菜代售详情页</h5><p>具体页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">font-family</span>: Arial, sans-serif;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.price</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.details</span>, <span class="hljs-selector-class">.status</span>, <span class="hljs-selector-class">.transaction</span>, <span class="hljs-selector-class">.account-info</span>, <span class="hljs-selector-class">.extra-info</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.status</span>, <span class="hljs-selector-class">.transaction</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.button</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 商品价格 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;price&quot;</span>&gt;</span>¥$&#123;price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 商品信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;details&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;productCode&#125; 号 【$&#123;productName&#125;】 $&#123;productDesc&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$&#123;views&#125; 人看过<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 状态信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;status&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>卖家实名: $&#123;sellerStatus&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>交易时间: $&#123;tradeTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>保障: $&#123;guarantee&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 交易流程 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;transaction&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>交易流程<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                &lt;#list transactionSteps as step&gt;<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>$&#123;step&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                &lt;/#list&gt;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 账号信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;account-info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>账号信息<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>荣耀典藏: $&#123;gloryCount&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>皮肤数: $&#123;skinCount&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>信用评分: $&#123;creditScore&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 其他信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;extra-info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>有无防沉迷: $&#123;antiAddiction&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>实名情况: $&#123;realNameStatus&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>能否人脸包赔: $&#123;faceGuarantee&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- 操作按钮 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;consult.html&quot;</span>&gt;</span>咨询客服<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;buy.html&quot;</span>&gt;</span>立即购买<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sas">Map&lt;String, Object&gt; dataModel = new HashMap&lt;&gt;();<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-string">&quot;1500&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;productCode&quot;</span>, <span class="hljs-string">&quot;CG5BM&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;productName&quot;</span>, <span class="hljs-string">&quot;小国标垂悬虎&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;productDesc&quot;</span>, <span class="hljs-string">&quot;贵族6 皮肤价 值:59808 荣耀典藏0 传说皮肤3 史诗皮肤31 英雄皮肤103 传奇王者&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;views&quot;</span>, <span class="hljs-string">&quot;36&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;sellerStatus&quot;</span>, <span class="hljs-string">&quot;已完成实名认证&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;tradeTime&quot;</span>, <span class="hljs-string">&quot;00:00~23:00&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;guarantee&quot;</span>, <span class="hljs-string">&quot;可买包赔&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;transactionSteps&quot;</span>, Arrays.asList(<span class="hljs-string">&quot;下单&quot;</span>, <span class="hljs-string">&quot;验号&quot;</span>, <span class="hljs-string">&quot;换绑&quot;</span>, <span class="hljs-string">&quot;合同签署&quot;</span>, <span class="hljs-string">&quot;完成交易&quot;</span>));<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;gloryCount&quot;</span>, <span class="hljs-string">&quot;0.0&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;skinCount&quot;</span>, <span class="hljs-string">&quot;103.0&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;creditScore&quot;</span>, <span class="hljs-string">&quot;可排位&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;antiAddiction&quot;</span>, <span class="hljs-string">&quot;无防沉迷&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;realNameStatus&quot;</span>, <span class="hljs-string">&quot;可二次实名&quot;</span>);<br>dataModel.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;faceGuarantee&quot;</span>, <span class="hljs-string">&quot;支持人脸包赔&quot;</span>);<br><br>//来自模拟数据-具体类无法贴出<br><br></code></pre></td></tr></table></figure><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">//静态化测试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Template <span class="hljs-keyword">template</span> = configuration.getTemplate(<span class="hljs-string">&quot;wzry.ftl&quot;</span>);<br>             Map&lt;String, Object&gt; dataModel = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>             dataModel.put(<span class="hljs-string">&quot;wzry&quot;</span>, wzry);<br>               dataModel.put(<span class="hljs-string">&quot;tupian&quot;</span>, scdtp);<br>             <span class="hljs-comment">///创建 `StringWriter` 来捕获模板处理后的输出。</span><br>            StringWriter <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> StringWriter();<br>            <span class="hljs-keyword">template</span>.process(dataModel, <span class="hljs-keyword">out</span>);<br>            <span class="hljs-comment">//转输入流</span><br>            InputStream <span class="hljs-keyword">is</span> = <span class="hljs-keyword">new</span> ByteArrayInputStream(<span class="hljs-keyword">out</span>.toString().getBytes());<br>            <span class="hljs-comment">//minio文件上传</span><br>            fileStorageService.uploadHtmlFile(<span class="hljs-string">&quot;&quot;</span>,onlineMusic.getMusic()+<span class="hljs-string">&quot;.html&quot;</span>,<span class="hljs-keyword">is</span>);<br>            <span class="hljs-comment">//这里会回填数据库url</span><br>            <span class="hljs-comment">//前端会判断是直接进入url-还是访问redis</span><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;静态化失败&quot;</span>);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            /*</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinIO对象存储</title>
    <link href="/2024/10/17/Middleware/minIo/MinIO/"/>
    <url>/2024/10/17/Middleware/minIo/MinIO/</url>
    
    <content type="html"><![CDATA[<h1 id="MinIO对象存储服务"><a href="#MinIO对象存储服务" class="headerlink" title="MinIO对象存储服务"></a>MinIO对象存储服务</h1><h4 id="minio介绍"><a href="#minio介绍" class="headerlink" title="minio介绍"></a>minio介绍</h4><p>MinIO基于Apache License v2.0开源协议的对象存储服务，可以做为云存储的解决方案用来保存海量的图片，视频，文档。</p><p>采用Golang实现-服务端可以跨平台</p><p>MinIO兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。</p><p>Simple Storage Service简单存储服务-s3</p><p><strong>基本概念</strong></p><ul><li>bucket – 类比于文件系统的目录</li><li>Object – 类比文件系统的文件</li><li>Keys – 类比文件名</li></ul><h4 id="minIO特点"><a href="#minIO特点" class="headerlink" title="minIO特点"></a>minIO特点</h4><p>数据保护-Minio Erasure Code（纠删码）-即便损坏一半以上的driver，但是仍然可以从中恢复。</p><p>高性能-</p><p>可扩容-不同MinIO集群可以组成联邦，并形成一个全局的命名空间，并跨越多个数据中心</p><p>SDK支持-有操作页面-功能简单-丰富的API-文件变化主动通知</p><h4 id="minio部署"><a href="#minio部署" class="headerlink" title="minio部署"></a>minio部署</h4><p>docker部署</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -p 9000:9000 --name minio -d --restart=always -e <span class="hljs-string">&quot;MINIO_ACCESS_KEY=minio&quot;</span> -e <span class="hljs-string">&quot;MINIO_SECRET_KEY=minio123&quot;</span> -v /home/data:/data -v /home/config:/root/.minio minio/minio server /data</span><br></code></pre></td></tr></table></figure><p>进入控制台-创建桶</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241017105152526.png" alt="image-20241017105152526"></p><h4 id="Spring集成"><a href="#Spring集成" class="headerlink" title="Spring集成"></a>Spring集成</h4><h5 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.minio<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>minio<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinIOTest</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            fileInputStream =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\list.html&quot;</span>);;<br><br>            <span class="hljs-comment">//1.创建minio链接客户端</span><br>            <span class="hljs-type">MinioClient</span> <span class="hljs-variable">minioClient</span> <span class="hljs-operator">=</span> MinioClient.builder().credentials(<span class="hljs-string">&quot;minio&quot;</span>, <span class="hljs-string">&quot;minio123&quot;</span>).endpoint(<span class="hljs-string">&quot;http://192.168.200.130:9000&quot;</span>).build();<br>            <span class="hljs-comment">//2.上传</span><br>            <span class="hljs-type">PutObjectArgs</span> <span class="hljs-variable">putObjectArgs</span> <span class="hljs-operator">=</span> PutObjectArgs.builder()<br>                    .object(<span class="hljs-string">&quot;list.html&quot;</span>)<span class="hljs-comment">//文件名</span><br>                    .contentType(<span class="hljs-string">&quot;text/html&quot;</span>)<span class="hljs-comment">//文件类型</span><br>                    .bucket(<span class="hljs-string">&quot;leadnews&quot;</span>)<span class="hljs-comment">//桶名词  与minio创建的名词一致</span><br>                    .stream(fileInputStream, fileInputStream.available(), -<span class="hljs-number">1</span>) <span class="hljs-comment">//文件流</span><br>                    .build();<br>            minioClient.putObject(putObjectArgs);<br><br>            System.out.println(<span class="hljs-string">&quot;http://192.168.200.130:9000/leadnews/ak47.jpg&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-配置minIO"><a href="#2-配置minIO" class="headerlink" title="2.配置minIO"></a>2.配置minIO</h5><p>修改applicationtion.yml文件，增加MinIO服务的地址，账号密码等相关配置，具体如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">minio:</span><br><span class="hljs-symbol">  endpoint:</span> http:<span class="hljs-comment">//192.168.78.101:9001</span><br><span class="hljs-symbol">  accessKey:</span> admin<br><span class="hljs-symbol">  secretKey:</span> <span class="hljs-number">12345678</span><br><span class="hljs-symbol">  bucketName:</span> weiz-test<br></code></pre></td></tr></table></figure><h5 id="3-创建配置类"><a href="#3-创建配置类" class="headerlink" title="3.创建配置类"></a>3.创建配置类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@author</span> weiz</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinioConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 访问地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.endpoint&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * accessKey类似于用户ID，用于唯一标识你的账户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.accessKey&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKey;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * secretKey是你账户的密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.secretKey&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String secretKey;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认存储桶</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;minio.bucketName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MinioClient <span class="hljs-title function_">minioClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MinioClient</span> <span class="hljs-variable">minioClient</span> <span class="hljs-operator">=</span> MinioClient.builder()<br>                .endpoint(endpoint)<br>                .credentials(accessKey, secretKey)<br>                .build();<br>        <span class="hljs-keyword">return</span> minioClient;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-创建minIO操作类"><a href="#4-创建minIO操作类" class="headerlink" title="4.创建minIO操作类"></a>4.创建minIO操作类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MinIO工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinioUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MinioClient minioClient;<br><br>    <span class="hljs-comment">/******************************  Operate Bucket Start  ******************************/</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动SpringBoot容器的时候初始化Bucket</span><br><span class="hljs-comment">     * 如果没有Bucket则创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBucket</span><span class="hljs-params">(String bucketName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!bucketExists(bucketName)) &#123;<br>            minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断Bucket是否存在，true：存在，false：不存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bucketExists</span><span class="hljs-params">(String bucketName)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得Bucket的策略</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBucketPolicy</span><span class="hljs-params">(String bucketName)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.getBucketPolicy(GetBucketPolicyArgs<br>                .builder()<br>                .bucket(bucketName)<br>                .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得所有Bucket列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> List&lt;Bucket&gt; <span class="hljs-title function_">getAllBuckets</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.listBuckets();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据bucketName获取其相关信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> Optional&lt;Bucket&gt; <span class="hljs-title function_">getBucket</span><span class="hljs-params">(String bucketName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getAllBuckets().stream().filter(b -&gt; b.name().equals(bucketName)).findFirst();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据bucketName删除Bucket，true：删除成功； false：删除失败，文件或已不存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeBucket</span><span class="hljs-params">(String bucketName)</span> &#123;<br>        minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());<br>    &#125;<br><br>    <span class="hljs-comment">/******************************  Operate Bucket End  ******************************/</span><br><br><br>    <span class="hljs-comment">/******************************  Operate Files Start  ******************************/</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断文件是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isObjectExist</span><span class="hljs-params">(String bucketName, String objectName)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">exist</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            minioClient.statObject(StatObjectArgs.builder().bucket(bucketName).object(objectName).build());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;[Minio工具类]&gt;&gt;&gt;&gt; 判断文件是否存在, 异常：&quot;</span>, e);<br>            exist = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> exist;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断文件夹是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFolderExist</span><span class="hljs-params">(String bucketName, String objectName)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">exist</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(<br>                    ListObjectsArgs.builder().bucket(bucketName).prefix(objectName).recursive(<span class="hljs-literal">false</span>).build());<br>            <span class="hljs-keyword">for</span> (Result&lt;Item&gt; result : results) &#123;<br>                <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> result.get();<br>                <span class="hljs-keyword">if</span> (item.isDir() &amp;&amp; objectName.equals(item.objectName())) &#123;<br>                    exist = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;[Minio工具类]&gt;&gt;&gt;&gt; 判断文件夹是否存在，异常：&quot;</span>, e);<br>            exist = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> exist;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据文件前置查询文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix     前缀</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> recursive  是否使用递归查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> MinioItem 列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> List&lt;Item&gt; <span class="hljs-title function_">getAllObjectsByPrefix</span><span class="hljs-params">(String bucketName,</span><br><span class="hljs-params">                                            String prefix,</span><br><span class="hljs-params">                                            <span class="hljs-type">boolean</span> recursive)</span> &#123;<br>        List&lt;Item&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Iterable&lt;Result&lt;Item&gt;&gt; objectsIterator = minioClient.listObjects(<br>                ListObjectsArgs.builder().bucket(bucketName).prefix(prefix).recursive(recursive).build());<br>        <span class="hljs-keyword">if</span> (objectsIterator != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Result&lt;Item&gt; o : objectsIterator) &#123;<br>                <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> o.get();<br>                list.add(item);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件流</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName 文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 二进制流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> InputStream <span class="hljs-title function_">getObject</span><span class="hljs-params">(String bucketName, String objectName)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.getObject(<br>                GetObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断点下载</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName 文件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset     起始字节的位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> length     要读取的长度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 二进制流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> InputStream <span class="hljs-title function_">getObject</span><span class="hljs-params">(String bucketName, String objectName, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> length)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.getObject(<br>                GetObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .offset(offset)<br>                        .length(length)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取路径下文件列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix     文件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> recursive  是否递归查找，false：模拟文件夹结构查找</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 二进制流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Iterable&lt;Result&lt;Item&gt;&gt; <span class="hljs-title function_">listObjects</span><span class="hljs-params">(String bucketName, String prefix, <span class="hljs-type">boolean</span> recursive)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.listObjects(<br>                ListObjectsArgs.builder()<br>                        .bucket(bucketName)<br>                        .prefix(prefix)<br>                        .recursive(recursive)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用MultipartFile进行文件上传</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName  存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file        文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName  对象名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> contentType 类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> ObjectWriteResponse <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(String bucketName, MultipartFile file, String objectName, String contentType)</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();<br>        <span class="hljs-keyword">return</span> minioClient.putObject(<br>                PutObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .contentType(contentType)<br>                        .stream(inputStream, inputStream.available(), -<span class="hljs-number">1</span>)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 图片上传</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> imageBase64</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> imageName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ObjectWriteResponse <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(String bucketName, String imageBase64, String imageName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(imageBase64)) &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> base64ToInputStream(imageBase64);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> System.currentTimeMillis() + <span class="hljs-string">&quot;_&quot;</span> + imageName + <span class="hljs-string">&quot;.jpg&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> String.valueOf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getYear());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> String.valueOf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().getMonth());<br>            <span class="hljs-keyword">return</span> uploadFile(bucketName, year + <span class="hljs-string">&quot;/&quot;</span> + month + <span class="hljs-string">&quot;/&quot;</span> + newName, in);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputStream <span class="hljs-title function_">base64ToInputStream</span><span class="hljs-params">(String base64)</span> &#123;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BASE64Decoder</span>().decodeBuffer(base64.trim());<br>            stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> stream;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上传本地文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName 对象名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName   本地文件路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> ObjectWriteResponse <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(String bucketName, String objectName, String fileName)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.uploadObject(<br>                UploadObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .filename(fileName)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过流上传文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName  存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName  文件对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputStream 文件流</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> ObjectWriteResponse <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(String bucketName, String objectName, InputStream inputStream)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.putObject(<br>                PutObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .stream(inputStream, inputStream.available(), -<span class="hljs-number">1</span>)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建文件夹或目录</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName 目录路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> ObjectWriteResponse <span class="hljs-title function_">createDir</span><span class="hljs-params">(String bucketName, String objectName)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.putObject(<br>                PutObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .stream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;&#125;), <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件信息, 如果抛出异常则说明文件不存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName 文件名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFileStatusInfo</span><span class="hljs-params">(String bucketName, String objectName)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.statObject(<br>                StatObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .build()).toString();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拷贝文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName    存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName    文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> srcBucketName 目标存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> srcObjectName 目标文件名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> ObjectWriteResponse <span class="hljs-title function_">copyFile</span><span class="hljs-params">(String bucketName, String objectName, String srcBucketName, String srcObjectName)</span> &#123;<br>        <span class="hljs-keyword">return</span> minioClient.copyObject(<br>                CopyObjectArgs.builder()<br>                        .source(CopySource.builder().bucket(bucketName).object(objectName).build())<br>                        .bucket(srcBucketName)<br>                        .object(srcObjectName)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName 文件名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFile</span><span class="hljs-params">(String bucketName, String objectName)</span> &#123;<br>        minioClient.removeObject(<br>                RemoveObjectArgs.builder()<br>                        .bucket(bucketName)<br>                        .object(objectName)<br>                        .build());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量删除文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> keys       需要删除的文件列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFiles</span><span class="hljs-params">(String bucketName, List&lt;String&gt; keys)</span> &#123;<br>        List&lt;DeleteObject&gt; objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        keys.forEach(s -&gt; &#123;<br>            objects.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteObject</span>(s));<br>            <span class="hljs-keyword">try</span> &#123;<br>                removeFile(bucketName, s);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;[Minio工具类]&gt;&gt;&gt;&gt; 批量删除文件，异常：&quot;</span>, e);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件外链</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName 存储桶</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName 文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expires    过期时间 &lt;=7 秒 （外链有效时间（单位：秒））</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> url</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPresignedObjectUrl</span><span class="hljs-params">(String bucketName, String objectName, Integer expires)</span> &#123;<br>        <span class="hljs-type">GetPresignedObjectUrlArgs</span> <span class="hljs-variable">args</span> <span class="hljs-operator">=</span> GetPresignedObjectUrlArgs.builder().expiry(expires).bucket(bucketName).object(objectName).build();<br>        <span class="hljs-keyword">return</span> minioClient.getPresignedObjectUrl(args);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得文件外链</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objectName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> url</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows(Exception.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPresignedObjectUrl</span><span class="hljs-params">(String bucketName, String objectName)</span> &#123;<br>        <span class="hljs-type">GetPresignedObjectUrlArgs</span> <span class="hljs-variable">args</span> <span class="hljs-operator">=</span> GetPresignedObjectUrlArgs.builder()<br>                .bucket(bucketName)<br>                .object(objectName)<br>                .method(Method.GET).build();<br>        <span class="hljs-keyword">return</span> minioClient.getPresignedObjectUrl(args);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将URLDecoder编码转成UTF8</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> UnsupportedEncodingException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUtf8ByURLDecoder</span><span class="hljs-params">(String str)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> str.replaceAll(<span class="hljs-string">&quot;%(?![0-9a-fA-F]&#123;2&#125;)&quot;</span>, <span class="hljs-string">&quot;%25&quot;</span>);<br>        <span class="hljs-keyword">return</span> URLDecoder.decode(url, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-minio测试"><a href="#5-minio测试" class="headerlink" title="5.minio测试"></a>5.minio测试</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/oss&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OSSController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MinioUtils</span> minioUtils;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MinioConfig</span> minioConfig;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件上传</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">file</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/upload&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;file&quot;</span>) <span class="hljs-title class_">MultipartFile</span> file</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//文件名</span><br>            <span class="hljs-title class_">String</span> fileName = file.<span class="hljs-title function_">getOriginalFilename</span>();<br>            <span class="hljs-title class_">String</span> newFileName = <span class="hljs-title class_">System</span>.<span class="hljs-title function_">currentTimeMillis</span>() + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">substringAfterLast</span>(fileName, <span class="hljs-string">&quot;.&quot;</span>);<br>            <span class="hljs-comment">//类型</span><br>            <span class="hljs-title class_">String</span> contentType = file.<span class="hljs-title function_">getContentType</span>();<br>            minioUtils.<span class="hljs-title function_">uploadFile</span>(minioConfig.<span class="hljs-title function_">getBucketName</span>(), file, newFileName, contentType);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;上传成功&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            log.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;上传失败&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;上传失败&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">fileName</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;fileName&quot;</span>) <span class="hljs-title class_">String</span> fileName</span>) &#123;<br>        minioUtils.<span class="hljs-title function_">removeFile</span>(minioConfig.<span class="hljs-title function_">getBucketName</span>(), fileName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">fileName</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/info&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getFileStatusInfo</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;fileName&quot;</span>) <span class="hljs-title class_">String</span> fileName</span>) &#123;<br>        <span class="hljs-keyword">return</span> minioUtils.<span class="hljs-title function_">getFileStatusInfo</span>(minioConfig.<span class="hljs-title function_">getBucketName</span>(), fileName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件外链</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">fileName</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/url&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPresignedObjectUrl</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;fileName&quot;</span>) <span class="hljs-title class_">String</span> fileName</span>) &#123;<br>        <span class="hljs-keyword">return</span> minioUtils.<span class="hljs-title function_">getPresignedObjectUrl</span>(minioConfig.<span class="hljs-title function_">getBucketName</span>(), fileName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件下载</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">fileName</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">response</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/download&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">download</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;fileName&quot;</span>) <span class="hljs-title class_">String</span> fileName, <span class="hljs-title class_">HttpServletResponse</span> response</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-title class_">InputStream</span> fileInputStream = minioUtils.<span class="hljs-title function_">getObject</span>(minioConfig.<span class="hljs-title function_">getBucketName</span>(), fileName);<br>            response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + fileName);<br>            response.<span class="hljs-title function_">setContentType</span>(<span class="hljs-string">&quot;application/force-download&quot;</span>);<br>            response.<span class="hljs-title function_">setCharacterEncoding</span>(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-title class_">IOUtils</span>.<span class="hljs-title function_">copy</span>(fileInputStream, response.<span class="hljs-title function_">getOutputStream</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            log.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;下载失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-min操作类-2"><a href="#6-min操作类-2" class="headerlink" title="6.min操作类(2)"></a>6.min操作类(2)</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileStorageService</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  上传图片文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix  文件前缀</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filename  文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputStream 文件流</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  文件全路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">uploadImgFile</span>(<span class="hljs-title class_">String</span> prefix, <span class="hljs-title class_">String</span> filename,<span class="hljs-title class_">InputStream</span> inputStream);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  上传html文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix  文件前缀</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filename   文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputStream  文件流</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  文件全路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">uploadHtmlFile</span>(<span class="hljs-title class_">String</span> prefix, <span class="hljs-title class_">String</span> filename,<span class="hljs-title class_">InputStream</span> inputStream);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pathUrl  文件全路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">delete</span>(<span class="hljs-title class_">String</span> pathUrl);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下载文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pathUrl  文件全路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> byte[]  <span class="hljs-title function_">downLoadFile</span>(<span class="hljs-title class_">String</span> pathUrl);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现</p><p>MinIOFileStorageService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@EnableConfigurationProperties(MinIOConfigProperties.class)</span><br><span class="hljs-meta">@Import(MinIOConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinIOFileStorageService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileStorageService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinioClient minioClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MinIOConfigProperties minIOConfigProperties;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">separator</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dirPath</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filename  yyyy/mm/dd/file.jpg</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">builderFilePath</span><span class="hljs-params">(String dirPath,String filename)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">50</span>);<br>        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(dirPath))&#123;<br>            stringBuilder.append(dirPath).append(separator);<br>        &#125;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy/MM/dd&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">todayStr</span> <span class="hljs-operator">=</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        stringBuilder.append(todayStr).append(separator);<br>        stringBuilder.append(filename);<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  上传图片文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix  文件前缀</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filename  文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputStream 文件流</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  文件全路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadImgFile</span><span class="hljs-params">(String prefix, String filename,InputStream inputStream)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> builderFilePath(prefix, filename);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">PutObjectArgs</span> <span class="hljs-variable">putObjectArgs</span> <span class="hljs-operator">=</span> PutObjectArgs.builder()<br>                    .object(filePath)<br>                    .contentType(<span class="hljs-string">&quot;image/jpg&quot;</span>)<br>                    .bucket(minIOConfigProperties.getBucket()).stream(inputStream,inputStream.available(),-<span class="hljs-number">1</span>)<br>                    .build();<br>            minioClient.putObject(putObjectArgs);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">urlPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(minIOConfigProperties.getReadPath());<br>            urlPath.append(separator+minIOConfigProperties.getBucket());<br>            urlPath.append(separator);<br>            urlPath.append(filePath);<br>            <span class="hljs-keyword">return</span> urlPath.toString();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception ex)&#123;<br>            log.error(<span class="hljs-string">&quot;minio put file error.&quot;</span>,ex);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;上传文件失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  上传html文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix  文件前缀</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filename   文件名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputStream  文件流</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  文件全路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">uploadHtmlFile</span><span class="hljs-params">(String prefix, String filename,InputStream inputStream)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> builderFilePath(prefix, filename);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">PutObjectArgs</span> <span class="hljs-variable">putObjectArgs</span> <span class="hljs-operator">=</span> PutObjectArgs.builder()<br>                    .object(filePath)<br>                    .contentType(<span class="hljs-string">&quot;text/html&quot;</span>)<br>                    .bucket(minIOConfigProperties.getBucket()).stream(inputStream,inputStream.available(),-<span class="hljs-number">1</span>)<br>                    .build();<br>            minioClient.putObject(putObjectArgs);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">urlPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(minIOConfigProperties.getReadPath());<br>            urlPath.append(separator+minIOConfigProperties.getBucket());<br>            urlPath.append(separator);<br>            urlPath.append(filePath);<br>            <span class="hljs-keyword">return</span> urlPath.toString();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception ex)&#123;<br>            log.error(<span class="hljs-string">&quot;minio put file error.&quot;</span>,ex);<br>            ex.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;上传文件失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pathUrl  文件全路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String pathUrl)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> pathUrl.replace(minIOConfigProperties.getEndpoint()+<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> key.indexOf(separator);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> key.substring(<span class="hljs-number">0</span>,index);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> key.substring(index+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 删除Objects</span><br>        <span class="hljs-type">RemoveObjectArgs</span> <span class="hljs-variable">removeObjectArgs</span> <span class="hljs-operator">=</span> RemoveObjectArgs.builder().bucket(bucket).object(filePath).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            minioClient.removeObject(removeObjectArgs);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;minio remove file error.  pathUrl:&#123;&#125;&quot;</span>,pathUrl);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下载文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pathUrl  文件全路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  文件流</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] downLoadFile(String pathUrl)  &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> pathUrl.replace(minIOConfigProperties.getEndpoint()+<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> key.indexOf(separator);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> key.substring(<span class="hljs-number">0</span>,index);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> key.substring(index+<span class="hljs-number">1</span>);<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = minioClient.getObject(GetObjectArgs.builder().bucket(minIOConfigProperties.getBucket()).object(filePath).build());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;minio down file error.  pathUrl:&#123;&#125;&quot;</span>,pathUrl);<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!((rc = inputStream.read(buff, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)) &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            byteArrayOutputStream.write(buff, <span class="hljs-number">0</span>, rc);<br>        &#125;<br>        <span class="hljs-keyword">return</span> byteArrayOutputStream.toByteArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"> 对外加入自动配置<br><br>在resources中新建`META-INF/spring.factories`<br><br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\<br>  com<span class="hljs-selector-class">.heima</span><span class="hljs-selector-class">.file</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span>.MinIOFileStorageService<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@SpringBootTest(classes = MinioApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinioTest</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> FileStorageService fileStorageService;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateImgFile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;E:\\tmp\\ak47.jpg&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> fileStorageService.uploadImgFile(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ak47.jpg&quot;</span>, fileInputStream);<br>        System.out.println(filePath);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h4><h5 id="黑马头条"><a href="#黑马头条" class="headerlink" title="黑马头条"></a>黑马头条</h5><p>静态网页使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241017110414165.png" alt="image-20241017110414165"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = ArticleApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleFreemarkerTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Configuration configuration;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> FileStorageService fileStorageService;<br><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApArticleMapper apArticleMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApArticleContentMapper apArticleContentMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createStaticUrlTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.获取文章内容</span><br>        <span class="hljs-type">ApArticleContent</span> <span class="hljs-variable">apArticleContent</span> <span class="hljs-operator">=</span> apArticleContentMapper.selectOne(Wrappers.&lt;ApArticleContent&gt;lambdaQuery().eq(ApArticleContent::getArticleId, <span class="hljs-number">1390536764510310401L</span>));<br>        <span class="hljs-keyword">if</span>(apArticleContent != <span class="hljs-literal">null</span> &amp;&amp; StringUtils.isNotBlank(apArticleContent.getContent()))&#123;<br>            <span class="hljs-comment">//2.文章内容通过freemarker生成html文件</span><br>            <span class="hljs-type">StringWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>            <span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> configuration.getTemplate(<span class="hljs-string">&quot;article.ftl&quot;</span>);<br><br>            Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            params.put(<span class="hljs-string">&quot;content&quot;</span>, JSONArray.parseArray(apArticleContent.getContent()));<br><br>            template.process(params, out);<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(out.toString().getBytes());<br><br>            <span class="hljs-comment">//3.把html文件上传到minio中</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> fileStorageService.uploadHtmlFile(<span class="hljs-string">&quot;&quot;</span>, apArticleContent.getArticleId() + <span class="hljs-string">&quot;.html&quot;</span>, is);<br><br>            <span class="hljs-comment">//4.修改ap_article表，保存static_url字段</span><br>            <span class="hljs-type">ApArticle</span> <span class="hljs-variable">article</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApArticle</span>();<br>            article.setId(apArticleContent.getArticleId());<br>            article.setStaticUrl(path);<br>            apArticleMapper.updateById(article);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleFreemarkerServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ArticleFreemarkerService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ApArticleContentMapper</span> apArticleContentMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Configuration</span> configuration;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">FileStorageService</span> fileStorageService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ApArticleService</span> apArticleService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成静态文件上传到minIO中</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">apArticle</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">content</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">buildArticleToMinIO</span>(<span class="hljs-params"><span class="hljs-title class_">ApArticle</span> apArticle, <span class="hljs-title class_">String</span> content</span>) &#123;<br>        <span class="hljs-comment">//已知文章的id</span><br>        <span class="hljs-comment">//4.1 获取文章内容</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isNotBlank</span>(content))&#123;<br>            <span class="hljs-comment">//4.2 文章内容通过freemarker生成html文件</span><br>            <span class="hljs-title class_">Template</span> template = <span class="hljs-literal">null</span>;<br>            <span class="hljs-title class_">StringWriter</span> out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>            <span class="hljs-keyword">try</span> &#123;<br>                template = configuration.<span class="hljs-title function_">getTemplate</span>(<span class="hljs-string">&quot;article.ftl&quot;</span>);<br>                <span class="hljs-comment">//数据模型</span><br>                <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Object</span>&gt; contentDataModel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                contentDataModel.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-title class_">JSON</span><span class="hljs-built_in">Array</span>.<span class="hljs-title function_">parseArray</span>(content));<br>                <span class="hljs-comment">//合成</span><br>                template.<span class="hljs-title function_">process</span>(contentDataModel,out);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>                e.<span class="hljs-title function_">printStackTrace</span>();<br>            &#125;<br><br>            <span class="hljs-comment">//4.3 把html文件上传到minio中</span><br>            <span class="hljs-title class_">InputStream</span> <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(out.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">getBytes</span>());<br>            <span class="hljs-title class_">String</span> path = fileStorageService.<span class="hljs-title function_">uploadHtmlFile</span>(<span class="hljs-string">&quot;&quot;</span>, apArticle.<span class="hljs-title function_">getId</span>() + <span class="hljs-string">&quot;.html&quot;</span>, <span class="hljs-keyword">in</span>);<br><br><br>            <span class="hljs-comment">//4.4 修改ap_article表，保存static_url字段</span><br>            apArticleService.<span class="hljs-title function_">update</span>(<span class="hljs-title class_">Wrappers</span>.&lt;<span class="hljs-title class_">ApArticle</span>&gt;<span class="hljs-title function_">lambdaUpdate</span>().<span class="hljs-title function_">eq</span>(<span class="hljs-title class_">ApArticle</span>::getId,apArticle.<span class="hljs-title function_">getId</span>())<br>                    .<span class="hljs-title function_">set</span>(<span class="hljs-title class_">ApArticle</span>::getStaticUrl,path));<br><br><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="音乐社区"><a href="#音乐社区" class="headerlink" title="音乐社区"></a>音乐社区</h5><p>利用了上的的spring集成接口直接上传-很简单-只需要配置环境即可</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs d"><br><span class="hljs-comment">//静态化测试</span><br> <span class="hljs-keyword">try</span> &#123;<br>     Template <span class="hljs-keyword">template</span> = configuration.getTemplate(<span class="hljs-string">&quot;02-list.ftl&quot;</span>);<br>      Map&lt;String, Object&gt; dataModel = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>      dataModel.put(<span class="hljs-string">&quot;music&quot;</span>, onlineMusic);<br>     StringWriter <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> StringWriter();<br>     <span class="hljs-keyword">template</span>.process(dataModel, <span class="hljs-keyword">out</span>);<br>     InputStream <span class="hljs-keyword">is</span> = <span class="hljs-keyword">new</span> ByteArrayInputStream(<span class="hljs-keyword">out</span>.toString().getBytes());<br>     fileStorageService.uploadHtmlFile(<span class="hljs-string">&quot;&quot;</span>,onlineMusic.getMusic()+<span class="hljs-string">&quot;.html&quot;</span>,<span class="hljs-keyword">is</span>);<br><br> &#125;<span class="hljs-keyword">catch</span> (Exception e)<br> &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;静态化失败&quot;</span>);<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/2024/10/12/Middleware/Elasticsearch/ElasticSearch/"/>
    <url>/2024/10/12/Middleware/Elasticsearch/ElasticSearch/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><p>官方文档 <a href="https://www.elastic.co/">https://www.elastic.co</a></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e3be99393eb52f2b6559211f1b012807.png" alt="e3be99393eb52f2b6559211f1b012807"></p><h3 id="es介绍"><a href="#es介绍" class="headerlink" title="es介绍"></a>es介绍</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171722024-1222796164.png" alt="image"></p><h6 id="1-ElasticSearch"><a href="#1-ElasticSearch" class="headerlink" title="1.ElasticSearch"></a>1.ElasticSearch</h6><p>ElasticSearch 是一个基于分布式搜索引擎的开源项目，主要用于<strong>全文搜索、结构化搜索以及分析</strong>。它在大数据场景下有广泛应用，特别是在需要处理复杂查询和数据检索的环境中。</p><p>elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p><p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p><h6 id="2-elastic-stack（ELK）"><a href="#2-elastic-stack（ELK）" class="headerlink" title="2.elastic stack（ELK）"></a>2.elastic stack（ELK）</h6><ul><li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li></ul><h6 id="3-Lucene"><a href="#3-Lucene" class="headerlink" title="3.Lucene"></a>3.Lucene</h6><ul><li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li></ul><h6 id="4-Elk技术"><a href="#4-Elk技术" class="headerlink" title="4.Elk技术"></a>4.Elk技术</h6><p>elasticsearch结合kibana、Logstash、Beats，也就是<strong>elastic stack</strong>（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p><h3 id="es概念"><a href="#es概念" class="headerlink" title="es概念"></a>es概念</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241012140649009.png" alt="image-20241012140649009"></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h5 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h5><p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171741388-1990334679.png" alt="image"></p><p>如果是根据id查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于title做模糊查询，只能是逐行扫描数据，逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p><h5 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h5><blockquote><p>倒排索引中有两个非常重要的概念：</p><ul><li><strong>文档</strong>（<code>Document</code>）：用来搜索的数据，其中的<strong>每一条数据就是一个文档</strong>。一个商品信息，mysql的一行记录</li><li><strong>词条</strong>（<code>Term</code>）：<strong>对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。</strong>例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171751933-576636800.png" alt="image"></p><p>对title这一行的文档进行分词-</p><p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p><p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p><p>4）拿着文档id到正向索引中查找具体文档。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171803916-704919285.png" alt="image"></p><p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！<strong>无需全表扫描。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241012142500383.png" alt="image-20241012142500383"></p><p>一个字段-一个词条-非聚集索引和正向索引蛮像的</p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>概念区别：</p><ul><li><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</li><li>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</li></ul><p>优缺点：</p><p><strong>正向索引</strong>：</p><ul><li>优点：<ul><li><strong>可以给多个字段创建索引</strong></li><li><strong>根据索引字段搜索、排序速度非常快</strong></li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能<strong>全表扫描。</strong></li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li><strong>根据词条搜索、模糊搜索时，速度非常快</strong></li></ul></li><li>缺点：<ul><li><strong>只能给词条创建索引，而不是字段</strong></li><li>无法根据字段做排序</li></ul></li></ul><h3 id="Es数据概念"><a href="#Es数据概念" class="headerlink" title="Es数据概念"></a>Es数据概念</h3><h5 id="1-文档和字段"><a href="#1-文档和字段" class="headerlink" title="1.文档和字段"></a>1.文档和字段</h5><blockquote><p>一个文档就像数据库里的一条数据，字段就像数据库里的列</p></blockquote><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是<strong>数据库中的一条商品数据</strong>，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171811564-2114810461.png" alt="image"></p><h5 id="2-索引和隐射"><a href="#2-索引和隐射" class="headerlink" title="2.索引和隐射"></a>2.索引和隐射</h5><blockquote><p>索引就像数据库里的表，映射就像数据库中定义的表结构</p></blockquote><p><strong>索引（Index）</strong>，就是相同类型的文档的集合【<strong>类似mysql中的表</strong>】</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引；</li><li>所有商品的文档，可以组织在一起，称为商品的索引；</li><li>所有订单的文档，可以组织在一起，称为订单的索引；</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171817377-1198317744.png" alt="image"></p><p>因此，我们可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h5 id="3-mysql和es"><a href="#3-mysql和es" class="headerlink" title="3.mysql和es"></a>3.mysql和es</h5><p>各自长处：</p><ul><li><p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p></li><li><p>Elasticsearch：擅长海量数据的搜索、分析、计算</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a929874a1d2e29f822ec386084f46463.png" alt="a929874a1d2e29f822ec386084f46463"></p></li></ul><h3 id="es安装"><a href="#es安装" class="headerlink" title="es安装"></a>es安装</h3><h5 id="1-安装es、kibana、分词器"><a href="#1-安装es、kibana、分词器" class="headerlink" title="1.安装es、kibana、分词器"></a>1.安装es、kibana、分词器</h5><blockquote><p>分词器的作用是什么？</p><ul><li><strong>创建倒排索引时对文档分词</strong></li><li><strong>用户搜索时，对输入的内容分词</strong></li></ul><p><strong>IK分词器有几种模式？</strong></p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><p>IK分词器如何拓展词条？如何停用词条？</p><ul><li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li><li>在词典中添加拓展词条或者停用词条</li></ul></blockquote><h5 id="2-部署es"><a href="#2-部署es" class="headerlink" title="2.部署es"></a>2.部署es</h5><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">docker network create es-<span class="hljs-built_in">net</span><br></code></pre></td></tr></table></figure><p>加载镜像</p><blockquote><p>这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。</p><p>课前资料提供了镜像的tar包：</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171831042-1395359270.png" alt="image"></p><p>大家将其上传到虚拟机中，然后运行命令加载即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 导入数据</span><br>docker load -i es.tar<br></code></pre></td></tr></table></figure><p><strong>注意：同理还有<code>kibana</code>的tar包也需要这样做。</strong></p><p>运行docker命令，部署单点es：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br>--name es \<br>    -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \<br>    -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>    -v es-data:/usr/share/elasticsearch/data \<br>    -v es-plugins:/usr/share/elasticsearch/plugins \<br>    --privileged \<br>    --network es-net \<br>    -p 9200:9200 \<br>    -p 9300:9300 \<br>elasticsearch:7.12.1<br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a href="http://192.168.194.131/:9200">http://192.168.194.131/:9200</a> 即可看到elasticsearch的响应结果：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171842180-458017634.png" alt="image"></p><h5 id="3-部署kibana"><a href="#3-部署kibana" class="headerlink" title="3.部署kibana"></a>3.部署kibana</h5><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p><p><strong>创建网络后，导入kibana压缩包，然后创建并启动相应容器。【和前面部署单点es一样做法】</strong></p><p>再运行docker命令，部署kibana</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br>--name kibana \<br>-e ELASTICSEARCH_HOSTS=http://es:9200 \<br>--network=es-net \<br>-p 5601:5601  \<br>kibana:7.12.1<br></code></pre></td></tr></table></figure><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker logs -f kibana<br></code></pre></td></tr></table></figure><p>查看运行日志，当查看到下面的日志，说明成功：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171848067-1760891955.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171852468-457961443.png" alt="image"></p><p>kibana左侧中提供了一个DevTools界面：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171858509-678638964.png" alt="image"></p><p>这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p><h5 id="4-安装IK分词器"><a href="#4-安装IK分词器" class="headerlink" title="4.安装IK分词器"></a>4.安装IK分词器</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 进入容器内部</span><br>docker exec -it elasticsearch <span class="hljs-regexp">/bin/</span>bash<br><br><span class="hljs-comment"># 在线下载并安装</span><br>.<span class="hljs-regexp">/bin/</span>elasticsearch-plugin  install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/medcl/</span>elasticsearch-analysis-ik<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v7.12.1/</span>elasticsearch-analysis-ik-<span class="hljs-number">7.12</span>.<span class="hljs-number">1</span>.zip<br><br><span class="hljs-comment">#退出</span><br><span class="hljs-keyword">exit</span><br><span class="hljs-comment">#重启容器</span><br>docker restart elasticsearch<br><br></code></pre></td></tr></table></figure><p>.离线安装ik插件</p><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect es-plugins</span><br></code></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;CreatedAt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-05-06T10:06:34+08:00&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Mountpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es-plugins&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data</code>这个目录中。</p><p><strong>解压缩分词器安装包</strong></p><p> 下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p><p><img src="https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205171931639-1168552613.png" alt="image"></p><h6 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a><strong>3）上传到es容器的插件数据卷中</strong></h6><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data</code>：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205171956796-973760726.png" alt="image"></p><p><strong>重启容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 4、重启容器<br>docker restart es<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看es日志</span><br>docker logs -f es<br></code></pre></td></tr></table></figure><h6 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h6><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>：最少切分</li><li><code>ik_max_word</code>：最细切分</li></ul><p>在kibana的Dev tools中输入以下代码：</p><p>”analyzer“ 就是选择分词器模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /_analyze<br>&#123;<br>  <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>  <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;黑马程序员学习java太棒了&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs ada">&#123;<br>  <span class="hljs-string">&quot;tokens&quot;</span> : [<br>    &#123;<br>      <span class="hljs-string">&quot;token&quot;</span> : &quot;黑马&quot;,<br>      <span class="hljs-string">&quot;start_offset&quot;</span> : 0,<br>      <span class="hljs-string">&quot;end_offset&quot;</span> : 2,<br>      <span class="hljs-string">&quot;type&quot;</span> : &quot;<span class="hljs-type">CN_WORD</span><span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 0</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>程序员<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 2,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 5,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>CN_WORD<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 1</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>程序<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 2,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 4,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>CN_WORD<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 2</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>员<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 4,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 5,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>CN_CHAR<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 3</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>学习<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 5,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 7,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>CN_WORD<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 4</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>java<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 7,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 11,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>ENGLISH<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 5</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>太棒了<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 11,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 14,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>CN_WORD<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 6</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>太棒<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 11,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 13,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>CN_WORD<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 7</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;</span>token<span class="hljs-string">&quot; : &quot;</span>了<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>start_offset<span class="hljs-string">&quot; : 13,</span><br><span class="hljs-string">      &quot;</span>end_offset<span class="hljs-string">&quot; : 14,</span><br><span class="hljs-string">      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>CN_CHAR<span class="hljs-string">&quot;,</span><br><span class="hljs-string">      &quot;</span>position<span class="hljs-string">&quot; : 8</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h6 id="6-扩展词词典"><a href="#6-扩展词词典" class="headerlink" title="6.扩展词词典"></a>6.扩展词词典</h6><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“白嫖” 等。</p><p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p><p>）打开IK分词器config目录：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172005673-1129389907.png" alt="image"></p><p>在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p><p>白嫖 奥力给</p><p>重启elasticsearch</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> restart es <span class="hljs-comment"># 查看 日志 docker logs -f elasticsearch</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172011932-1622225700.png" alt="image"></p><p>日志中已经成功加载ext.dic配置文件</p><p>测试效果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /_analyze<br>&#123;<br>  <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>  <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;传智播客Java就业超过90%,奥力给！&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p><h6 id="7-停用词词典"><a href="#7-停用词词典" class="headerlink" title="7.停用词词典"></a>7.停用词词典</h6><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p><p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>         <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 stopword.dic 添加停用词</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">大帅逼<br></code></pre></td></tr></table></figure><p>重启elasticsearch</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /_analyze &#123;  <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;我是真的会谢Java就业率超过95%,大帅逼都点赞白嫖,奥力给！&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="索引库-表-操作"><a href="#索引库-表-操作" class="headerlink" title="索引库(表)操作"></a>索引库(表)操作</h3><h5 id="1-Mapping映射属性"><a href="#1-Mapping映射属性" class="headerlink" title="1. Mapping映射属性"></a>1. Mapping映射属性</h5><blockquote><p><strong>索引库就类似数据库表</strong>，<strong>mapping映射就类似表的结构。</strong></p><p>我们要向es中存储数据，必须先创建“库”和“表”。</p></blockquote><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241012151307336.png" alt="image-20241012151307336"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">21</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">52.1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isMarried&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;真相只有一个！&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">99.1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">99.5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">98.9</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;柯&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;南&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241012151443910.png" alt="image-20241012151443910"></p><h5 id="2-索引库的CRUD"><a href="#2-索引库的CRUD" class="headerlink" title="2. 索引库的CRUD"></a>2. 索引库的CRUD</h5><blockquote><p>CRUD简单描述：</p><ul><li>创建索引库：PUT &#x2F;索引库名</li><li>查询索引库：GET &#x2F;索引库名</li><li>删除索引库：DELETE &#x2F;索引库名</li><li>修改索引库（添加字段）：PUT &#x2F;索引库名&#x2F;_mapping</li></ul><p>这里统一使用Kibana编写DSL的方式来演示。</p></blockquote><h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><h5 id="1-文档的CRUD"><a href="#1-文档的CRUD" class="headerlink" title="1. 文档的CRUD"></a>1. 文档的CRUD</h5><h6 id="1-新增文档"><a href="#1-新增文档" class="headerlink" title="1.新增文档"></a>1.新增文档</h6><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">POST /索引库名<span class="hljs-string">/_doc/</span>文档id<br>&#123;<br>    <span class="hljs-string">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-string">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-string">&quot;字段3&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;子属性1&quot;</span>: <span class="hljs-string">&quot;值3&quot;</span>,<br>        <span class="hljs-string">&quot;子属性2&quot;</span>: <span class="hljs-string">&quot;值4&quot;</span><br>    &#125;,<br>    <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">POST <span class="hljs-operator">/</span>heima<span class="hljs-operator">/</span>_doc<span class="hljs-operator">/</span><span class="hljs-number">1</span>#索引库<br>&#123;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-comment">/**mapping映射</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &quot;info&quot;: &quot;真相只有一个！&quot;,</span><br><span class="hljs-comment">    &quot;email&quot;: &quot;zy@itcast.cn&quot;,</span><br><span class="hljs-comment">    &quot;name&quot;: &#123;</span><br><span class="hljs-comment">        &quot;firstName&quot;: &quot;柯&quot;,</span><br><span class="hljs-comment">        &quot;lastName&quot;: &quot;南&quot;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172052120-910375955.png" alt="image"></p><blockquote><p>在名为 <code>heima</code> 的索引库中创建或更新一条文档，其 ID 为 <code>1</code>。其中，<code>/_doc/1</code> 表示该文档的 ID 是 <code>1</code>，文档内容则包含一些个人信息</p><p>如果索引库中不存在 ID 为 <code>1</code> 的文档，它会新建该文档；如果存在，则会更新该文档。</p><p>数据存储在名为 <code>heima</code> 的索引库中。索引库相当于数据库中的表。</p><p>Elasticsearch 自动为字段生成映射（<code>mapping</code>），它会根据字段的内容自动推断字段的类型。比如：</p><ul><li><code>&quot;info&quot;</code> 和 <code>&quot;email&quot;</code> 会被映射为字符串类型（<code>text</code> 或 <code>keyword</code>）。</li><li><code>&quot;name&quot;</code> 作为一个嵌套对象，会被识别为对象类型，<code>firstName</code> 和 <code>lastName</code> 可能也会被映射为字符串类型。</li></ul></blockquote><h6 id="2-查询文档"><a href="#2-查询文档" class="headerlink" title="2.查询文档"></a>2.查询文档</h6><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /&#123;索引库名称&#125;/<span class="hljs-variable">_doc</span>/&#123;id&#125;<br><span class="hljs-comment">//批量查询：查询该索引库下的全部文档</span><br><span class="hljs-built_in">GET</span> /&#123;索引库名称&#125;/<span class="hljs-variable">_search</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /heima/_doc/1<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172058746-892146016.png" alt="image"></p><h6 id="3-删除文档"><a href="#3-删除文档" class="headerlink" title="3.删除文档"></a>3.删除文档</h6><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/&#123;索引库名&#125;/</span>_doc/id值<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 根据id删除数据</span><br><span class="hljs-attribute">DELETE</span> /heima/_doc/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172105015-1483849739.png" alt="image"></p><h6 id="4-修改文档"><a href="#4-修改文档" class="headerlink" title="4.修改文档"></a>4.修改文档</h6><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><blockquote><p>全量修改</p></blockquote><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：<strong>如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">PUT /&#123;索引库名&#125;<span class="hljs-string">/_doc/</span>文档id<br>&#123;<br>    <span class="hljs-string">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-string">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-string">//</span> <span class="hljs-string">...</span> 略<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/heima/</span>_doc/<span class="hljs-number">1</span><br>&#123;<br>    <span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;黑马程序员高级Java讲师&quot;</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;zy@itcast.cn&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;云&quot;</span>,<br>        <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;赵&quot;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>增量修改</p></blockquote><p>增量修改是只修改指定id匹配的文档中的部分字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST /&#123;索引库名&#125;/_update/文档<span class="hljs-built_in">id</span><br>&#123;<br>    <span class="hljs-string">&quot;doc&quot;</span>: &#123;<br>         <span class="hljs-string">&quot;字段名&quot;</span>: <span class="hljs-string">&quot;新的值&quot;</span>,<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/heima/</span>_update/<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;doc&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;ZhaoYun@itcast.cn&quot;</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="RestAPI"><a href="#RestAPI" class="headerlink" title="RestAPI"></a>RestAPI</h3><blockquote><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><p>其中的Java Rest Client又包括两种：</p><ul><li>Java Low Level Rest Client</li><li>Java High Level Rest Client</li></ul></blockquote><p>我们使用的是Java <strong>HighLevel</strong> Rest Client客户端API</p><h5 id="1-Api操作索引库"><a href="#1-Api操作索引库" class="headerlink" title="1.Api操作索引库"></a>1.Api操作索引库</h5><blockquote><p>JavaRestClient操作elasticsearch的流程基本类似。核心是<strong>client.indices()方法来获取索引库的操作对象。</strong></p><p>索引库操作的基本步骤：【可以根据发送请求那步的第一个参数，发过来判断需要创建什么XXXXRequest】</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要，其它是无参）</li><li>发送请求。调用RestHighLevelClient#indices().<strong>xxx()方法</strong>，xxx是create、exists、delete</li></ul></blockquote><h5 id="2-Mapping映射分析"><a href="#2-Mapping映射分析" class="headerlink" title="2.Mapping映射分析"></a>2.Mapping映射分析</h5><blockquote><p><strong>根据MySQL数据库表结构（建表语句），去写索引库结构JSON。表和索引库一一对应</strong></p><p><strong>注意</strong>：地理坐标、组合字段。<strong>索引库里的地理坐标是一个字段：<code>坐标：维度,精度</code></strong> 。copy_<strong>to组合字段作用是供用户查询（输入关键字可以查询多个字段）</strong></p></blockquote><blockquote><p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">字段名<br>字段数据类型<br>是否参与搜索 *<br>是否需要分词 *<br>如果分词，分词器是什么？ *<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">字段名、字段数据类型，可以参考数据表结构的名称和类型<br>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索<br>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词<br>分词器，我们可以统一使用ik_max_word<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT /hotel  <span class="hljs-comment">//索引名字</span><br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123; <span class="hljs-comment">//开始映射</span><br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<span class="hljs-comment">//映射集体</span><br>      <span class="hljs-string">&quot;id&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-comment">//唯一标识符，用于精确搜索</span><br>      &#125;,<br>      <span class="hljs-string">&quot;name&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<span class="hljs-comment">//分词</span><br>        <span class="hljs-string">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><span class="hljs-comment">//将值复制带all字段-方便综合搜索</span><br>      &#125;,<br>      <span class="hljs-string">&quot;address&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-literal">false</span><span class="hljs-comment">//不创建索引</span><br>      &#125;,<br>      <span class="hljs-string">&quot;price&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;score&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;brand&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<span class="hljs-comment">//唯一标识符，用于精确搜索</span><br>        <span class="hljs-string">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><span class="hljs-comment">//将值复制带all字段-方便综合搜索</span><br>      &#125;,<br>      <span class="hljs-string">&quot;city&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<span class="hljs-comment">///唯一标识符，用于精确搜索</span><br>        <span class="hljs-string">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><span class="hljs-comment">//将值复制带all字段-方便综合搜索</span><br>      &#125;,<br>      <span class="hljs-string">&quot;starName&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-comment">///唯一标识符，用于精确搜索</span><br>      &#125;,<br>      <span class="hljs-string">&quot;business&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-comment">///唯一标识符，用于精确搜索</span><br>      &#125;,<br>      <span class="hljs-string">&quot;location&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;geo_point&quot;</span><span class="hljs-comment">//地理坐标类型</span><br>      &#125;,<br>      <span class="hljs-string">&quot;pic&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>, <span class="hljs-comment">///唯一标识符，用于精确搜索</span><br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;,<br>      <span class="hljs-string">&quot;all&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-comment">//总体分词</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>几个特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li></ul><p><strong>地理坐标说明：</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172124085-626335563.png" alt="image"></p><p>copy_to说明：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172128097-289087887.png" alt="image"></p><h5 id="3-初始化RestClient"><a href="#3-初始化RestClient" class="headerlink" title="3.初始化RestClient"></a>3.初始化RestClient</h5><blockquote><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p></blockquote><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">引入es的RestHighLevelClient依赖：<br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;properties&gt;</span><br>    <span class="hljs-section">&lt;java.version&gt;</span><span class="hljs-attribute">1</span>.<span class="hljs-number">8</span>&lt;/java.version&gt;<br>    <span class="hljs-section">&lt;elasticsearch.version&gt;</span><span class="hljs-attribute">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span>&lt;/elasticsearch.version&gt;<br><span class="hljs-section">&lt;/properties&gt;</span><br></code></pre></td></tr></table></figure><p>初始化RestHighLevelClient：这里一般在启动类或者配置类里注入该Bean，用于告诉Java 访问ES的ip地址</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">RestHighLevelClient</span> <span class="hljs-title function_">client</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(<span class="hljs-title class_">RestClient</span>.<span class="hljs-title function_">builder</span>(<br>        <span class="hljs-title class_">HttpHost</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在**@BeforeEach**方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelIndexTest</span> &#123;<br>    <span class="hljs-keyword">private</span> RestHighLevelClient client;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.client.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-Spring-索引库-Crud"><a href="#4-Spring-索引库-Crud" class="headerlink" title="4.Spring  索引库 Crud"></a>4.Spring  索引库 Crud</h5><h6 id="1-创建索引库"><a href="#1-创建索引库" class="headerlink" title="1.创建索引库"></a>1.创建索引库</h6><blockquote><p>代码分为三步：</p><ul><li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li></ul></blockquote><p>创建索引库的API如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172138463-1252488196.png" alt="image"></p><p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p><p>HotelConstants –MAPPING_TEMPLATE</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">package</span> cn.itcast.hotel.constants;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelConstants</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-type">MAPPING_TEMPLATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;  <span class="hljs-subst">\&quot;</span>mappings<span class="hljs-subst">\&quot;</span>: &#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;    <span class="hljs-subst">\&quot;</span>properties<span class="hljs-subst">\&quot;</span>: &#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>id<span class="hljs-subst">\&quot;</span>: &#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>name<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>text<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>analyzer<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>ik_max_word<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>copy_to<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>all<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>address<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>index<span class="hljs-subst">\&quot;</span>: false<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>price<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>integer<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>score<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>integer<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>brand<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>copy_to<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>all<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>city<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>copy_to<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>all<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>starName<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>business<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>location<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>geo_point<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>pic<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>index<span class="hljs-subst">\&quot;</span>: false<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>all<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>text<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>analyzer<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>ik_max_word<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;    &#125;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;  &#125;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">CreateIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateIndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求的参数：DSL语句</span><br>    request.source(MAPPING_TEMPLATE, XContentType.JSON);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.indices().create(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-删除索引库"><a href="#2-删除索引库" class="headerlink" title="2.删除索引库"></a>2.删除索引库</h6><p>三步走：</p><ul><li>1）创建Request对象。这次是DeleteIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用delete方法</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /hotel<br></code></pre></td></tr></table></figure><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">DeleteIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteIndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    client.indices().delete(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-查询索引库"><a href="#3-查询索引库" class="headerlink" title="3. 查询索引库"></a>3. 查询索引库</h6><p>三步走：</p><ul><li>1）创建Request对象。这次是GetIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用exists方法</li></ul><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p><p>GET &#x2F;hotel</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Test</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testExistsHotelIndex</span><span class="hljs-params">()</span> throws IOException </span>&#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    GetIndexRequest request = <span class="hljs-keyword">new</span> <span class="hljs-built_in">GetIndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    <span class="hljs-type">boolean</span> exists = client.<span class="hljs-built_in">indices</span>().<span class="hljs-built_in">exists</span>(request, RequestOptions.<span class="hljs-literal">DEFAULT</span>);<br>    <span class="hljs-comment">// 3.输出</span><br>    System.err.<span class="hljs-built_in">println</span>(exists ? <span class="hljs-string">&quot;索引库已经存在！&quot;</span> : <span class="hljs-string">&quot;索引库不存在！&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="API操作文档"><a href="#API操作文档" class="headerlink" title="API操作文档"></a>API操作文档</h3><blockquote><p>这里更多的是先读取Mysql中的数据，然后再存进ES中。</p><p>文档操作的基本步骤：【可以根据发送请求那步的第一个参数，发过来判断需要创建什么XXXXRequest】</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul></blockquote><h5 id="文档CRUD"><a href="#文档CRUD" class="headerlink" title="文档CRUD"></a>文档CRUD</h5><h6 id="1-批量导入文档"><a href="#1-批量导入文档" class="headerlink" title="1.批量导入文档"></a>1.批量导入文档</h6><p>三步走：</p><ul><li>1）创建Request对象。这里是BulkRequest</li><li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li><li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li></ul><p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p><blockquote><p>步骤如下：</p><ul><li>利用mybatis-plus查询酒店数据</li><li>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</li><li>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</li></ul></blockquote><p><strong>语法说明：</strong></p><p>批量处理BulkRequest，其本质就是<strong>将多个普通的CRUD请求组合在一起发送</strong>。</p><p>其中提供了一个add方法，用来添加其他请求：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172220573-1990074801.png" alt="image"></p><p>可以看到，能添加的请求包括：</p><ul><li>IndexRequest，也就是新增</li><li>UpdateRequest，也就是修改</li><li>DeleteRequest，也就是删除</li></ul><p>因此Bulk中添加了多个<strong>IndexRequest</strong>，就是批量新增功能了。示例：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172227358-759338253.png" alt="image"></p><p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBulkRequest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 批量查询酒店数据</span><br>    List&lt;Hotel&gt; hotels = hotelService.list();<br><br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>    <span class="hljs-comment">// 2.准备参数，添加多个新增的Request</span><br>    <span class="hljs-keyword">for</span> (Hotel hotel : hotels) &#123;<br>        <span class="hljs-comment">// 2.1.转换为文档类型HotelDoc</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotelDoc</span>(hotel);<br>        <span class="hljs-comment">// 2.2.创建新增文档的Request对象</span><br>        request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>)<br>                    .id(hotelDoc.getId().toString())<br>                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));<br>    &#125;<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.bulk(request, RequestOptions.DEFAULT);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-批量-新增文档"><a href="#2-批量-新增文档" class="headerlink" title="2.批量  新增文档"></a>2.批量  新增文档</h6><blockquote><p>四步走：</p><ul><li>0）创建索引库实体类</li><li>1）创建Request对象</li><li>2）准备请求参数，也就是DSL中的JSON文档</li><li>3）发送请求 （注意：这里直接使用client.xxx()的API，不再需要**client.indices()**了）</li></ul></blockquote><p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p><p>1.<strong>创建索引库实体类</strong></p><blockquote><p>一般实体类里包含<strong>经纬度都需要创建一个新的实体类，将经纬度拼成一个字段</strong></p></blockquote><p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName</span>(<span class="hljs-string">&quot;tb_hotel&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Hotel</span> </span>&#123;<br>    <span class="hljs-meta">@TableId</span>(type = IdType.INPUT)<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> address;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-keyword">private</span> Integer score;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> brand;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> city;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> starName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> business;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> longitude;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> latitude;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> pic;<br>&#125;<br></code></pre></td></tr></table></figure><p>与我们的索引库结构存在差异：</p><ul><li>longitude和latitude需要合并为location</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelDoc</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-keyword">private</span> Integer score;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String starName;<br>    <span class="hljs-keyword">private</span> String business;<br>    <span class="hljs-keyword">private</span> String location;<br>    <span class="hljs-keyword">private</span> String pic;<br><br>    <span class="hljs-keyword">public</span> HotelDoc(Hotel hotel) &#123;<br>        <span class="hljs-keyword">this</span>.id = hotel.getId();<br>        <span class="hljs-keyword">this</span>.name = hotel.getName();<br>        <span class="hljs-keyword">this</span>.address = hotel.getAddress();<br>        <span class="hljs-keyword">this</span>.price = hotel.getPrice();<br>        <span class="hljs-keyword">this</span>.score = hotel.getScore();<br>        <span class="hljs-keyword">this</span>.brand = hotel.getBrand();<br>        <span class="hljs-keyword">this</span>.city = hotel.getCity();<br>        <span class="hljs-keyword">this</span>.starName = hotel.getStarName();<br>        <span class="hljs-keyword">this</span>.business = hotel.getBusiness();<br>        <span class="hljs-keyword">this</span>.location = hotel.getLatitude() + <span class="hljs-string">&quot;, &quot;</span> + hotel.getLongitude();<br>        <span class="hljs-keyword">this</span>.pic = hotel.getPic();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>新增代码</strong></p><p>新增文档的DSL语句如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/&#123;索引库名&#125;/</span>_doc/<span class="hljs-number">1</span><br>&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jack&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">21</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应的java代码如图：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172259030-1988634807.png" alt="image"></p><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p><ul><li>酒店数据来自于数据库，我们需要先查询出来，得到<strong>hotel</strong>对象</li><li>hotel对象需要<strong>转为HotelDoc对象</strong></li><li>HotelDoc需要序列化为json格式</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 批量查询酒店数据</span><br>    List&lt;Hotel&gt; hotels = hotelService.list();<br><br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>    <span class="hljs-comment">// 2.准备参数，添加多个新增的Request</span><br>    <span class="hljs-keyword">for</span> (Hotel hotel : hotels) &#123;<br>        <span class="hljs-comment">// 2.1.转换为文档类型HotelDoc</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotelDoc</span>(hotel);<br>        <span class="hljs-comment">// 2.2.创建新增文档的Request对象</span><br>        request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>)<br>                    .id(hotelDoc.getId().toString())<br>                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));<span class="hljs-comment">//实体类转JSON，指定JSON格式</span><br>        request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;xxx&quot;</span>)...)<br>    &#125;<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.bulk(request, RequestOptions.DEFAULT);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-查询文档"><a href="#3-查询文档" class="headerlink" title="3.查询文档"></a>3.查询文档</h6><blockquote><p>查询文档是根据id查询的，所以没有批量查询</p><p>三步走：</p><ul><li>1）准备Request对象。这次是查询，所以是GetRequest</li><li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li><li>3）解析结果，就是对JSON做反序列化</li></ul></blockquote><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_doc/<span class="hljs-punctuation">&#123;</span>id<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>非常简单，因此代码大概分两步：</p><ul><li>准备Request对象</li><li>发送请求</li></ul><p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p><p><img src="https://img2023.cnblogs.com/blog/2729274/202302/2729274-20230205172309780-381577770.png" alt="image"></p><p>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，使用工具反序列化为Java对象即可。</p><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">GetRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61082&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求，得到响应</span><br>    <span class="hljs-type">GetResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.get(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.解析响应结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> response.getSourceAsString();<br><br>    <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> JSON.parseObject(json, HotelDoc.class);<br>    System.out.println(hotelDoc);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-批量删除文档"><a href="#4-批量删除文档" class="headerlink" title="4.批量删除文档"></a>4.批量删除文档</h6><p>三步走：</p><ul><li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li><li>2）准备参数，无参</li><li>3）发送请求。因为是删除，所以是client.delete()方法</li></ul><p>删除的DSL为是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /hotel/_doc/<span class="hljs-punctuation">&#123;</span>id<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//0.查询数据库中的数据</span><br>    List&lt;Hotel&gt; list = hotelService.list();<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>    <span class="hljs-comment">//2.批量转换实体类，顺便写入到ES中</span><br>    <span class="hljs-keyword">for</span> (Hotel hotel : list) &#123;<br>        <span class="hljs-comment">//2.1转换实体类</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">HotelDoc</span>(hotel);<br>        <span class="hljs-comment">//2.2写入ES</span><br>        request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>)<br>                    .id(hotel.getId().toString()));<br>    &#125;<br>    <span class="hljs-comment">//3.发送请求</span><br>    client.bulk(request,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-批量修改文档"><a href="#5-批量修改文档" class="headerlink" title="5.批量修改文档"></a>5.批量修改文档</h6><p>三步走：</p><ul><li>1）准备Request对象。这次是修改，所以是<strong>UpdateRequest</strong></li><li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li><li>3）更新文档。这里调用client.update()方法</li></ul><p>修改有两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>增量修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p><strong>只演示增量修改：</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172320621-611636092.png" alt="image"></p><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//0.查询数据库中的数据</span><br>    List&lt;Hotel&gt; list = hotelService.list();<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>    <span class="hljs-comment">//2.批量转换实体类，顺便写入到ES中</span><br>    <span class="hljs-keyword">for</span> (Hotel hotel : list) &#123;<br>        <span class="hljs-comment">//2.1转换实体类</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">HotelDoc</span>(hotel);<br>        <span class="hljs-comment">//2.2写入ES</span><br>        request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>,hotel.getId().toString())<br>                    .doc(<br>                        <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-string">&quot;952&quot;</span>,<br>                        <span class="hljs-string">&quot;starName&quot;</span>, <span class="hljs-string">&quot;四钻&quot;</span><br>                    ));<br>    &#125;<br>    <span class="hljs-comment">//3.发送请求</span><br>    client.bulk(request,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Es搜索引擎"><a href="#Es搜索引擎" class="headerlink" title="Es搜索引擎"></a>Es搜索引擎</h3><h5 id="DSL查询"><a href="#DSL查询" class="headerlink" title="DSL查询"></a>DSL查询</h5><h6 id="1-dsl查询分类"><a href="#1-dsl查询分类" class="headerlink" title="1.dsl查询分类"></a>1.dsl查询分类</h6><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><p><strong>查询所有</strong>：查询出所有数据，<em>一般测试用</em>。例如：match_all</p></li><li><p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p><ul><li><strong>match_query</strong></li><li><strong>multi_match_query</strong></li></ul></li><li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul></li><li><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET /indexName/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;查询类型&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;查询条件&quot;</span>: <span class="hljs-string">&quot;条件值&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们以查询所有为例，其中：</p><ul><li>查询类型为match_all</li><li>没有查询条件</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// 查询所有</span><br><span class="hljs-built_in">GET</span> /indexName/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_all&quot;</span>: &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p><h6 id="2-全文检索"><a href="#2-全文检索" class="headerlink" title="2.全文检索"></a>2.全文检索</h6><p>match和multi_match的区别是什么？</p><ul><li>match：根据一个字段查询【推荐：使用copy_to构造all字段】</li><li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li></ul><p><strong>注：搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</strong></p><blockquote><p>全文检索查询的<strong>基本流程</strong>如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的<strong>场景</strong>包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172332617-1391223216.png" alt="image"></p><p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。</p><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：<strong>多字段查询，任意一个字段符合条件就算符合查询条件</strong></li></ul><p>match查询语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /indexName/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<span class="hljs-comment">//条件</span><br>      <span class="hljs-string">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span><br>          <span class="hljs-comment">//字段名称</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>match查询示例：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172338916-1567477721.png" alt="image"></p><p>mulit_match语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /indexName/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span>, <span class="hljs-comment">//值</span><br>      <span class="hljs-string">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;FIELD1&quot;</span>, <span class="hljs-string">&quot; FIELD12&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172344847-66722394.png" alt="image"></p><h6 id="3-精准查询"><a href="#3-精准查询" class="headerlink" title="3.精准查询"></a>3.精准查询</h6><p>精准查询类型：</p><ul><li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li><li>range查询：根据数值范围查询，可以是数值、日期的范围</li></ul><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p><ul><li><strong>term：根据词条精确值查询</strong></li><li><strong>range：根据值的范围查询</strong></li></ul><p>1.term查找</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// term查询</span><br><span class="hljs-built_in">GET</span> /indexName/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;FIELD&quot;</span>: &#123;<span class="hljs-comment">//字段</span><br>        <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;VALUE&quot;</span> <span class="hljs-comment">//value-值</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>示例：</p><p>当我搜索的是精确词条时，能正确查询出结果：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172353868-723957119.png" alt="image"></p><p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172404632-400137183.png" alt="image"></p><p>2.range查询</p><blockquote><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p></blockquote><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// range查询</span><br><span class="hljs-built_in">GET</span> /indexName/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 这里的gte代表大于等于，gt则代表大于</span><br>        <span class="hljs-string">&quot;lte&quot;</span>: <span class="hljs-number">20</span> <span class="hljs-comment">// lte代表小于等于，lt则代表小于</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172415197-322405876.png" alt="image"></p><h6 id="4-地理坐标查询"><a href="#4-地理坐标查询" class="headerlink" title="4.地理坐标查询"></a>4.地理坐标查询</h6><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p><p>见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><p>附近的酒店：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172420925-939257883.png" alt="image"></p><p>附近的车：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172429568-981337372.png" alt="image"></p><p>矩形范围查询</p><blockquote><p>很少有业务有这种需求</p></blockquote><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172556695-448469947.gif" alt="image"></p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// geo_bounding_box查询</span><br><span class="hljs-built_in">GET</span> /indexName/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;geo_bounding_box&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;top_left&quot;</span>: &#123; <span class="hljs-comment">// 左上点</span><br>          <span class="hljs-string">&quot;lat&quot;</span>: <span class="hljs-number">31.1</span>,<br>          <span class="hljs-string">&quot;lon&quot;</span>: <span class="hljs-number">121.5</span><br>        &#125;,<br>        <span class="hljs-string">&quot;bottom_right&quot;</span>: &#123; <span class="hljs-comment">// 右下点</span><br>          <span class="hljs-string">&quot;lat&quot;</span>: <span class="hljs-number">30.9</span>,<br>          <span class="hljs-string">&quot;lon&quot;</span>: <span class="hljs-number">121.7</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>附近(圆形)查询</p><p>附近查询，也叫做距离查询（geo_distance）：<strong>查询到指定中心点小于某个距离值的所有文档。</strong></p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172657385-1268854128.gif" alt="image"></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// geo_distance 查询</span><br><span class="hljs-built_in">GET</span> /indexName/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;geo_distance&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;distance&quot;</span>: <span class="hljs-string">&quot;15km&quot;</span>, <span class="hljs-comment">// 半径</span><br>      <span class="hljs-string">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;31.21,121.5&quot;</span> <span class="hljs-comment">// 圆心</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子</p><p>我们先搜索陆家嘴附近15km的酒店：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205172724869-1773754207.png" alt="image"></p><p>经纬度开始的15km内的酒店</p><h6 id="5-复合查询"><a href="#5-复合查询" class="headerlink" title="5.复合查询"></a>5.复合查询</h6><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：<strong>算分函数查询</strong>，可以控制文档相关性算分，控制文档排名</li><li>bool query：<strong>布尔查询</strong>，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><p>1.符合查询归纳</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/hotel/</span>_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;function_score&quot;</span>: &#123;           <br>      <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-regexp">//</span> 原始查询，可以是任意条件<br>          <span class="hljs-string">&quot;bool&quot;</span>: &#123; <span class="hljs-regexp">//</span>bool 查询<br>must：要求必须匹配的条件。在这里，文档的 city 字段必须是 <span class="hljs-string">&quot;上海&quot;</span> 才会被返回。<br>              <span class="hljs-string">&quot;must&quot;</span>: [<br>                  &#123;<span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;上海&quot;</span> &#125;&#125;<br>              ],<br>              <span class="hljs-string">&quot;should&quot;</span>: [<span class="hljs-regexp">//</span>should：是可选的条件，但匹配这些条件的文档会获得更高的评分。在这里，如果文档的 brand 是 <span class="hljs-string">&quot;皇冠假日&quot;</span> 或 <span class="hljs-string">&quot;华美达&quot;</span>，它的评分会增加。<br>                  &#123;<span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;brand&quot;</span>: <span class="hljs-string">&quot;皇冠假日&quot;</span> &#125;&#125;,<br>                  &#123;<span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;brand&quot;</span>: <span class="hljs-string">&quot;华美达&quot;</span> &#125;&#125;<br>              ],<span class="hljs-regexp">//</span>/must_not：要求不匹配的条件。这里的条件是不允许 price 字段小于等于 <span class="hljs-number">500</span> 的文档。<br><br><br>              <span class="hljs-string">&quot;must_not&quot;</span>: [<br>                  &#123; <span class="hljs-string">&quot;range&quot;</span>: &#123; <span class="hljs-string">&quot;price&quot;</span>: &#123; <span class="hljs-string">&quot;lte&quot;</span>: <span class="hljs-number">500</span> &#125; &#125;&#125;<br>              ],<span class="hljs-regexp">//mu</span>st_not：要求不匹配的条件。这里的条件是不允许 price 字段小于等于 <span class="hljs-number">500</span> 的文档。<br><br>              <span class="hljs-string">&quot;filter&quot;</span>: [<br>                  &#123; <span class="hljs-string">&quot;range&quot;</span>: &#123;<span class="hljs-string">&quot;score&quot;</span>: &#123; <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">45</span> &#125; &#125;&#125;<br>              ]<br>          &#125;<br>      &#125;,<br>      <span class="hljs-string">&quot;functions&quot;</span>: [ <span class="hljs-regexp">//</span> 算分函数<br>        &#123;<br>          <span class="hljs-string">&quot;filter&quot;</span>: &#123; <span class="hljs-regexp">//</span> 满足的条件，品牌必须是如家【品牌是如家的才加分，这里是加分条件】<br>            <span class="hljs-string">&quot;term&quot;</span>: &#123;<br>              <span class="hljs-string">&quot;brand&quot;</span>: <span class="hljs-string">&quot;如家&quot;</span><br>            &#125;<br>          &#125;,<br>          <span class="hljs-string">&quot;weight&quot;</span>: <span class="hljs-number">2</span> <span class="hljs-regexp">//</span> 算分权重为<span class="hljs-number">2</span><br>        &#125;<br>      ],<br>      <span class="hljs-string">&quot;boost_mode&quot;</span>: <span class="hljs-string">&quot;sum&quot;</span> <span class="hljs-regexp">//</span> 加权模式，求和<br>    &#125;<br>  &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-相关性算法分析"><a href="#6-相关性算法分析" class="headerlink" title="6.相关性算法分析"></a>6.相关性算法分析</h6><p>省</p><p>elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p><ul><li>TF-IDF算法</li><li>BM25算法，elasticsearch5.1版本后采用的算法</li></ul><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ada">[<br>  &#123;<br>    <span class="hljs-string">&quot;_score&quot;</span> : 17.850193,<br>    <span class="hljs-string">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : &quot;虹桥如家酒店真不错&quot;,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;_score&quot;</span> : 12.259849,<br>    <span class="hljs-string">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : &quot;外滩如家酒店真不错&quot;,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;_score&quot;</span> : 11.91091,<br>    <span class="hljs-string">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : &quot;迪士尼如家酒店真不错&quot;,<br>    &#125;<br>  &#125;<br>]<br><br></code></pre></td></tr></table></figure><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173433826-368331600.png" alt="image"></p><p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173438720-1124832591.png" alt="image"></p><p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173443307-150506578.png" alt="image"></p><h6 id="7-算分函数查询"><a href="#7-算分函数查询" class="headerlink" title="7.算分函数查询"></a>7.算分函数查询</h6><p><strong>在搜索出来的结果的分数基础上，再手动与指定的数字进行一定运算来改变算分，从而改变结果的排序。</strong></p><p>function score query定义的三要素是什么？</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173451256-1402835153.png" alt="image"></p><p>要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173456315-243388005.png" alt="image"></p><p>function score 查询中包含四部分内容：</p><ul><li><p><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</p></li><li><p><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</p></li><li><p>算分函数</p><p>：符合filter条件的文档要根据这个函数做运算，得到的</p><p>函数算分</p><p>（function score），有四种函数</p><ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><p>运算模式</p><p>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：</p><ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>需求：给“如家”这个品牌的酒店排名靠前一些</p><p>翻译一下这个需求，转换为之前说的四个要点：</p><ul><li>原始条件：不确定，可以任意变化</li><li>过滤条件：brand &#x3D; “如家”</li><li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li><li>运算模式：比如求和</li></ul><p>因此最终的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;function_score&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  .... <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 原始查询，可以是任意条件</span><br>      <span class="hljs-attr">&quot;functions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-comment">// 算分函数</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 满足的条件，品牌必须是如家【品牌是如家的才加分，这里是加分条件】</span><br>            <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;如家&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span> <span class="hljs-comment">// 算分权重为2</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;boost_mode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sum&quot;</span> <span class="hljs-comment">// 加权模式，求和</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>测试，在未添加算分函数时，如家得分如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173504670-1488473639.png" alt="image"></p><p>添加了算分函数后，如家得分就提升了：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173509427-1841421871.png" alt="image"></p><h6 id="8-布尔查询"><a href="#8-布尔查询" class="headerlink" title="8.布尔查询"></a>8.布尔查询</h6><p>省</p><h4 id="设置查询结果"><a href="#设置查询结果" class="headerlink" title="设置查询结果"></a>设置查询结果</h4><h5 id="搜索结果种类"><a href="#搜索结果种类" class="headerlink" title="搜索结果种类"></a>搜索结果种类</h5><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><h6 id="1-地址坐标排序"><a href="#1-地址坐标排序" class="headerlink" title="1.地址坐标排序"></a>1.地址坐标排序</h6><p>地理坐标排序略有不同。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /indexName/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;FIELD&quot;</span> : <span class="hljs-string">&quot;纬度，经度&quot;</span>, <span class="hljs-comment">// 文档中geo_point类型的字段名、目标坐标点</span><br>          <span class="hljs-string">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <span class="hljs-comment">// 排序方式</span><br>          <span class="hljs-string">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">// 排序的距离单位</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul><p>示例</p><p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p><p>提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p><p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173623518-625657913.png" alt="image"></p><h6 id="2-分页"><a href="#2-分页" class="headerlink" title="2.分页"></a>2.分页</h6><h6 id="3-高亮"><a href="#3-高亮" class="headerlink" title="3.高亮"></a>3.高亮</h6><h5 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h5><h3 id="RestClient查询文档"><a href="#RestClient查询文档" class="headerlink" title="RestClient查询文档"></a>RestClient查询文档</h3><blockquote><p>文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括：</p><ul><li>1）准备Request对象</li><li>2）准备请求参数</li><li>3）发起请求</li><li>4）解析响应</li></ul></blockquote><h5 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h5><blockquote><p>查询的基本步骤是：</p><ol><li><p>创建SearchRequest对象</p></li><li><p>准备Request.source()，也就是DSL。</p><p>① QueryBuilders来构建查询条件</p><p>② 传入Request.source() 的 query() 方法</p></li><li><p>发送请求，得到结果</p></li><li><p>解析结果（参考JSON结果，从外到内，逐层解析）</p></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173800773-301602834.png" alt="image"></p><ul><li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p></li><li><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li><p>第三步，利用client.search()发送请求，得到响应</p></li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含<strong>了查询、排序、分页、高亮</strong>等所有功能：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173808406-253737161.png" alt="image"></p><p>另一个是<code>QueryBuilders</code>，其中包含<strong>match、term、function_score、bool</strong>等各种查询：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173813297-2072845032.png" alt="image"></p><h5 id="结果解析"><a href="#结果解析" class="headerlink" title="结果解析"></a>结果解析</h5><p>响应结果的解析：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173819239-1577366921.png" alt="image"></p><blockquote><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><pre><code class="hljs">hits<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>：命中的结果<br><br>- `total`：总条数，其中的value是具体的总条数值<br><br>- `max_score`：所有结果中得分最高的文档的相关性算分<br><br>- ```<br>  hits<br></code></pre></td></tr></table></figure>  ：搜索结果的文档数组，其中的每个文档都是一个json对象  - `_source`：文档中的原始数据，也是json对象</code></pre></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><pre><code class="hljs">SearchHits<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs leaf"><br>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<br><br>- `SearchHits<span class="hljs-punctuation">#</span><span class="hljs-keyword">getTotalHits</span><span class="hljs-params">()</span>.value`：获取总条数信息<br><br>- ```<br>  SearchHits<span class="hljs-punctuation">#</span><span class="hljs-keyword">getHits</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure>  ：获取SearchHit数组，也就是文档数组  - `SearchHit#getSourceAsString()`：获取文档结果中的_source，也就是原始的json文档数据</code></pre></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatchAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    request.source()<br>        .query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br><br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> &#123;<br>    <span class="hljs-comment">// 4.解析响应</span><br>    <span class="hljs-type">SearchHits</span> <span class="hljs-variable">searchHits</span> <span class="hljs-operator">=</span> response.getHits();<br>    <span class="hljs-comment">// 4.1.获取总条数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 4.2.文档数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-comment">// 4.3.遍历</span><br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 获取文档source</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> hit.getSourceAsString();<br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-type">HotelDoc</span> <span class="hljs-variable">hotelDoc</span> <span class="hljs-operator">=</span> JSON.parseObject(json, HotelDoc.class);<br>        System.out.println(<span class="hljs-string">&quot;hotelDoc = &quot;</span> + hotelDoc);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><h6 id="1-全文检索查询"><a href="#1-全文检索查询" class="headerlink" title="1.全文检索查询"></a>1.全文检索查询</h6><p>全文检索<strong>的match和multi_match查询与match_all的API基本一致</strong>。差别是查询条件，也就是query的部分。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173828395-1519960077.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> testMatch <span class="hljs-keyword">throw</span> Ioexception&#123;<br>   <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>,<span class="hljs-string">&quot;如家&quot;</span>));<br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>    <br><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-精准查找"><a href="#2-精准查找" class="headerlink" title="2.精准查找"></a>2.精准查找</h6><p>精确查询主要是两者：</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173839234-1487715770.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> testMatch <span class="hljs-keyword">throw</span> Ioexception&#123;<br>   <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source().query(QueryBuilders.termQuery(<span class="hljs-string">&quot;city&quot;</span>,<span class="hljs-string">&quot;杭州&quot;</span>));<br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-地理查询"><a href="#3-地理查询" class="headerlink" title="3.地理查询"></a>3.地理查询</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173843949-30830550.png" alt="image"></p><p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173850338-1907101734.png" alt="image"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gradle">@Override<br><span class="hljs-keyword">public</span> PageResult search(RequestParams params) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1.准备Request</span><br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        <span class="hljs-comment">// 2.准备DSL</span><br>        <span class="hljs-comment">// 2.1.query</span><br>        buildBasicQuery(params, request);<br><br>        <span class="hljs-comment">// 2.2.分页</span><br>        <span class="hljs-keyword">int</span> page = params.getPage();<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = params.getSize();<br>        request.<span class="hljs-keyword">source</span>().<span class="hljs-keyword">from</span>((page - <span class="hljs-number">1</span>) * <span class="hljs-keyword">size</span>).<span class="hljs-keyword">size</span>(<span class="hljs-keyword">size</span>);<br><br>        <span class="hljs-comment">// 2.3.排序</span><br>        String location = params.getLocation();<br>        <span class="hljs-keyword">if</span> (location != <span class="hljs-keyword">null</span> &amp;&amp; !location.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            request.<span class="hljs-keyword">source</span>().<span class="hljs-keyword">sort</span>(SortBuilders<br>                                  .geoDistanceSort(<span class="hljs-string">&quot;location&quot;</span>, <span class="hljs-keyword">new</span> GeoPoint(location))<br>                                  .order(SortOrder.ASC)<br>                                  .unit(DistanceUnit.KILOMETERS)<br>                                 );<br>        &#125;<br><br>        <span class="hljs-comment">// 3.发送请求</span><br>        SearchResponse response = client.search(request, RequestOptions.<span class="hljs-keyword">DEFAULT</span>);<br>        <span class="hljs-comment">// 4.解析响应</span><br>        <span class="hljs-keyword">return</span> handleResponse(response);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-布尔查询"><a href="#4-布尔查询" class="headerlink" title="4.布尔查询"></a>4.布尔查询</h6><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2729274-20230205173858188-382428581.png" alt="image"></p><p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.准备BooleanQuery</span><br>    <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">boolQuery</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>    <span class="hljs-comment">// 2.2.添加term</span><br>    boolQuery.must(QueryBuilders.termQuery(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;杭州&quot;</span>));<br>    <span class="hljs-comment">// 2.3.添加range</span><br>    boolQuery.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(<span class="hljs-number">250</span>));<br><br>    request.source().query(boolQuery);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-算分函数"><a href="#5-算分函数" class="headerlink" title="5.算分函数"></a>5.算分函数</h6><h6 id="6-设置搜索结果"><a href="#6-设置搜索结果" class="headerlink" title="6.设置搜索结果"></a>6.设置搜索结果</h6><h6 id="7-高亮"><a href="#7-高亮" class="headerlink" title="7.高亮"></a>7.高亮</h6><h6 id="8-聚合"><a href="#8-聚合" class="headerlink" title="8.聚合"></a>8.聚合</h6><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><h3 id="Es-Mysql数据同步"><a href="#Es-Mysql数据同步" class="headerlink" title="Es Mysql数据同步"></a>Es Mysql数据同步</h3><h3 id="Es集群"><a href="#Es集群" class="headerlink" title="Es集群"></a>Es集群</h3><p>&#x2F;&#x2F;项目用到自然会讲解</p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><h4 id="1-kafka配和更新"><a href="#1-kafka配和更新" class="headerlink" title="1.kafka配和更新"></a>1.kafka配和更新</h4><p>具体就是拿到新增的分值-然后传到es</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleIncrHandleListener</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-title class_">RedisTemplate</span> redisTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-title class_">RestHighLevelClient</span> restHighLevelClient;<br>    <span class="hljs-meta">@KafkaListener</span>(topics = <span class="hljs-title class_">HotArticleConstants</span>.<span class="hljs-property">HOT_ARTICLE_CONSUMER_QUEUE</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> message</span>) &#123;<br>        <span class="hljs-title class_">ArticleVisitStreamMess</span> mess= <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parseObject</span>(message, <span class="hljs-title class_">ArticleVisitStreamMess</span>.<span class="hljs-property">class</span>);<br>        <span class="hljs-comment">//对分值进行处理</span><br>        <span class="hljs-title function_">savemess</span>(mess);<br><br>        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;收到消息:&#123;&#125;&quot;</span>, message);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">savemess</span>(<span class="hljs-params"><span class="hljs-title class_">ArticleVisitStreamMess</span> mess</span>) &#123;<br>        <span class="hljs-comment">//拿出点赞 评论 浏览-id的权重</span><br>        <span class="hljs-comment">//计算总评分-存入redis-id+总积分-叠加//总积分表 -mucisid id-&gt;根据音乐id总权拿id</span><br>        int score=mess.<span class="hljs-title function_">getLike</span>()*<span class="hljs-number">5</span>+mess.<span class="hljs-title function_">getComment</span>()*<span class="hljs-number">2</span>+mess.<span class="hljs-title function_">getView</span>();<br>        redisTemplate.<span class="hljs-title function_">opsForZSet</span>().<span class="hljs-title function_">add</span>(<span class="hljs-title class_">HotArticleConstants</span>.<span class="hljs-property">HOT_ARTICLE_REDIS_QUEUE</span>,mess.<span class="hljs-title function_">getMuicid</span>(),score);<br><br>        <span class="hljs-comment">//根据数量-评论 浏览 id 修改es对应的最新数量</span><br>        <span class="hljs-title class_">UpdateRequest</span> updateRquest=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateRequest</span>();<br>        updateRquest.<span class="hljs-title function_">index</span>(<span class="hljs-string">&quot;online_music_index&quot;</span>).<span class="hljs-title function_">id</span>(mess.<span class="hljs-title function_">getMuicid</span>()).<span class="hljs-title function_">doc</span>(mess);<br><br><br>        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        params.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;view&quot;</span>, mess.<span class="hljs-title function_">getView</span>());<br>        params.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;comment&quot;</span>, mess.<span class="hljs-title function_">getComment</span>());<br>        params.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;like&quot;</span>, mess.<span class="hljs-title function_">getLike</span>());<br><br>        <span class="hljs-title class_">Script</span> script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Script</span>(<span class="hljs-title class_">ScriptType</span>.<span class="hljs-property">INLINE</span>, <span class="hljs-string">&quot;painless&quot;</span>,<br>                <span class="hljs-string">&quot;ctx._source.comments += params.comment;&quot;</span> +<br>                        <span class="hljs-string">&quot;ctx._source.views += params.view;&quot;</span> +<br>                        <span class="hljs-string">&quot;ctx._source.likes += params.like;&quot;</span>,<br>                params);<br>        updateRquest.<span class="hljs-title function_">script</span>(script);<br>        <span class="hljs-keyword">try</span> &#123;<br>            restHighLevelClient.<span class="hljs-title function_">update</span>(updateRquest, <span class="hljs-title class_">RequestOptions</span>.<span class="hljs-property">DEFAULT</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//目前能像到的就这样</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-页面的附加展示和推荐"><a href="#2-页面的附加展示和推荐" class="headerlink" title="2.页面的附加展示和推荐"></a>2.页面的附加展示和推荐</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>RestHighLevelClient restHighLevelClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> R <span class="hljs-title function_">show</span><span class="hljs-params">(OnlineMusic onlineMusic)</span> &#123;<br>    <span class="hljs-comment">//根据redis-从分值开始拿出推荐-缺点就是一直固定</span><br>    <span class="hljs-comment">/// redisTemplate.opsForZSet().add(HotArticleConstants.HOT_ARTICLE_REDIS_QUEUE,mess.getMuicid(),score);</span><br>    <span class="hljs-comment">//1 10 2 20 3 30</span><br>    <span class="hljs-comment">//降序reverseRange 升序 range</span><br><br>    Set&lt;String&gt; set = redisTemplate.opsForZSet().reverseRange(HotArticleConstants.HOT_ARTICLE_REDIS_QUEUE, onlineMusic.getPage() * <span class="hljs-number">10</span> - <span class="hljs-number">10</span>, onlineMusic.getPage() * <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//数据来自es-两个搜索-带坐标附加-不带就是推荐</span><br><br>    <span class="hljs-type">OnlineMusicDoc</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnlineMusicDoc</span>(onlineMusic);<br>    <span class="hljs-type">GeoPoint</span> <span class="hljs-variable">geoPoint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeoPoint</span>(doc.getLocation());<br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;online_music_index&quot;</span>);<br>    <span class="hljs-keyword">if</span>(doc.getLocation().isEmpty())<br>    &#123;<br>        <span class="hljs-comment">//首页搜索</span><br><br>        <span class="hljs-type">SearchSourceBuilder</span> <span class="hljs-variable">searchSourceBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchSourceBuilder</span>();<br>        searchSourceBuilder.query(QueryBuilders.termsQuery(<span class="hljs-string">&quot;music&quot;</span>, set)); <span class="hljs-comment">// 使用文档ID字段</span><br><br>        request.source(searchSourceBuilder);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">search</span> <span class="hljs-operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)<br>        &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//附加推荐搜索</span><br><br>        <span class="hljs-type">SearchSourceBuilder</span> <span class="hljs-variable">sourceBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchSourceBuilder</span>();<br>        sourceBuilder.sort(SortBuilders.geoDistanceSort(<span class="hljs-string">&quot;location&quot;</span>, geoPoint)<br>                .order(SortOrder.ASC)  <span class="hljs-comment">// 按距离升序排序</span><br>                .unit(org.elasticsearch.common.unit.DistanceUnit.KILOMETERS));  <span class="hljs-comment">// 单位为公里</span><br>        sourceBuilder.query(QueryBuilders.termsQuery(<span class="hljs-string">&quot;music&quot;</span>, set)); <span class="hljs-comment">// 使用文档ID字段</span><br>        request.source(sourceBuilder);<br>    &#125;<br>    List&lt;Map&lt;String, Object&gt;&gt; resultList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//解析es</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <br>        <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">search</span> <span class="hljs-operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);<br><br>        <span class="hljs-comment">// 获取 hits</span><br>        SearchHit[] hits = search.getHits().getHits();<br>        <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();<br>            resultList.add(sourceAsMap);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ps:应该由es直接提供，es本身就能计算分值</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">return</span> R.success(resultList);<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kafka Stream</title>
    <link href="/2024/10/11/Middleware/kafka/kafkaStream/Kafka%20Stream/"/>
    <url>/2024/10/11/Middleware/kafka/kafkaStream/Kafka%20Stream/</url>
    
    <content type="html"><![CDATA[<h1 id="kafka-Streams"><a href="#kafka-Streams" class="headerlink" title="kafka Streams"></a>kafka Streams</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011132134511.png" alt="image-20241011132134511"></p><blockquote><p><strong>Kafka Streams</strong>：作为 Kafka 的内置流处理库，专注于处理 Kafka 中的数据流，适合需要流式处理 Kafka 消息的应用，具有简单的 API 和高效的处理能力。</p></blockquote><h5 id="1-了解kafka-Streams"><a href="#1-了解kafka-Streams" class="headerlink" title="1.了解kafka Streams"></a>1.了解kafka Streams</h5><p>Kafka Stream是Apache Kafka从0.10版本引入的一个新Feature。它是提供了对存储于Kafka内的数据进行流式处理和分析的功能。</p><p>Kafka Stream的特点如下：</p><ul><li>Kafka Stream提供了一个非常简单而轻量的Library，它可以非常方便地嵌入任意Java应用中，也可以任意方式打包和部署</li><li>除了Kafka外，无任何外部依赖</li><li>充分利用Kafka分区机制实现水平扩展和顺序性保证</li><li>通过可容错的state store实现高效的状态操作（如windowed join和aggregation）</li><li>支持正好一次处理语义</li><li>提供记录级的处理能力，从而实现毫秒级的低延迟</li><li>支持基于事件时间的窗口操作，并且可处理晚到的数据（late arrival of records）</li><li>同时提供底层的处理原语Processor（类似于Storm的spout和bolt），以及高层抽象的DSL（类似于Spark的map&#x2F;group&#x2F;reduce）</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011132426558.png" alt="image-20241011132426558"></p><p>按照时间轴堆积处理</p><h5 id="2-Kafka-Streams的关键概念"><a href="#2-Kafka-Streams的关键概念" class="headerlink" title="2.Kafka Streams的关键概念"></a>2.Kafka Streams的关键概念</h5><ul><li><strong>源处理器（Source Processor）</strong>：<strong>源处理器是一个没有任何上游处理器的特殊类型的流处理器。它从一个或多个kafka主题生成输入流。通过消费这些主题的消息并将它们转发到下游处理器。</strong>-交换机</li><li><strong>Sink处理器</strong>：sink处理器是一个没有下游流处理器的特殊类型的流处理器。它接收上游流处理器的消息发送到一个指定的<strong>Kafka主题</strong>。-队列-与此kafka主题为消费者</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011132529993.png" alt="image-20241011132529993"></p><h5 id="3-KStream数据结构"><a href="#3-KStream数据结构" class="headerlink" title="3.KStream数据结构"></a>3.KStream数据结构</h5><p>结构类似于map,如下图，key-value键值对</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011132829446.png" alt="image-20241011132829446"></p><h5 id="4-KStream"><a href="#4-KStream" class="headerlink" title="4.KStream"></a>4.KStream</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011132931855.png" alt="image-20241011132931855"></p><p>KStream 是 Kafka Streams API 中用于处理数据流的一个核心概念，<strong>代表着一个顺序且不断更新的数据集</strong>.</p><p>数据流中常记录事件，每个事件都类似于向日志中插入的新数据，而不是对之前数据的更新。</p><p>因此，每一条数据都被看作是对前一条数据的累加或增量更新。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011133220139.png" alt="image-20241011133220139"></p><p>每一条新数据都是对流中已有数据的增量，而不是对某个值的替换或更新。即使新数据和已有数据的 key 相同（如上例中的 “alice”），它们也不会覆盖，<strong>而是作为新数据插入流中。</strong>-&gt;我们可以汇总行为-算出结果集</p><h5 id="原生代码"><a href="#原生代码" class="headerlink" title="原生代码"></a>原生代码</h5><p>需求分析，求单词个数（word count）</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011133318225.png" alt="image-20241011133318225"></p><p>依赖导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- kafkfa --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt;<br>            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br>            &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;<br>        &lt;/exclusion&gt;<br>    &lt;/exclusions&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br>    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br>    &lt;artifactId&gt;kafka-streams&lt;/artifactId&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt;<br>            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br>            &lt;artifactId&gt;connect-json&lt;/artifactId&gt;<br>        &lt;/exclusion&gt;<br>        &lt;exclusion&gt;<br>            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br>            &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;<br>        &lt;/exclusion&gt;<br>    &lt;/exclusions&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><blockquote><ol><li><p><strong>生产者发送消息</strong>：</p><ul><li>Kafka 生产者应用程序负责发送消息到 Kafka 集群中的主题（Topic）。在你的示例中，生产者发送消息到 <code>itcast-topic-input</code> 主题。</li></ul></li><li><p><strong>Kafka Streams 应用程序进行流处理</strong>：</p><ul><li>Kafka Streams 应用程序使用 <code>StreamsBuilder</code> 来构建流处理拓扑。</li><li>在你的代码中，<code>streamProcessor</code> 方法定义了流处理逻辑，它从 <code>itcast-topic-input</code> 主题接收消息，进行处理（例如分割、聚合等），并将处理结果发送到另一个主题 <code>itcast-topic-out</code>。</li></ul></li><li><p><strong>消费者获取消息</strong>：</p><ul><li>Kafka 消费者应用程序连接到 Kafka 集群，并从特定主题中拉取（consume）消息。</li><li>在你的示例中，消费者应该订阅 <code>itcast-topic-out</code> 主题来获取 Kafka Streams 应用程序处理后的消息。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011144449509.png" alt="image-20241011144449509"></p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">kafka_test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 配置 Apache Kafka Streams 应用程序的属性</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">///class Properties extends Hashtable&lt;Object,Object&gt;</span><br>        prop.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="hljs-string">&quot;192.168.200.130:9092&quot;</span>);<br>        prop.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());<br>        prop.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());<br>        prop.put(StreamsConfig.APPLICATION_ID_CONFIG,<span class="hljs-string">&quot;streams-quickstart&quot;</span>);<br>        <span class="hljs-comment">//stream 构建器</span><br>        <span class="hljs-type">StreamsBuilder</span> <span class="hljs-variable">streamsBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamsBuilder</span>();<br><br>        <span class="hljs-comment">// 定义流处理逻辑</span><br>        streamProcessor(streamsBuilder);<br><br><br>        <span class="hljs-comment">// 创建 Kafka Streams 实例</span><br>        <span class="hljs-type">KafkaStreams</span> <span class="hljs-variable">kafkaStreams</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaStreams</span>(streamsBuilder.build(),prop);<br>        <span class="hljs-comment">//开启流式计算</span><br>        kafkaStreams.start();<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 流式计算</span><br><span class="hljs-comment">     * 消息的内容：hello kafka  hello itcast</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> streamsBuilder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">streamProcessor</span><span class="hljs-params">(StreamsBuilder streamsBuilder)</span> &#123;<br>        <span class="hljs-comment">//创建kstream对象，同时指定从那个topic中接收消息</span><br>        KStream&lt;String, String&gt; stream = streamsBuilder.stream(<span class="hljs-string">&quot;itcast-topic-input&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 处理消息的value</span><br><span class="hljs-comment">         */</span><br>        stream.flatMapValues(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueMapper</span>&lt;String, Iterable&lt;String&gt;&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Iterable&lt;String&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(String value)</span> &#123;<br>                        <span class="hljs-keyword">return</span> Arrays.asList(value.split(<span class="hljs-string">&quot; &quot;</span>));<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">//按照value进行聚合处理</span><br>                .groupBy((key,value)-&gt;value)<br>                <span class="hljs-comment">//时间窗口</span><br>                .windowedBy(TimeWindows.of(Duration.ofSeconds(<span class="hljs-number">10</span>)))<br>                <span class="hljs-comment">//统计单词的个数</span><br>                .count()<br>                <span class="hljs-comment">//转换为kStream</span><br>                .toStream()<br>                .map((key,value)-&gt;&#123;<br>                    System.out.println(<span class="hljs-string">&quot;key:&quot;</span>+key+<span class="hljs-string">&quot;,vlaue:&quot;</span>+value);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyValue</span>&lt;&gt;(key.key().toString(),value.toString());<br>                &#125;)<br>                <span class="hljs-comment">//发送消息</span><br>                .to(<span class="hljs-string">&quot;itcast-topic-out&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.kafka的配置信息</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//Kafka的连接地址</span><br>        pro.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="hljs-string">&quot;49.234.48.192:9092&quot;</span>);<br>        <span class="hljs-comment">//发送失败，失败重连次数</span><br>        pro.put(ProducerConfig.RETRIES_CONFIG,<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//消息key的序列化器</span><br>        pro.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        <span class="hljs-comment">//消息value的序列化器</span><br>        pro.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        <span class="hljs-comment">//数据压缩</span><br>        pro.put(ProducerConfig.COMPRESSION_TYPE_CONFIG,<span class="hljs-string">&quot;lz4&quot;</span>);<br>        <span class="hljs-comment">//2.生产者对象</span><br>        KafkaProducer&lt;String,String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;String, String&gt;(pro);<br><br>         String[] messages = &#123;<br>                <span class="hljs-string">&quot;hello kafka hello itcast&quot;</span>,<br>                <span class="hljs-string">&quot;welcome to kafka streams&quot;</span>,<br>                <span class="hljs-string">&quot;kafka is a distributed streaming platform&quot;</span><br>        &#125;;<br>          <span class="hljs-keyword">for</span> (String message : messages) &#123;<br>            ProducerRecord&lt;String, String&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;&gt;(<span class="hljs-string">&quot;itcast-topic-input&quot;</span>, message);<br>            producer.send(record);<br>            System.out.println(<span class="hljs-string">&quot;Sent: &quot;</span> + message);<br>        &#125;<br><br>        <br>        <span class="hljs-comment">//5.关闭消息通道(必选)</span><br>        producer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消费者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.添加Kafka配置信息</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//Kafka的连接地址</span><br>        pro.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="hljs-string">&quot;49.234.48.192:9092&quot;</span>);<br>        <span class="hljs-comment">//消费者组</span><br>        pro.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="hljs-string">&quot;group2&quot;</span>);<br>        <span class="hljs-comment">//消息key的反序列化器</span><br>        pro.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,<span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        <span class="hljs-comment">//消息value的反序列化器</span><br>        pro.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,<span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        <span class="hljs-comment">//手动提交偏移量</span><br>        pro.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//2.消费者对象</span><br>        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(pro);<br>        <span class="hljs-comment">//3.订阅主题</span><br>        consumer.subscribe(Collections.singletonList(<span class="hljs-string">&quot;tbug-topic-out&quot;</span>));<br>        <span class="hljs-comment">//4.设置线程一种处于监听状态</span><br>        <span class="hljs-comment">//同步提交和异步提交偏移量</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">//5.获取消息</span><br>                ConsumerRecords&lt;String, String&gt; messages = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>)); <span class="hljs-comment">//设置每秒钟拉取一次</span><br>                <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; message : messages) &#123;<br>                    System.out.print(message.key() + <span class="hljs-string">&quot;:&quot;</span>);<br>                    System.out.println(message.value());<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;记录错误的信息：&quot;</span>+e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//同步</span><br>            consumer.commitSync();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="spring-集结"><a href="#spring-集结" class="headerlink" title="spring 集结"></a>spring 集结</h5><blockquote><ul><li>JDK 8或更高版本</li><li>Apache Kafka</li><li>Spring Boot</li><li>Maven</li></ul></blockquote><p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Spring Boot --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- Spring Kafka --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br>    <span class="hljs-comment">&lt;!-- Kafka Streams --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-streams<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.在application.properties文件中添加Kafka相关的配置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">spring.kafka.bootstrap-servers=localhost:<span class="hljs-number">9092</span><br>spring.kafka.consumer.auto-<span class="hljs-keyword">offset</span>-<span class="hljs-keyword">reset</span>=earliest///指定了消费者在读取特定主题时，如果未找到有效的 <span class="hljs-keyword">offset</span>（比如在消费者开始读取之前主题刚刚被创建），消费者应该从哪个 <span class="hljs-keyword">offset</span> 开始读取数据。<br>earliest：消费者将从每个分区的最开始处开始读取消息。<br>latest：消费者将从每个分区的最新记录开始读取消息。<br><span class="hljs-keyword">none</span>：消费者将拒绝读取消息，如果它找不到有效的 <span class="hljs-keyword">offset</span>。<br><br><br>spring.kafka.consumer.<span class="hljs-keyword">group</span>-id=my-<span class="hljs-keyword">group</span><br>Kafka 使用消费者组来管理一组消费者，它们共同消费一个主题的数据。每个消费者组内的消费者实例会协调彼此，以平衡负载并确保每个消息只被组内的一个消费者处理。<br><span class="hljs-keyword">group</span>-id 是用来标识一个消费者组的唯一标识符。同一个消费者组中的所有消费者将共享相同的 <span class="hljs-keyword">group</span>-id。<br></code></pre></td></tr></table></figure><p>3.创建Kafka Streams处理器</p><p>4.我们需要创建一个Kafka Streams处理器来定义我们的数据处理逻辑。可以创建一个新的类，实现Spring的<code>KafkaStreamsDSL</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableKafkaStreams</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaStreamsProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">KafkaStreamsDSL</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">INPUT_TOPIC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;my-input-topic&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT_TOPIC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;my-output-topic&quot;</span>;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildStreams</span><span class="hljs-params">(StreamsBuilder builder)</span> &#123;<br>        <span class="hljs-comment">//本身作为输入流</span><br>        KStream&lt;String, String&gt; inputTopic = builder.stream(INPUT_TOPIC);<br>        <br>        <span class="hljs-comment">// 在这里添加数据处理逻辑</span><br>        KStream&lt;String, String&gt; outputTopic = inputTopic<br>            .mapValues(value -&gt; value.toUpperCase())<br>            .filter((key, value) -&gt; value.length() &gt; <span class="hljs-number">5</span>);<br>            <br>        outputTopic.to(OUTPUT_TOPIC);<span class="hljs-comment">//充当数据数据的作用-发送给output</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在上面的代码中，我们创建了一个输入主题<code>my-input-topic</code>和一个输出主题<code>my-output-topic</code>。然后，我们使用<code>mapValues</code>方法将输入流中的值转换为大写，并使用<code>filter</code>方法过滤长度大于5的记录。最后，我们使用<code>to</code>方法将输出流写入输出主题。</p></blockquote><p>5.我们可以在Spring Boot应用程序的主类中启动Kafka Streams处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>        <span class="hljs-comment">//启用处理器</span><br>        <br>        <span class="hljs-type">KafkaStreamsProcessor</span> <span class="hljs-variable">kafkaStreamsProcessor</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaStreamsProcessor</span>();<br>            <br>        kafkaStreamsProcessor.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.生产和消费消息</p><p>我们可以使用Kafka生产者向输入主题发送消息，并使用Kafka消费者从输出主题接收处理后的数据。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jade">@RestController<br>public class MessageController &#123;<br> <br>    @Autowired<br>    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br> <br>    @PostMapping(&quot;/send&quot;)<br>    public ResponseEntity&lt;String&gt; sendMessage(@RequestBody String message) &#123;<br>        kafkaTemplate.send(&quot;my-input-topic&quot;, message);<br>        return ResponseEntity.ok(&quot;Message sent successfully&quot;);<br>    &#125;<br>    <br>    @GetMapping(&quot;/receive&quot;)<br>    public ResponseEntity&lt;List&lt;String&gt;&gt; receiveMessages() &#123;<br>        List&lt;String&gt; messages = // 从输出主题读取消息<br>        return ResponseEntity.ok(messages);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="计算音乐热点值"><a href="#计算音乐热点值" class="headerlink" title="计算音乐热点值"></a>计算音乐热点值</h5><h6 id="1-导出依赖"><a href="#1-导出依赖" class="headerlink" title="1.导出依赖"></a>1.导出依赖</h6><p>2.编写输出类</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">&quot;消息发送增量&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateArticleMess</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> musicid;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改数据的增量，可为正负</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer add;<br>    <br>    <span class="hljs-keyword">private</span> UpdateArticleType type;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-title class_"><span class="hljs-keyword">enum</span> <span class="hljs-title">UpdateArticleType</span> &#123;</span><br>        COMMENT, <span class="hljs-comment">// 评论</span><br>        LIKE, <span class="hljs-comment">// 点赞</span><br>        VIEWS; <span class="hljs-comment">// 浏览量（假设您想保留原有的VIEWS，表示浏览次数）</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-编写发送消息"><a href="#3-编写发送消息" class="headerlink" title="3.编写发送消息"></a>3.编写发送消息</h6><blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">HotArticleConstants</span> </span>&#123;<br><br>    <span class="hljs-comment">// 消费者队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> HOT_ARTICLE_CONSUMER_QUEUE = <span class="hljs-string">&quot;hot_article_consumer_queue&quot;</span>;<br><br>    <span class="hljs-comment">// 生产者队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> HOT_ARTICLE_PRODUCER_QUEUE = <span class="hljs-string">&quot;hot_article_producer_queue&quot;</span>;<br><br>    <span class="hljs-comment">// 数据聚合处理队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> HOT_ARTICLE_AGGREGATION_QUEUE = <span class="hljs-string">&quot;hot_article_aggregation_queue&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><p>发送消息到聚合处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">mucisId</span> <span class="hljs-operator">=</span> String.valueOf(redisTemplate.opsForHash().increment(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + MusicId, OnlineMusicField.PLAY_COUNT.getFieldCode(), <span class="hljs-number">1</span>));<br>       UpdateArticleMess mess=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateArticleMess</span>();<br>       mess.setMusicid(MusicId);<br>       mess.setAdd(<span class="hljs-number">1</span>);<br>       mess.setType(UpdateArticleMess.UpdateArticleType.VIEWS);<br><br><br>       kmsTemplate.send( HotArticleConstants.HOT_ARTICLE_AGGREGATION_QUEUE,mess);<br></code></pre></td></tr></table></figure><p>4..定义消息封装类</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs axapta">@Data<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleVisitStreamMess</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文章id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String muicid ;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阅读</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> view;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 评论</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> comment;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 点赞</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">like</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-编写数据聚合处理"><a href="#5-编写数据聚合处理" class="headerlink" title="5.编写数据聚合处理 **"></a>5.编写数据聚合处理 **</h6><p>ps:感谢ai大老人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotArticleStreamHandler</span> &#123;<br>    <span class="hljs-comment">///从某个 Kafka 主题中读取数据并进行处理</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> KStream&lt;String,String&gt; <span class="hljs-title function_">kStream</span><span class="hljs-params">(StreamsBuilder streamsBuilder)</span> &#123;<br>        <span class="hljs-comment">//读取数据聚合队列消息-数据消息miss类型</span><br>        KStream&lt;String, String&gt; stream = streamsBuilder.stream(HotArticleConstants.HOT_ARTICLE_AGGREGATION_QUEUE);<br>        <span class="hljs-comment">//聚合流式处理</span><br>        stream.map((key,value)-&gt;<br>                &#123;<br>                    UpdateArticleMess mess= JSON.parseObject(value,UpdateArticleMess.class);<br>                    <span class="hljs-comment">//重置消息的key:1234343434(musicid)   和  value: likes:1(typeAndAdd)</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">musicid</span> <span class="hljs-operator">=</span> mess.getMusicid();<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">typeAndAdd</span> <span class="hljs-operator">=</span>mess.getType().name()+mess.getAdd();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyValue</span>&lt;&gt;(musicid, typeAndAdd);<br>                &#125;<span class="hljs-comment">///第一层数据转换stream</span><br>                ).groupBy((key,value)-&gt;key)<span class="hljs-comment">//根据id分组</span><br>                .windowedBy(TimeWindows.of(Duration.ofSeconds(<span class="hljs-number">10</span>)))<span class="hljs-comment">//时间窗口堆积处理</span><br>                        .aggregate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Initializer</span>&lt;String&gt;()<br>                                   &#123;<span class="hljs-comment">///    // 执行聚合操作，初始化为 &quot;0&quot;</span><br>                                       <span class="hljs-meta">@Override</span><br>                                       <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">()</span> &#123;<br>                                           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;view:0,comment:0,like:0&quot;</span>;<br>                                       &#125;<br>                                   &#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Aggregator</span>&lt;String,String,String&gt;()<br>                                   &#123;<br>                                       <span class="hljs-comment">/**</span><br><span class="hljs-comment">                                        * 真正的聚合操作，返回值是消息的value</span><br><span class="hljs-comment">                                        */</span><br>                                       <span class="hljs-meta">@Override</span><br>                                       <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(String key, String value, String aggValue)</span> &#123;<br>                                           <span class="hljs-comment">//无值直接返回</span><br>                                           <span class="hljs-keyword">if</span>(StringUtils.isBlank(value))<br>                                           &#123;<br>                                               <span class="hljs-keyword">return</span> aggValue;<br>                                           &#125;<br>                                           <span class="hljs-comment">///&quot;view:0,comment:0,like:0&quot;</span><br>                                           <span class="hljs-comment">/// likes:1(typeAndAdd)</span><br>                                           String[] aggAry = aggValue.split(<span class="hljs-string">&quot;,&quot;</span>);<br>                                           <span class="hljs-type">int</span> com=<span class="hljs-number">0</span>,lik=<span class="hljs-number">0</span>,vie=<span class="hljs-number">0</span>;<span class="hljs-comment">//评论 点赞 浏览</span><br>                                           <span class="hljs-keyword">for</span> (String item : aggAry) &#123;<br>                                               <span class="hljs-comment">//拿出对应的点赞 浏览 评论次数</span><br>                                               <span class="hljs-keyword">if</span>(item.startsWith(<span class="hljs-string">&quot;comment&quot;</span>))<br>                                               &#123;<br>                                                   com=Integer.parseInt(item.split(<span class="hljs-string">&quot;:&quot;</span>)[<span class="hljs-number">1</span>]);<br>                                               &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item.startsWith(<span class="hljs-string">&quot;like&quot;</span>))<br>                                               &#123;<br>                                                   lik=Integer.parseInt(item.split(<span class="hljs-string">&quot;:&quot;</span>)[<span class="hljs-number">1</span>]);<br>                                               &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item.startsWith(<span class="hljs-string">&quot;view&quot;</span>))<br>                                               &#123;<br>                                                   vie=Integer.parseInt(item.split(<span class="hljs-string">&quot;:&quot;</span>)[<span class="hljs-number">1</span>]);<br>                                               &#125;<br><br>                                           &#125;<br>                                           <span class="hljs-comment">///累加操作</span><br>                                           String[] valAry = value.split(<span class="hljs-string">&quot;:&quot;</span>);<br>                                           <span class="hljs-keyword">if</span>(valAry[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;view&quot;</span>))<br>                                           &#123;<br>                                               vie+=Integer.parseInt(valAry[<span class="hljs-number">1</span>]);<br>                                           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(valAry[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;comment&quot;</span>))<br>                                           &#123;<br>                                               com+=Integer.parseInt(valAry[<span class="hljs-number">1</span>]);<br>                                           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(valAry[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;like&quot;</span>))<br>                                           &#123;<br>                                               lik+=Integer.parseInt(valAry[<span class="hljs-number">1</span>]);<br>                                           &#125;<br>                                           <span class="hljs-comment">// 进行统计</span><br>                                           <span class="hljs-type">String</span> <span class="hljs-variable">formatStr</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;,COMMENT:%d,LIKES:%d,VIEWS:%d&quot;</span>,  com, lik, vie);<br>                                           System.out.println(<span class="hljs-string">&quot;文章的id:&quot;</span>+key);<br>                                           System.out.println(<span class="hljs-string">&quot;当前时间窗口内的消息处理结果：&quot;</span>+formatStr);<br><br>                                           <span class="hljs-keyword">return</span> formatStr;<br>                                       &#125;<br>                                   &#125;, Materialized.as(<span class="hljs-string">&quot;hot-article-stream-aggregation-store&quot;</span>))<span class="hljs-comment">// 指定状态存储</span><br>                <span class="hljs-comment">///Kafka Streams 会使用这个名称为你的聚合操作创建一个状态存储，并将结果存储在本地（或远程）供后续查询和使用。</span><br>                <span class="hljs-comment">//使用 Materialized.as() 可以创建命名的存储。如果你想在流处理应用程序中查询聚合结果，可以通过状态存储的名称找到对应的结果。</span><br>                                .toStream().map((key,value)-&gt;&#123;<br><br>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyValue</span>&lt;&gt;(key.key().toString(),formatObj(key.key().toString(),value));<br>                        &#125;).to(HotArticleConstants.HOT_ARTICLE_PRODUCER_QUEUE);<span class="hljs-comment">// // 生产者队列</span><br><br>        <span class="hljs-keyword">return</span> stream;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将传入的文章统计数据（作为字符串形式）解析为一个 ArticleVisitStreamMess 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">formatObj</span><span class="hljs-params">(String mucid, String value)</span> &#123;<br>        <span class="hljs-type">ArticleVisitStreamMess</span> <span class="hljs-variable">mess</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArticleVisitStreamMess</span>();<br>        mess.setMuicid(mucid);<br>        <span class="hljs-comment">//COMMENT:0,LIKES:0,VIEWS:0</span><br>        String[] valAry = value.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String val : valAry) &#123;<br>            String[] split = val.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 COMMENT, // 评论</span><br><span class="hljs-comment">        LIKE, // 点赞</span><br><span class="hljs-comment">        VIEWS; // 浏览量（假设您想保留原有的VIEWS，表示浏览次数）</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">switch</span> (UpdateArticleMess.UpdateArticleType.valueOf(split[<span class="hljs-number">0</span>]))&#123;<br>                <span class="hljs-keyword">case</span> COMMENT:<br>                    mess.setComment(Integer.parseInt(split[<span class="hljs-number">1</span>]));<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> LIKE:<br>                    mess.setLike(Integer.parseInt(split[<span class="hljs-number">1</span>]));<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> VIEWS:<br>                    mess.setView(Integer.parseInt(split[<span class="hljs-number">1</span>]));<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;聚合消息处理之后的结果为:&#123;&#125;&quot;</span>,JSON.toJSONString(mess));<br>        <span class="hljs-keyword">return</span> JSON.toJSONString(mess);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>分层聚合图片</p><p>该代码的核心是流处理的三个阶段：</p><ol><li>读取来自 Kafka 队列的数据流。</li><li>对数据进行映射、分组和聚合处理。</li><li>将聚合后的结果输出到另一个 Kafka 队列。</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241012112753671.png" alt="image-20241012112753671"></p><h6 id="6-定义监听者"><a href="#6-定义监听者" class="headerlink" title="6.定义监听者"></a>6.定义监听者</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleIncrHandleListener</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-title class_">RedisTemplate</span> redisTemplate;<br>    <span class="hljs-meta">@KafkaListener</span>(topics = <span class="hljs-title class_">HotArticleConstants</span>.<span class="hljs-property">HOT_ARTICLE_CONSUMER_QUEUE</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> message</span>) &#123;<br>        <span class="hljs-title class_">ArticleVisitStreamMess</span> mess= <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parseObject</span>(message, <span class="hljs-title class_">ArticleVisitStreamMess</span>.<span class="hljs-property">class</span>);<br>        <span class="hljs-comment">//对分值进行处理</span><br>        <span class="hljs-title function_">savemess</span>(mess);<br><br>        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;收到消息:&#123;&#125;&quot;</span>, message);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">savemess</span>(<span class="hljs-params"><span class="hljs-title class_">ArticleVisitStreamMess</span> mess</span>) &#123;<br>        <span class="hljs-comment">//拿出点赞 评论 浏览-id的权重</span><br>        <span class="hljs-comment">//计算总评分-存入redis-id+总积分-叠加//总积分表 -mucisid id-&gt;根据音乐id总权拿id</span><br>        <span class="hljs-comment">//根据数量-评论 浏览 id 修改es对应的最新数量</span><br>        <span class="hljs-comment">//目前能像到的就这样</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ps:集体逻辑完了</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Canal</title>
    <link href="/2024/10/10/Middleware/Canal/canal/"/>
    <url>/2024/10/10/Middleware/Canal/canal/</url>
    
    <content type="html"><![CDATA[<h1 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h1><h3 id="canal介绍"><a href="#canal介绍" class="headerlink" title="canal介绍"></a>canal介绍</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139313130343130313733353934372e706e67" alt="img"></p><p>基于日志增量订阅和消费的业务包括</p><ul><li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护(拆分异构索引、倒排索引等)</li><li>业务 cache 刷新</li><li>带业务逻辑的增量数据处理</li></ul><p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x</p><h4 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab12595ca3315b4b6de1ad18fad728b4.png" alt="img"></p><p>如上是mysql的主从同步</p><blockquote><p>1.Master 主库将改变记录，写到binary log中</p><p>2.Slave 从库向 MySQL Master 发送 dump 协议，将 Master 主库的 binary log events 拷到它的relay log</p><p>3.Slave 从库读取并重做relay log中的事件，将改变的数据同步到自己的数据库</p></blockquote><p>其他优点</p><blockquote><p>在线上环境，对于读远大于写的场景，一般都是一主多从，主库进行写操作，从库进行读操作，然后主库内容更新再同步给从库</p><p>binary log主要作⽤是记录数据库中表的更改，它只记录改变数据的sql，不改变数据的sql不会写⼊，⽐如select语句⼀般不会被记录，因为他们不会对数据产⽣任何改动</p><p>relay log的结构和binlog非常相似，只不过他多了一个master.info和relay-log.info的文件，master.info记录了上一次读取到master同步过来的binlog的位置，以及连接master和启动复制必须的所有信息。relay-log.info记录了文件复制的进度，下一个事件从什么位置开始，由sql线程负责更新</p></blockquote><h4 id="canal原理"><a href="#canal原理" class="headerlink" title="canal原理"></a>canal原理</h4><p>canal其实本质就是将自己伪装成一个slave，同步主库的binary log</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010103125364.png" alt="image-20241010103125364"></p><blockquote><p>1.canal 模拟 mysql slave 的交互协议，伪装自己为 mysql slave，向 mysql master 发送 dump 协议</p><p>2.ysql master 收到 dump 请求，开始推送 binary log 给 slave (也就是 canal)</p><p>3.canal 解析 binary log 对象 </p></blockquote><h4 id="binlog日志"><a href="#binlog日志" class="headerlink" title="binlog日志"></a>binlog日志</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010103245785.png" alt="image-20241010103245785"></p><h3 id="canal部署"><a href="#canal部署" class="headerlink" title="canal部署"></a>canal部署</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010103334811.png" alt="image-20241010103334811"></p><h4 id="web页面部署"><a href="#web页面部署" class="headerlink" title="web页面部署"></a>web页面部署</h4><h5 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010103507206.png" alt="image-20241010103507206"></p><p>如果为OFF，则需要配置开启。</p><p>window版5.7.43，在安装目录找到<strong>my.ini</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><br><span class="hljs-attr">log-bin</span>= H:\\binlog\mysql-bin<br><span class="hljs-attr">server-id</span>=<span class="hljs-number">100</span><br><span class="hljs-attr">binlog_format</span> = ROW<br></code></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a></p><p>下载发布和admin</p><h5 id="配置UI界面"><a href="#配置UI界面" class="headerlink" title="配置UI界面"></a>配置UI界面</h5><p>1.执行脚本</p><blockquote><p>SQL脚本位置：conf&#x2F;canal_manager.sql</p><p>脚本中是单独创建了一个数据库canal_manager，我们也可以不单独创建数据库，与其他业务表放在一起</p></blockquote><p><strong>修改配置文件</strong></p><p>conf&#x2F;application.yml</p><p>修改内容：</p><p>数据库账户密码</p><p>点击bin&#x2F;startup.bat</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010105155750.png" alt="image-20241010105155750"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b17c6ad34b8f8f21423ad5ab89430769.png" alt="b17c6ad34b8f8f21423ad5ab89430769"></p><h5 id="2-集群设置"><a href="#2-集群设置" class="headerlink" title="2.集群设置"></a>2.集群设置</h5><p>在集群管理中，点击新建集群，新建一个集群配置。这里的zk地址就是服务端集群的zk地址。</p><p><strong>Canal的集群原理是指如何将多个Canal节点组成一个集群,以提高系统的可用性和扩展性。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010105612140.png" alt="image-20241010105612140"></p><h4 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h4><h6 id="1-配置更改"><a href="#1-配置更改" class="headerlink" title="1.配置更改"></a>1.配置更改</h6><blockquote><p><strong>mysql connector</strong></p><p>canal-admin中默认提供的驱动器是mysql5.0的，因此要替换一下（canal-deployer解压目录的lib文件夹）自行查看是否替换</p></blockquote><p>在conf目录下，备份canal.properties，将canal_local.properties重命名为canal.properties。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010110225593.png" alt="image-20241010110225593"></p><h6 id="2-启动"><a href="#2-启动" class="headerlink" title="2.启动"></a>2.启动</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010112307812.png" alt="image-20241010112307812"></p><p>在主配置中统一修改集群下的服务端deployer的配置文件，也可以统一的查看集群下的服务端实例。</p><p>在【Instance管理】中新增一个实例，也就是我们之前在服务端的conf文件夹下配置的，每一个子文件夹就代表了一个实例，每个实例都有自己的instance.properties配置文件，这里新增的实例就是这个配置文件：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010112621425.png" alt="image-20241010112621425"></p><h4 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2443180-20230617223534222-875201162.png" alt="img"></p><p>29行: canal.serverMode &#x3D; rocketMQ (这里设置了rocketMQ所以需要配置162行有关的内容，不同选择修改不同地方的配置)</p><p>86行: canal.instance.tsdb.enable &#x3D; false</p><p>127行: canal.mq.flatMessage &#x3D; true（flatMessage 为true 生产到mq的消息就是json的, 否则就是protobuf二进制的）</p><h3 id="集成Spirngboot"><a href="#集成Spirngboot" class="headerlink" title="集成Spirngboot"></a>集成Spirngboot</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这里要考虑版本兼容问题，这是与jdk8匹配的jar版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br><span class="hljs-comment">&lt;!-- Canal 相关 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.otter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>canal.protocol<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.otter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>canal.client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># rocket配置 </span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">function:</span><br>        <span class="hljs-attr">definition:</span> <span class="hljs-string">twoConsumer</span> <span class="hljs-comment"># 方法定义</span><br>      <span class="hljs-attr">bindings:</span><br>        <span class="hljs-comment"># 发送必须配置此处</span><br>        <span class="hljs-attr">producerInfo-out-0:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">test_topic</span> <span class="hljs-comment"># topic消息主题</span><br>        <span class="hljs-comment"># 配置channel消息通道 （接收必须配置此处）</span><br>        <span class="hljs-attr">twoConsumer-in-0:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">test-top</span> <span class="hljs-comment"># topic消息主题</span><br>          <span class="hljs-attr">group:</span> <span class="hljs-string">consumer-group</span> <span class="hljs-comment"># 消费者组</span><br>      <span class="hljs-attr">rocketmq:</span><br>        <span class="hljs-attr">binder:</span><br>          <span class="hljs-attr">name-server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.152</span><span class="hljs-number">.130</span><span class="hljs-string">:9876</span> <span class="hljs-comment"># rocketmq服务地址</span><br>        <span class="hljs-comment"># 配置消息通道独特属性（仅适用于rocketmq）</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-comment"># 发送必须配置此处</span><br>          <span class="hljs-comment"># 配置channel消息通道（生产者：[functionName]-out-[index]，消费者：[functionName]-in-[index]）</span><br>          <span class="hljs-attr">producerInfo-out-0:</span><br>            <span class="hljs-attr">producer:</span><br>              <span class="hljs-attr">group:</span> <span class="hljs-string">consumer-group</span> <span class="hljs-comment">#生产者的组名称（一般与消费者组相同），用于负载均衡</span><br>              <span class="hljs-attr">sync:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启同步发送</span><br></code></pre></td></tr></table></figure><p>再配置监听者-具体到MQ中配置</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2024/10/10/Middleware/mq/mq/"/>
    <url>/2024/10/10/Middleware/mq/mq/</url>
    
    <content type="html"><![CDATA[<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010135925459.png" alt="image-20241010135925459"></p><h4 id="mq分类"><a href="#mq分类" class="headerlink" title="mq分类"></a>mq分类</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010140032274.png" alt="image-20241010140032274"></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="1-场景调用"><a href="#1-场景调用" class="headerlink" title="1.场景调用"></a>1.场景调用</h4><p>OpenFeign-&gt;同步调用</p><p>很多情况下-我们需要异步调用-也就是需要一个信息通知</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010140454685.png" alt="image-20241010140454685"></p><blockquote><p>如图-交易服务-扣减肯定是同步的-其余的都能异步慢慢来处理</p><p>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。<br>这其实就是同步调用的级联失败问题。</p><p>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧。</p><p>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010140721494.png" alt="image-20241010140721494"></p><blockquote><p>异步调用<br>发送者<br>信息代理<br>信息接收者-&gt;多久读一次信息列表</p></blockquote><p>异步优点<br>1.解藕<br>2.性能高<br>3.业务扩展强<br>4.避免级联失败</p><p>缺点<br>1.依赖MQ服务器</p><h4 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h4><p><a href="https://github.com/heibaiying/Full-Stack-Notes/blob/master/notes/installation/RabbitMQ%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">https://github.com/heibaiying/Full-Stack-Notes/blob/master/notes/installation/RabbitMQ%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md</a></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/af7344458d741a8e46b618fc52ce4764.png" alt="af7344458d741a8e46b618fc52ce4764"></p><h4 id="3-控制台操作"><a href="#3-控制台操作" class="headerlink" title="3.控制台操作"></a>3.控制台操作</h4><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672*：RabbitMQ提供的管理控制台的端口</li><li>5672*：RabbitMQ的消息发送处理接口</li></ul><p>rabbitmq架构</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010141905396.png" alt="image-20241010141905396"></p><p>生产者<br><strong>publisher</strong>：生产者，也就是发送消息的一方</p><p><strong>consumer</strong>：消费者，也就是消费消息的一方</p><p><strong>queue</strong>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</p><p><strong>exchange</strong>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</p><p><strong>virtual host</strong>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</p><h5 id="1-交换机控制台操作"><a href="#1-交换机控制台操作" class="headerlink" title="1.交换机控制台操作"></a>1.交换机控制台操作</h5><p>将信息传递到队列</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143105352.png" alt="image-20241010143105352"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143112502.png" alt="c"></p><p>发送信息。无消费者</p><p>交换机没有存储信息能力</p><h5 id="2-queues-队列"><a href="#2-queues-队列" class="headerlink" title="2.queues 队列"></a>2.queues 队列</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143209622.png" alt="image-20241010143209622"></p><p>添加队列</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143227992.png" alt="image-20241010143227992"></p><p>再以相同的方式，创建一个队列，名字为hello.queue2</p><p>我们继续发送信息。信息还是丢失。队列没有信息</p><p>队列和交换机需要相互绑定</p><p>绑定关系-交换机内绑定</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143247886.png" alt="image-20241010143247886"></p><p>我们绑定了2个队列-那么会自动负载均衡-选择发送一个队列</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143255742.png" alt="image-20241010143255742"></p><h5 id="3-数据隔离"><a href="#3-数据隔离" class="headerlink" title="3.数据隔离"></a>3.数据隔离</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143313747.png" alt="image-20241010143313747"></p><p>Name 用户名<br>Tags 权限<br>Can access virtual host 可以访问的数据区域</p><p>一个小公司基本就一个MQ集群–这个mq供多个项目使用</p><p>virtual host的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的virtual host，将每个项目的数据隔离</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143321459.png" alt="image-20241010143321459"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143330783.png" alt="image-20241010143330783"></p><p>数据区域-登录hmall账号</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143336766.png" alt="image-20241010143336766"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143341174.png" alt="image-20241010143341174"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143345830.png" alt="image-20241010143345830"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143351227.png" alt="image-20241010143351227"></p><p>如图</p><p>1.创建隔离 创建账号 账号内给予空间<br>回admin～换空间 查看队列</p><h4 id="4-spring集成RabbitMQ"><a href="#4-spring集成RabbitMQ" class="headerlink" title="4.spring集成RabbitMQ"></a>4.spring集成RabbitMQ</h4><h5 id="1-spring-amqp"><a href="#1-spring-amqp" class="headerlink" title="1.spring amqp"></a>1.spring amqp</h5><p>abbitmq-&gt;基于amqo协议收发信息</p><p>Spring的官方基于RabbitMQ提供了一套消息收发的模板工具<br><a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p>SpringAMQP提供了三个功能：</p><ul><li><strong>自动声明队列、交换机及其绑定关系</strong></li><li><strong>基于注解的监听器模式，异步接收消息</strong></li><li><strong>封装了RabbitTemplate工具，用于发送消息</strong></li></ul><h5 id="2-案例入门"><a href="#2-案例入门" class="headerlink" title="2.案例入门"></a>2.案例入门</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010143956995.png" alt="image-20241010143956995"></p><p>生产者发布信息到队列-消费者消费过程</p><h6 id="1-添加队列"><a href="#1-添加队列" class="headerlink" title="1.添加队列"></a>1.添加队列</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144017012.png" alt="image-20241010144017012"></p><h6 id="2-信息发送"><a href="#2-信息发送" class="headerlink" title="2.信息发送"></a>2.信息发送</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144027987.png" alt="image-20241010144027987"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144038058.png" alt="image-20241010144038058"></p><h6 id="3-消费者定义"><a href="#3-消费者定义" class="headerlink" title="3.消费者定义"></a>3.消费者定义</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144048066.png" alt="image-20241010144048066"></p><h6 id="4-WorkQueues"><a href="#4-WorkQueues" class="headerlink" title="4.WorkQueues"></a>4.WorkQueues</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144107380.png" alt="image-20241010144107380"></p><p>mq的负载均衡<br>优点-多消费者读取一个队列-加快信息读取-<br>发送50个消息</p><p>代码如上-带默认的负载均衡是-</p><ul><li>费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。</li></ul><p>默认的负载均衡就是评分信息-没有考虑到消费者处理信息的快慢问题-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144116699.png" alt="image-20241010144116699"></p><p>消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h4 id="5-交换机类型"><a href="#5-交换机类型" class="headerlink" title="5.交换机类型"></a>5.交换机类型</h4><p>Fanout：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</p><p>Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</p><p>Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</p><p>Headers：头匹配，基于MQ的消息头匹配，用的较少。</p><h6 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h6><p>把信息发送给绑定该交换机的所有队列</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144302415.png" alt="image-20241010144302415"></p><p>信息-全发送</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144317208.png" alt="image-20241010144317208"></p><p>该交换机默认就有</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144416247.png" alt="image-20241010144416247"></p><p>接受信息</p><p>每个消费者都收到了信息–</p><h6 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144840710.png" alt="image-20241010144840710"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144856402.png" alt="image-20241010144856402"></p><p>队列</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144908307.png" alt="image-20241010144908307"></p><p>最终</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144925223.png" alt="image-20241010144925223"></p><p>信息接收-<br>信息发送</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144938501.png" alt="image-20241010144938501"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010144945331.png" alt="image-20241010144945331"></p><p>信息携带key-到交换机-</p><p>交换机根据绑定的队列key-选择给哪个队列</p><h6 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010145009012.png" alt="image-20241010145009012"></p><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010145714091.png" alt="image-20241010145714091"></p><p>中国新闻和其他新闻</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010145721692.png" alt="image-20241010145721692"></p><p>信息发送</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010145744426.png" alt="image-20241010145744426"></p><p>信息接收</p><p>交换机根据绑定的通配符-来选择要发送的队列-&gt;队列再发送给下消费者</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010145806105.png" alt="image-20241010145806105"></p><p><strong>RabbitMQ控制台来创建队列、交换机。</strong><br><strong>实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。</strong></p><p><strong>做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</strong></p><h4 id="6-Spring-Amqp"><a href="#6-Spring-Amqp" class="headerlink" title="6.Spring Amqp"></a>6.Spring Amqp</h4><h6 id="1-注解开发"><a href="#1-注解开发" class="headerlink" title="1.注解开发"></a>1.注解开发</h6><p>SpringAMQP提供了一个Queue类，用来创建队列</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010150034420.png" alt="image-20241010150034420"></p><p>创建交换机</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010150043852.png" alt="image-20241010150043852"></p><p>我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010150059789.png" alt="image-20241010150059789"></p><p><strong>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010150106900.png" alt="image-20241010150106900"></p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="1-fanout"><a href="#1-fanout" class="headerlink" title="1.fanout"></a>1.fanout</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010150639595.png" alt="image-20241010150639595"></p><h6 id="2-direct-注解"><a href="#2-direct-注解" class="headerlink" title="2.direct 注解"></a>2.direct 注解</h6><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010150720379.png" alt="image-20241010150720379"></p><p>基于Bean声明交换机还是非常复杂的-注解方式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151117702.png" alt="image-20241010151117702"></p><p>注解-<br>1.参数1-bindings-@Queuebinding(value-exchange)–声明对应和交换机类型</p><p>key</p><h6 id="3-topic"><a href="#3-topic" class="headerlink" title="3.topic"></a>3.topic</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151128494.png" alt="image-20241010151128494"></p><h4 id="信息转换器"><a href="#信息转换器" class="headerlink" title="信息转换器"></a>信息转换器</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151150384.png" alt="image-20241010151150384"></p><p>也就是你的信息-是经过java序列化为字节发送-后续在反序列化 </p><p>序列化-&gt;配置JSON转换器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151215150.png" alt="image-20241010151215150"></p><p>配置信息转化器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151221231.png" alt="image-20241010151221231"></p><p>后续</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151235030.png" alt="image-20241010151235030"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151239718.png" alt="image-20241010151239718"></p><h4 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h4><p>微服务到微服务-&gt;Feing的拦截器实现的</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010151313511.png" alt="image-20241010151313511"></p><p>加再消息头-拦截器获取-&gt;再加入线程处理器</p><p>这样就不需要每个信息都加入登录信息了</p><h1 id="RabbitMq可靠性探究"><a href="#RabbitMq可靠性探究" class="headerlink" title="RabbitMq可靠性探究"></a>RabbitMq可靠性探究</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010230049706.png" alt="image-20241010230049706"></p><h4 id="1-可靠性探究"><a href="#1-可靠性探究" class="headerlink" title="1.可靠性探究"></a>1.可靠性探究</h4><p>异步-会脱离事务处理-比如我们有一个支付成功加积分抢卷的服务</p><p>用户支付事务成功了-发送mq-但是mq没有处理-用户的积分没有加</p><p>因此，确保 MQ 消息的可靠性至关重要。</p><p>我们该如何确保MQ消息的可靠性？</p><p>如果真的发送失败，有没有其它的兜底方案？</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010231202408.png" alt="image-20241010231202408"></p><blockquote><p>1.确保生产者一定把信息发送到MQ<br>2.确保MQ不会将信息弄丢<br>3.确保消费者一定要处理信息</p></blockquote><h4 id="2-生产者可靠性探究"><a href="#2-生产者可靠性探究" class="headerlink" title="2.生产者可靠性探究"></a>2.生产者可靠性探究</h4><h5 id="1-生产者重试机制"><a href="#1-生产者重试机制" class="headerlink" title="1.生产者重试机制"></a>1.生产者重试机制</h5><p>生产者发送信息到mq失败-进行重新发送</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">springamqp</span> <span class="hljs-string">提供信息发送重试机制-&gt;类似三次握手</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 设置MQ的连接超时时间</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br></code></pre></td></tr></table></figure><blockquote><p>当生产者网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，导致当前线程的阻塞，这个线程就一直卡着。这个用户也会被卡着<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p></blockquote><h5 id="3-生产者确认机制"><a href="#3-生产者确认机制" class="headerlink" title="3.生产者确认机制"></a>3.生产者确认机制</h5><p>信息发送到MQ丢失-生产者确认机制</p><ul><li>1.MQ内部处理消息的进程发生了异常</li><li>2.生产者发送消息到达MQ后未找到Exchange</li><li>3.生产者发送消息到达MQ的Exchange后，未找到合适的Queue，因此无法路由</li></ul><p><strong>Publisher Confirm和Publisher Return两种</strong>。在开启确认机制的情况下，当生产者发送消息给MQ后，<strong>MQ会根据消息处理的情况返回不同的回执</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010232042339.png" alt="image-20241010232042339"></p><p>1.临时信息 -持久化信息 -入队返回ack 告知投递成功<br>2.当消息投递到MQ，但是路由失败时-&gt;告知投递失败-&gt;通过Publisher Return返回异常信息-&gt;反ack确认</p><p><strong>其中ack和nack属于Publisher Confirm机制</strong>，ack是投递成功；<strong>nack是投递失败</strong>。<strong>而return则属于Publisher Return机制。</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata">生产者确认机制<br>spring:<br>  rabbitmq:<br>    publisher-<span class="hljs-keyword">confirm</span>-<span class="hljs-keyword">type</span>: correlated # 开启publisher <span class="hljs-keyword">confirm</span>机制，并设置<span class="hljs-keyword">confirm</span>类型<br>    publisher-returns: true # 开启publisher <span class="hljs-keyword">return</span>机制<br>这里publisher-<span class="hljs-keyword">confirm</span>-<span class="hljs-keyword">type</span>有三种模式可选：<br>- none：关闭<span class="hljs-keyword">confirm</span>机制<br>- simple：同步阻塞等待MQ的回执<br>- correlated：MQ异步回调返回回执<br></code></pre></td></tr></table></figure><p>定义ConfirmCallback</p><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的<strong>convertAndSend</strong>方法时，多传递一个参数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010232612356.png" alt="image-20241010232610899"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010232639947.png" alt="image-20241010232639947"></p><h6 id="1-案例"><a href="#1-案例" class="headerlink" title="1.案例"></a>1.案例</h6><p>案例</p><p>向系统自带的交换机发送消息，并且添加ConfirmCallback</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010232817300.png" alt="image-20241010232817300"></p><p>confirmcallback是保证发送到交换机了；returncallback是保证路由到队列了</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241010232827043.png" alt="image-20241010232827043"></p><h5 id="4-实际使用"><a href="#4-实际使用" class="headerlink" title="4.实际使用"></a>4.实际使用</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">CorrelationData</span> cd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>        cd.<span class="hljs-title function_">getFuture</span>().<span class="hljs-title function_">addCallback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;<span class="hljs-title class_">CorrelationData</span>.<span class="hljs-property">Confirm</span>&gt;()<br>     &#123;<br>               <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onFailure</span>(<span class="hljs-params"><span class="hljs-title class_">Throwable</span> throwable</span>) &#123;<br>             <span class="hljs-comment">// 处理失败的情况</span><br>            throwable.<span class="hljs-title function_">printStackTrace</span>();<br>                                   &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onSuccess</span>(<span class="hljs-params"><span class="hljs-title class_">CorrelationData</span>.<span class="hljs-title class_">Confirm</span> confirm</span>) &#123;<br><span class="hljs-comment">// 处理成功的情况</span><br><span class="hljs-keyword">if</span>(confirm.<span class="hljs-title function_">isAck</span>())<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;消息发送成功&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;消息发送失败&quot;</span>);<br>&#125;<br>&#125;<br><br>);<br><br><br><br><br>        kmsTemplate.<span class="hljs-title function_">send</span>( <span class="hljs-title class_">HotArticleConstants</span>.<span class="hljs-property">HOT_ARTICLE_AGGREGATION_QUEUE</span>,mess,cd);<br></code></pre></td></tr></table></figure><h4 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h4><h5 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1.持久化"></a>1.持久化</h5><p>信息到达MQ-&gt;信息是否会丢失-&gt;一旦丢失–生产者重试机制也是没有效果的<br><strong>为了保证数据的可靠性，必须配置数据持久化</strong><br>1.交换机持久存储<br>2.队列持久化<br>3.消息持久化</p><h6 id="交换机持久存储"><a href="#交换机持久存储" class="headerlink" title="交换机持久存储"></a>交换机持久存储</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101857514.png" alt="image-20241011101857514"></p><h6 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101907966.png" alt="image-20241011101907966"></p><h6 id="信息持久化"><a href="#信息持久化" class="headerlink" title="信息持久化"></a>信息持久化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101946560.png" alt="image-20241011101946560"></p><h5 id="Lazy队列"><a href="#Lazy队列" class="headerlink" title="Lazy队列"></a>Lazy队列</h5><p><strong>LazyQueue 惰性队列-&gt;MQ可靠性的持久化存储</strong><br>功能:信息堆积-&gt;任务给内存挤爆了-&gt;出发内存预警上线<br><strong>自动将信息刷到磁盘-&gt;这个行为成为PageOut. PageOut会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</strong></p><p>Lazy Queues的模式</p><p>1.- <strong>接收到消息后直接存入磁盘而非内存</strong><br>2.- <strong>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</strong><br>3.- <strong>支持数百万条的消息存储</strong></p><p>设置懒加载</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011102122853.png" alt="image-20241011102122853"></p><p>代码配置lazy模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011102137784.png" alt="image-20241011102137784"></p><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>rabbitmqctl set_policy Lazy “^lazy-queue$” ‘{“queue-mode”:”lazy”}’ –apply-to queues  </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011102159179.png" alt="image-20241011102159179"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011102204312.png" alt="image-20241011102204312"></p><p>懒队列再次了解</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011102227206.png" alt="image-20241011102227206"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011102233763.png" alt="image-20241011102233763"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011102240099.png" alt="image-20241011102240099"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">directQueue</span>(<span class="hljs-params"></span>)<br> &#123;<br> <br>     <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     args.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;x-queue-mode&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>);  <span class="hljs-comment">// 设置队列为懒人模式</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;direct.music&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);  <span class="hljs-comment">// 持久化，非独占，非自动删除</span><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h4><h5 id="1-问题产生"><a href="#1-问题产生" class="headerlink" title="1.问题产生"></a>1.问题产生</h5><h6 id="0-消费者可靠性条件"><a href="#0-消费者可靠性条件" class="headerlink" title="0.消费者可靠性条件"></a>0.消费者可靠性条件</h6><p>消息投递给消费者并不代表就一定被正确消费了</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常<br>RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</li></ul><h5 id="2-消费者确认机制"><a href="#2-消费者确认机制" class="headerlink" title="2.消费者确认机制"></a>2.消费者确认机制</h5><p>消费者确认机制-<br>当消费者处理信息结束后-会返回回执 </p><p>ack<br>nack<br>reject-&gt;拒绝信息-&gt;删除<br>将消息处理的代码通过try catch机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>springamqp实现-</p><p><strong>1.none发送即删除</strong><br><strong>2.manual 手段-&gt;自己发送ack-或者reject-&gt;存在业务入侵</strong><br><strong>auto:</strong><br>SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，<strong>当业务正常执行时则自动返回ack.  当业务出现异常时，根据异常判断返回不同结果：</strong><br>  - 如果是业务异常，会自动返回nack；  - 如果是消息处理或校验异常，自动返回reject;</p><p>Spring 配置ack</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011104114575.png" alt="image-20241011104114575"></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing">@<span class="hljs-title function_">RabbitListener</span>(queues = <span class="hljs-string">&quot;simple.queue&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span>(<span class="hljs-built_in">String</span> msg) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">MessageConversionException</span>(<span class="hljs-string">&quot;故意的&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;消息处理完成&quot;</span>);<br>&#125;<br>-&gt;信息转化异常返回的reject<br><br>业务异常返回nack<br></code></pre></td></tr></table></figure><h5 id="3-失败重试机制"><a href="#3-失败重试机制" class="headerlink" title="3.失败重试机制"></a>3.失败重试机制</h5><p>失败重试机制<br><strong>消费者-&gt;重试-&gt;出现异常-&gt;返回mq</strong><br><strong>一直下去-消耗资源-</strong><br><strong>在消费者出现异常时-&gt;利用本地重试-不到mq队列</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011104250361.png" alt="image-20241011104250361"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011104257380.png" alt="image-20241011104257380"></p><p>到达一定次数丢弃-不符合部分业务的规则</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011104310196.png" alt="image-20241011104310196"></p><p>投递指定交换机</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011105639223.png" alt="image-20241011105639223"></p><p>绑定失败重试后发送的队列</p><h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h4><h6 id="1-问题发生"><a href="#1-问题发生" class="headerlink" title="1.问题发生"></a>1.问题发生</h6><p>业务幂等性 对同一任务进行重复操作<br>业务幂等<br>- 页面卡顿时频繁刷新导致表单重复提交 - 服务间调用的重试<br>- MQ消息的重复投递 例子<br>对方已支付-&gt;发信息给生产者-&gt;出现问题-&gt;重新投递-&gt;用户退款-&gt;执行成功-&gt;已支付信息开始消费-&gt;订单出现异常</p><p>解决-唯一信息ID<br>给信息添加唯一ID</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110133636.png" alt="image-20241011110133636"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">messageConverterto</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span> <span class="hljs-title function_">methodConverter</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title class_">Jackson2JsonMessageConverter</span> jjmc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>        jjmc.<span class="hljs-title function_">setCreateMessageIds</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> jjmc;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">String</span>&gt; processedMessageIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-meta">@RabbitListener</span>(queues=<span class="hljs-string">&quot;direct.music&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listen</span>(<span class="hljs-params"><span class="hljs-title class_">Message</span> message</span>)<br>&#123;<br>    <span class="hljs-comment">// 模拟存储已处理的 MessageId，实际可以用 Redis 或数据库替代</span><br><br>    <span class="hljs-title class_">String</span> messageId = message.<span class="hljs-title function_">getMessageProperties</span>().<span class="hljs-title function_">getMessageId</span>();<br><br>    <span class="hljs-comment">// 检查消息是否已处理</span><br>    <span class="hljs-keyword">if</span> (messageId != <span class="hljs-literal">null</span> &amp;&amp; processedMessageIds.<span class="hljs-title function_">contains</span>(messageId)) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;重复消息，已跳过处理：&quot;</span> + messageId);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 消息已处理，跳过</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>虽然 <code>Jackson2JsonMessageConverter</code> 可以为每条消息生成唯一的 <code>MessageId</code>，但是为了确保幂等性，还需要在消息消费者侧做以下工作：</p><ul><li>检查是否已处理过该 <code>MessageId</code>。</li><li>记录处理过的消息 ID，防止重复处理。</li></ul><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">byte</span>[] <span class="hljs-keyword">body</span> = message.getBody();<br>       String jsonString = <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">body</span>);<br>       <span class="hljs-keyword">try</span> &#123;<br>            onlineMusic = <span class="hljs-keyword">new</span> ObjectMapper().readValue( jsonString, OnlineMusic.<span class="hljs-keyword">class</span>);<br>       &#125;<br></code></pre></td></tr></table></figure><p>2.问题解决</p><p>幂等判断–<br>根据功能来判断是否需要判断 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110146875.png" alt="image-20241011110146875"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110150917.png" alt="image-20241011110150917"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110153932.png" alt="image-20241011110153932"></p><p>我们如果以退款改3-&gt;也就不会重复消费-再代码层面解决这些问题</p><h4 id="Mq兜底"><a href="#Mq兜底" class="headerlink" title="Mq兜底"></a>Mq兜底</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110229766.png" alt="image-20241011110229766"></p><p>也就是开定时任务-&gt;去查询支付服务内-已经支付的-<br>再对比-订单中为成功支付的 改库</p><h4 id="Mq可靠性总结"><a href="#Mq可靠性总结" class="headerlink" title="Mq可靠性总结"></a>Mq可靠性总结</h4><blockquote><ol><li><strong>生产者可靠性</strong>：<ul><li>开启生产者重试机制：如果生产者因特殊原因未成功将消息发送到消息队列（MQ），系统会自动进行重试。</li><li>生产者确认机制：生产者发送的消息成功到达交换机和队列时，MQ会发送回执，生产者根据回执进行处理，确保消息已成功进入队列。</li></ul></li><li><strong>MQ可靠性</strong>：<ul><li>持久化队列和交换机：通过将队列和交换机持久化到磁盘，确保数据不会因为系统故障而丢失。</li><li>使用优化策略如<strong>磁盘加速</strong>，提升高并发场景下的消息处理效率，减少延迟。</li></ul></li><li><strong>消费者可靠性</strong>：<ul><li>消费者确认机制：开启消费者端的确认机制，消费者处理完消息后会返回回执，保证消息已成功消费。</li><li>消费者重试机制：当消费者处理消息时出现异常，系统会多次重试，超过一定次数后将消息发送到异常队列和异常交换机，以供进一步处理。</li></ul></li><li><strong>定时任务</strong>：<ul><li>通过定时任务监控两张表中不同的状态，确保信息在整个生产、传输、消费过程中保持一致性，解决可能出现的状态不一致问题。</li></ul></li></ol><p>这样的机制设计，可以在高并发环境中，确保消息在生</p></blockquote><h4 id="延迟信息"><a href="#延迟信息" class="headerlink" title="延迟信息"></a>延迟信息</h4><h6 id="1-死信"><a href="#1-死信" class="headerlink" title="1.死信"></a>1.死信</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110619435.png" alt="image-20241011110619435"></p><p>死信交换机-和延迟信息 </p><p>1.收集因为-消费者出现异常的信息<br>2.收集队列满了 被拒绝的信息<br><strong>3.收集因TTL 到期的信息 前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的RepublishMessageRecoverer作用类似。</strong><br>延迟信息</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110641511.png" alt="image-20241011110641511"></p><p>为信息绑定一个没有消费者的队列-让他的超时时间超过-&gt;绑定死信-&gt;沿用之前key-&gt;死信有一个队列key-blue<br>就会被消费 需要key交换机-队列 </p><p>死信-&gt;key队列</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110650748.png" alt="image-20241011110650748"></p><h6 id="2-DelayExchange"><a href="#2-DelayExchange" class="headerlink" title="2.DelayExchange"></a>2.DelayExchange</h6><p>DelayExchange插件<br><a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq">https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq</a><br><a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq">https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq</a></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110703277.png" alt="image-20241011110703277"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110711119.png" alt="image-20241011110711119"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110717436.png" alt="image-20241011110717436"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110721725.png" alt="image-20241011110721725"></p><h6 id="3-死信代码"><a href="#3-死信代码" class="headerlink" title="3.死信代码"></a>3.死信代码</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110755981.png" alt="image-20241011110755981"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110759394.png" alt="image-20241011110759394"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110802893.png" alt="image-20241011110802893"></p><ol start="2"><li></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110809851.png" alt="image-20241011110809851"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110813309.png" alt="image-20241011110813309"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110823990.png" alt="image-20241011110823990"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011110827287.png" alt="image-20241011110827287"></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串</title>
    <link href="/2024/10/09/data%20structure/%E4%B8%B2/"/>
    <url>/2024/10/09/data%20structure/%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024143131106.png" alt="image-20241024143131106"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241009155935846.png" alt="image-20241009155935846"></p><h4 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h4><h6 id="1-BF算法"><a href="#1-BF算法" class="headerlink" title="1.BF算法"></a>1.BF算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a8ebc0224c07a8aaaf99acfe45849024.jpeg" alt="a8ebc0224c07a8aaaf99acfe45849024"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/705e9778c0cae22e81dcdc5c0b52dbf4.jpg" alt="705e9778c0cae22e81dcdc5c0b52dbf4"></p><h6 id="2-kpm算法"><a href="#2-kpm算法" class="headerlink" title="2.kpm算法"></a>2.kpm算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9b4a91ab92d725f0ddf8fe4512e48870.jpeg" alt="9b4a91ab92d725f0ddf8fe4512e48870"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241009160121051.png" alt="image-20241009160121051"></p><hr><p>回头学习-串的性质</p><h4 id="串的基本性质"><a href="#串的基本性质" class="headerlink" title="串的基本性质"></a>串的基本性质</h4><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011093945764.png" alt="image-20241011093945764"></strong></p><p>很基本的增删改查</p><h4 id="串的顺序结构"><a href="#串的顺序结构" class="headerlink" title="串的顺序结构"></a>串的顺序结构</h4><h5 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br><span class="hljs-type">char</span> data [maxSize];<br><span class="hljs-type">int</span> length;<br>&#125;sqString;<br></code></pre></td></tr></table></figure><h5 id="2-串的实现"><a href="#2-串的实现" class="headerlink" title="2.串的实现"></a>2.串的实现</h5><h6 id="1-串赋值运算算法"><a href="#1-串赋值运算算法" class="headerlink" title="1.串赋值运算算法"></a>1.串赋值运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011094847367.png" alt="image-20241011094847367"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011094925569.png" alt="image-20241011094925569"></p><h6 id="2-销毁串运算算法"><a href="#2-销毁串运算算法" class="headerlink" title="2.销毁串运算算法"></a>2.销毁串运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011095045459.png" alt="image-20241011095045459"></p><h6 id="3-串复制运算算法"><a href="#3-串复制运算算法" class="headerlink" title="3.串复制运算算法"></a>3.串复制运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011095107989.png" alt="image-20241011095107989"></p><h6 id="4-求串长运算算法"><a href="#4-求串长运算算法" class="headerlink" title="4.求串长运算算法"></a>4.求串长运算算法</h6><p><img src="C:\Users\nixg\AppData\Roaming\Typora\typora-user-images\image-20241011095305154.png" alt="image-20241011095305147"></p><h6 id="5-判断串相等运算算法"><a href="#5-判断串相等运算算法" class="headerlink" title="5.判断串相等运算算法"></a>5.判断串相等运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011095349493.png" alt="image-20241011095349493"></p><h6 id="6-串链接运算算法"><a href="#6-串链接运算算法" class="headerlink" title="6.串链接运算算法"></a>6.串链接运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011095655155.png" alt="image-20241011095655155"></p><h6 id="7-求子串运算算法"><a href="#7-求子串运算算法" class="headerlink" title="7.求子串运算算法"></a>7.求子串运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100003543.png" alt="image-20241011100003543"></p><h6 id="8-查找子串位置运算算法"><a href="#8-查找子串位置运算算法" class="headerlink" title="8.查找子串位置运算算法"></a>8.查找子串位置运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100249668.png" alt="image-20241011100249668"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100332064.png" alt="image-20241011100332064"></p><h6 id="9-子串插入算法"><a href="#9-子串插入算法" class="headerlink" title="9.子串插入算法"></a>9.子串插入算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100314083.png" alt="image-20241011100314083"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100347704.png" alt="image-20241011100347704"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100513692.png" alt="image-20241011100513692"></p><h6 id="10子串删除"><a href="#10子串删除" class="headerlink" title="10子串删除"></a>10子串删除</h6><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100603584.png" alt="image-20241011100603584"></h6><p>给后面元素往前面罗-i个位置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100645408.png" alt="image-20241011100645408"></p><h6 id="11-子串替换运算算法"><a href="#11-子串替换运算算法" class="headerlink" title="11.子串替换运算算法"></a>11.子串替换运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100802781.png" alt="image-20241011100802781"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100751383.png" alt="image-20241011100751383"></p><h6 id="12输出串算法"><a href="#12输出串算法" class="headerlink" title="12输出串算法"></a>12输出串算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011100817907.png" alt="image-20241011100817907"></p><h4 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h4><h6 id="链串定义"><a href="#链串定义" class="headerlink" title="链串定义"></a>链串定义</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101035994.png" alt="image-20241011101035994"></p><p>就类似链表</p><h6 id="串赋值运算算法"><a href="#串赋值运算算法" class="headerlink" title="串赋值运算算法"></a>串赋值运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101125792.png" alt="image-20241011101125792"></p><h5 id="销毁串"><a href="#销毁串" class="headerlink" title="销毁串"></a>销毁串</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101200328.png" alt="image-20241011101200328"></p><h6 id="串复制运算算法"><a href="#串复制运算算法" class="headerlink" title="串复制运算算法"></a>串复制运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101214887.png" alt="image-20241011101214887"></p><h6 id="求串运算长度"><a href="#求串运算长度" class="headerlink" title="求串运算长度"></a>求串运算长度</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101230164.png" alt="image-20241011101230164"></p><h6 id="判断串相等"><a href="#判断串相等" class="headerlink" title="判断串相等"></a>判断串相等</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101254054.png" alt="image-20241011101254054"></p><h6 id="串链接运算算法"><a href="#串链接运算算法" class="headerlink" title="串链接运算算法"></a>串链接运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101314636.png" alt="image-20241011101314636"></p><h6 id="求子串运算算法"><a href="#求子串运算算法" class="headerlink" title="求子串运算算法"></a>求子串运算算法</h6><p>省</p><h6 id="查找子串位置"><a href="#查找子串位置" class="headerlink" title="查找子串位置"></a>查找子串位置</h6><p>省</p><h6 id="子串插入运算算法"><a href="#子串插入运算算法" class="headerlink" title="子串插入运算算法"></a>子串插入运算算法</h6><p>省</p><h6 id="子串删除运算算法"><a href="#子串删除运算算法" class="headerlink" title="子串删除运算算法"></a>子串删除运算算法</h6><p>省</p><h6 id="子串替换运算算法"><a href="#子串替换运算算法" class="headerlink" title="子串替换运算算法"></a>子串替换运算算法</h6><p>省</p><h6 id="输出串运算算法"><a href="#输出串运算算法" class="headerlink" title="输出串运算算法"></a>输出串运算算法</h6><p>省</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101518892.png" alt="image-20241011101518892"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-数组</title>
    <link href="/2024/10/09/data%20structure/%E6%95%B0%E7%BB%84/"/>
    <url>/2024/10/09/data%20structure/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h4 id="1-数组的概念"><a href="#1-数组的概念" class="headerlink" title="1.数组的概念"></a>1.数组的概念</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011101615958.png" alt="image-20241011101615958"></p><p>数组通常采用顺序存储结构</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/766ade2e15e40d22fdbd519ce123126b.jpeg" alt="766ade2e15e40d22fdbd519ce123126b"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/399eed84788291a7c41769f0cd60bf86.png" alt="399eed84788291a7c41769f0cd60bf86"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">题目要求计算三维数组 A 的元素个数，数组的三个维度分别是：<br><br>A[<span class="hljs-string">-2</span>..2]，即从 <span class="hljs-string">-2</span> 到 2，包含的元素个数为 5（<span class="hljs-string">-2</span>、<span class="hljs-string">-1</span>、0、1、2）。<br>A[<span class="hljs-string">-4</span>..5]，即从 <span class="hljs-string">-4</span> 到 5，包含的元素个数为 10（<span class="hljs-string">-4</span>、<span class="hljs-string">-3</span>、<span class="hljs-string">-2</span>、<span class="hljs-string">-1</span>、0、1、2、3、4、5）。<br>A[2..6]，即从 2 到 6，包含的元素个数为 5（2、3、4、5、6）。<br>因此，数组的总元素个数为三个维度元素个数的乘积：<br>5×10×5=250<br>正确答案是 B. 250。<br></code></pre></td></tr></table></figure><h4 id="2-特殊矩阵压缩"><a href="#2-特殊矩阵压缩" class="headerlink" title="2.特殊矩阵压缩"></a>2.特殊矩阵压缩</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241009160508352.png" alt="image-20241009160508352"></p><h6 id="1-对称矩阵"><a href="#1-对称矩阵" class="headerlink" title="1.对称矩阵"></a>1.对称矩阵</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/057fdae6ddc8ee7a2a2ddc8de8c06966.png" alt="057fdae6ddc8ee7a2a2ddc8de8c06966"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024171221274.png" alt="image-20241024171221274"></p><p>1+2+3+4+5+6+7+……n</p><p>观察性质</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024171154940.png" alt="image-20241024171154940"></p><p>公式推导</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024173418875.png" alt="image-20241024173418875"></p><p>计算元素位置</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024171112919.png" alt="image-20241024171112919"></strong></p><p>矩阵从零开始会多算一层-所以都是(I+1)I</p><h6 id="2-三角矩阵"><a href="#2-三角矩阵" class="headerlink" title="2.三角矩阵"></a>2.三角矩阵</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3272d9e6f47987fd84f5a4228cd227e2.png" alt="3272d9e6f47987fd84f5a4228cd227e2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241024173452056.png" alt="image-20241024173452056"></p><p>一旦i&gt;j就未知-求最好一位</p><h6 id="3-对角矩阵"><a href="#3-对角矩阵" class="headerlink" title="3.对角矩阵"></a>3.对角矩阵</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9d977f088b0c154045093b10ffc036db.png" alt="9d977f088b0c154045093b10ffc036db"></p><h6 id="4-稀疏矩阵-顺序存储法-三元组"><a href="#4-稀疏矩阵-顺序存储法-三元组" class="headerlink" title="4.稀疏矩阵-顺序存储法-三元组"></a>4.稀疏矩阵-顺序存储法-三元组</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cfd3301719db4e90f5c0bad967d590be.jpeg" alt="cfd3301719db4e90f5c0bad967d590be"></p><p>稀疏矩阵（sparse matrix）中的<strong>0</strong>通常是<strong>多</strong>的。稀疏矩阵的特点是大多数元素为零，只有少量非零元素。与之相对的密集矩阵（dense matrix）则大多数元素为非零。稀疏矩阵在大规模数据处理中常见，因为可以通过只存储非零元素来节省内存和计算资源。</p><p>注意存储方法</p><h6 id="稀疏矩阵-链式存储"><a href="#稀疏矩阵-链式存储" class="headerlink" title="稀疏矩阵-链式存储"></a>稀疏矩阵-链式存储</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b47b8257267e6b272893d4a8919daec.jpeg" alt="1b47b8257267e6b272893d4a8919daec"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云岚到家思维导图</title>
    <link href="/2024/10/09/yunlan/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2024/10/09/yunlan/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="云岚到家思维导图"><a href="#云岚到家思维导图" class="headerlink" title="云岚到家思维导图"></a>云岚到家思维导图</h1><h6 id="1-4"><a href="#1-4" class="headerlink" title="1-4"></a>1-4</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6.png" alt="云岚到家"></p><p>2.27-5.24具体笔记所在</p><h6 id="5-支付"><a href="#5-支付" class="headerlink" title="5 支付"></a>5 支付</h6><blockquote><ul><li><pre><code class="hljs"> 下单预约 1.预约下单状态设计 2.订单表设计思路 3.下单思路 4.OpenFeign 5.微服务雪崩问题探究 5.sentinel 熔断降级- @Component  public class CustomerClient&#123;  @Resource   private Api Api;  @SentinelResource(value = &quot;getAddressBookDetail&quot;, fallback = &quot;detailFallback&quot;, blockHandler = &quot;detailBlockHandler&quot;)    public AddressBookResDTO getDetail(Long id)   &#123;       return Api.api(id);   &#125;   public  AddressBookResDTO detailFallback(Long id, Throwable throwable)   &#123;       log.error(&quot;异常抛出&quot;);       return null;   &#125;   public  AddressBookResDTO detailBlockHandler(Long id, Throwable throwable)   &#123;       log.error(&quot;熔断&quot;);       return null;   &#125;    &#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br></code></pre></td></tr></table></figure></code></pre></li></ul><p> 6.订单号生成规则</p><p> 7.事务优化</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br></code></pre></td></tr></table></figure><p>@Transactional(rollbackFor &#x3D; Exception.class)<br>public void save()<br>{<br>&#x2F;&#x2F;远程调用<br>api.selectid();&#x2F;&#x2F;提高事务时长-锁数据库时间增加-造成雪崩</p><p>&#x2F;&#x2F;本地添加 -抽离save<br>this.save();<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>public void save()<br>{<br>&#x2F;&#x2F;远程调用<br>api.selectid();&#x2F;&#x2F;提高事务时长-锁数据库时间增加-造成雪崩<br>this.saveqq();&#x2F;&#x2F;事务失效–Spring进行事务控制是通过代理对象进行的，在调用add方法之前开启事务，方法执行结束提交事务。</p><p>}<br>@Transactional(rollbackFor &#x3D; Exception.class)<br>public void saveqq()<br>{<br>&#x2F;&#x2F;本地添加 -<br>this.save();<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>public class qq{<br>@Resource<br> private qq MM;<br>public void save()<br>{<br>&#x2F;&#x2F;远程调用<br>api.selectid();&#x2F;&#x2F;提高事务时长-锁数据库时间增加-造成雪崩<br>MM.saveqq();&#x2F;&#x2F;–Spring进行事务控制是通过代理对象进行的，在调用add方法之前开启事务，方法执行结束提交事务。</p><p>}<br>@Transactional(rollbackFor &#x3D; Exception.class)<br>public void saveqq()<br>{<br>&#x2F;&#x2F;本地添加 -<br>this.save();<br>}<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p> 8.循环依赖</p><p>抽出来当博客</p><p> 微信小程序支付流程</p><p> 1.开通流程</p><p> 2.小程序支付接口</p><p> 3.支付业务流程</p><p> 4.小程序下单</p><p> 5.小程序调起支付</p><p> 6.小程序支付通知</p><p> 7.订单号查询订单</p><p> Native使用</p><p> 2.流程</p><p> SDK</p><p> 1.导入微信支付sdk</p><p> 2.名词认识</p><p>.3.WechatPayHttpClientBuilder构建请求</p><p> 请求构建</p><p> jsapi下单</p><p> 查单 </p><p> 退单</p><pre><code class="hljs">6.6-6.9内容</code></pre></blockquote><h6 id="6-支付"><a href="#6-支付" class="headerlink" title="6 支付"></a>6 支付</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.png" alt="img"></p><h6 id="7-退款"><a href="#7-退款" class="headerlink" title="7 退款"></a>7 退款</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E9%80%80%E6%AC%BE.png" alt="img"></p><p>6.11</p><h6 id="8-状态机退款"><a href="#8-状态机退款" class="headerlink" title="8 状态机退款"></a>8 状态机退款</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%94%AF%E4%BB%98%E7%AB%A0%E8%8A%82.png" alt="支付章节"></p><p>6.12</p><h6 id="9-订单优化-分库分表-索引"><a href="#9-订单优化-分库分表-索引" class="headerlink" title="9  订单优化 分库分表 索引"></a>9  订单优化 分库分表 索引</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E8%AE%A2%E5%8D%95%E4%BC%98%E5%8C%96.png" alt="img"></p><p>6.22-6.24</p><h6 id="10-秒杀抢购"><a href="#10-秒杀抢购" class="headerlink" title="10 秒杀抢购"></a>10 秒杀抢购</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1%E7%A7%92%E6%9D%80%E6%8A%A2%E8%B4%AD.png" alt="1秒杀抢购"></p><p>7.3-7.8</p><h6 id="11-抢卷结果同步"><a href="#11-抢卷结果同步" class="headerlink" title="11 抢卷结果同步"></a>11 抢卷结果同步</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%8A%A2%E5%8D%B7%E7%BB%93%E6%9E%9C%E5%90%8C%E6%AD%A5.png" alt="img"></p><p>7.9</p><h6 id="12-核销抢单取消"><a href="#12-核销抢单取消" class="headerlink" title="12  核销抢单取消"></a>12  核销抢单取消</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%A0%B8%E9%94%80%E6%8A%A2%E5%8D%95%E5%8F%96%E6%B6%88.png" alt="img"></p><p>7.9*-7.11</p><h6 id="13订单各类优化"><a href="#13订单各类优化" class="headerlink" title="13订单各类优化"></a>13订单各类优化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E8%AE%A2%E5%8D%95.png" alt="img"></p><p>7.16-7.17</p><h6 id="14-派单"><a href="#14-派单" class="headerlink" title="14 派单"></a>14 派单</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%B4%BE%E5%8D%95%E7%AD%96%E7%95%A5.png" alt="img"></p><p>7.17</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>项目已经复习了一次-写完是花了28天时间-技术面非常广泛</p><h6 id="业务部分"><a href="#业务部分" class="headerlink" title="业务部分"></a>业务部分</h6><p>思维导图来自官方</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9024291640ec41ca7aa09bec44326e9b.png" alt="9024291640ec41ca7aa09bec44326e9b"></p><h6 id="技术部分"><a href="#技术部分" class="headerlink" title="技术部分"></a>技术部分</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241003160553910.png" alt="image-20241003160553883"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241003160607274.png" alt="image-20241003160607274"></p><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>通过网盘分享的文件：云岚到家 -新<br>链接: <a href="https://pan.baidu.com/s/1KeGLcvCHReneF278uG4REw?pwd=c9si">https://pan.baidu.com/s/1KeGLcvCHReneF278uG4REw?pwd=c9si</a> 提取码: c9si</p>]]></content>
    
    
    <categories>
      
      <category>云岚到家</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>音乐社区</title>
    <link href="/2024/10/08/case/%E9%9F%B3%E4%B9%90%E7%A4%BE%E5%8C%BA%E6%A1%88%E4%BE%8B/"/>
    <url>/2024/10/08/case/%E9%9F%B3%E4%B9%90%E7%A4%BE%E5%8C%BA%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="音乐社区"><a href="#音乐社区" class="headerlink" title="音乐社区"></a>音乐社区</h1><blockquote><p>全民歌推荐例子<br>仿 全民k歌或者热门帖子排行榜<br>默认功能<br>1.大数据推荐—根据浏览或者说音乐播放—点赞—评价进行-kafka+redis计算分值<br>2.音乐播放—只有真正播放才加浏览量 –没技术<br>3.附近音乐搜索-es 或者redis–Canal-Elasticsearch-mq同步方案<br>4.发布音乐-隐私音乐-没啥好说的-</p><p>5.音乐上传-上传服务- 修改为异步上传</p><p>5.音乐详情页 -freemarker mnio</p><p>7.音乐首页-由大数据推荐</p></blockquote><p>不能太复杂-能想到的就现在这些功能了</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>配环境崩溃了-直接卸载虚拟机了-一下所有技术栈默认环境配好</p><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><h6 id="1-用户表"><a href="#1-用户表" class="headerlink" title="1.用户表"></a>1.用户表</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2467f0e53f38841879af044ac1de22e6.png" alt="2467f0e53f38841879af044ac1de22e6"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt;  <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>( userid <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">primary key</span>, username <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">UNIQUE</span>, <span class="hljs-keyword">password</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.04</span> sec)<br></code></pre></td></tr></table></figure><h6 id="2-音乐表"><a href="#2-音乐表" class="headerlink" title="2.音乐表"></a>2.音乐表</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9ed90b1e765b215e73e770b53299f3e0.png" alt="9ed90b1e765b215e73e770b53299f3e0"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">mysql&gt;  create table <span class="hljs-title function_">Online_music</span><span class="hljs-params">( music varchar(<span class="hljs-number">255</span>)</span> primary key, userid <span class="hljs-title function_">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span> not <span class="hljs-literal">null</span>,    music_name <span class="hljs-title function_">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span> not <span class="hljs-literal">null</span>,   file_location <span class="hljs-title function_">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span> not <span class="hljs-literal">null</span>,upload_date     date not <span class="hljs-literal">null</span>,likes <span class="hljs-type">int</span>  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>,views <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>,comments <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>,latitude <span class="hljs-title function_">DECIMAL</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>)</span> not <span class="hljs-literal">null</span>,longitude <span class="hljs-title function_">DECIMAL</span><span class="hljs-params">(<span class="hljs-number">11</span>, <span class="hljs-number">8</span>)</span> not <span class="hljs-literal">null</span>);<br>Query OK, <span class="hljs-number">0</span> rows <span class="hljs-title function_">affected</span> <span class="hljs-params">(<span class="hljs-number">0.02</span> sec)</span><br><br></code></pre></td></tr></table></figure><p>ps：后续再说把</p><h6 id="3-积分表-redis"><a href="#3-积分表-redis" class="headerlink" title="3.积分表-redis"></a>3.积分表-redis</h6><p>计算每首歌的分值-</p><h6 id="4-redis-音乐记录"><a href="#4-redis-音乐记录" class="headerlink" title="4.redis-音乐记录"></a>4.redis-音乐记录</h6><p>包含点赞-浏览-评论</p><p>第四个是音乐播放需要</p><blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//1 评论 2 代表播放 3 代表点赞</span><br><span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + onlineMusic.<span class="hljs-built_in">getMusic</span>(), OnlineMusicField.PLAY_COUNT.<span class="hljs-built_in">getFieldCode</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + onlineMusic.<span class="hljs-built_in">getMusic</span>(), OnlineMusicField.LIKE_COUNT.<span class="hljs-built_in">getFieldCode</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + onlineMusic.<span class="hljs-built_in">getMusic</span>(), OnlineMusicField.COMMENT_COUNT.<span class="hljs-built_in">getFieldCode</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineFile:&quot;</span> + onlineMusic.<span class="hljs-built_in">getFileLocation</span>(), OnlineMusicField.FILE_ID.<span class="hljs-built_in">getFieldCode</span>(), onlineMusic.<span class="hljs-built_in">getMusic</span>());<br></code></pre></td></tr></table></figure></blockquote><p>我们是根据文件id直接进行的-</p><h4 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h4><p>登录注册<br>redis+缓存击穿+MySQL配合锁防止mysql炸开<br>注册</p><p>redis记录ip值判断是都超过安全阈值。设置有效期，有效期内超过多少多少就拦截掉</p><p>校验使用httpSesioon</p><p>利用redis锁-防止缓存击穿-</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> @Override<br>    <span class="hljs-built_in">public</span> R register(<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">user</span>==<span class="hljs-keyword">null</span>||<span class="hljs-keyword">user</span>.getPassword().isEmpty()||<span class="hljs-keyword">user</span>.getPassword().isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">return</span>  R.error(&quot;请补全参数&quot;);<br>        &#125;<br>        //各类校验<br>        <span class="hljs-keyword">Object</span> o = redisTemplate.opsForValue().<span class="hljs-keyword">get</span>(<span class="hljs-keyword">user</span>.getUsername());<br>        <span class="hljs-keyword">if</span>(o!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> R.error(&quot;账号已存在&quot;);<br>        &#125;<br>        ///后续做xxl-job<br><span class="hljs-comment">/*        String keyRegister = &quot;register&quot;+user.getAccount();</span><br><span class="hljs-comment">        redisTemplate.opsForValue().set(keyRegister,user.getPassword());*/</span><br>        RedissonClient redissonClient = Redisson.<span class="hljs-keyword">create</span>();<br>        //获取锁<br>        RLock loc=redissonClient.getLock(&quot;register&quot;);<br>        ///加锁<br>        try &#123;<br>            <span class="hljs-type">boolean</span> isLock=loc.tryLock(<span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, TimeUnit.SECONDS);<br>            <span class="hljs-keyword">if</span>(isLock)<br>            &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">insert</span> = this.baseMapper.<span class="hljs-keyword">insert</span>(<span class="hljs-keyword">user</span>);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">insert</span>==<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">return</span>  R.error(&quot;注册失败&quot;);<br>                &#125;<br>                //即时缓存<br>                redisTemplate.opsForValue().<span class="hljs-keyword">set</span>(<span class="hljs-keyword">user</span>.getUsername(),<span class="hljs-keyword">user</span>);<br>            &#125;<br><br><br><br>        &#125;catch (<span class="hljs-keyword">Exception</span> e)<br>        &#123;<br>            throw  <span class="hljs-built_in">new</span> BusinessException(<span class="hljs-number">500</span>,&quot;注册失败&quot;);<br>        &#125;finally &#123;<br>            <span class="hljs-keyword">if</span> (loc != <span class="hljs-keyword">null</span> &amp;&amp; loc.isLocked()) &#123;<br>                loc.unlock();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> R.success(&quot;注册成功&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="音乐发布"><a href="#音乐发布" class="headerlink" title="音乐发布"></a>音乐发布</h4><p>技术方案</p><p>canal监听数据库-发送mq-&gt;同步es-</p><p>后续查询直接去es查询-也能够实现附加查询</p><p>配上userid+redis监控-不弄锁了</p><p>文件上传-异步实现</p><h6 id="1-单实现"><a href="#1-单实现" class="headerlink" title="1.单实现"></a>1.单实现</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs typescript">    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">upload</span>(<span class="hljs-params"><span class="hljs-title class_">MultipartFile</span> file, <span class="hljs-title class_">String</span> musicName, <span class="hljs-title class_">BigDecimal</span> latitude, <span class="hljs-title class_">BigDecimal</span> longitude</span>) &#123;<br>       <span class="hljs-comment">//</span><br>        <span class="hljs-title class_">String</span> userId = (<span class="hljs-title class_">String</span>) <span class="hljs-title class_">RequestContextHolder</span>.<span class="hljs-title function_">getRequestAttributes</span>().<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-title class_">RequestAttributes</span>.<span class="hljs-property">SCOPE_REQUEST</span>);<br><br>        <span class="hljs-title class_">OnlineMusic</span> onlineMusic=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnlineMusic</span>();<br>        <span class="hljs-keyword">if</span>(file.<span class="hljs-title function_">isEmpty</span>()||musicName.<span class="hljs-title function_">isEmpty</span>()||latitude==<span class="hljs-literal">null</span>||longitude==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;参数错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(file.<span class="hljs-title function_">getSize</span>()&gt;<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">50</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;文件过大&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//异步线程池上传文件</span><br>        <span class="hljs-title class_">String</span> fileid=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br>        onlineMusic.<span class="hljs-title function_">setMusicName</span>(musicName);<br>        onlineMusic.<span class="hljs-title function_">setLongitude</span>(longitude);<br>        onlineMusic.<span class="hljs-title function_">setLatitude</span>(latitude);<br>        onlineMusic.<span class="hljs-title function_">setUserid</span>(userId);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-title class_">Future</span>&lt;<span class="hljs-title class_">String</span>&gt; future= <span class="hljs-title function_">fileupload</span>(file);<br>            fileid = future.<span class="hljs-title function_">get</span>();<span class="hljs-comment">//等待上传完成</span><br>        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;文件上传失败&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(fileid.<span class="hljs-title function_">isEmpty</span>())<br>        &#123;<br>          <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;文件上传失败&quot;</span>);<br>        &#125;<br>        onlineMusic.<span class="hljs-title function_">setFileLocation</span>(fileid);<br><br>        <span class="hljs-keyword">return</span> R.<span class="hljs-title function_">success</span>(onlineMusic);<br><br><br>    &#125;<br><span class="hljs-comment">//也不设计线程池-设计</span><br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">ExecutorService</span> executorService = <span class="hljs-title class_">Executors</span>.<span class="hljs-title function_">newFixedThreadPool</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 定义一个固定大小的线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Future</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">fileupload</span>(<span class="hljs-params"><span class="hljs-title class_">MultipartFile</span> file</span>) &#123;<br><br>        <span class="hljs-keyword">return</span> executorService.<span class="hljs-title function_">submit</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-title class_">Random</span> random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                <span class="hljs-title class_">String</span> uuid = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">valueOf</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(random.<span class="hljs-title function_">nextLong</span>()));  <span class="hljs-comment">// 确保为非负数</span><br>                <span class="hljs-title class_">Path</span> destinationFile = <span class="hljs-title class_">Paths</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;I:\\mp3\\&quot;</span> + uuid + <span class="hljs-string">&quot;.&quot;</span> + file.<span class="hljs-title function_">getContentType</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">1</span>]);<br><br>                <span class="hljs-comment">// 存储文件</span><br>                <span class="hljs-title class_">Files</span>.<span class="hljs-title function_">copy</span>(file.<span class="hljs-title function_">getInputStream</span>(), destinationFile);<br>                <span class="hljs-keyword">return</span> uuid;<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;文件上传失败&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h4><p>疯狂read-看用本地还是数据库</p><p>只允许音乐文件上传-通过id-模糊去找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; bofang(String id) &#123;<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;I:\\mp3\\&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> id + <span class="hljs-string">&quot;*&quot;</span>;  <span class="hljs-comment">// 使用 id + 通配符的方式匹配文件</span><br>        <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">InputStreamResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, pattern)) &#123;<br>                Iterator&lt;Path&gt; iterator = stream.iterator();<br>                <span class="hljs-keyword">if</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-type">Path</span> <span class="hljs-variable">matchedFile</span> <span class="hljs-operator">=</span> iterator.next();<br>                    <span class="hljs-comment">//取第一个 优化思路 id+后缀 存redis-我uuid随机生成</span><br>                    <span class="hljs-comment">//重复改了极其低-但是如果大项目就需要考虑了</span><br>                     headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>                    headers.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM_VALUE);  <span class="hljs-comment">// 改为音频文件类型</span><br>                    headers.add(HttpHeaders.CONTENT_TYPE, <span class="hljs-string">&quot;audio/mpeg&quot;</span>); <span class="hljs-comment">// 设置正确的音频类型</span><br>                    resource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamResource</span>(Files.newInputStream(matchedFile));<br>                &#125;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ResponseEntity.ok()<br>                .headers(headers)<br>                .body(resource);<br>    &#125;<br></code></pre></td></tr></table></figure><p>仅仅完成了音乐播放的功能</p><h4 id="bean开发"><a href="#bean开发" class="headerlink" title="bean开发"></a>bean开发</h4><blockquote><p>编写bean。注解后的参数就必须有，没有就直接返回参数错误，。每次判断为空太蠢了</p></blockquote><h4 id="第一次调试"><a href="#第一次调试" class="headerlink" title="第一次调试"></a>第一次调试</h4><h6 id="1-注册接口调试-问题1"><a href="#1-注册接口调试-问题1" class="headerlink" title="1.注册接口调试 问题1"></a>1.注册接口调试 问题1</h6><p>大部分基础架构来自第一个项目-</p><blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column <span class="hljs-string">&#x27;userid&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;field list&#x27;</span><br>### The error may exist <span class="hljs-keyword">in</span> com/anli02/mapper/UserMapper.java (best guess)<br>### The error may involve com.anli02.mapper.UserMapper.insert-Inline<br>### The error occurred while setting parameters<br>### SQL: INSERT INTO user  ( userid, username, password )  VALUES  ( ?, ?, ? )<br>### Cause: java.sql.SQLSyntaxErrorException: Unknown column <span class="hljs-string">&#x27;userid&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;field list&#x27;</span><br>; bad SQL grammar []<br></code></pre></td></tr></table></figure><p>此错误表明数据库表 user 中不存在名为 userid 的列，但在SQL语句中却尝试插入该列的数据。</p></blockquote><p>非常奇怪</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@TableId</span>(value = <span class="hljs-string">&quot;userid&quot;</span>, <span class="hljs-keyword">type</span> = <span class="hljs-title class_">IdType</span>.<span class="hljs-property">ASSIGN_ID</span>)<br> <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> userid;<br><br></code></pre></td></tr></table></figure><p>userid    varchar(255)</p><blockquote><p>逆天问题，忘记改配置文件了</p></blockquote><h6 id="2-登录拦截器调试"><a href="#2-登录拦截器调试" class="headerlink" title="2.登录拦截器调试"></a>2.登录拦截器调试</h6><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">sessionwebUserD<span class="hljs-keyword">to</span>.<span class="hljs-built_in">set</span>UserId(<span class="hljs-keyword">user</span>.getUserid());<br>        sessionwebUserD<span class="hljs-keyword">to</span>.<span class="hljs-built_in">set</span>Username(<span class="hljs-keyword">user</span>.getUsername());<br></code></pre></td></tr></table></figure><p>下面代码刚刚也是setuserid</p><blockquote><p>org.apache.catalina.session.StandardSessionFacade cannot be cast to com.anli02.entity.dto.SessionwebUserDto</p></blockquote><blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">SessionwebUserD<span class="hljs-keyword">to</span> sessionwebUserD<span class="hljs-keyword">to</span> = (SessionwebUserD<span class="hljs-keyword">to</span>) request.getSession().getAttribute(<span class="hljs-string">&quot;session_account&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><p>这里传递的是字符串-&gt;框架自动根据字符串找到保存再服务器的数据】</p><hr><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">RequestContextHolder.currentRequestAttributes().<span class="hljs-built_in">set</span>Attribute(<span class="hljs-string">&quot;user&quot;</span>, sessionwebUserD<span class="hljs-keyword">to</span>, RequestAttributes.SCOPE_REQUEST);<br></code></pre></td></tr></table></figure><h6 id="3-上传文件接口"><a href="#3-上传文件接口" class="headerlink" title="3.上传文件接口"></a>3.上传文件接口</h6><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### Error updating database.  Cause: java.sql.SQLSyntaxErrorException: Column <span class="hljs-string">&#x27;userid&#x27;</span> specified twice<br>### The error may exist <span class="hljs-keyword">in</span> com/anli02/mapper/OnlineMusicMapper.java (best guess)<br>### The error may involve com.anli02.mapper.OnlineMusicMapper.insert-Inline<br>### The error occurred while setting parameters<br>### SQL: INSERT INTO online_music  ( userid, userid, music_name, file_location,     latitude, longitude )  VALUES  ( ?, ?, ?, ?,     ?, ? )<br>### Cause: java.sql.SQLSyntaxErrorException: Column <span class="hljs-string">&#x27;userid&#x27;</span> specified twice<br>; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: Column <span class="hljs-string">&#x27;userid&#x27;</span> specified twice<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@TableId</span>(value = <span class="hljs-string">&quot;userid&quot;</span>, <span class="hljs-keyword">type</span> = <span class="hljs-title class_">IdType</span>.<span class="hljs-property">ASSIGN_ID</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> music;<br></code></pre></td></tr></table></figure><p>复制的时候忘记改了</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">### Error updating <span class="hljs-keyword">database</span>.  Cause: java.<span class="hljs-keyword">sql</span>.SQLException: Field <span class="hljs-string">&#x27;upload_date&#x27;</span> doesn<span class="hljs-string">&#x27;t have a default value</span><br><span class="hljs-string">### The error may exist in com/anli02/mapper/OnlineMusicMapper.java (best guess)</span><br><span class="hljs-string">### The error may involve com.anli02.mapper.OnlineMusicMapper.insert-Inline</span><br><span class="hljs-string">### The error occurred while setting parameters</span><br><span class="hljs-string">### SQL: INSERT INTO online_music  ( music, userid, music_name, file_location,     latitude, longitude )  VALUES  ( ?, ?, ?, ?,     ?, ? )</span><br><span class="hljs-string">### Cause: java.sql.SQLException: Field &#x27;</span>upload_dat<span class="hljs-string">e&#x27; doesn&#x27;</span>t have a <span class="hljs-keyword">default</span> <span class="hljs-keyword">value</span><br>; Field <span class="hljs-string">&#x27;upload_date&#x27;</span> doesn<span class="hljs-string">&#x27;t have a default value; nested exception is java.sql.SQLException: Field &#x27;</span>upload_dat<span class="hljs-string">e&#x27; doesn&#x27;</span>t have a <span class="hljs-keyword">default</span> <span class="hljs-keyword">value</span><br></code></pre></td></tr></table></figure><p>忘记塞值了</p><p>逻辑</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">if</span>(!q)<br>   &#123;<br>       <span class="hljs-comment">//删除本地文件了--没写</span><br>       throw  new <span class="hljs-built_in">BusinessException</span>(<span class="hljs-number">500</span>,&quot;文件上传失败&quot;);<br>   &#125;<br></code></pre></td></tr></table></figure><p>不是交接项目不写</p><p>完美完成</p><h6 id="4-音乐播放调试"><a href="#4-音乐播放调试" class="headerlink" title="4.音乐播放调试"></a>4.音乐播放调试</h6><h4 id="音乐播放修改"><a href="#音乐播放修改" class="headerlink" title="音乐播放修改"></a>音乐播放修改</h4><p>基础播放已经完成-我们现在-需要进行点赞-评论-</p><p>播放-redis+1</p><p>每天数据库进行同步-线程池-或者什么想干啥干啥-游标同步-根据日期进行同步-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">redisTemplate</span>.opsForHash().increment(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + MusicId, OnlineMusicField.PLAY_COUNT.getFieldCode(),<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h5 id="音乐上传修改"><a href="#音乐上传修改" class="headerlink" title="音乐上传修改"></a>音乐上传修改</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + onlineMusic.<span class="hljs-built_in">getMusic</span>(), OnlineMusicField.PLAY_COUNT.<span class="hljs-built_in">getFieldCode</span>(), <span class="hljs-number">0</span>);<br>      <span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + onlineMusic.<span class="hljs-built_in">getMusic</span>(), OnlineMusicField.LIKE_COUNT.<span class="hljs-built_in">getFieldCode</span>(), <span class="hljs-number">0</span>);<br>      <span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineMusic:&quot;</span> + onlineMusic.<span class="hljs-built_in">getMusic</span>(), OnlineMusicField.COMMENT_COUNT.<span class="hljs-built_in">getFieldCode</span>(), <span class="hljs-number">0</span>);<br>      <span class="hljs-selector-tag">redisTemplate</span><span class="hljs-selector-class">.opsForHash</span>()<span class="hljs-selector-class">.put</span>(<span class="hljs-string">&quot;onlineFile:&quot;</span> + onlineMusic.<span class="hljs-built_in">getFileLocation</span>(), OnlineMusicField.FILE_ID.<span class="hljs-built_in">getFieldCode</span>(), onlineMusic.<span class="hljs-built_in">getMusic</span>());<br></code></pre></td></tr></table></figure><p><strong>ps:关于上传优化</strong></p><p><strong>我们可以提前生成uuid-然后直接异步-注意就不需要阻塞的等待上传了，就可以异步线程池了</strong></p><h4 id="10-11"><a href="#10-11" class="headerlink" title="10&#x2F;11"></a>10&#x2F;11</h4><p>代码要大改了——</p><h4 id="上传修改"><a href="#上传修改" class="headerlink" title="上传修改"></a>上传修改</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">修正上传-改为异步多线程上传<br>具体看gitee<br></code></pre></td></tr></table></figure><h4 id="计算音乐热点"><a href="#计算音乐热点" class="headerlink" title="计算音乐热点"></a>计算音乐热点</h4><p>幻想时刻-kafka的环境已经搭建好了 直接使用即可</p><p>生产者-聚合-消费者</p><p>xxl-job-&gt;发送到redis</p><p>分时间切块</p><p>权重设计</p><p>浏览&#x3D;1  点赞&#x3D;5 评论&#x3D;2</p><p>用户浏览点赞评论-&gt;生产者(有时间间隔-一般是多个浏览)-&gt;发送到聚合-&gt;进行分割好后-&gt;</p><p>音乐id -浏览人数  </p><p>点赞id -点赞人数</p><p>总权重-或者单独权重</p><p>{</p><p>总权重-简单-后续只需要相加</p><p>分批次-消费者还要进行处理</p><p>}</p><p>选择分批次-这样后续才能es入库</p><p>…………………</p><p>-&gt;发送给消费者</p><p>消费者拿到数据-&gt;计算权重聚合-&gt;推荐热点分值增加</p><blockquote><p>使用 Redis 的 <code>ZSET（有序集合）</code> 数据结构，其中音乐的 <code>ID</code> 作为成员，分值作为排序权重。</p></blockquote><blockquote><p><code>ZRANGE</code> 或 <code>ZREVRANGE</code> 命令按分值排序后获取音乐列表</p></blockquote><blockquote><p>获取到这些音乐 <code>ID</code> 后，通过批量查询的方式从 Elasticsearch 中获取对应的音乐详细信息</p><p>还实现了附加查询</p></blockquote><h4 id="10-12"><a href="#10-12" class="headerlink" title="10&#x2F;12"></a>10&#x2F;12</h4><h5 id="0-音乐热点代码"><a href="#0-音乐热点代码" class="headerlink" title="0.音乐热点代码"></a>0.音乐热点代码</h5><h6 id="1-数据库设计"><a href="#1-数据库设计" class="headerlink" title="1.数据库设计"></a>1.数据库设计</h6><h4 id="10-15"><a href="#10-15" class="headerlink" title="10&#x2F;15"></a>10&#x2F;15</h4><h4 id="cancle-mq"><a href="#cancle-mq" class="headerlink" title="cancle+mq"></a>cancle+mq</h4><p>1.配置cancle<br>2.配置mq<br>开始代码<br> &#x2F;&#x2F;发送mq信息-生产者<br>交换机设计<br>direct交换机<br>队列绑定交换机-key   music</p><h4 id="mq定义"><a href="#mq定义" class="headerlink" title="mq定义"></a>mq定义</h4><blockquote><ol><li>配置RabbitMQ连接</li><li>配置生产者<br>3.创建mq文件夹</li></ol></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> sun.<span class="hljs-property">misc</span>.<span class="hljs-property">Queue</span>;<br><br><span class="hljs-keyword">import</span> javax.<span class="hljs-property">naming</span>.<span class="hljs-property">Binding</span>;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DirectExchage</span> <span class="hljs-title function_">directExchage</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ExchangeBuilder</span>.<span class="hljs-title function_">directExchage</span>(<span class="hljs-string">&quot;music&quot;</span>).<span class="hljs-title function_">build</span>();<br>    &#125;<br>    <span class="hljs-comment">//创建队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">directQueue</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;direct.music&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingQueue</span>(<span class="hljs-params"><span class="hljs-title class_">Queue</span> directQueue ,<span class="hljs-title class_">DirectExchage</span>  directExchage  </span>)<br>    &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(directQueue).<span class="hljs-title function_">to</span>(directExchage).<span class="hljs-title function_">wint</span>(<span class="hljs-string">&quot;music&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生产者定义</strong></p><pre><code class="hljs">@Servicepublic class OnlineMusicServiceImpl extends ServiceImpl&lt;OnlineMusicMapper, OnlineMusic&gt; implements IOnlineMusicService &#123;    @Autowired    private RabbitTemplate rabbitTemplate;</code></pre><p><strong>消费者定义</strong></p><p>发送到mq了</p><p>进行转json处理后</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Component</span><br>public  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MusicConsumer</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-variable">@RabbitListener</span>(queues=<span class="hljs-string">&quot;direct.music&quot;</span>)<br>    public void <span class="hljs-keyword">listen</span>(String message)<br>    &#123;<br>        <span class="hljs-regexp">//</span>同步到es<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="es"><a href="#es" class="headerlink" title="es"></a>es</h4><p>es同步<br>1.导入依赖<br>Java High Level Rest Client<br>引入es的RestHighLevelClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">elsConfig</span> </span>&#123;<br>    <span class="hljs-variable">@Bean</span><br>    public RestHighLevelClient client()&#123;<br>        <span class="hljs-keyword">return</span> new RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>        ));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnlineMusicDoc</span> <span class="hljs-title">implements</span> <span class="hljs-title">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-meta">@TableId(value = <span class="hljs-string">&quot;music&quot;</span>, type = IdType.ASSIGN_ID)</span><br>    <span class="hljs-keyword">private</span> String music;<br><br>    <span class="hljs-keyword">private</span> String userid;<br><br>    <span class="hljs-keyword">private</span> String musicName;<br><br>    <span class="hljs-keyword">private</span> String fileLocation;<br><br>    <span class="hljs-keyword">private</span> LocalDate uploadDate;<br><br>    <span class="hljs-keyword">private</span> Integer likes;<br><br>    <span class="hljs-keyword">private</span> Integer views;<br><br>    <span class="hljs-keyword">private</span> Integer comments;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *     private BigDecimal latitude;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *     private BigDecimal longitude;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String location;<br>    <span class="hljs-comment">//重写构造--需要传递原类型-自动转es类型</span><br>    <span class="hljs-keyword">public</span> OnlineMusicDoc(OnlineMusic onlinemusic) &#123;<br>        <span class="hljs-keyword">this</span>.location = onlinemusic.getLatitude() + <span class="hljs-string">&quot;, &quot;</span> + onlinemusic.getLongitude();<br>        <span class="hljs-keyword">this</span>.music = onlinemusic.getMusic();<br>        <span class="hljs-keyword">this</span>.userid = onlinemusic.getUserid();<br>        <span class="hljs-keyword">this</span>.musicName = onlinemusic.getMusicName();<br>        <span class="hljs-keyword">this</span>.fileLocation = onlinemusic.getFileLocation();<br>        <span class="hljs-keyword">this</span>.uploadDate = onlinemusic.getUploadDate();<br>        <span class="hljs-keyword">this</span>.likes = onlinemusic.getLikes();<br>        <span class="hljs-keyword">this</span>.views = onlinemusic.getViews();<br>        <span class="hljs-keyword">this</span>.comments = onlinemusic.getComments();<br><br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>es类处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicConsumer</span><br>&#123;<br><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-title class_">RestHighLevelClient</span> client;<br>    <span class="hljs-meta">@RabbitListener</span>(queues=<span class="hljs-string">&quot;direct.music&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listen</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> message</span>)<br>    &#123;<br>        <span class="hljs-title class_">OnlineMusic</span> onlineMusic=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnlineMusic</span>();<br>        <span class="hljs-comment">//同步到es</span><br>        <span class="hljs-comment">// 将接收到的消息转换为OnlineMusic对象</span><br>        <span class="hljs-keyword">try</span> &#123;<br>             onlineMusic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().<span class="hljs-title function_">readValue</span>(message, <span class="hljs-title class_">OnlineMusic</span>.<span class="hljs-property">class</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e)<br>        &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br><br>        <span class="hljs-title class_">OnlineMusicDoc</span> onlineMusicDoc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnlineMusicDoc</span>(onlineMusic);<br>        <span class="hljs-title class_">IndexRequest</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;music&quot;</span>);<br>        request.<span class="hljs-title function_">id</span>(onlineMusicDoc.<span class="hljs-title function_">getMusic</span>()); <span class="hljs-comment">// 设置文档ID</span><br>        <span class="hljs-comment">///指定数据的格式</span><br>        request.<span class="hljs-title function_">source</span>(onlineMusicDoc, <span class="hljs-title class_">XContentType</span>.<span class="hljs-property">JSON</span>));<br>        <span class="hljs-comment">///2默认</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            client.<span class="hljs-title function_">index</span>(request,<span class="hljs-title class_">RequestOptions</span>.<span class="hljs-property">DEFAULT</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e)<br>        &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>        <br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p> 合并-创建索引库<br>明天<br>RestClient查询文档</p><p>完成mq各类可靠性</p><p>.完成缓存预热。之后的工作。</p><h4 id="10-16"><a href="#10-16" class="headerlink" title="10&#x2F;16"></a>10&#x2F;16</h4><h4 id="数据库修改"><a href="#数据库修改" class="headerlink" title="数据库修改"></a>数据库修改</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">mysql</span>&gt; alter table <span class="hljs-type">Online_music</span> add introduce varchar(<span class="hljs-number">255</span>);<br><span class="hljs-type">Query</span> <span class="hljs-type">OK</span>, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.01</span> sec)<br><span class="hljs-type">Records</span>: <span class="hljs-number">0</span>  <span class="hljs-type">Duplicates</span>: <span class="hljs-number">0</span>  <span class="hljs-type">Warnings</span>: <span class="hljs-number">0</span><br><br><span class="hljs-title">mysql</span>&gt; select *from <span class="hljs-type">Online_music</span>;<br>+---------------------+---------------------+------------+---------------------+-------------+-------+-------+----------+-------------+--------------+-----------+<br>| music               | userid              | music_name | file_location       | upload_date | likes | views | comments | latitude    | longitude    | introduce |<br>+---------------------+---------------------+------------+---------------------+-------------+-------+-------+----------+-------------+--------------+-----------+<br>| <span class="hljs-number">1843906669077049345</span> | <span class="hljs-number">1843897607711019010</span> | 我爱你     | <span class="hljs-number">5553676743117756205</span> | <span class="hljs-number">2024</span>-<span class="hljs-number">10</span>-<span class="hljs-number">09</span>  |     <span class="hljs-number">0</span> |     <span class="hljs-number">0</span> |        <span class="hljs-number">0</span> | <span class="hljs-number">29.56376100</span> | <span class="hljs-number">106.55046400</span> | <span class="hljs-type">NULL</span>      |<br>+---------------------+---------------------+------------+---------------------+-------------+-------+-------+----------+-------------+--------------+-----------+<br></code></pre></td></tr></table></figure><p>introduce提供分词</p><p>算了.</p><p>已废弃-分词根据name分</p><h4 id="索引库创建"><a href="#索引库创建" class="headerlink" title="索引库创建"></a>索引库创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs sql">PUT <span class="hljs-operator">/</span>online_music_index<br>&#123;<br>  &quot;mappings&quot;: &#123;<br>    &quot;properties&quot;: &#123;<br>      &quot;music&quot;: &#123;<br>        &quot;type&quot;: &quot;keyword&quot;<br>      &#125;,<br>      &quot;userid&quot;: &#123;<br>        &quot;type&quot;: &quot;keyword&quot;<br>      &#125;,<br>      &quot;musicName&quot;: &#123;<br>        &quot;type&quot;: &quot;text&quot;,<br>        &quot;analyzer&quot;: &quot;standard&quot;<br>      &#125;,<br>      &quot;fileLocation&quot;: &#123;<br>        &quot;type&quot;: &quot;keyword&quot;<br>      &#125;,<br>      &quot;uploadDate&quot;: &#123;<br>        &quot;type&quot;: &quot;date&quot;,<br>        &quot;format&quot;: &quot;yyyy-MM-dd&quot;<br>      &#125;,<br>      &quot;likes&quot;: &#123;<br>        &quot;type&quot;: &quot;integer&quot;<br>      &#125;,<br>      &quot;views&quot;: &#123;<br>        &quot;type&quot;: &quot;integer&quot;<br>      &#125;,<br>      &quot;comments&quot;: &#123;<br>        &quot;type&quot;: &quot;integer&quot;<br>      &#125;,<br>      &quot;location&quot;: &#123;<br>        &quot;type&quot;: &quot;geo_point&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong><code>music</code><strong>、</strong><code>userid</code><strong>、</strong><code>fileLocation</code></strong> 使用 <code>keyword</code> 类型，适合不需要进行全文搜索的字段。</p><p><strong><code>musicName</code></strong> 使用 <code>text</code> 类型，并配置了标准分词器 <code>analyzer: &quot;standard&quot;</code>，适合需要进行全文搜索的字段。</p><p><strong><code>uploadDate</code></strong> 使用 <code>date</code> 类型，并指定了日期格式 <code>yyyy-MM-dd</code>。</p><p><strong><code>likes</code><strong>、</strong><code>views</code><strong>、</strong><code>comments</code></strong> 使用 <code>integer</code> 类型，表示整型数据。</p></blockquote><h4 id="mq生产者信息确认"><a href="#mq生产者信息确认" class="headerlink" title="mq生产者信息确认"></a>mq生产者信息确认</h4><h6 id="1-开启生产者重试机制"><a href="#1-开启生产者重试机制" class="headerlink" title="1.开启生产者重试机制"></a>1.开启生产者重试机制</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">springamqp</span> <span class="hljs-string">提供信息发送重试机制-&gt;类似三次握手</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 设置MQ的连接超时时间</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br></code></pre></td></tr></table></figure><h6 id="2-生产者确认机制"><a href="#2-生产者确认机制" class="headerlink" title="2.生产者确认机制"></a>2.生产者确认机制</h6><p>生产者确认机制</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata">spring:<br>  rabbitmq:<br>    publisher-<span class="hljs-keyword">confirm</span>-<span class="hljs-keyword">type</span>: correlated # 开启publisher <span class="hljs-keyword">confirm</span>机制，并设置<span class="hljs-keyword">confirm</span>类型<br>    publisher-returns: true # 开启publisher <span class="hljs-keyword">return</span>机制<br>这里publisher-<span class="hljs-keyword">confirm</span>-<span class="hljs-keyword">type</span>有三种模式可选：<br><br>- none：关闭<span class="hljs-keyword">confirm</span>机制<br>- simple：同步阻塞等待MQ的回执<br>- correlated：MQ异步回调返回回执<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">CorrelationData</span> cd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>        cd.<span class="hljs-title function_">getFuture</span>().<span class="hljs-title function_">addCallback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;<span class="hljs-title class_">CorrelationData</span>.<span class="hljs-property">Confirm</span>&gt;()<br>                                   &#123;<br>                                       <span class="hljs-meta">@Override</span><br>                                       <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onFailure</span>(<span class="hljs-params"><span class="hljs-title class_">Throwable</span> throwable</span>) &#123;<br>                                           <span class="hljs-comment">// 处理失败的情况</span><br>                                           throwable.<span class="hljs-title function_">printStackTrace</span>();<br>                                       &#125;<br><br>                                       <span class="hljs-meta">@Override</span><br>                                       <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onSuccess</span>(<span class="hljs-params"><span class="hljs-title class_">CorrelationData</span>.<span class="hljs-title class_">Confirm</span> confirm</span>) &#123;<br>                                           <span class="hljs-comment">// 处理成功的情况</span><br>                                        <span class="hljs-keyword">if</span>(confirm.<span class="hljs-title function_">isAck</span>())<br>                                            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;消息发送成功&quot;</span>);<br>                                        <span class="hljs-keyword">else</span><br>                                            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;消息发送失败&quot;</span>);<br>                                       &#125;<br>                                   &#125;<br><br>        );<br><br><br><br><br>        kmsTemplate.<span class="hljs-title function_">send</span>( <span class="hljs-title class_">HotArticleConstants</span>.<span class="hljs-property">HOT_ARTICLE_AGGREGATION_QUEUE</span>,mess,cd);<br></code></pre></td></tr></table></figure><p>可以把cd提出来</p><h4 id="mq可靠性"><a href="#mq可靠性" class="headerlink" title="mq可靠性"></a>mq可靠性</h4><p>去控制台给交换机持久化</p><p>设置队列懒人化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">directQueue</span>(<span class="hljs-params"></span>)<br> &#123;<br> <br>     <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     args.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;x-queue-mode&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>);  <span class="hljs-comment">// 设置队列为懒人模式</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;direct.music&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);  <span class="hljs-comment">// 持久化，非独占，非自动删除</span><br> &#125;<br></code></pre></td></tr></table></figure><p>控制台开启信息持久化</p><h4 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h4><h6 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h6><p>SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，<strong>当业务正常执行时则自动返回ack.  当业务出现异常时，根据异常判断返回不同结果：</strong><br>  - 如果是业务异常，会自动返回nack；  - 如果是消息处理或校验异常，自动返回reject;</p><p>SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，<strong>当业务正常执行时则自动返回ack.  当业务出现异常时，根据异常判断返回不同结果：</strong><br>  - 如果是业务异常，会自动返回nack；  - 如果是消息处理或校验异常，自动返回reject;</p><h6 id="失败者重试机制"><a href="#失败者重试机制" class="headerlink" title="失败者重试机制"></a>失败者重试机制</h6><p>失败重试机制<br><strong>消费者-&gt;重试-&gt;出现异常-&gt;返回mq</strong><br><strong>一直下去-消耗资源-</strong><br><strong>在消费者出现异常时-&gt;利用本地重试-不到mq队列</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241016091944980.png" alt="image-20241016091944980"></p><p><img src="C:\Users\nixg\AppData\Roaming\Typora\typora-user-images\image-20241016091951933.png" alt="image-20241016091951933"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241016091957207.png" alt="image-20241016091957207"></p><h6 id="重试投递"><a href="#重试投递" class="headerlink" title="重试投递"></a>重试投递</h6><p>失败交换机</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241016093219024.png" alt="image-20241016093219024"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchageMQ</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DirectExchange</span> <span class="hljs-title function_">directExchage</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;erro.direct&quot;</span>);<br><br><br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">erroqueue</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;erro.queue&quot;</span>,<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingQueue</span>(<span class="hljs-params"><span class="hljs-title class_">Queue</span> erroqueue , <span class="hljs-title class_">DirectExchange</span>  directExchage  </span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(erroqueue).<span class="hljs-title function_">to</span>(directExchage).<span class="hljs-title function_">with</span>(<span class="hljs-string">&quot;erro.key&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">MessageRecoverer</span> <span class="hljs-title function_">messageRecoverer</span>(<span class="hljs-params"><span class="hljs-title class_">RabbitTemplate</span> rabbitTemplate</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepublishMessageRecoverer</span>(rabbitTemplate,<span class="hljs-string">&quot;erro.direct&quot;</span>,<span class="hljs-string">&quot;erro.key&quot;</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>RabbitListenerContainerFactory</code> 中配置重试机制，指定重试次数和重试间隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQRetryConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title function_">rabbitListenerContainerFactory</span><span class="hljs-params">(ConnectionFactory connectionFactory)</span> &#123;<br>        <span class="hljs-type">SimpleRabbitListenerContainerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRabbitListenerContainerFactory</span>();<br>        factory.setConnectionFactory(connectionFactory);<br><br>        <span class="hljs-comment">// 配置重试模板</span><br>        factory.setRetryTemplate(retryTemplate());<br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RetryTemplate <span class="hljs-title function_">retryTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RetryTemplate</span> <span class="hljs-variable">retryTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryTemplate</span>();<br><br>        <span class="hljs-comment">// 设置重试策略，例如最多重试 5 次</span><br>        <span class="hljs-type">SimpleRetryPolicy</span> <span class="hljs-variable">retryPolicy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRetryPolicy</span>();<br>        retryPolicy.setMaxAttempts(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 设置最大重试次数</span><br>        retryTemplate.setRetryPolicy(retryPolicy);<br><br>        <span class="hljs-comment">// 可选：设置重试间隔</span><br>        retryTemplate.setBackOffPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedBackOffPolicy</span>() &#123;<br>            &#123;<br>                setBackOffPeriod(<span class="hljs-number">2000</span>);  <span class="hljs-comment">// 设置重试间隔为 2 秒</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> retryTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h6><p>多次发送-同意的id-对吧-发送了没事情</p><p>我们假设有幂等性问题</p><p>信息加入id</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">messageConverterto</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span> <span class="hljs-title function_">methodConverter</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title class_">Jackson2JsonMessageConverter</span> jjmc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>        jjmc.<span class="hljs-title function_">setCreateMessageIds</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> jjmc;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">String</span>&gt; processedMessageIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-meta">@RabbitListener</span>(queues=<span class="hljs-string">&quot;direct.music&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listen</span>(<span class="hljs-params"><span class="hljs-title class_">Message</span> message</span>)<br>&#123;<br>    <span class="hljs-comment">// 模拟存储已处理的 MessageId，实际可以用 Redis 或数据库替代</span><br><br>    <span class="hljs-title class_">String</span> messageId = message.<span class="hljs-title function_">getMessageProperties</span>().<span class="hljs-title function_">getMessageId</span>();<br><br>    <span class="hljs-comment">// 检查消息是否已处理</span><br>    <span class="hljs-keyword">if</span> (messageId != <span class="hljs-literal">null</span> &amp;&amp; processedMessageIds.<span class="hljs-title function_">contains</span>(messageId)) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;重复消息，已跳过处理：&quot;</span> + messageId);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 消息已处理，跳过</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>虽然 <code>Jackson2JsonMessageConverter</code> 可以为每条消息生成唯一的 <code>MessageId</code>，但是为了确保幂等性，还需要在消息消费者侧做以下工作：</p><ul><li>检查是否已处理过该 <code>MessageId</code>。</li><li>记录处理过的消息 ID，防止重复处理。</li></ul><h4 id="热点数据续"><a href="#热点数据续" class="headerlink" title="热点数据续"></a>热点数据续</h4><p>reids设计</p><p>id 配和分值</p><p>sorted sets-key value(id) value(分值)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleIncrHandleListener</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-title class_">RedisTemplate</span> redisTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-title class_">RestHighLevelClient</span> restHighLevelClient;<br>    <span class="hljs-meta">@KafkaListener</span>(topics = <span class="hljs-title class_">HotArticleConstants</span>.<span class="hljs-property">HOT_ARTICLE_CONSUMER_QUEUE</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> message</span>) &#123;<br>        <span class="hljs-title class_">ArticleVisitStreamMess</span> mess= <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parseObject</span>(message, <span class="hljs-title class_">ArticleVisitStreamMess</span>.<span class="hljs-property">class</span>);<br>        <span class="hljs-comment">//对分值进行处理</span><br>        <span class="hljs-title function_">savemess</span>(mess);<br><br>        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;收到消息:&#123;&#125;&quot;</span>, message);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">savemess</span>(<span class="hljs-params"><span class="hljs-title class_">ArticleVisitStreamMess</span> mess</span>) &#123;<br>        <span class="hljs-comment">//拿出点赞 评论 浏览-id的权重</span><br>        <span class="hljs-comment">//计算总评分-存入redis-id+总积分-叠加//总积分表 -mucisid id-&gt;根据音乐id总权拿id</span><br>        int score=mess.<span class="hljs-title function_">getLike</span>()*<span class="hljs-number">5</span>+mess.<span class="hljs-title function_">getComment</span>()*<span class="hljs-number">2</span>+mess.<span class="hljs-title function_">getView</span>();<br>        redisTemplate.<span class="hljs-title function_">opsForZSet</span>().<span class="hljs-title function_">add</span>(<span class="hljs-title class_">HotArticleConstants</span>.<span class="hljs-property">HOT_ARTICLE_REDIS_QUEUE</span>,mess.<span class="hljs-title function_">getMuicid</span>(),score);<br><br>        <span class="hljs-comment">//根据数量-评论 浏览 id 修改es对应的最新数量</span><br>        <span class="hljs-title class_">UpdateRequest</span> updateRquest=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateRequest</span>();<br>        updateRquest.<span class="hljs-title function_">index</span>(<span class="hljs-string">&quot;online_music_index&quot;</span>).<span class="hljs-title function_">id</span>(mess.<span class="hljs-title function_">getMuicid</span>()).<span class="hljs-title function_">doc</span>(mess);<br><br><br>        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        params.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;view&quot;</span>, mess.<span class="hljs-title function_">getView</span>());<br>        params.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;comment&quot;</span>, mess.<span class="hljs-title function_">getComment</span>());<br>        params.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;like&quot;</span>, mess.<span class="hljs-title function_">getLike</span>());<br><br>        <span class="hljs-title class_">Script</span> script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Script</span>(<span class="hljs-title class_">ScriptType</span>.<span class="hljs-property">INLINE</span>, <span class="hljs-string">&quot;painless&quot;</span>,<br>                <span class="hljs-string">&quot;ctx._source.comments += params.comment;&quot;</span> +<br>                        <span class="hljs-string">&quot;ctx._source.views += params.view;&quot;</span> +<br>                        <span class="hljs-string">&quot;ctx._source.likes += params.like;&quot;</span>,<br>                params);<br>        updateRquest.<span class="hljs-title function_">script</span>(script);<br>        <span class="hljs-keyword">try</span> &#123;<br>            restHighLevelClient.<span class="hljs-title function_">update</span>(updateRquest, <span class="hljs-title class_">RequestOptions</span>.<span class="hljs-property">DEFAULT</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//目前能像到的就这样</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="展示编写"><a href="#展示编写" class="headerlink" title="展示编写"></a>展示编写</h4><p>两个搜索 一个根据ids查询所有数据返回</p><p>另外一个就是带坐标的搜索</p><p>后端就返回个集合就可以了 json</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /your_index/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;ids&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;values&quot;</span>: [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Autowired</span><br>RestHighLevelClient restHighLevelClient;<br><br><span class="hljs-meta">@Override</span><br>public R <span class="hljs-keyword">show</span>(OnlineMusic onlineMusic) &#123;<br>    <span class="hljs-comment">//根据redis-从分值开始拿出推荐-缺点就是一直固定</span><br>    <span class="hljs-comment">/// <span class="language-markdown">redisTemplate.opsForZSet().add(HotArticleConstants.HOT<span class="hljs-emphasis">_ARTICLE_</span>REDIS<span class="hljs-emphasis">_QUEUE,mess.getMuicid(),score);</span></span></span><br>    <span class="hljs-comment">//1 10 2 20 3 30</span><br>    <span class="hljs-comment">//降序reverseRange 升序 range</span><br><br>    <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">set</span> = redisTemplate.opsForZSet().reverseRange(HotArticleConstants.HOT_ARTICLE_REDIS_QUEUE, onlineMusic.getPage() * <span class="hljs-number">10</span> - <span class="hljs-number">10</span>, onlineMusic.getPage() * <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//数据来自es-两个搜索-带坐标附加-不带就是推荐</span><br><br>    OnlineMusicDoc doc = <span class="hljs-keyword">new</span> OnlineMusicDoc(onlineMusic);<br>    GeoPoint geoPoint = <span class="hljs-keyword">new</span> GeoPoint(doc.getLocation());<br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;online_music_index&quot;</span>);<br>    <span class="hljs-keyword">if</span>(doc.getLocation().isEmpty())<br>    &#123;<br>        <span class="hljs-comment">//首页搜索</span><br><br>        SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>        searchSourceBuilder.query(QueryBuilders.termsQuery(<span class="hljs-string">&quot;music&quot;</span>, <span class="hljs-keyword">set</span>)); <span class="hljs-comment">// 使用文档ID字段</span><br><br>        request.source(searchSourceBuilder);<br>        <span class="hljs-keyword">try</span> &#123;<br>            SearchResponse search = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)<br>        &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//附加推荐搜索</span><br><br>        SearchSourceBuilder sourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>        sourceBuilder.sort(SortBuilders.geoDistanceSort(<span class="hljs-string">&quot;location&quot;</span>, geoPoint)<br>                .order(SortOrder.ASC)  <span class="hljs-comment">// 按距离升序排序</span><br>                .unit(org.elasticsearch.common.unit.DistanceUnit.KILOMETERS));  <span class="hljs-comment">// 单位为公里</span><br>        sourceBuilder.query(QueryBuilders.termsQuery(<span class="hljs-string">&quot;music&quot;</span>, <span class="hljs-keyword">set</span>)); <span class="hljs-comment">// 使用文档ID字段</span><br>        request.source(sourceBuilder);<br>    &#125;<br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt;&gt; resultList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//解析es</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <br><br>        SearchResponse search = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br><br>        <span class="hljs-comment">// 获取 hits</span><br>        SearchHit[] hits = search.getHits().getHits();<br>        <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>            <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; sourceAsMap = hit.getSourceAsMap();<br>            resultList.add(sourceAsMap);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br><br><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ps:应该由es直接提供，es本身就能计算分值</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">return</span> R.success(resultList);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="10-17"><a href="#10-17" class="headerlink" title="10&#x2F;17"></a>10&#x2F;17</h4><p>今天</p><p>发布文章-&gt;生成静态页面（名字就是id)-&gt;上传到minio</p><p>feign+Sentinel-&gt;向头像微服务(凭空想象微服务)发起获取头像</p><h4 id="freemarker模板"><a href="#freemarker模板" class="headerlink" title="freemarker模板"></a>freemarker模板</h4><h6 id="评论数据库问题"><a href="#评论数据库问题" class="headerlink" title="评论数据库问题"></a>评论数据库问题</h6><p>根本就没向评论表-逆天-本来想遍历对象的</p><p>假设评论-“评论”,”评论”-&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].musicName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    &lt;#if dataModel[&quot;music&quot;].likes gt 100&gt;<br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].musicName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    &lt;/#if&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> &gt;</span>$&#123;dataModel[&quot;music&quot;].musicName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>点赞:<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].likes&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>$&#123;dataModel[&quot;music&quot;].comments&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;playMusic(music.fileLocation)&quot;</span>&gt;</span>播放音乐<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">playMusic</span>(<span class="hljs-params">fileId</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 使用接口中的文件ID拼接音乐播放地址</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> musicUrl = <span class="hljs-string">&#x27;/mp3/&#x27;</span> + fileId;</span><br><span class="language-javascript">        <span class="hljs-comment">// 创建一个音频对象，进行播放</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> audio = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audio</span>(musicUrl);</span><br><span class="language-javascript">        audio.<span class="hljs-title function_">play</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>ps:评论表应该去发请求-而不是本地生成-管他的。不改了</p><p> 01-basic.ftl</p><h6 id="2-导入依赖"><a href="#2-导入依赖" class="headerlink" title="2.导入依赖"></a>2.导入依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="3-评论数据库"><a href="#3-评论数据库" class="headerlink" title="3.评论数据库"></a>3.评论数据库</h6><p>我设计的是评论数量-没有问题，不需要显示评论即可</p><h6 id="4-生成静态页面"><a href="#4-生成静态页面" class="headerlink" title="4.生成静态页面"></a>4.生成静态页面</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//静态化测试</span><br>      <span class="hljs-keyword">try</span> &#123;<br>          Template <span class="hljs-keyword">template</span> = configuration.<span class="hljs-built_in">getTemplate</span>(<span class="hljs-string">&quot;02-list.ftl&quot;</span>);<br>           Map&lt;<span class="hljs-type">String</span>, Object&gt; dataModel = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>           dataModel.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;music&quot;</span>, onlineMusic);<br>          <span class="hljs-keyword">template</span>.<span class="hljs-built_in">process</span>(dataModel, <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileWriter</span>(<span class="hljs-string">&quot;d:/list.html&quot;</span>));<br><br>      &#125;<br></code></pre></td></tr></table></figure><p>因为要用minio 故此-无需生成本地</p><h4 id="minIO配置"><a href="#minIO配置" class="headerlink" title="minIO配置"></a>minIO配置</h4><h6 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h6><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">minio:</span><br><span class="hljs-symbol">  endpoint:</span> http:<span class="hljs-comment">//192.168.78.101:9001</span><br><span class="hljs-symbol">  accessKey:</span> admin<br><span class="hljs-symbol">  secretKey:</span> <span class="hljs-number">12345678</span><br><span class="hljs-symbol">  bucketName:</span> weiz-test<br></code></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;minio&quot;</span>)  <span class="hljs-comment">// 文件上传 配置前缀file.oss</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MinIOConfigProperties</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Serializable</span></span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> accessKey;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> secretKey;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> bucket;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> endpoint;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> readPath;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Data</span><br><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableConfigurationProperties</span>(&#123;MinIOConfigProperties.class&#125;)<br><span class="hljs-comment">//当引入FileStorageService接口时</span><br><span class="hljs-variable">@ConditionalOnClass</span>(FileStorageService.class)<br>public class MinIOConfig &#123;<br><br>   <span class="hljs-variable">@Autowired</span><br>   private MinIOConfigProperties minIOConfigProperties;<br><br>    <span class="hljs-variable">@Bean</span><br>    public MinioClient <span class="hljs-built_in">buildMinioClient</span>()&#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">MinioClient</span><br>                <span class="hljs-selector-class">.builder</span>()<br>                <span class="hljs-selector-class">.credentials</span>(minIOConfigProperties.<span class="hljs-built_in">getAccessKey</span>(), minIOConfigProperties.<span class="hljs-built_in">getSecretKey</span>())<br>                <span class="hljs-selector-class">.endpoint</span>(minIOConfigProperties.<span class="hljs-built_in">getEndpoint</span>())<br>                <span class="hljs-selector-class">.build</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上传接口的复制</p><p>………..</p><p>………..</p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//静态化测试<br> try &#123;<br>     <span class="hljs-keyword">Template</span> template = <span class="hljs-keyword">configuration</span>.getTemplate(&quot;02-list.ftl&quot;);<br>      Map&lt;String, <span class="hljs-keyword">Object</span>&gt; dataModel = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>      dataModel.put(&quot;music&quot;, onlineMusic);<br>     StringWriter <span class="hljs-keyword">out</span> = <span class="hljs-built_in">new</span> StringWriter();<br>     <span class="hljs-keyword">template</span>.process(dataModel, <span class="hljs-keyword">out</span>);<br>     InputStream <span class="hljs-keyword">is</span> = <span class="hljs-built_in">new</span> ByteArrayInputStream(<span class="hljs-keyword">out</span>.toString().getBytes());<br>     fileStorageService.uploadHtmlFile(&quot;&quot;,onlineMusic.getMusic()+&quot;.html&quot;,<span class="hljs-keyword">is</span>);<br><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="完结"><a href="#完结" class="headerlink" title="完结"></a><strong>完结</strong></h3><p>纯炫技项目。完结就完结了吧</p><p><a href="https://gitee.com/laomaodu/music-platform-demo">https://gitee.com/laomaodu/music-platform-demo</a></p><p>地址</p><p>“项目的环境全靠猜想，所有并没有跑过。纯炫技术项目。下个项目11月份开启。微服务炫技项目”</p>]]></content>
    
    
    <categories>
      
      <category>后端实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/10/05/Middleware/redis/Redis/"/>
    <url>/2024/10/05/Middleware/redis/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h4 id="redis认识"><a href="#redis认识" class="headerlink" title="redis认识"></a>redis认识</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007223906853.png" alt="image-20241007223906853"></p><p>Redis 是一个开源（BSD 许可）的，<strong>内存</strong> 中的数据结构存储系统，它可以用作 <strong>数据库、缓存和消息中间件</strong>。 </p><hr><blockquote><ul><li>内存数据库，速度快，也支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等多种数据结构的存储。</li><li>Redis支持数据的备份（master-slave）与集群（分片存储），以及拥有哨兵监控机制。</li><li>支持事务</li></ul></blockquote><blockquote><p>Redis 性能高、原子操作、支持多种数据类型，主从复制与哨兵监控，持久化操作等。</p></blockquote><h4 id="Redis-的高并发实现"><a href="#Redis-的高并发实现" class="headerlink" title="Redis 的高并发实现"></a>Redis 的高并发实现</h4><p>Redis 是 <strong>纯内存</strong> 数据库</p><p>Redis 使用的是 <strong>非阻塞 IO</strong>，<strong>IO 多路复用</strong> </p><p><strong>Redis 采用了 单线程 的模型</strong></p><blockquote><p>优点</p><p><strong>不需要各种锁的性能消耗</strong></p><p><strong>不需要各种锁的性能消耗</strong></p><p><strong>CPU 消耗</strong></p></blockquote><h4 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h4><p>基本数据结构包含：字符串（strings）、 散列（hashes）、 列表（lists）、 集合（sets）、 有序集合（sorted sets）五种。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007224006260.png" alt="image-20241007224006260"></p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>Redis 的字符串是一个由字节组成的序列，跟 Java 里面的 <strong>ArrayList</strong> 有点类似，<strong>采用预分配冗余空间的方式来减少内存的频繁分配</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/008eGmZEly1gphaysn7lbj30fw04pt8m.jpg" alt="img"></p><p>实际分配的空间 <code>capacity</code> 一般要高于实际字符串长度 len。</p><p>应用场景</p><blockquote><p>字符串类型在工作中使用广泛，主要用于<strong>缓存数据，提高查询性能</strong>。比如存储登录用户信息、电商中存储商品信息、可以做计数器（想知道什么时候封锁一个IP地址（访问超过几次））等等。</p></blockquote><p>指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 添加一条String类型数据<br><span class="hljs-keyword">set</span> key <span class="hljs-keyword">value</span><br># 获取一条String类型数据<br><span class="hljs-keyword">get</span> key<br># 添加多条String类型数据<br>mset key1 value1 key2 value2<br># 获取多条String类型数据<br>mget key1 key2<br># 自增（<span class="hljs-operator">+</span><span class="hljs-number">1</span>）<br>incr key<br># 按照步长（step）自增<br>incrby key step<br># 自减（<span class="hljs-number">-1</span>）<br>decr key<br># 按照步长（step）递减<br>decrby key step<br># 删除<br>del key<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span><span class="hljs-keyword">set</span> username zhangsan  <br>&quot;OK&quot;  <br>​  <br># 获取字符串  <br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">get</span> username  <br>&quot;zhangsan&quot;  <br>​  <br># 插入多个字符串  <br><span class="hljs-operator">&gt;</span>mset age <span class="hljs-number">18</span> address bj  <br>&quot;OK&quot;  <br>​  <br># 获取多个字符串  <br><span class="hljs-operator">&gt;</span>mget username age  <br> <span class="hljs-number">1</span>)  &quot;zhangsan&quot;  <br> <span class="hljs-number">2</span>)  &quot;18&quot;  <br>​  <br># 自增  <br><span class="hljs-operator">&gt;</span>incr num  <br>&quot;1&quot;  <br><span class="hljs-operator">&gt;</span>incr num  <br>&quot;2&quot;  <br>​  <br># 自减  <br><span class="hljs-operator">&gt;</span>decr num  <br>&quot;1&quot;  <br>​  <br># 指定步长自增  <br><span class="hljs-operator">&gt;</span>incrby num <span class="hljs-number">2</span>  <br>&quot;3&quot;  <br><span class="hljs-operator">&gt;</span>incrby num <span class="hljs-number">2</span>  <br>&quot;5&quot;  <br>​  <br># 指定步长自减  <br><span class="hljs-operator">&gt;</span>decrby num <span class="hljs-number">3</span>  <br>&quot;2&quot;  <br>​  <br># 删除  <br><span class="hljs-operator">&gt;</span>del num  <br>&quot;1&quot;<br></code></pre></td></tr></table></figure><h5 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h5><p>散列相当于 Java 中的 HashMap，内部是无序字典。实现原理跟 <code>HashMap</code> 一致。</p><p>个哈希表有多个节点，每个节点保存一个键值对。</p><blockquote><p><code>HashMap</code> 中的键是唯一的，每个键都映射到一个对应的值。它的底层实现使用了哈希函数，通过将键映射为数组中的索引位置，来实现高效的查找、插入和删除操作。</p></blockquote><p>应用场景</p><p>Hash 也可以同于对象存储，比如存储用户信息，与字符串不一样的是，字符串是需要将对象进行序列化（比如 JSON 序列化）之后才能保存，而 <strong>Hash 则可以将用户对象的每个字段单独存储</strong>，<strong>这样就能节省序列化和反序列的时间。</strong></p><blockquote><p>可以保存用户的购买记录，比如 key 为用户 id，field 为商品 id，value 为商品数量。同样还可以用于购物车数据的存储，比如 key 为用户 id，field 为商品 id，value 为购买数量等等。</p></blockquote><p>也就是设计结构单对单-优先散列</p><p><strong>操作指令</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 设置属性<br>hset keyname field1 value1 field2 value2<br># 获取某个属性值<br>hget keyname field<br># 获取所有属性值<br>hgetall keyname<br># 删除某个属性<br>hdel keyname field<br># 获取属性个数<br>hlen keyname<br># 按照步长自增<span class="hljs-operator">/</span>自减某个属性（该属性必须是数字）<br>hincrby keyname field step<br># 删除整个 hash<br>del keyname<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005152410795.png" alt="image-20241005152410795"></p><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>Redis 中的 lists 相当于 Java 中的 <code>LinkedList</code>，实现原理是一个双向链表（其底层是一个快速列表），即可以支持反向查找和遍历，更方便操作。插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p><p>应用场景</p><p>ists 的应用场景非常多，可以利用它轻松实现热销榜。</p><p><strong>可以实现工作队列</strong>（利用 lists 的 push 操作，将任务存在 lists 中，然后工作线程再用 pop 操作将任务取出进行执行 ）。</p><p>可以实现最新列表，比如最新评论等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 左进<br>lpush key value1 value2 value3...<br><br># 左出<br>lpop key<br><br># 右进<br>rpush key value1 value2 value3...<br><br># 右出<br>rpop key<br><br># 从左往右读取 <span class="hljs-keyword">start</span>和<span class="hljs-keyword">end</span>是下标<br>lrange key <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># 从 list 左边依次插入</span><br>&gt;lpush student zhangsan lisi wangwu<br><span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-comment"># 从 list 右边插入</span><br>&gt;rpush student tianqi<br><span class="hljs-string">&quot;4&quot;</span><br><br><span class="hljs-comment"># 从 list 左边弹出一个</span><br>&gt;lpop liangshan<br><span class="hljs-string">&quot;wangwu&quot;</span><br><br><span class="hljs-comment"># 从 list 右边弹出一个</span><br>&gt;rpop liangshan<br><span class="hljs-string">&quot;tianqi&quot;</span><br><br><span class="hljs-comment"># 获取 list 下标 0 ~ 1 的数据(左闭右闭)</span><br>&gt;<span class="hljs-keyword">lrange</span> liangshan <span class="hljs-number">0</span> <span class="hljs-number">1</span><br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;lisi&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;zhangsan&quot;</span><br></code></pre></td></tr></table></figure><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合类似 Java 中的 <code>HashSet</code>，（<code>HashSet</code> 的内部 <code>HashMap</code> 的<strong>键</strong>代表集合中的元素，而<strong>值</strong>可以认为是无意义的，只用于填充。它并不一定是 <code>null</code>，而是同一个固定的占位对象。key-value-只有key有值） HashMap，实际就是通过计算 hash 的方式来快速排重的，这 也是 set 能提供判断一个成员是否在集合内的原因。</p><blockquote><p>Redis 的 sets 类型是使用哈希表构造的，因此复杂度是 0(1)。它支持集合内的增删改查，并且支持多个集合间的交集、并集、 差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。比如计算网站独立 ip，用户画像中的用 户标签，共同好友等功能。</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gauss"> 添加内容<br>sadd <span class="hljs-built_in">key</span> value1 value2<br><span class="hljs-meta"># 查询 key 里所有的值</span><br>smembers <span class="hljs-built_in">key</span><br><span class="hljs-meta"># 移除 key 里面的某个 value</span><br>srem <span class="hljs-built_in">key</span> value<br><span class="hljs-meta"># 随机移除某个 value</span><br>spop <span class="hljs-built_in">key</span><br><span class="hljs-meta"># 返回两个 set 的并集</span><br>sunion key1 key2<br><span class="hljs-meta">#返回 key1 剔除交集的那部分(差集)</span><br>sdiff key1 key2<br><span class="hljs-meta">#跟 siffer 相反，返回交集</span><br>sinter key1 key2<br></code></pre></td></tr></table></figure><h5 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h5><p>sorted sets 是 Redis 类似于 <code>SortedSet</code> 和 <code>HashMap</code> 的结合体，一方面它是一个 set，保证了内部 value 的<strong>唯一性</strong>，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的<strong>排序权重</strong>。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/008eGmZEgy1gphbh2tslvj31ku0qidvt.jpg" alt="image-20210412221232375"></p><blockquote><p>主要应用于根据某个权重进行排序的队列的场景，比如游戏积分排行榜，设置优先级的任务列表，学生成绩表等。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 添加元素<br>zadd key score <span class="hljs-keyword">value</span> [score value...]<br><br># 获取集合的值并按照score从小到大排列， 最小的是最上面<br>zrange key <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> <br><br># 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列, 最小的是最上面<br>zrangeByScore key score_min score_max <br><br># 删除<br>zrem key <span class="hljs-keyword">value</span> <br><br># 获取key的集合有多少元素<br>zcard key<br><br># 统计分数从小到大有多少元素 （闭区间）<br>zcount key score_min score_max <br><br># 获取<span class="hljs-keyword">value</span>所在位置（从小到大排序，最小的是<span class="hljs-number">0</span>）<br>zrank key <span class="hljs-keyword">value</span> <br><br># 获取<span class="hljs-keyword">value</span>所在的位置（从大到小排列， 最大的是<span class="hljs-number">0</span>）<br>zrevrank key <span class="hljs-keyword">value</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 插入多条数据和分数并去重及排序<br><span class="hljs-operator">&gt;</span>zadd rank <span class="hljs-number">66</span> zhangsan <span class="hljs-number">88</span> lisi <span class="hljs-number">77</span> wangwu <span class="hljs-number">99</span> zhaoliu<br>&quot;4&quot;<br><br># 插入多条数据及分数并去重及排序<br><span class="hljs-operator">&gt;</span>zadd rank <span class="hljs-number">66</span> zhangsan <span class="hljs-number">88</span> lisi <span class="hljs-number">77</span> wangwu <span class="hljs-number">99</span> zhaoliu<br>&quot;0&quot;<br><br># 获取下标 <span class="hljs-number">0</span> <span class="hljs-operator">~</span> <span class="hljs-number">3</span> 的数据(左闭右闭)<br><span class="hljs-operator">&gt;</span>zrange rank <span class="hljs-number">0</span> <span class="hljs-number">3</span><br> <span class="hljs-number">1</span>)  &quot;zhangsan&quot;<br> <span class="hljs-number">2</span>)  &quot;wangwu&quot;<br> <span class="hljs-number">3</span>)  &quot;lisi&quot;<br> <span class="hljs-number">4</span>)  &quot;zhaoliu&quot;<br><br># 获取分数在 <span class="hljs-number">77</span> <span class="hljs-operator">~</span> <span class="hljs-number">99</span> 之间的数据(左闭右闭)<br><span class="hljs-operator">&gt;</span>zrangeByScore rank <span class="hljs-number">77</span> <span class="hljs-number">99</span><br> <span class="hljs-number">1</span>)  &quot;wangwu&quot;<br> <span class="hljs-number">2</span>)  &quot;lisi&quot;<br> <span class="hljs-number">3</span>)  &quot;zhaoliu&quot;<br><br># 删除一条数据<br><span class="hljs-operator">&gt;</span>zrem rank zhaoliu<br>&quot;1&quot;<br><br># 查询元素的个数<br><span class="hljs-operator">&gt;</span>zcard rank<br>&quot;3&quot;<br><br># 统计分数在 <span class="hljs-number">77</span> <span class="hljs-operator">~</span> <span class="hljs-number">88</span> 之间的数据(左闭右闭)<br><span class="hljs-operator">&gt;</span>zcount rank <span class="hljs-number">77</span> <span class="hljs-number">88</span><br>&quot;2&quot;<br><br># 获取指定元素的下标<br><span class="hljs-operator">&gt;</span>zrank rank zhangsan<br>&quot;0&quot;<br><br># 获取指定元素的下标并反转<br><span class="hljs-operator">&gt;</span>zrevrank rank zhangsan<br>&quot;2&quot;<br></code></pre></td></tr></table></figure><h4 id="redis高级数据结构"><a href="#redis高级数据结构" class="headerlink" title="redis高级数据结构"></a>redis高级数据结构</h4><h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><h5 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h5><h5 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h5><h5 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h5><h4 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h4><p>通常数据库存在三种用于持久操作以防止数据损坏的常见策略</p><blockquote><ol><li>数据库不关心故障，而是在数据文件损坏后从数据备份或快照中恢复。RDB 就是这种情况。</li><li>使用日志记录每个操作的操作行为，以在失败后通过日志恢复一致性。由于操作日志是按顺序追加写入的，因此不会出现无法恢复操作日志的情况。类似于 MySQL 的 redo log 和 undo log。</li><li>数据库不修改旧数据，而仅通过追加进行写入，因为数据本身就是日志，因此永远不会出现数据无法恢复的情况，CouchDB 是一个很好的例子。AOF 类似这种情况。</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005153226509.png" alt="image-20241005153226509"></p><blockquote><p><strong>RDB 持久化</strong>：</p><ul><li>Redis 生成某一时刻的数据快照，保存到磁盘的 RDB 文件中。可以手动触发生成，也可以通过配置让 Redis 在特定的时间间隔生成。</li><li>适合冷备份或者在不特别关注数据丢失的场景下使用，因为在快照之间的写操作数据不会保存。</li></ul><p><strong>AOF 持久化</strong>：</p><ul><li>Redis 将每个写命令以日志的形式顺序追加到 AOF 文件中，恢复时则从头开始重放日志文件的命令来还原数据。可以通过配置控制日志写入磁盘的频率，比如每秒一次、每次写入、由操作系统控制等。</li><li>适合对数据安全性要求高的场景，但文件大小可能较大。</li></ul><p><strong>混合持久化</strong>：</p><ul><li>这是 Redis 4.0 引入的一种持久化方式，它结合了 RDB 和 AOF 的优点。恢复时可以使用 RDB 快速加载大部分数据，AOF 文件补充最新的增量操作。</li><li>适用于既要快速恢复又希望减少数据丢失的场景。</li></ul></blockquote><h6 id="开启方式-案例"><a href="#开启方式-案例" class="headerlink" title="开启方式-案例"></a>开启方式-案例</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建配置目录</span><br>mkdir -p /usr/local/redis/conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建数据目录</span><br>mkdir -p /usr/local/redis/data<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建日志目录</span><br>mkdir -p /usr/local/redis/log<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /usr/local/redis/conf/redis.conf<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">放行 IP 访问限制</span><br>bind 0.0.0.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">后台启动</span><br>daemonize yes<br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志存储目录及日志文件名</span><br>logfile &quot;/usr/local/redis/log/redis.log&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RDB 数据文件名</span><br>dbfilename dump.rdb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RDB 数据文件和 AOF 数据文件的存储目录</span><br>dir /usr/local/redis/data<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置密码</span><br>requirepass 123456<br></code></pre></td></tr></table></figure><p>在 <code>redis.conf</code> 文件末尾加上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">900 秒内如果超过 1 个key改动，则发起快照保存</span><br>save 900 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">300 秒内如果超过 10 个 key 改动，则发起快照保存</span><br>save 300 10<br><span class="hljs-meta prompt_"># </span><span class="language-bash">60 秒内如果超过 1W 个 key 改动，则发起快照保存</span><br>save 60 10000<br></code></pre></td></tr></table></figure><blockquote><p>快照，顾名思义可以理解为拍照一样，把整个内存数据映射到硬盘中，保存一份到磁盘，因此恢复数据起来比较快，把数据映射回去即可，<strong>不像 AOF 一样，一条条的执行操作指令</strong>。</p><p>快照是<strong>默认</strong>的持久化方式。这种方式就是将内存中数据以快照的放入写入<strong>二进制文件</strong>中，默认的文件名为 <code>dump.rdb</code>，可以通过配置设置自动做快照持久化的方式。</p></blockquote><hr><p>aof</p><p>通过配置 <code>redis.conf</code> 进行启动，默认是关闭的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">默认 appendonly 为 no</span><br>appendonly yes<br>appendfilename &quot;appendonly.aof&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RDB 文件和 AOF 文件所在目录</span><br>dir /usr/local/redis/data<br></code></pre></td></tr></table></figure><h6 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h6><ol><li>独立部署，硬盘优化<ul><li>持久化过程是密集计算的过程，所以最好把 Redis 单独部署到一台服务器上。</li><li><strong>写入请求多的话，可以考虑性能更高的 SSD 磁盘。</strong></li></ul></li><li>缓存禁用持久化<ul><li>缓存丢失了也不要紧。</li></ul></li><li>主从模式，从持久化<ul><li><strong>从节点一般只提供读功能，把持久化的工作交给从节点，减轻主节点的压力。</strong></li><li><strong>AOF 可以考虑禁用，因为多个从节点我们只需要选取追新的那份备份就可以了。</strong></li></ul></li><li>优化 fork 处理<ul><li><strong>降低 AOF 的重写频率。</strong></li><li>重写期间如果已经阻塞的时候，那就不接收重写期间的数据了。</li></ul></li></ol><h4 id="redis-spring集成"><a href="#redis-spring集成" class="headerlink" title="redis spring集成"></a>redis spring集成</h4><h6 id="1-坐标"><a href="#1-坐标" class="headerlink" title="1.坐标"></a>1.坐标</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">121.4</span><span class="hljs-number">.146</span><span class="hljs-number">.25</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h6 id="3-配置序列化"><a href="#3-配置序列化" class="headerlink" title="3.配置序列化"></a>3.配置序列化</h6><p>在不指定序列化方式时，Spring 组件通常会使用<strong>Java 默认的序列化机制</strong>，即 <code>Serializable</code> 接口进行序列化。这种方式虽然可以工作，但效率较低，且生成的序列化结果较大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>    RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>    template.setConnectionFactory(connectionFactory);<br>    <br>    <span class="hljs-comment">// 设置键的序列化方式</span><br>    template.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>    <br>    <span class="hljs-comment">// 设置值的序列化方式</span><br>    template.setValueSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class));<br>    <br>    <span class="hljs-keyword">return</span> template;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <br>        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br><br>        <span class="hljs-comment">// 使用 Jackson2JsonRedisSerialize 替换默认序列化</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br><br>        <span class="hljs-comment">// 设置 key 和 value 的序列化规则</span><br>        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = &#123;RedisSpringbootApplication.class&#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisSpringbootApplicationTests</span> &#123;<br><br>    <span class="hljs-comment">// 注入模板对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedis</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(redisTemplate.getConnectionFactory().getConnection().ping());<br>        <span class="hljs-comment">// 获取 Redis 操作对象</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;key&quot;</span>);<br><br>        redisTemplate.opsForHash().put(<span class="hljs-string">&quot;hashKey&quot;</span>, <span class="hljs-string">&quot;field&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">hashValue</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForHash().get(<span class="hljs-string">&quot;hashKey&quot;</span>, <span class="hljs-string">&quot;field&quot;</span>);<br><br>        redisTemplate.opsForList().leftPush(<span class="hljs-string">&quot;listKey&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">listValue</span> <span class="hljs-operator">=</span> redisTemplate.opsForList().rightPop(<span class="hljs-string">&quot;listKey&quot;</span>);<br><br>        redisTemplate.opsForSet().add(<span class="hljs-string">&quot;setKey&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br><span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet().isMember(<span class="hljs-string">&quot;setKey&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br><br>        redisTemplate.opsForZSet().add(<span class="hljs-string">&quot;zsetKey&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-number">1.0</span>);<br>Set&lt;String&gt; zSetValues = redisTemplate.opsForZSet().range(<span class="hljs-string">&quot;zsetKey&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><br>        <br>        <br>        <br><br>    &#125;<br><br></code></pre></td></tr></table></figure><blockquote><h3 id="RedisTemplate-的工作原理"><a href="#RedisTemplate-的工作原理" class="headerlink" title="RedisTemplate 的工作原理"></a><code>RedisTemplate</code> 的工作原理</h3><p>当你使用 <code>RedisTemplate</code> 时，具体的操作大致可以分为以下几步：</p><ol><li><strong>获取 Redis 连接</strong>：通过 <code>RedisConnectionFactory</code> 获取 Redis 的连接。</li><li><strong>序列化键&#x2F;值</strong>：使用配置的序列化器将键和值序列化为 Redis 可以识别的格式（如字符串或二进制数据）。</li><li><strong>执行 Redis 命令</strong>：通过底层的 Redis 客户端库（如 <strong>Jedis</strong> 或 <strong>Lettuce</strong>）向 Redis 服务器发送命令。</li><li><strong>反序列化返回数据</strong>：Redis 返回的结果通过反序列化器转换回 Java 对象供应用使用。</li></ol></blockquote><blockquote><ul><li><pre><code class="hljs">RedisTemplate<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>   本质上依赖于底层的 Redis 客户端库，与 Redis 服务器进行通信。Spring Data Redis 支持多个 Redis 客户端，例如：<br><br>  - **Jedis**：一个常用的 Redis Java 客户端，适用于传统阻塞式操作。<br>  - **Lettuce**：一个支持异步和同步通信的非阻塞 Redis 客户端，默认用于 Spring Data Redis。<br><br>当我们使用 `RedisTemplate` 进行操作时，它会调用 Redis 客户端库的 API 来与 Redis 服务器通信。<br><br>###### <span class="hljs-number">5.</span>reids配合日期配置<br><br><span class="hljs-number">1.</span>redis配置<br><br></code></pre></td></tr></table></figure>@Configurationpublic class RedisConfig&lt;V&gt; &#123;</code></pre></li></ul></blockquote><pre><code class="hljs">@Autowiredprivate RedisProperties redisProperties;@Beanpublic LettuceConnectionFactory connectionFactory() &#123;    RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();    config.setHostName(redisProperties.getHost());    config.setPort(redisProperties.getPort());    return new LettuceConnectionFactory(config);&#125;@Beanpublic RedisTemplate&lt;String, V&gt; redisTemplate(RedisConnectionFactory factory) &#123;    RedisTemplate&lt;String, V&gt; template = new RedisTemplate&lt;&gt;();    template.setConnectionFactory(factory);    // 设置key的序列化方式    template.setKeySerializer(RedisSerializer.string());    // 设置value的序列化方式    template.setValueSerializer(RedisSerializer.json());    // 设置hash的key的序列化方式    template.setHashKeySerializer(RedisSerializer.string());    // 设置hash的value的序列化方式    template.setHashValueSerializer(RedisSerializer.json());    template.afterPropertiesSet();    return template;&#125;</code></pre><p>}</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-number">2.</span>类<br><br>```java<br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@EqualsAndHashCode(callSuper = false)</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-meta">@TableName(<span class="hljs-string">&quot;coupon&quot;</span>)</span><br><span class="hljs-meta">@ApiModel(value=<span class="hljs-string">&quot;Coupon对象&quot;</span>, description=<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coupon</span> <span class="hljs-title">implements</span> <span class="hljs-title">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">1L</span>;<br>    <span class="hljs-meta">@TableId(value = <span class="hljs-string">&quot;id&quot;</span>, type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;<br><br>    <span class="hljs-meta">@TableField(<span class="hljs-string">&quot;start_time&quot;</span>)</span><br>    <span class="hljs-meta">@JsonFormat(pattern = <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, timezone = <span class="hljs-string">&quot;GMT+8&quot;</span>)</span><br>    <span class="hljs-meta">@DateTimeFormat(pattern = <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> Date  startTime;<br><br>    <span class="hljs-meta">@TableField(<span class="hljs-string">&quot;end_time&quot;</span>)</span><br>    <span class="hljs-meta">@JsonFormat(pattern = <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, timezone = <span class="hljs-string">&quot;GMT+8&quot;</span>)</span><br>    <span class="hljs-meta">@DateTimeFormat(pattern = <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> Date endTime;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h6 id="1-缓存方式选择"><a href="#1-缓存方式选择" class="headerlink" title="1.缓存方式选择"></a>1.缓存方式选择</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007223535709.png" alt="image-20241007223535709"></p><p>字符串-需要序列化适合小数据-拿取需要取出所有字符串-大数据麻烦</p><p>哈希-拿去根据key拿去-不需要序列化-适合大数据</p><h6 id="2-数据类型支持缓存"><a href="#2-数据类型支持缓存" class="headerlink" title="2.数据类型支持缓存"></a>2.数据类型支持缓存</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7468e1fc2e0e15018ebbd9c9677284e7.png" alt="7468e1fc2e0e15018ebbd9c9677284e7"></p><h5 id="缓存异常解决"><a href="#缓存异常解决" class="headerlink" title="缓存异常解决"></a>缓存异常解决</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007224145594.png" alt="image-20241007224145594"></p><h6 id="1-缓存击穿"><a href="#1-缓存击穿" class="headerlink" title="1.缓存击穿"></a>1.缓存击穿</h6><p>缓存击穿是指缓存中没有但数据库中有的数据<strong>（一般是缓存时间到期）</strong>，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p><ol><li><p>设置热点数据永远不过期。</p></li><li><p>设置随机过期时间-不会一下子大家一下到期</p></li><li><p><strong>读mysql数据库-加互斥锁</strong></p><blockquote><p>理论上如果能根据 key 值加锁就更好了，就是线程 A 从数据库取 key1 的数据并不妨碍线程 B 取 key2 的数据， –优化方向</p><p><strong>—-要做好降级处理哦</strong></p></blockquote><p><strong>4.提前缓存预热-每天预热多少条数据-使用游标</strong></p></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/008i3skNly1gt27ltgn9zj60l60fvgng02.jpg" alt="img"></p><h6 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h6><blockquote><p>当查询缓存是无此 key 对应的值，后去数据库查询，数据库有值时存入缓存无值时返回无此值，但再一次查此 key 是还是一样的结果，但大量的访问此 key 是对数据库会造成更大的压力。</p></blockquote><p>缓存空值-第一次查mysql后无数据-设置较低有效期(防止对方进行攻击-不建议)</p><p><strong>布隆过滤器</strong></p><ul><li><p>当客户端进行查询时，先经过布隆过滤器，判断要查询的数据 key 是否在布隆数组当中，如果可能存在，则查询数据库，如果不可能存在，则返回空。</p></li><li><blockquote><p>布隆过滤器（Bloom Filter）是一种数据结构，用于快速判断一个元素是否属于一个集合中。</p><p>它使用多个Hash函数将一个元素映射成一个位阵列（Bit array）中的一个点，将Bit array理解为一个二进制数组，数组元素是0或1。</p><p>当一个元素加入集合时，通过N个散列函数将这个元素映射到一个Bit array中的N个点，把它们设置为1。</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007224925550.png" alt="image-20241007224925550"></p><blockquote><p>检索某个元素时再通过这N个散列函数对这个元素进行映射，根据映射找到具体位置的元素，如果这些位置有任何一个0，则该元素一定不存在，如果都是1很可能存在误判。</p><p>**哈希函数的基本特性：</p><p>同一个数使用同一个哈希函数计算哈希值，其哈希值总是一样的。</p><p>对不同的数用相同的哈希函数计算哈希值，其哈希值可能一样，这称为哈希冲突。</p><p>哈希函数通常是单向的不可逆的，即从哈希值不能逆向推导出原始输入。这使得哈希函数适用于加密和安全应用。</p><p>为什么存在哈希误判</p><p>主要原因是哈希冲突。布隆过滤器使用多个哈希函数将输入的元素映射到位数组中的多个位置，当多个不同的元素通过不同的哈希函数映射到相同的位数组位置时就发生了哈希冲突。</p><p>由于哈希函数的有限性，不同的元素可能会映射到相同的位置上，这种情况下即使元素不在布隆过滤器中可能产生误判，即布隆过滤器判断元素在集合中。</p><p><strong>如何降低误判率？</strong></p><p>增加Bit array空间，减少哈希冲突，优化散列函数，使用更多的散列函数。</p></blockquote><hr><p>使用</p><p>将要查询的元素通过N个散列函数提前全部映射到Bit array中，比如：查询服务信息，需要将全部服务的id提前映射到Bit array中，当去查询元素是否在数据库存在时从布隆过滤器查询即可，如果哈希函数返回0则表示肯定不存在。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007224956276.png" alt="image-20241007224956276"></p><blockquote><p>布隆过滤器的优点是：二进制数组占用空间少，插入和查询效率高效。</p><p>缺点是存在误判率，并且删除困难，因为同一个位置由于哈希冲突可能存在多个元素，删除某个元素可能删除了其它元素。</p><p>使用场景</p><p>1、海量数据去重，比如URL去重，搜索引擎爬虫抓取网页，使用布隆过滤器可以快速判定一个URL是否已经被爬取过，避免重复爬取。</p><p>2、垃圾邮件过滤：使用布隆过滤器可以用于快速判断一个邮件地址是否是垃圾邮件发送者，对于海量的邮件地址，布隆过滤器可以提供高效的判定。</p><p>3、安全领域：在网络安全中，布隆过滤器可以用于检查一个输入值是否在黑名单中，用于快速拦截一些潜在的恶意请求。</p><p>4、避免缓存穿透：通过布隆过滤器判断是否不存在，如果不存在则直接返回。</p></blockquote><p>实现</p><p>使用redit的bitmap位图结构实现。</p><p>使用redisson实现。</p><p>使用google的Guava库实现。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sas">void test1()<br> &#123;<br>     BloomFilter&lt;String&gt; bloomFilter = BloomFilter.<span class="hljs-keyword">create</span>(Funnels.stringFunnel(Charset.defaultCharset()), 1000, 0.01);<br><br>     // 添加元素到布隆过滤器<br>     bloomFilter.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;example1&quot;</span>);<br>     bloomFilter.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;example2&quot;</span>);<br>     bloomFilter.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;example3&quot;</span>);<br><br>     // 测试元素是否在布隆过滤器中<br>     System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(bloomFilter.mightContai<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;example1&quot;</span>)); // true<br>     System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(bloomFilter.mightContai<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;example4&quot;</span>)); // false<br> &#125;<br></code></pre></td></tr></table></figure><h6 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h6><p>缓存雪崩是缓存中大量key失效后当高并发到来时导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p><p>比如对某信息设置缓存过期时间为30分钟，在大量请求同时查询该类信息时，此时就会有大量的同类信息存在相同的过期时间，一旦失效将同时失效，造成雪崩问题。</p><p>   1.雪崩后关闭外网服务，对数据库 <strong>预热缓存</strong> 再开启外网服务。</p><ol><li><strong>将缓存的 key 的到期时间设置为不同个的时间，避免同一个时间段大规模的缓存失效。</strong></li><li>将缓存备份。</li><li><strong>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</strong></li><li><strong>设置热点数据永远不过期。</strong></li></ol><h6 id="4-缓存淘汰"><a href="#4-缓存淘汰" class="headerlink" title="4.缓存淘汰"></a>4.缓存淘汰</h6><p>Redis 的最大缓存、主键失效、淘汰机制等参数都是通过 <code>redis.conf</code> 配置文件来配置的。</p><p>通过设置最大缓存-还有淘汰机制-减少无效数据</p><h5 id="缓存不一致问题"><a href="#缓存不一致问题" class="headerlink" title="缓存不一致问题"></a>缓存不一致问题</h5><h6 id="1-缓存不一致问题"><a href="#1-缓存不一致问题" class="headerlink" title="1.缓存不一致问题"></a>1.缓存不一致问题</h6><p>缓存不一致问题是指当发生数据变更后该数据在数据库和缓存中是不一致的，此时查询缓存得到的并不是与数据库一致的数据。</p><p>写数据库和写缓存导致不一致称为<strong>双写不一致</strong>，比如：先更新数据库成功了，更新缓存时失败了，最终导致不一致。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007230658977.png" alt="image-20241007230658977"></p><p>CPU划分时间片</p><p>线程1 写数据库-写完 key 123</p><p>此时cpu划分时间片到线程2</p><p>线程2-写数据-写完-写redis写完 key 456</p><p>线程1继续执行-直接替换redis缓存 导致缓存不一致问题-key123</p><p>先缓存后数据 照样线程安全问题</p><p>数据库 key456</p><p>redis key123</p><h6 id="解决方案-1-分布式锁"><a href="#解决方案-1-分布式锁" class="headerlink" title="解决方案-1.分布式锁"></a>解决方案-1.分布式锁</h6><p>将缓存-和数据库操作 同时上锁</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007230740088.png" alt="image-20241007230740088"></p><p>线程1申请分布式锁，拿到锁。此时其它线程无法获取同一把锁。</p><p>线程1写数据库，写缓存，操作完成释放锁。</p><p>线程2申请分布锁成功，写数据库，写缓存。</p><p>对双写的操作每个线程顺序执行。</p><p>对操作异常问题仍需要解决：写数据库成功写缓存失败了，数据库需要回滚，此时就需要使用分布式事务组件。</p><p><strong>使用<strong><strong>分布式锁</strong></strong>解决双写一致性不仅性能低下，复杂度增加。</strong></p><h6 id="2-延迟双删"><a href="#2-延迟双删" class="headerlink" title="2.延迟双删"></a>2.延迟双删</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007230801582.png" alt="image-20241007230801582"></p><p><strong>主从复制还没完成-线程2就去读了-导致读了旧数据</strong>-只要不更新-后面的人都读旧数据-出错</p><h6 id="3-最终一致"><a href="#3-最终一致" class="headerlink" title="3.最终一致"></a>3.最终一致</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007230853382.png" alt="image-20241007230853382"></p><blockquote><p>延迟多长时间呢？</p><p>延迟主数据向从数据库同步的时间间隔，如果延迟时间设置不合理也会导致数据不一致。</p><p>—定时器删除缓存最好—</p><p>也许有人还能查询到旧数据-</p><p>只要过了删除时间</p><p>有人再去查-那么就能保证肯定拿到的新缓存数据</p></blockquote><h6 id="4-Canal-Mq方案"><a href="#4-Canal-Mq方案" class="headerlink" title="4.Canal Mq方案"></a>4.Canal Mq方案</h6><p>延迟双删的目的也是为了保证最终一致性，即允许缓存短暂不一致，最终保证一致性。</p><p>保证最终一致性的方案有很多，比如：通过MQ、Canal、定时任务都可以实现。</p><p>Canal是一个数据同步工具，读取MySQL的binlog日志拿到更新的数据，再通过MQ发送给异步同步程序，最终由异步同步程序写到redis。<strong>此方案适用于对数据实时性有一定要求的场景。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007231258473.png" alt="image-20241007231258473"></p><p>线程1写数据库</p><p><strong>canal读取binlog日志，将数据变化日志写入mq</strong></p><p>同步程序监听mq接收到数据变化的消息</p><p>同步程序解析消息内容写入redis，写入redis成功正常消费完成，消息从mq删除。</p><h6 id="5-定时器解决"><a href="#5-定时器解决" class="headerlink" title="5.定时器解决"></a>5.定时器解决</h6><p>专门启动一个数据同步任务定时读取数据同步到redis，此方式适用于对数据实时性要求不强更新不频繁的数据。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241007231347023.png" alt="image-20241007231347023"></p><p>从思路来看-定时器和Canal差不多 但是别人更节省cpu资源</p><h4 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h4><h6 id="1-缓存优化"><a href="#1-缓存优化" class="headerlink" title="1.缓存优化"></a>1.缓存优化</h6><p>最基础的使用-需要考虑缓存异常解决场景-还有缓存不一致情况</p><blockquote><p><a href="https://gitee.com/laomaodu/anli01">https://gitee.com/laomaodu/anli01</a> </p><p><a href="https://gitee.com/laomaodu/kaqi-pan">https://gitee.com/laomaodu/kaqi-pan</a></p><p><a href="https://gitee.com/yun-lan-arrives-home/jzo2o-customer">https://gitee.com/yun-lan-arrives-home/jzo2o-customer</a></p></blockquote><h6 id="2-延迟任务-消息队列"><a href="#2-延迟任务-消息队列" class="headerlink" title="2.延迟任务-消息队列"></a>2.延迟任务-消息队列</h6><blockquote><p>黑马头条中-延迟文字的发布-后续会自写项目-现在先空着</p></blockquote><h6 id="3-秒杀抢购"><a href="#3-秒杀抢购" class="headerlink" title="3.秒杀抢购"></a>3.秒杀抢购</h6><blockquote><p><a href="https://gitee.com/laomaodu/anli01">https://gitee.com/laomaodu/anli01</a>   非常经典的一个秒杀抢购</p></blockquote><h6 id="4-实时统计"><a href="#4-实时统计" class="headerlink" title="4.实时统计"></a>4.实时统计</h6><blockquote></blockquote><h6 id="5-限流处理"><a href="#5-限流处理" class="headerlink" title="5.限流处理"></a>5.限流处理</h6><blockquote></blockquote><h6 id="6-排行榜"><a href="#6-排行榜" class="headerlink" title="6.排行榜"></a>6.排行榜</h6><blockquote><p><a href="https://gitee.com/laomaodu/music-platform-demo">https://gitee.com/laomaodu/music-platform-demo</a></p></blockquote><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">redisTemplate.opsForZSet<span class="hljs-comment">()</span>.add<span class="hljs-comment">(HotArticleConstants.HOT_ARTICLE_REDIS_QUEUE,mess.getMuicid()</span>,score);<span class="hljs-comment">//分数</span><br><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//降序reverseRange 升序 range</span><br><br>       redisTemplate<span class="hljs-selector-class">.opsForZSet</span>()<span class="hljs-selector-class">.reverseRange</span>(HotArticleConstants.HOT_ARTICLE_REDIS_QUEUE, onlineMusic.getPage()*<span class="hljs-number">10</span>-<span class="hljs-number">10</span>, onlineMusic<span class="hljs-selector-class">.getPage</span>()*<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>拿出</p><h6 id="7-会话管理"><a href="#7-会话管理" class="headerlink" title="7.会话管理"></a>7.会话管理</h6><blockquote><p>session-id-&gt;对应数据-可防止服务器失效后数据丢失</p></blockquote><h4 id="Redis优化"><a href="#Redis优化" class="headerlink" title="Redis优化"></a>Redis优化</h4><p>空着-如果12月份无实习就继续学习</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xxl-job</title>
    <link href="/2024/10/05/Middleware/xxl-job/xxl-job/"/>
    <url>/2024/10/05/Middleware/xxl-job/xxl-job/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍xxl-job"><a href="#介绍xxl-job" class="headerlink" title="介绍xxl-job"></a>介绍xxl-job</h4><p>XXL-JOB 是一个开源的<strong>分布式任务调度平台</strong>，旨在提供开发快速、学习简单、轻量级并且易于扩展的解决方案。它已经广泛应用于多个公司的线上产品中，支持开箱即用的分布式任务管理。</p><p>XXL-JOB 的核心包括：</p><ul><li><strong>多种调度模式</strong>：支持固定速率、Cron表达式等调度方式，满足不同业务需求。</li></ul><p>**  任务监控与日志管理**：可以实时监控任务的执行进度，支持日志滚动查看，并提供故障报警功能。</p><p>   <strong>跨语言支持与易集成</strong>：提供RESTful API，支持与多种语言（如Python、Shell、PHP等）集成，便于执行器与调度中心的对</p><p><a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p><p>开源地址</p><h4 id="分布式体现"><a href="#分布式体现" class="headerlink" title="分布式体现"></a><strong>分布式体现</strong></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005141236070.png" alt="image-20241005141236070"></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/356a4b0bdf0713a54875c87bff3acbce.png" alt="img"></p><p>调度中心是个web服务，提供触发定时任务的执行-它依赖数据库-调度中心也支持集群-但是数据库必须是同一个</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>执行器可以理解为就是平时开发的服务，一个服务实例对应一个执行器实例</p><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>调度中心派发任务到对应执行器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/83f3128fcf47565be987b9ef3c4405de.png" alt="img"></p><h5 id="阻塞处理策略"><a href="#阻塞处理策略" class="headerlink" title="阻塞处理策略"></a><strong>阻塞处理策略</strong></h5><p>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；</p><ul><li><p>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO(First Input First Output)队列并以串行方式运行；</p></li><li><p>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</p></li><li><p>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</p></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011131037495.png" alt="image-20241011131037495"></p><h5 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a><strong>路由策略</strong></h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011131058761.png" alt="image-20241011131058761"></p><ul><li><p>FIRST（第一个）：固定选择第一个机器；</p></li><li><p>LAST（最后一个）：固定选择最后一个机器；</p></li><li><p><strong>ROUND（轮询）</strong></p></li><li><p>RANDOM（随机）：随机选择在线的机器；</p></li><li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</p></li><li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</p></li><li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</p></li><li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</p></li><li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</p></li><li><p><strong>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</strong></p></li></ul><h5 id="路由分片广播"><a href="#路由分片广播" class="headerlink" title="路由分片广播"></a>路由分片广播</h5><h6 id="1-分片逻辑"><a href="#1-分片逻辑" class="headerlink" title="1.分片逻辑"></a>1.分片逻辑</h6><p>执行器集群部署时，任务路由策略选择”分片广播”情况下，<strong>一次任务调度将会广播触发对应集群中所有执行器执行一次任务</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011131156522.png" alt="image-20241011131156522"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011131218435.png" alt="image-20241011131218435"></p><h6 id="2-分片广播-案例"><a href="#2-分片广播-案例" class="headerlink" title="2.分片广播-案例"></a>2.分片广播-案例</h6><p>需求：让两个节点同时执行10000个任务，每个节点分别执行5000个任务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241011131249840.png" alt="image-20241011131249840"></p><p>③：分片广播代码</p><p>   分片参数</p><p>​     <strong>index：当前分片序号(从0开始)，执行器集群列表中当前执行器的序号；</strong></p><p>​     <strong>total：总分片数，执行器集群的总机器数量；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloJob</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String port;<br><br><br>    <span class="hljs-meta">@XxlJob(&quot;demoJobHandler&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helloJob</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;简单任务执行了。。。。&quot;</span>+port);<br><br>    &#125;<br><br>    <span class="hljs-meta">@XxlJob(&quot;shardingJobHandler&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shardingJobHandler</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//分片的参数</span><br>        <span class="hljs-comment">//分片序号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">shardIndex</span> <span class="hljs-operator">=</span> XxlJobHelper.getShardIndex();<br>        <span class="hljs-comment">//总分片数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">shardTotal</span> <span class="hljs-operator">=</span> XxlJobHelper.getShardTotal();<br><br>        <span class="hljs-comment">//业务逻辑</span><br>        List&lt;Integer&gt; list = getList();<br>        <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>            <span class="hljs-keyword">if</span>(integer % shardTotal == shardIndex)&#123;<br>                System.out.println(<span class="hljs-string">&quot;当前第&quot;</span>+shardIndex+<span class="hljs-string">&quot;分片执行了，任务项为：&quot;</span>+integer);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getList</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="简单认识"><a href="#简单认识" class="headerlink" title="简单认识"></a>简单认识</h4><p>搭建调度中心</p><p><a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4a97d7ab3554f1ed4eafa64761fadbdc.png" alt="4a97d7ab3554f1ed4eafa64761fadbdc"></p><p>运行sql脚本-修改admin数据库配置信息</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005142704913.png" alt="image-20241005142704913"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/18410115f78e440b99150dc924353d54.png" alt="18410115f78e440b99150dc924353d54"></p><p>新增执行器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005143347178.png" alt="image-20241005143347178"></p><p>新增任务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005143706161.png" alt="image-20241005143706161"></p><p><strong>每隔1s，执行一次<code>抢卷</code>这个执行器中的<code>发卷</code>任务</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005144151432.png" alt="image-20241005144151432"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 依赖">&lt;dependency&gt;<br>         &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;<br>         &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;<br>         &lt;version&gt;2.4.0&lt;/version&gt;<br>     &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxlJobConfiguration</span>  &#123;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span>  XxlJobSpringExecutor  <span class="hljs-title function_">xxlJobSpringExecutor</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">XxlJobSpringExecutor</span> <span class="hljs-variable">xxlJobSpringExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XxlJobSpringExecutor</span>();<br>        <span class="hljs-comment">//设置调用中心的连接地址</span><br>        xxlJobSpringExecutor.setAdminAddresses(<span class="hljs-string">&quot;http://localhost:8080/xxl-job-admin&quot;</span>);<br>        <span class="hljs-comment">//设置执行器的名称</span><br>        xxlJobSpringExecutor.setAppname(<span class="hljs-string">&quot;fajuan&quot;</span>);<br>        <span class="hljs-comment">//设置一个端口，后面会讲作用</span><br>        xxlJobSpringExecutor.setPort(<span class="hljs-number">9999</span>);<br>        <span class="hljs-comment">//这个token是保证访问安全的，默认是这个，当然可以自定义，</span><br>        <span class="hljs-comment">// 但需要保证调度中心配置的xxl.job.accessToken属性跟这个token是一样的</span><br>        xxlJobSpringExecutor.setAccessToken(<span class="hljs-string">&quot;default_token&quot;</span>);<br>        <span class="hljs-comment">//任务执行日志存放的目录</span><br>        xxlJobSpringExecutor.setLogPath(<span class="hljs-string">&quot;./&quot;</span>);<br>        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">issueJob</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(issueJob.class);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建一个与 issueJob 类关联的日志记录器。</span><br><span class="hljs-comment">日志记录器用于输出日志信息，以帮助开发者在运行时了解程序的执行状态或排查问题。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@XxlJob(&quot;TestJob&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJob</span><span class="hljs-params">()</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;TestJob任务执行了。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>启动任务-更改spirng默认端口号</p><p>流程</p><p>spring启动-&gt;注册到调度中心</p><p>调度中心任务启动-&gt;由调度中心选择调度器进行调度-&gt;找到对应bean执行</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1ab671f60dcad496739f8e0ff8594905.png" alt="1ab671f60dcad496739f8e0ff8594905"></p><h4 id="xxl-job代码框架解读"><a href="#xxl-job代码框架解读" class="headerlink" title="xxl-job代码框架解读"></a>xxl-job代码框架解读</h4>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Springcache</title>
    <link href="/2024/10/05/Middleware/redis/SpringCache/springCache/"/>
    <url>/2024/10/05/Middleware/redis/SpringCache/springCache/</url>
    
    <content type="html"><![CDATA[<h1 id="Springcache"><a href="#Springcache" class="headerlink" title="Springcache"></a>Springcache</h1><p>不指定序列化方式时，Spring 组件通常会使用<strong>Java 默认的序列化机制</strong>，即 <code>Serializable</code> 接口进行序列化。这种方式虽然可以工作，但效率较低，且生成的序列化结果较大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RedisCacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>    <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>          .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class)));<br>    <br>    <span class="hljs-keyword">return</span> RedisCacheManager.builder(connectionFactory).cacheDefaults(config).build();<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图</title>
    <link href="/2024/10/04/data%20structure/%E5%9B%BE/"/>
    <url>/2024/10/04/data%20structure/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h4 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/19214be3c45d09940407b8c6322f29e1.png" alt="19214be3c45d09940407b8c6322f29e1"></p><p>a b c d e f组成顶点集<br>边集-链接顶点的边组成</p><p>图的规则-图的每个边必须有顶点</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b7a8db0b939dd4da7949904e9effd2ab.png" alt="b7a8db0b939dd4da7949904e9effd2ab" style="zoom: 50%;" /><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/540e70ba6ea8f4383bae1be2ab0253d1.png" alt="540e70ba6ea8f4383bae1be2ab0253d1"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aea691c9c97d85a4569c92a3e01d3caa.png" alt="aea691c9c97d85a4569c92a3e01d3caa"></p><p>图-的边集可以是空</p><h4 id="图的逻辑结果应用"><a href="#图的逻辑结果应用" class="headerlink" title="图的逻辑结果应用"></a>图的逻辑结果应用</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e768e87564a1f0ffaf46241def8f8d16.png" alt="e768e87564a1f0ffaf46241def8f8d16"></p><h4 id="图的性质"><a href="#图的性质" class="headerlink" title="图的性质"></a>图的性质</h4><h5 id="无向图和有向图"><a href="#无向图和有向图" class="headerlink" title="无向图和有向图"></a>无向图和有向图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/558e406be0fb79e8913871d97c993196.png" alt="558e406be0fb79e8913871d97c993196"></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/620e418d6d60ef2a8ebcd7e928bb085a.png" alt="620e418d6d60ef2a8ebcd7e928bb085a" style="zoom:50%;" /></strong></p><p>有向图</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ff73d6e358747263936168f878ca4d8.png" alt="0ff73d6e358747263936168f878ca4d8"></p><p>尾 -&gt;没有箭头<br>头-&gt;有箭头</p><p>A-&gt;c  A弧尾  C弧头</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/af418af68cb716958a4790c6c147e495.png" alt="af418af68cb716958a4790c6c147e495" style="zoom:50%;" /><h5 id="简单图多重图"><a href="#简单图多重图" class="headerlink" title="简单图多重图"></a>简单图多重图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4c63b0b865be3241750e2c81432d88ce.png" alt="4c63b0b865be3241750e2c81432d88ce"></p><blockquote><p><strong>无重边</strong>：图中任意两个顶点之间最多只有一条边，即不存在多条边连接同一对顶点。例如 a-&gt;b不能再出现一条a-&gt;b</p><p><strong>无自环</strong>：图中不存在连接自身的边，即任何顶点不能有与自身相连的边。</p><p><strong>无方向</strong>（对于无向图）：边没有方向，即边的连接关系是对称的；有向图则没有此要求。</p></blockquote><blockquote><p><strong>检查边的数量</strong>：查看是否有重复的边。如果有重边，则不是简单图。</p><p><strong>检查自环</strong>：检查每个顶点是否有连接自身的边。如果有自环，则不是简单图。</p><p><strong>确认边的方向</strong>（对于无向图）：确保所有边都是无向的，且连接的顶点对是唯一的。</p></blockquote><p>只探讨简单图</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3aa2a0d6462a243daa747c659b6d0288.png" alt="3aa2a0d6462a243daa747c659b6d0288" style="zoom:33%;" /><p>多重 不许自己加自己好友-不许重复加好友</p><h5 id="顶点的度-入度-出度"><a href="#顶点的度-入度-出度" class="headerlink" title="顶点的度 入度 出度"></a>顶点的度 入度 出度</h5><p>弧尾-hu头</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/90ec4308e2c4d454e66104654a2112e9.png" alt="90ec4308e2c4d454e66104654a2112e9"></p><p>有向图计算 顶点度的计算</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb3c96e46ff13c39547c95fd3b39e191.png" alt="eb3c96e46ff13c39547c95fd3b39e191"></p><h5 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述 ***"></a>顶点-顶点的关系描述 ***</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bc517c509e931b20b768753113386775.png" alt="bc517c509e931b20b768753113386775"></p><hr><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/419915ab238d666e8193aa36ebe5a5bc.png" alt="419915ab238d666e8193aa36ebe5a5bc"></p><p>不是简单路径情况-a b a b d  ab都重复出现了</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55a99d194510bcdc954d45b3e11e0e4e.png" alt="55a99d194510bcdc954d45b3e11e0e4e"></p><p>例如 无向图 F A-无穷   A-B 就是最短路径</p><hr><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241004150018957.png" alt="image-20241004150018957"></p><h5 id="连通图-强连通图"><a href="#连通图-强连通图" class="headerlink" title="连通图 强连通图"></a>连通图 强连通图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/75c56e5e5386e8aaa102ff6c307e59bb.png" alt="75c56e5e5386e8aaa102ff6c307e59bb"></p><h6 id="考点"><a href="#考点" class="headerlink" title="考点**"></a>考点**</h6><p>连通图考点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/687bc9622ce00d325b200fa7b814477b.png" alt="687bc9622ce00d325b200fa7b814477b"></p><p>n-1性质</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241004150427522.png" alt="image-20241004150427499" style="zoom:33%;" /><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c8afcc69e98643f7293b908edadaaabe.svg" alt="img"></p><p>感叹号表示阶乘</p><p>5!&#x3D;5×4×3×2×1&#x3D;120</p><p>4&#x3D;24</p><p>4</p><p>6边</p><h5 id="图的局部-子图"><a href="#图的局部-子图" class="headerlink" title="图的局部-子图"></a>图的局部-子图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/09e176c4d7932855ed4af7cd85633c5a_720.png" alt="09e176c4d7932855ed4af7cd85633c5a_720"></p><h5 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4d9bea812dcc5375ceb7a1c0882cd4d5_720.png" alt="4d9bea812dcc5375ceb7a1c0882cd4d5_720"></p><p>现实意义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bec91adb0e0d50cb9dc3367607d96ed8_720.png" alt="bec91adb0e0d50cb9dc3367607d96ed8_720"></p><h5 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9f7867cd39629f7782ac64d3afa1aac5_720.png" alt="9f7867cd39629f7782ac64d3afa1aac5_720"></p><h5 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2cf42947974209c5299c61c17a699a94_720.png" alt="2cf42947974209c5299c61c17a699a94_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cd99171e5e41b9ffd74cc5d983d8b138_720.png" alt="cd99171e5e41b9ffd74cc5d983d8b138_720"></p><p><strong>最小的边 生成树–n-1条边</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0acaaa3621a430673b98ff2fe9f798c2_720.png" alt="0acaaa3621a430673b98ff2fe9f798c2_720"></p><h4 id="边的权-带权-网"><a href="#边的权-带权-网" class="headerlink" title="边的权 带权&#x2F;网"></a>边的权 带权&#x2F;网</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0fd0dcf41f2f9205785bb41b28b44da3_720.png" alt="0fd0dcf41f2f9205785bb41b28b44da3_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8a825a3ab967ed9da32337e57de0c1f4.png" alt="8a825a3ab967ed9da32337e57de0c1f4"></p><h5 id="几种特殊的图"><a href="#几种特殊的图" class="headerlink" title="几种特殊的图"></a>几种特殊的图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/25ca3d3231825f83e283f83b1c4042fe_720.png" alt="25ca3d3231825f83e283f83b1c4042fe_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a8bc1688c3bbc91568a1f2634ad6a8d6_720.png" alt="a8bc1688c3bbc91568a1f2634ad6a8d6_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/63bee5979d586f937dd795e3ae58b167_720.png" alt="63bee5979d586f937dd795e3ae58b167_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c95914dfd3d386038086b80df2641f31.png" alt="c95914dfd3d386038086b80df2641f31"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9ba66fbe9e662b2b03dd33f352e5822c_720.png" alt="9ba66fbe9e662b2b03dd33f352e5822c_720"></p><h4 id="邻接矩阵法-图"><a href="#邻接矩阵法-图" class="headerlink" title="邻接矩阵法-图"></a>邻接矩阵法-图</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008130534545.png" alt="image-20241008130534545"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008130557841.png" alt="image-20241008130557841"></p><h6 id="度的计算"><a href="#度的计算" class="headerlink" title="度的计算"></a>度的计算</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008130739063.png" alt="image-20241008130739063"></p><h6 id="带权图"><a href="#带权图" class="headerlink" title="带权图"></a>带权图</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/492a4e07aa792bd18ca441e915a34b26.png" alt="492a4e07aa792bd18ca441e915a34b26"></p><h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008131141052.png" alt="image-20241008131141052"></p><h6 id="性质-路径计算"><a href="#性质-路径计算" class="headerlink" title="性质-路径计算"></a>性质-路径计算</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008131446829.png" alt="image-20241008131446829"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008131659580.png" alt="image-20241008131659580"></p><blockquote><p>人为计算出-由A-&gt;D有多少条路径-比如上图A-&gt;D 只有一条</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8ea3157b9033bfad354591ef2c003454.png" alt="8ea3157b9033bfad354591ef2c003454"></p><h5 id="考点回顾"><a href="#考点回顾" class="headerlink" title="考点回顾"></a>考点回顾</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008132015487.png" alt="image-20241008132015487"></p><h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008132112170.png" alt="image-20241008132112170"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008132901580.png" alt="image-20241008132901580"></p><h6 id="1-出入度计算"><a href="#1-出入度计算" class="headerlink" title="1.出入度计算"></a>1.出入度计算</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008132954668.png" alt="image-20241008132954668"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241008133013848.png" alt="image-20241008133013848"></p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5ba297047dc0196f2c17a91a76f27f3c.jpeg" alt="5ba297047dc0196f2c17a91a76f27f3c"></p><h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><h5 id="图的定义-1"><a href="#图的定义-1" class="headerlink" title="图的定义"></a>图的定义</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48946152b6e188cbfa362aae9d0bfa25_720.jpg" alt="48946152b6e188cbfa362aae9d0bfa25_720"></p><h5 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p>先序-根左右</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/50c4ed992c7a42aba28bff244bf20b6c.jpg" alt="50c4ed992c7a42aba28bff244bf20b6c"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/91df4bee03058056f399933a2830dd51_720.jpg" alt="91df4bee03058056f399933a2830dd51_720"></p><h6 id="计算机实现dfs"><a href="#计算机实现dfs" class="headerlink" title="计算机实现dfs"></a>计算机实现dfs</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/25deb88135e2d9d2f75ec2dbd13ccb97_720.jpg" alt="25deb88135e2d9d2f75ec2dbd13ccb97_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c514ae80e63fe3ccd87b7a49b90f52c0.jpg" alt="c514ae80e63fe3ccd87b7a49b90f52c0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/78a10d17f7e55d0c34ac6b93898f3b05.jpg" alt="78a10d17f7e55d0c34ac6b93898f3b05"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f8a1c398f84e1c3e86efed22335ceefe.jpeg" alt="f8a1c398f84e1c3e86efed22335ceefe"></p><h4 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h4><p>层次遍历</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/706b0675405bab460a27aec283f998e1.jpg" alt="706b0675405bab460a27aec283f998e1"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/695b746b8cfdfad90a44f5f8e816fa24_720.jpg" alt="695b746b8cfdfad90a44f5f8e816fa24_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8742f6be528b4af8879b06cf4f4a2023.jpg" alt="8742f6be528b4af8879b06cf4f4a2023"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eba6252310c221881e4a9fb4ef474004.jpg" alt="eba6252310c221881e4a9fb4ef474004"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/60ba35de0c3e5076460bc82ce1c301c9.jpg" alt="60ba35de0c3e5076460bc82ce1c301c9"></p><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bebc8d6f828144df1f1a4e3c9d171f54.png" alt="bebc8d6f828144df1f1a4e3c9d171f54"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c1f20dd21a95115e6d50a3b0ce185ffe.png" alt="c1f20dd21a95115e6d50a3b0ce185ffe"></p><h5 id="普利姆算法"><a href="#普利姆算法" class="headerlink" title="普利姆算法"></a>普利姆算法</h5><p>最小生成树-考研阶段补考-我专本贯通不可能考<br>了解即可</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3c3a869a1d212c34bccde79412b56aec.png" alt="3c3a869a1d212c34bccde79412b56aec"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/793da0b44b569b6b9ef74d280943dc4e.png" alt="793da0b44b569b6b9ef74d280943dc4e"></p><h5 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/518525f92ebc07371fa6bb1c91918a35.png" alt="518525f92ebc07371fa6bb1c91918a35"></p><h5 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e0de7d8305249f953c9c2cf42a803b45.png" alt="e0de7d8305249f953c9c2cf42a803b45"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ef2ebdd1464378a93e8a18d5482d92d4.png" alt="ef2ebdd1464378a93e8a18d5482d92d4"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>登录令牌探究(cookie)</title>
    <link href="/2024/10/04/skill/Jwtcookieseiion/"/>
    <url>/2024/10/04/skill/Jwtcookieseiion/</url>
    
    <content type="html"><![CDATA[<h1 id="登录令牌探究-cookie"><a href="#登录令牌探究-cookie" class="headerlink" title="登录令牌探究(cookie)"></a>登录令牌探究(cookie)</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2db9fbc3e04de8bcf5bbd95f05261d8c.png" alt="2db9fbc3e04de8bcf5bbd95f05261d8c"></p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p><strong>定义</strong>：Session 是服务器端用于保存用户会话状态的数据结构。在用户登录时，服务器为其创建一个 Session，并生成一个唯一的 Session ID 来标识该会话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>            session.setAttribute(<span class="hljs-string">&quot;session_account&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>服务器<br></code></pre></td></tr></table></figure><p>客户端拿到的是一段令牌-后续传递到服务端-服务端会解密-</p><p><strong>存储位置</strong>：<strong>服务器端</strong>。服务器保存每个用户的 Session 数据，客户端通过 <strong>Session ID</strong> 与服务器通信。</p><p><strong>特点</strong>：</p><ul><li><strong>有状态</strong>：服务器必须存储 Session 数据，因此这种方式需要服务器管理用户的会话信息。</li><li><strong>Session ID 传递</strong>：<strong>服务器在用户登录时生成 Session ID 并发送给客户端，客户端通常通过 Cookie 来存储 Session ID，并在每次请求时自动发送给服务器。</strong></li><li><strong>安全性</strong>：由于 Session ID 存储在 Cookie 中，结合 Cookie 的安全设置（如 <code>HttpOnly</code>、<code>Secure</code>）可以提升安全性，但 Session 本身依赖服务器存储和管理。</li><li><strong>应用场景</strong>：传统 Web 应用中会话管理最常用的方式，尤其适合需要维护状态的应用。</li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><strong>定义</strong>：Cookie 是存储在客户端的小型数据文件，通常由服务器生成，用于在客户端和服务器之间传递信息，最常用于保存会话信息、用户偏好等。</p><p><strong>存储位置</strong>：客户端（浏览器）中，客户端每次发起请求时会自动将与请求域相关的 Cookie 发送给服务器。</p><p><strong>会话管理</strong>：Cookie 可以存储用户的 Session ID 等信息，用于维持用户的会话状态。</p><p><strong>大小限制</strong>：单个 Cookie 的大小通常限制为 4KB。</p><p><strong>安全性</strong>：Cookie 可以设置 <code>HttpOnly</code>（防止客户端 JavaScript 访问）、<code>Secure</code>（仅通过 HTTPS 传输）等安全属性。</p><p><strong>自动发送</strong>：浏览器会在每次请求时自动携带 Cookie，无需客户端手动干预。</p><p><strong>应用场景</strong>：主要用于会话管理和状态维护，常用于 Web 应用的用户登录状态保持。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">if</span> (Objects.<span class="hljs-built_in">nonNull</span>(r.<span class="hljs-built_in">getData</span>())) &#123;<br>         Cookie cookie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>, (<span class="hljs-type">String</span>) r.<span class="hljs-built_in">getData</span>());<br>         resp.<span class="hljs-built_in">addCookie</span>(cookie);<br>     &#125;<br></code></pre></td></tr></table></figure><h4 id="session再探究"><a href="#session再探究" class="headerlink" title="session再探究"></a>session再探究</h4><p><strong>工作流程</strong></p><p>当用户登录应用时，服务器为该用户创建一个 Session 并生成一个唯一的 <strong>Session ID</strong>。</p><p><strong>Session ID</strong> 通常是一个随机生成的字符串，用于唯一标识该用户的会话。</p><p>服务器将 <strong>Session ID</strong> 和会话数据（如用户信息、权限等）存储在服务器的内存或数据库中。</p><p>服务器通过 HTTP 响应将 <strong>Session ID</strong> 发送给客户端，客户端通常会将这个 <strong>Session ID</strong> 保存在 <strong>Cookie</strong> 中。</p><p>在随后的每个请求中，客户端会将 <strong>Session ID</strong> 通过 Cookie 自动发送给服务器。</p><p>服务器接收到请求时，通过查询存储的 Session ID 来获取对应的会话数据，从而确定用户的身份。</p><p><strong>session数据查找</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241004234535358.png" alt="image-20241004234535358"></p><p><strong>接收请求</strong>：客户端通过 Cookie 发送 <strong>Session ID</strong> 给服务器。</p><p><strong>查询服务器存储</strong>：服务器在内部的 Session 存储中查找该 <strong>Session ID</strong> 是否存在。</p><p><strong>获取会话数据</strong>：如果找到匹配的 Session ID，服务器会返回对应的会话数据（如用户身份、权限等）。</p><p><strong>处理请求</strong>：服务器根据会话数据执行相应的操作。</p><p>会话劫持问题</p><p><strong>如果另一个人获得了有效的 Session ID</strong>，他确实可以伪装成该用户登录到系统。因为 Session ID 本质上是唯一标识用户会话的凭证，获得 Session ID 的人可以在没有输入用户名和密码的情况下发送请求，服务器会认为他们是合法的用户。这种攻击通常被称为 <strong>Session Hijacking（会话劫持）</strong>。</p><p>当服务器重启后session就失效-可以考虑redis实现</p><blockquote><p>IDEA 关闭服务器后，Session 会失效。但你可以通过使用外部存储（如 Redis、数据库）或配置服务器的持久化机制，来保留 Session 数据</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>knife4i</title>
    <link href="/2024/10/04/Middleware/knife4i/knife4i/"/>
    <url>/2024/10/04/Middleware/knife4i/knife4i/</url>
    
    <content type="html"><![CDATA[<h1 id="knife4i"><a href="#knife4i" class="headerlink" title="knife4i"></a>knife4i</h1><h4 id="1-依赖导入-认识knife4i"><a href="#1-依赖导入-认识knife4i" class="headerlink" title="1.依赖导入 认识knife4i"></a>1.依赖导入 认识knife4i</h4><blockquote><p>knife4i 是一个针对 Spring Boot 和 Spring Cloud 的增强型文档生成工具，主要用于生成和管理 RESTful API 文档。它是对 Swagger 的增强版，提供了更多功能和更好的用户体验。下面详细介绍 knife4i 的主要功能和如何在 Spring Boot 项目中使用它。</p></blockquote><blockquote><p>主要功能<br>API 文档生成：自动生成 RESTful API 文档。<br>UI 增强：提供更加友好的 UI 界面，方便查看和调试 API。<br>接口测试：直接在浏览器中测试接口。<br>代码生成：支持多种语言的客户端 SDK 代码生成。<br>接口管理：方便管理和维护 API 文档。</p></blockquote><p>官方配置文档</p><p><strong><a href="https://doc.xiaominfo.com/docs/quick-start">https://doc.xiaominfo.com/docs/quick-start</a></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml">parent&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.13.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-配置启动类"><a href="#2-配置启动类" class="headerlink" title="2.配置启动类"></a>2.配置启动类</h4><p>swagg</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><br><span class="hljs-variable">@EnableOpenApi</span>   <span class="hljs-comment">// 开启Swagger自定义接口文档</span><br><span class="hljs-variable">@Configuration</span>   <span class="hljs-comment">// 相当于Spring配置中的&lt;beans&gt;</span><br>public class SwaggerConfig &#123;<br>    <span class="hljs-comment">// 读取yaml中的配置</span><br>    <span class="hljs-variable">@Value</span>(<span class="hljs-string">&quot;$&#123;swagger.enable&#125;&quot;</span>)<br>    private Boolean enable;<br><br>    <span class="hljs-variable">@Bean</span>   <span class="hljs-comment">// 相当于Spring 配置中的&lt;bean&gt;</span><br>    public Docket <span class="hljs-built_in">createRestApi</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Docket</span>(DocumentationType.OAS_30)<br>                <span class="hljs-comment">// 配置swagger是否生效</span><br>                <span class="hljs-selector-class">.enable</span>(enable)<br>                <span class="hljs-selector-class">.apiInfo</span>(<span class="hljs-built_in">apiInfo</span>())<br>                <span class="hljs-selector-class">.select</span>()<br>                <span class="hljs-selector-class">.apis</span>(RequestHandlerSelectors.<span class="hljs-built_in">withMethodAnnotation</span>(ApiOperation.class))<br>                <span class="hljs-selector-class">.apis</span>(RequestHandlerSelectors.<span class="hljs-built_in">basePackage</span>(<span class="hljs-string">&quot;com.anli1.controller&quot;</span>)) <span class="hljs-comment">// 替换为你的controller包路径</span><br>                <span class="hljs-selector-class">.paths</span>(PathSelectors.<span class="hljs-built_in">any</span>())<br>                <span class="hljs-selector-class">.build</span>();<br>    &#125;<br>    <span class="hljs-comment">// API基础信息定义（就是更新Swagger默认页面上的信息）</span><br>    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">ApiInfo</span> <span class="hljs-selector-tag">apiInfo</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ApiInfoBuilder</span>()<br>                <span class="hljs-selector-class">.title</span>(<span class="hljs-string">&quot;Swagger3接口文档测试&quot;</span>)<br>                <span class="hljs-selector-class">.description</span>(<span class="hljs-string">&quot;这里是文档描述&quot;</span>)<br>                <span class="hljs-selector-class">.contact</span>(new <span class="hljs-built_in">Contact</span>(<span class="hljs-string">&quot;小盛&quot;</span>, <span class="hljs-string">&quot;网址&quot;</span>, <span class="hljs-string">&quot;邮箱&quot;</span>))<br>                <span class="hljs-selector-class">.version</span>(<span class="hljs-string">&quot;v1.0&quot;</span>)<br>                <span class="hljs-selector-class">.build</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Knife4j</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2WebMvc</span> <span class="hljs-comment">// 貌似被弃用，可以替换为@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife4jConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;swagger.enable&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> enable;<br><br>    <span class="hljs-meta">@Bean(value = <span class="hljs-string">&quot;defaultApi2&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> Docket defaultApi2() &#123;<br>        Docket docket=new Docket(DocumentationType.SWAGGER_2)<br>                .enable(enable)<br>                .apiInfo(<br>                        new ApiInfoBuilder()<br>                                <span class="hljs-comment">//.title(&quot;swagger-bootstrap-ui-demo RESTful APIs&quot;)</span><br>                                .description(<span class="hljs-string">&quot;# swagger-bootstrap-ui-demo RESTful APIs&quot;</span>)<br>                                .termsOfServiceUrl(<span class="hljs-string">&quot;http://www.xx.com/&quot;</span>)<br>                                .contact(new Contact(<span class="hljs-string">&quot;小盛&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;504040410@qq.com&quot;</span>))<br>                                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                                .build()<br>                )<br>                <span class="hljs-comment">//分组名称</span><br>                .groupName(<span class="hljs-string">&quot;2.X版本&quot;</span>)<br>                .select()<br>                <span class="hljs-comment">//这里指定你自己的Controller扫描包路径</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.anli1.controller&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></p><p> 访问文档地址</p><h4 id="3-注解认识"><a href="#3-注解认识" class="headerlink" title="3.注解认识"></a>3.注解认识</h4><h6 id="api"><a href="#api" class="headerlink" title="@api"></a>@api</h6><p>用于标记接口类或接口类的方法，描述接口的作用。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Api</span>(value = <span class="hljs-string">&quot;用户管理&quot;</span>, description = <span class="hljs-string">&quot;用户相关的API&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    // ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a>@ApiOperation</h6><p>作用：用于标记接口类的方法，描述具体操作的作用。<br>示例：</p><pre><code class="hljs"> @ApiOperation(value = &quot;获取用户列表&quot;, notes = &quot;返回所有用户的列表&quot;) @GetMapping(&quot;/users&quot;) public List&lt;User&gt; getUsers() &#123;     // ... &#125;</code></pre><h6 id="ApiModel"><a href="#ApiModel" class="headerlink" title="@ApiModel"></a>@ApiModel</h6><p>作用：用于描述模型对象，通常用于实体类</p><pre><code class="hljs"> @ApiModel(description = &quot;用户信息&quot;) public class User &#123;     @ApiModelProperty(value = &quot;用户ID&quot;)     private Long id;     @ApiModelProperty(value = &quot;用户名&quot;)     private String name;     // 其他字段和方法 &#125;</code></pre><h6 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="@ApiModelProperty"></a>@ApiModelProperty</h6><p>作用：用于描述模型对象中的属性。</p><pre><code class="hljs"> @ApiModelProperty(value = &quot;用户ID&quot;, required = true) private Long id;</code></pre><h6 id="ApiParam"><a href="#ApiParam" class="headerlink" title="@ApiParam"></a>@ApiParam</h6><p>作用：用于描述参数。</p><pre><code class="hljs"> @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User getUser(@ApiParam(value = &quot;用户ID&quot;, required = true) @PathVariable Long id) &#123;     // ... &#125;</code></pre><h6 id="ApiResponses"><a href="#ApiResponses" class="headerlink" title="@ApiResponses"></a>@ApiResponses</h6><p>作用：用于描述方法的响应结果。<br>示例：</p><pre><code class="hljs"> @ApiOperation(value = &quot;获取用户列表&quot;) @ApiResponses(&#123;     @ApiResponse(code = 200, message = &quot;成功&quot;),     @ApiResponse(code = 404, message = &quot;未找到&quot;) &#125;) @GetMapping(&quot;/users&quot;) public List&lt;User&gt; getUsers() &#123;     // ... &#125;</code></pre><h6 id="ApiResponse"><a href="#ApiResponse" class="headerlink" title="@ApiResponse"></a>@ApiResponse</h6><p>作用：用于描述单个响应结果。<br>示例：</p><pre><code class="hljs"> @ApiResponse(code = 200, message = &quot;成功&quot;, response = User.class)</code></pre><h6 id="ApiImplicitParams"><a href="#ApiImplicitParams" class="headerlink" title="@ApiImplicitParams"></a>@ApiImplicitParams</h6><pre><code class="hljs"> @ApiOperation(value = &quot;获取用户列表&quot;) @ApiImplicitParams(&#123;     @ApiImplicitParam(name = &quot;page&quot;, value = &quot;页码&quot;, paramType = &quot;query&quot;, dataType = &quot;int&quot;),     @ApiImplicitParam(name = &quot;size&quot;, value = &quot;每页数量&quot;, paramType = &quot;query&quot;, dataType = &quot;int&quot;) &#125;) @GetMapping(&quot;/users&quot;) public List&lt;User&gt; getUsers(@RequestParam int page, @RequestParam int size) &#123;     // ... &#125;</code></pre><h6 id="ApiImplicitParam"><a href="#ApiImplicitParam" class="headerlink" title="@ApiImplicitParam"></a>@ApiImplicitParam</h6><p>作用：用于描述单个隐式参数。<br>示例：</p><pre><code class="hljs"> @ApiImplicitParam(name = &quot;page&quot;, value = &quot;页码&quot;, paramType = &quot;query&quot;, dataType = &quot;int&quot;)</code></pre><h6 id="ApiIgnore"><a href="#ApiIgnore" class="headerlink" title="@ApiIgnore"></a>@ApiIgnore</h6><p>作用：用于忽略某个类或方法，使其不被文档化。<br>示例：</p><pre><code class="hljs">  @ApiIgnore  @GetMapping(&quot;/health&quot;)  public String healthCheck() &#123;      return &quot;OK&quot;;  &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>优惠卷发布平台</title>
    <link href="/2024/10/03/case/%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B/"/>
    <url>/2024/10/03/case/%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>ps</p><p>优惠卷发布平台<br>1.提供登录注册<br>登录注册采用redis缓存 减缓mysql压力<br>2.登录验证<br>采用cookie 对ID进行aes加密，拦截器解密<br>3.异常捕获<br>未知异常—全部补获—发送邮箱提醒开发者<br>4.优惠卷定时发布<br>采用xll—job<br>5.优惠券发布<br>mysql redis各一份<br>6.抢优惠卷</p><p>lua-redis-ecle</p><p>7.优惠卷同步</p><p>同步<br>xxl—job 配合线程池异步同步8.使用优惠券<br>redis 分布式锁 事务问题<br>9.优惠券展示<br>redis缓存问题—mysql索引优化</p><p>01案例，不想想太多，简简单单上个手</p><p>设计思路-</p><p>数据库 id 账号 密码</p><p>逻辑 -判断账号密码-给与seioon-拦截器进行判断</p><p>技术方案-</p><p>redis+&#x2F;&#x2F; SpringCache下一个项目再使用</p><p>MQ+Canal-同步数据库 </p><p>xxl-job预热缓存&#x2F;&#x2F;</p><p>cookie 加密登录逻辑 </p><p>调优方案</p><p>jvm-</p><p>查看堆-gc时间-查看高并发下运行时间</p><p>ps:</p><p>01案例-只需要搭建起查看时间，不需要进行各类jvm调优</p><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><p>太久没搭建环境了</p><p>创建的maven项目-导入的各类依赖</p><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h4><p>三个字段</p><p>主键 id (雪花算法) 用户名String –去重  密码String </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(id <span class="hljs-type">BigInt</span> <span class="hljs-keyword">Primary key</span>,account <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, <span class="hljs-keyword">password</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><h4 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2.配置环境"></a>2.配置环境</h4><p>1.配置maven 导入spring起步依赖 导入redis-导入knif34i 导入工具类</p><p>2.编写启动类-编写knif4i配置</p><p>3.导入mybutsplus-代码生成</p><p>4.自动生成mvc三层架构模式</p><p>5.插入数据库数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into user(id,account,password) values(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>6.修改用户账号索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> account_unique <span class="hljs-keyword">Unique</span>(account);<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="3-登录逻辑"><a href="#3-登录逻辑" class="headerlink" title="3.登录逻辑"></a>3.登录逻辑</h4><h4 id="1-controller"><a href="#1-controller" class="headerlink" title="1.controller"></a>1.controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleController</span> &#123;<br><span class="hljs-meta">@Autowired</span><br>    IUserService iUserService;<br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;登录&quot;)</span><br><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(value = &quot;用户ID&quot;, required = true)</span>String account, <span class="hljs-meta">@ApiParam(value = &quot;用户密码&quot;, required = true)</span> String password , HttpServletRequest req)</span> &#123;<br>        R r=iUserService.login(account,password);<br>        <span class="hljs-keyword">if</span>(Objects.nonNull(r.getData()))<br>        &#123;<br>            <span class="hljs-comment">//登录成功了的</span><br>            <span class="hljs-type">SessionwebUserDto</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (SessionwebUserDto) r.getData();<br>            <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>            session.setAttribute(<span class="hljs-string">&quot;session_account&quot;</span>,data);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-service"><a href="#2-service" class="headerlink" title="2.service"></a>2.service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><span class="hljs-meta">@Autowired</span><br>    RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">login</span><span class="hljs-params">(String account, String password)</span> &#123;<br>        <span class="hljs-comment">//查询redis缓存</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(account);<br>        <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">null</span>)<br>       &#123;<br>            <span class="hljs-comment">//弹出验证码-或者其他策略 查mysql</span><br>            <span class="hljs-comment">//mysql也为空</span><br>            LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            lambdaQueryWrapper.eq(User::getAccount, account); <span class="hljs-comment">// 使用 Lambda 表达式引用字段 lambdaQueryWrapper.ge(User::getAge, 18);</span><br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.baseMapper.selectOne(lambdaQueryWrapper);<br>            o=user;<br>            <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;账号或密码错误&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//插入user缓存到redis</span><br>           redisTemplate.opsForValue().set(account,user);<br><br>        &#125;<br>        <span class="hljs-comment">//账号对了</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) o;<br>        <span class="hljs-keyword">if</span>(!user.getPassword().equals(password))<br>        &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;账号或密码错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//登录成功给sessio</span><br>        <span class="hljs-type">SessionwebUserDto</span> <span class="hljs-variable">sessionwebUserDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionwebUserDto</span>();<br>        sessionwebUserDto.setAccountId(user.getAccount());<br><br>        <span class="hljs-keyword">return</span> R.success(sessionwebUserDto);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>demo 登录注册 <strong>抢单-核销</strong> lua-redis原子性</p><p>主要是的redis进行操作-看看<strong>redis的延迟任务</strong>能不能加入进来</p><h4 id="加密token编写"><a href="#加密token编写" class="headerlink" title="加密token编写"></a><em><strong>加密token编写</strong></em></h4><p>对明文seiion转json后加密</p><p>非对称和对称</p><p>加密解密都在服务器-选择对称加密</p><blockquote><p>采用base64编码，</p><p>需要手动解析data-赋值给对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenEncryption</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;token.encryption.key&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String key;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;token.encryption.iv&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String iv;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;token.encryption.algorithm&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String algorithm;<br><br><br>    <span class="hljs-keyword">private</span> SecretKeySpec AES;<br><br>    <span class="hljs-keyword">private</span>  IvParameterSpec ivSpec;<br>    <span class="hljs-keyword">private</span>  Cipher cipher;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIv</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> iv;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAlgorithm</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> algorithm;<br>    &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTokenEncryption</span><span class="hljs-params">(String data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//用于包装密钥 --包装向量</span><br>       extracted();<br>       <span class="hljs-comment">//指定加密</span><br>        <span class="hljs-comment">//加密</span><br>        cipher.init(Cipher.ENCRYPT_MODE, AES, ivSpec);<br>        <span class="hljs-type">byte</span>[] encrypted = cipher.doFinal(data.getBytes());<br>       <span class="hljs-type">String</span> <span class="hljs-variable">encryptedBase64</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(encrypted);<br><br><br>       <span class="hljs-keyword">return</span> encryptedBase64;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extracted</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(AES==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[] rawKey = adjustKeyLength(key, <span class="hljs-number">16</span>); <span class="hljs-comment">// 16字节=128位</span><br>            AES=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(rawKey,algorithm);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ivSpec==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[] ivBytes = adjustKeyLength(iv, <span class="hljs-number">16</span>);<br>            ivSpec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(ivBytes);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cipher == <span class="hljs-literal">null</span>)<br>        &#123;<br>             cipher = Cipher.getInstance(<span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>);<br>        &#125;<br>    &#125;<br><br> <span class="hljs-keyword">private</span>    SecretKeySpec secretKey;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">retToken</span><span class="hljs-params">(String data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(secretKey==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[]  rawKey = adjustKeyLength(key, <span class="hljs-number">16</span>); <span class="hljs-comment">// 16字节=128位</span><br>            secretKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(rawKey, algorithm);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(ivSpec==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[] ivBytes = adjustKeyLength(iv, <span class="hljs-number">16</span>);<br>            ivSpec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(ivBytes);<br>        &#125;<br>        <span class="hljs-comment">// 指定解密算法和模式</span><br>        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>);<br><br>        <span class="hljs-comment">// 初始化解密器</span><br>        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);<br><br>        <span class="hljs-comment">// 解密Base64编码的加密数据</span><br>        <span class="hljs-type">byte</span>[] decodedEncryptedData = Base64.getDecoder().decode(data);<br>        <span class="hljs-type">byte</span>[] decryptedData = cipher.doFinal(decodedEncryptedData);<br><br>        <span class="hljs-comment">// 返回解密后的原始字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decryptedData, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] adjustKeyLength(String key, <span class="hljs-type">int</span> length) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] keyBytes = key.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-keyword">if</span> (keyBytes.length == length) &#123;<br>            <span class="hljs-keyword">return</span> keyBytes;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyBytes.length &lt; length) &#123;<br>            <span class="hljs-comment">// 如果长度不足，使用0填充</span><br>            <span class="hljs-type">byte</span>[] paddedKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>            System.arraycopy(keyBytes, <span class="hljs-number">0</span>, paddedKey, <span class="hljs-number">0</span>, keyBytes.length);<br>            <span class="hljs-keyword">return</span> paddedKey;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果长度超出，截取前面的部分</span><br>            <span class="hljs-type">byte</span>[] shortenedKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>            System.arraycopy(keyBytes, <span class="hljs-number">0</span>, shortenedKey, <span class="hljs-number">0</span>, length);<br>            <span class="hljs-keyword">return</span> shortenedKey;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>脑子一抽就写出来了，本来准备套JWT的。。</p><p>我脑子抽了-</p><p>然后-关于过期就加入时间搓效验-我没有加-后续能人再加把-嘻嘻</p></blockquote><h4 id="拦截器编写"><a href="#拦截器编写" class="headerlink" title="拦截器编写"></a>拦截器编写</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>)&#123;<br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截所有请求</span><br>                .<span class="hljs-title function_">excludePathPatterns</span>(<span class="hljs-string">&quot;/api/login&quot;</span>, <span class="hljs-string">&quot;/error&quot;</span>); <span class="hljs-comment">// 排除某些路径不拦截</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>  <span class="hljs-meta">@Autowired</span><br>    TokenEncryption tokenEncryption;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">/*  HttpSession session = request.getSession();</span><br><span class="hljs-comment">        String token= (String) session.getAttribute(&quot;session_account&quot;);*/</span><br>        <span class="hljs-keyword">if</span>(tokenEncryption==<span class="hljs-literal">null</span>)<br>        &#123;<br>            tokenEncryption=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenEncryption</span>();<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                key: &quot;w7HqL+Jz3Kt0J3u6fYT3Ow==&quot;</span><br><span class="hljs-comment">    iv: &quot;77b07a672d57d64c&quot;</span><br><span class="hljs-comment">    algorithm: AES</span><br><span class="hljs-comment">             */</span><br>            tokenEncryption.setKey(<span class="hljs-string">&quot;w7HqL+Jz3Kt0J3u6fYT3Ow==&quot;</span>);<br>            tokenEncryption.setIv(<span class="hljs-string">&quot;77b07a672d57d64c&quot;</span>);<br>            tokenEncryption.setAlgorithm(<span class="hljs-string">&quot;AES&quot;</span>);<br>        &#125;<br><br>        Cookie[] cookies = request.getCookies();<br>        <span class="hljs-keyword">if</span> (cookies == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;用户错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;username&quot;</span>.equals(cookie.getName())) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> cookie.getValue();<br>              <span class="hljs-type">String</span> <span class="hljs-variable">userid</span>  <span class="hljs-operator">=</span>tokenEncryption.retToken(username);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;用户错误&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="全局异常编写"><a href="#全局异常编写" class="headerlink" title="全局异常编写"></a>全局异常编写</h4><p>我redis忘记启动了，报错信息直接给我出了-redis地址-笑死我了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandler</span> &#123;<br>    <span class="hljs-meta">@org</span>.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ExceptionHandler(value = Exception.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-keyword">public</span> R handleException(Exception e)<br>    &#123;<br>        e.getMessage();<br>        <span class="hljs-keyword">return</span>  R.error(<span class="hljs-string">&quot;对不起,操作失败,请联系管理员&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@org</span>.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ExceptionHandler(value = BusinessException.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-keyword">public</span> R handleException(BusinessException e)<br>    &#123;<br>       <br>        <span class="hljs-keyword">return</span>  R.error( e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BusinessException</span> <span class="hljs-title">extends</span> <span class="hljs-title">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">private</span> ResponseCodeEnum codeEnum;<br><br>    <span class="hljs-keyword">private</span> Integer code;<br><br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">public</span> BusinessException(String message, Throwable e) &#123;<br>        <span class="hljs-keyword">super</span>(message, e);<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(String message) &#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(Throwable e) &#123;<br>        <span class="hljs-keyword">super</span>(e);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(ResponseCodeEnum codeEnum) &#123;<br>        <span class="hljs-keyword">super</span>(codeEnum.getMsg());<br>        <span class="hljs-keyword">this</span>.codeEnum = codeEnum;<br>        <span class="hljs-keyword">this</span>.code = codeEnum.getCode();<br>        <span class="hljs-keyword">this</span>.message = codeEnum.getMsg();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(Integer code, String message) &#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ResponseCodeEnum getCodeEnum() &#123;<br>        <span class="hljs-keyword">return</span> codeEnum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer getCode() &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String getMessage() &#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写fillInStackTrace 业务异常不需要堆栈信息，提高效率.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Throwable fillInStackTrace() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>10&#x2F;4号代码</p><h4 id="注册编写"><a href="#注册编写" class="headerlink" title="注册编写"></a>注册编写</h4><p>以后碰到异常我自己捕获了，不能老是抛抛抛</p><p>使用 <code>IdType.ASSIGN_ID</code>（雪花算法）</p><p> MyBatis-Plus 的内置雪花算法来生成一个 <code>Long</code> 类型的唯一 ID</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@TableId(value = <span class="hljs-string">&quot;id&quot;</span>, type = IdType.ASSIGN_UUID)</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Override<br>    <span class="hljs-built_in">public</span> R register(<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">user</span>==<span class="hljs-keyword">null</span>||<span class="hljs-keyword">user</span>.getAccount() == <span class="hljs-keyword">null</span>||<span class="hljs-keyword">user</span>.getPassword()==<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>  R.error(&quot;请补全参数&quot;);<br>        &#125;<br>        //各类校验<br>        <span class="hljs-keyword">Object</span> o = redisTemplate.opsForValue().<span class="hljs-keyword">get</span>(<span class="hljs-keyword">user</span>.getAccount());<br>        <span class="hljs-keyword">if</span>(o!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> R.error(&quot;账号已存在&quot;);<br>        &#125;<br>        ///后续做xxl-job<br><span class="hljs-comment">/*        String keyRegister = &quot;register&quot;+user.getAccount();</span><br><span class="hljs-comment">        redisTemplate.opsForValue().set(keyRegister,user.getPassword());*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">insert</span> = this.baseMapper.<span class="hljs-keyword">insert</span>(<span class="hljs-keyword">user</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">insert</span>==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>  R.error(&quot;注册失败&quot;);<br>        &#125;<br>        //即时缓存<br>        redisTemplate.opsForValue().<span class="hljs-keyword">set</span>(<span class="hljs-keyword">user</span>.getAccount(),<span class="hljs-keyword">user</span>.getPassword());<br>        <span class="hljs-keyword">return</span> R.success(&quot;注册成功&quot;);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="设计出错"><a href="#设计出错" class="headerlink" title="设计出错"></a>设计出错</h4><p>redis设计结构出错-应该是id-配合整个类()</p><p>不然拿不到id-主键搜索本身就是聚集索引快-而账户搜索就不是</p><h4 id="前端编写"><a href="#前端编写" class="headerlink" title="前端编写"></a>前端编写</h4><h4 id="抢卷发布0"><a href="#抢卷发布0" class="headerlink" title="抢卷发布0"></a>抢卷发布0</h4><h4 id="redis各类技术"><a href="#redis各类技术" class="headerlink" title="-redis各类技术"></a>-redis各类技术</h4><p>设计思路-</p><p>我发布抢卷mysql</p><p>mysql-canlce—redis进行缓存–解决缓存不一致</p><p>redis各类击穿问题</p><p>reids-spring cache</p><p>redis原子性操作</p><h5 id="抢卷发布"><a href="#抢卷发布" class="headerlink" title="抢卷发布"></a>抢卷发布</h5><h6 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h6><p>抢卷ID -抢卷库存</p><p>抢卷表（Coupon）</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c8e2f1f67aa728ad3b18a0916b36c25b.png" alt="c8e2f1f67aa728ad3b18a0916b36c25b"></p><p> <strong>抢卷记录表（Coupon_Redemption）</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241005111703478.png" alt="image-20241005111703478"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> coupon( id <span class="hljs-type">BIGINT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>                    coupon_code <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">UNIQUE</span><br>                    ,total_stock <span class="hljs-type">int</span>,available_stock <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>                    ,start_time datetime <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,end_time datetime <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>                    ,status TINYINT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;0: 未开始, 1: 进行中, 2: 已结束&#x27;</span>,<br>                    index idex_coupon_status(status));<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Coupon_Redemption (<br>id <span class="hljs-type">bigint</span>  AUTO_INCREMENT  <span class="hljs-keyword">primary</span> key,<br>user_id <span class="hljs-type">Varchar</span>(<span class="hljs-number">255</span>),<br>coupon_id <span class="hljs-type">bigint</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>redemption_time DATETIME <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>   status TINYINT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;0: 失败, 1: 成功&#x27;</span>,<br>   <span class="hljs-keyword">foreign</span> key(coupon_id) <span class="hljs-keyword">references</span> coupon(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE,<br>   <span class="hljs-keyword">unique</span> key  uk_user_coupon (user_id, coupon_id)<br>   <br>);<br></code></pre></td></tr></table></figure><h4 id="发卷思路"><a href="#发卷思路" class="headerlink" title="发卷思路"></a>发卷思路</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f360eea2a393757063c2caf95fe55ecc.png" alt="f360eea2a393757063c2caf95fe55ecc"></p><h4 id="reids抢卷结构"><a href="#reids抢卷结构" class="headerlink" title="reids抢卷结构"></a>reids抢卷结构</h4><p>1.redis抢卷表记录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">redisTemplate.opsForValue().<span class="hljs-built_in">set</span>(coupon.getId(), coupon);<br></code></pre></td></tr></table></figure><p>id+整个表-</p><h4 id="再次设计问题"><a href="#再次设计问题" class="headerlink" title="再次设计问题"></a>再次设计问题</h4><p>redis+加上前缀-例如-登录+账户-优惠卷+id</p><h4 id="发卷service"><a href="#发卷service" class="headerlink" title="发卷service"></a>发卷service</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RestController</span><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/coupon&quot;</span>)<br>public class CouponController &#123;<br><span class="hljs-variable">@Autowired</span><br>    ICouponService iCouponService;<br><br>    <span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/publish&quot;</span>)<br>    <span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;发卷&quot;</span>)<br>    public R <span class="hljs-built_in">publish</span>(<span class="hljs-variable">@RequestBody</span> Coupon coupon) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">iCouponService</span><span class="hljs-selector-class">.publish</span>(coupon);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Service</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl&lt;CouponMapper</span>, <span class="hljs-title">Coupon&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">ICouponService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-type">RedisTemplate</span> redisTemplate;<br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">R</span> publish(<span class="hljs-type">Coupon</span> coupon) &#123;<br>        <span class="hljs-comment">//判断--太多硬编码了-懒得用常量-谁喜欢改谁改</span><br>        coupon= <span class="hljs-keyword">this</span>.ifCoupon(coupon);<br><br>        <span class="hljs-comment">//xxl-job每日扫描-防止错误</span><br><br>       boolean i=save(coupon);<br>       <span class="hljs-keyword">if</span>(!i)<br>       &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.error(<span class="hljs-string">&quot;发布失败&quot;</span>);<br>       &#125;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;coupon&quot;</span>+coupon.getId().toString(), coupon);<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.success(coupon);<br><br>    &#125;<br>    public <span class="hljs-type">Coupon</span> ifCoupon(<span class="hljs-type">Coupon</span> coupon)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(coupon.getTotalStock()==<span class="hljs-literal">null</span>)<br>        &#123;<br>            coupon.setTotalStock(<span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(coupon.getAvailableStock()==<span class="hljs-literal">null</span>)<br>        &#123;<br>            coupon.setAvailableStock(coupon.getTotalStock());<br>        &#125;<br>        <span class="hljs-keyword">if</span>(coupon.getStartTime()==<span class="hljs-literal">null</span>)<br>        &#123;<br>            coupon.setStartTime(<span class="hljs-type">LocalDateTime</span>.now());<br>        &#125;<br>        <span class="hljs-keyword">if</span>(coupon.getEndTime()==<span class="hljs-literal">null</span>)<br>        &#123;<br>            coupon.setEndTime(<span class="hljs-type">LocalDateTime</span>.now().plusDays(<span class="hljs-number">1</span>));<span class="hljs-comment">//默认一天后结束</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(coupon.getCouponCode()==<span class="hljs-literal">null</span>)<br>        &#123;<br>            coupon.generateCouponCode();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(coupon.getStatus()==<span class="hljs-literal">null</span>)<br>        &#123;<br>            coupon.setStatus(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> coupon;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="xxl-job-定时发布优惠卷"><a href="#xxl-job-定时发布优惠卷" class="headerlink" title="xxl-job 定时发布优惠卷"></a>xxl-job 定时发布优惠卷</h4><p>步骤 1.搭建调度中心-创建调度器-创建任务</p><p>配置调度中心-添加任务执行调度代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">issueJob</span> &#123;<br><br><br>   <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-title class_">ICouponService</span> iCouponService;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建一个与 issueJob 类关联的日志记录器。</span><br><span class="hljs-comment">日志记录器用于输出日志信息，以帮助开发者在运行时了解程序的执行状态或排查问题。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@XxlJob</span>(<span class="hljs-string">&quot;fajuan&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testJob</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Coupon</span> coupon=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Coupon</span>();<br>        <span class="hljs-comment">///coupon</span><br>        iCouponService.<span class="hljs-title function_">publish</span>(coupon);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="抢卷逻辑"><a href="#抢卷逻辑" class="headerlink" title="抢卷逻辑"></a>抢卷逻辑</h4><p>&#x2F;&#x2F;&#x2F;&#x2F;判断请求参数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Service</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponRedemptionServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl&lt;CouponRedemptionMapper</span>, <span class="hljs-title">CouponRedemption&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">ICouponRedemptionService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-type">RedisTemplate</span> redisTemplate;<br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">R</span> qiangjuan(<span class="hljs-type">CouponRedemption</span> coupon) &#123;<br>        <span class="hljs-type">String</span> userId = (<span class="hljs-type">String</span>) <span class="hljs-type">RequestContextHolder</span>.getRequestAttributes().getAttribute(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-type">RequestAttributes</span>.<span class="hljs-type">SCOPE_REQUEST</span>);<br>        <span class="hljs-keyword">if</span> (coupon.getUserId() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.error(<span class="hljs-string">&quot;用户id不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (coupon.getCouponId() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.error(<span class="hljs-string">&quot;活动查询失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//查询活动是否开始</span><br>        <span class="hljs-type">ValueOperations</span> valueOperations = redisTemplate.opsForValue();<br>        <span class="hljs-type">Object</span> o = valueOperations.get(<span class="hljs-string">&quot;coupon&quot;</span> + coupon.getCouponId());<br>        <span class="hljs-type">Coupon</span> coupon2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Coupon</span>();<br>        coupon2 = (<span class="hljs-type">Coupon</span>) o;<br>        <span class="hljs-keyword">if</span> (coupon2.getStatus() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.error(<span class="hljs-string">&quot;活动未开始&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">LocalDateTime</span> now = <span class="hljs-type">LocalDateTime</span>.now();<br>        <span class="hljs-keyword">if</span> (now.isBefore(coupon2.getStartTime())) &#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;活动尚未开始&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now.isAfter(coupon2.getEndTime())) &#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;活动已结束&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (coupon2.getTotalStock() &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//开始抢卷</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x2F;执行抢卷脚本</p><p>eval执行lua脚本-redistempplate替换 MULTL开始redis的事务</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua">lua脚本<br><span class="hljs-comment">--抢卷</span><br><span class="hljs-comment">--队列-抢卷成功队列 -设计库存-修改库存表的可用库存</span><br><span class="hljs-comment">--优惠卷是否抢过</span><br><span class="hljs-keyword">local</span> couponNum=redis.call(<span class="hljs-string">&quot;HGET&quot;</span>,KEYS[<span class="hljs-number">3</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-comment">-- hget 获取不到数据返回false而不是nil</span><br><span class="hljs-keyword">if</span> couponNum ~= <span class="hljs-literal">false</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">tonumber</span>(couponNum) &gt;= <span class="hljs-number">1</span><br><span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--库存是否充足</span><br><span class="hljs-keyword">local</span> stockNum=redis.call(<span class="hljs-string">&quot;HGET&quot;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> stockNum ~=  <span class="hljs-literal">false</span> <span class="hljs-keyword">or</span>  <span class="hljs-built_in">tonumber</span>(stockNum) &lt; <span class="hljs-number">1</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-2&quot;</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--减库存</span><br><span class="hljs-comment">--写入抢卷成功队列</span><br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x2F;返回抢卷结果</p><p>-1： 限领一张</p><p>-2： 已抢光</p><p>-3： 写入抢券成功队列失败，返回给用户为：抢券失败</p><p>-4：  已抢光</p><p>-5： 写入抢券同步队列失败，返回给用户为：抢券失败</p><hr><p>&#x2F;&#x2F;&#x2F;线程池xxl-job进行抢卷结果同步</p><h4 id="崩溃一天"><a href="#崩溃一天" class="headerlink" title="崩溃一天"></a>崩溃一天</h4><p>做redis-给redis加了个序列化器-导致后续代码一直获取redis失败</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponRedemptionServiceImpl</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">ServiceImpl</span></span>&lt;<span class="hljs-title">CouponRedemptionMapper</span>, <span class="hljs-title">CouponRedemption</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">ICouponRedemptionService</span></span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br>    RedisTemplate redisTemplate;<br><span class="hljs-comment">///@Resource(name = &quot;Lua_test01&quot;)</span><br>   <span class="hljs-comment">/// DefaultRedisScript&lt;Integer&gt; seizeCouponScript;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> R qiangjuan(CouponRedemption coupon) &#123;<br>        <span class="hljs-keyword">String</span> userId = (<span class="hljs-keyword">String</span>) RequestContextHolder.getRequestAttributes().getAttribute(<span class="hljs-string">&quot;userId&quot;</span>, RequestAttributes.SCOPE_REQUEST);<br>        <span class="hljs-keyword">if</span> (userId == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;用户id不能为空&quot;</span>);<br>        &#125;<br>        coupon.setUserId(userId);<br>        <span class="hljs-keyword">if</span> (coupon.getCouponId() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;活动查询失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//查询活动是否开始</span><br>        <span class="hljs-comment">//  redisTemplate.opsForValue().set(&quot;coupon&quot;+coupon.getCouponCode().toString(), coupon);</span><br>        Object o= redisTemplate.opsForValue().<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;coupon&quot;</span>+coupon.getCouponId().toString());<br>       <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">null</span>)<br>       &#123;<br>           <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;活动查询失败&quot;</span>);<br>       &#125;<br>        Coupon coupon2 = <span class="hljs-keyword">new</span><span class="hljs-type"></span> Coupon();<br>        coupon2 = (Coupon) o;<br>        <span class="hljs-keyword">if</span> (coupon2.getStatus() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;活动未开始&quot;</span>);<br>        &#125;<br>        LocalDateTime now = LocalDateTime.now();<br>        <span class="hljs-keyword">if</span> (now.isBefore(coupon2.getStartTime())) &#123;<br>            System.out.println(<span class="hljs-string">&quot;活动尚未开始&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now.isAfter(coupon2.getEndTime())) &#123;<br>            System.out.println(<span class="hljs-string">&quot;活动已结束&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (coupon2.getTotalStock() &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 同步队列redisKey</span><br><br>        <span class="hljs-comment">// 资源库存redisKey</span><br>        int index = (int) (UUID.randomUUID().hashCode() % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">String</span> resourceStockRedisKey = <span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;coupon%s&quot;</span>, index);<br>        <span class="hljs-keyword">String</span> couponSeizeSyncRedisKey = <span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;COUPON_SEIZE_SYNC_QUEUE_NAME%s&quot;</span>, index);<br>        <span class="hljs-comment">// 抢券成功列表</span><br>        <span class="hljs-keyword">String</span> couponSeizeListRedisKey = <span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;COUPON_SEIZE%s%s&quot;</span>,coupon.getCouponId(), index);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br><span class="hljs-comment">        list.add(couponSeizeSyncRedisKey);// 同步队列redisKey</span><br><span class="hljs-comment">        list.add(resourceStockRedisKey); // 资源库存redisKey</span><br><span class="hljs-comment">        list.add(couponSeizeListRedisKey); // 抢券成功列表</span><br><span class="hljs-comment">        用户id</span><br><span class="hljs-comment">        优惠卷id</span><br><span class="hljs-comment">         */</span><br>        List&lt;<span class="hljs-keyword">String</span>&gt; list=<span class="hljs-keyword">new</span><span class="hljs-type"></span> ArrayList&lt;&gt;();<br>        list.add(couponSeizeSyncRedisKey);<span class="hljs-comment">// 同步队列redisKey</span><br>        list.add(resourceStockRedisKey); <span class="hljs-comment">// 资源库存redisKey</span><br>        list.add(couponSeizeListRedisKey); <span class="hljs-comment">// 抢券成功列表</span><br><br>        <span class="hljs-comment">//开始抢卷</span><br>        <span class="hljs-comment">//  Object execute=redisTemplate.execute(seizeCouponScript,list,userId,coupon.getCouponId());</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优惠卷库存同步"><a href="#优惠卷库存同步" class="headerlink" title="优惠卷库存同步"></a>优惠卷库存同步</h4><p>ps:以前跟着别人写简简单单，自己真的就老实了-逆天时间复杂度</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs processing">@Configuration<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">kcyure</span> &#123;<br>    @Autowired<br>    RedisTemplate redisTemplate;<br>    @<span class="hljs-title function_">XxlJob</span>(value = <span class="hljs-string">&quot;kcyure&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kcyure</span>() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//Set&lt;String&gt; couponKeys  = redisTemplate.keys(&quot;*&quot;); // 假设你的优惠券键以 &quot;coupon:&quot; 开头</span><br>            <span class="hljs-comment">//拿出同步库存表的-进行id过滤掉已经同步过的库存</span><br>            <span class="hljs-comment">//拿去同步表ids</span><br>            Cursor&lt;<span class="hljs-type">byte</span>[]&gt; couponKeys = redisTemplate.<span class="hljs-property">getConnectionFactory</span>().<span class="hljs-property">getConnection</span>().<span class="hljs-property">scan</span>(ScanOptions.<span class="hljs-property">scanOptions</span>().<span class="hljs-property">match</span>(<span class="hljs-string">&quot;*coupon*&quot;</span>).<span class="hljs-property">count</span>(<span class="hljs-number">100</span>).<span class="hljs-property">build</span>());<br>            Set&lt;<span class="hljs-built_in">String</span>&gt; couponKeyss = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (couponKeys.<span class="hljs-property">hasNext</span>()) &#123;<br>                <span class="hljs-type">byte</span>[] <span class="hljs-built_in">key</span> = couponKeys.<span class="hljs-property">next</span>();<br>                <span class="hljs-built_in">String</span> keyStr = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(<span class="hljs-built_in">key</span>, StandardCharsets.<span class="hljs-property">UTF_8</span>); <span class="hljs-comment">// 转换为字符串</span><br><br>                <span class="hljs-comment">// 提取 coupon 后面的部分</span><br>                <span class="hljs-keyword">if</span> (keyStr.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;coupon&quot;</span>)) &#123;<br>                    <span class="hljs-built_in">String</span> suffix = keyStr.<span class="hljs-property">substring</span>(keyStr.<span class="hljs-property">indexOf</span>(<span class="hljs-string">&quot;coupon&quot;</span>) + <span class="hljs-string">&quot;coupon&quot;</span>.<span class="hljs-property">length</span>());<br>                    couponKeyss.<span class="hljs-property">add</span>(suffix);<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//拿去库存表</span><br>            Set&lt;<span class="hljs-built_in">String</span>&gt; stocks = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashSet</span>&lt;&gt;();<br>            Cursor&lt;<span class="hljs-type">byte</span>[]&gt; stocksi = redisTemplate.<span class="hljs-property">getConnectionFactory</span>().<span class="hljs-property">getConnection</span>()<br>                    .<span class="hljs-property">scan</span>(ScanOptions.<span class="hljs-property">scanOptions</span>().<span class="hljs-property">match</span>(<span class="hljs-string">&quot;stock*&quot;</span>).<span class="hljs-property">count</span>(<span class="hljs-number">100</span>).<span class="hljs-property">build</span>());<br>            <span class="hljs-keyword">while</span> (stocksi.<span class="hljs-property">hasNext</span>()) &#123;<br>                <span class="hljs-type">byte</span>[] <span class="hljs-built_in">key</span> = stocksi.<span class="hljs-property">next</span>();<br>                <span class="hljs-built_in">String</span> keyStr = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(<span class="hljs-built_in">key</span>, StandardCharsets.<span class="hljs-property">UTF_8</span>); <span class="hljs-comment">// 转换为字符串</span><br>                Map&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt; hashEntries = redisTemplate.<span class="hljs-property">opsForHash</span>().<span class="hljs-property">entries</span>(keyStr);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">Object</span> key1 : hashEntries.<span class="hljs-property">keySet</span>())<br>                &#123;<br>                        stocks.<span class="hljs-property">add</span>(keyStr);<br>                &#125;<br><br>            &#125;<br>            <span class="hljs-keyword">if</span> (couponKeyss != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> : couponKeyss) &#123;<br>                    <span class="hljs-keyword">if</span>(stocks.<span class="hljs-property">contains</span>(<span class="hljs-built_in">key</span>))<br>                    &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    Coupon coupon= (Coupon) redisTemplate.<span class="hljs-property">opsForValue</span>().<span class="hljs-property">get</span>(<span class="hljs-string">&quot;coupon&quot;</span>+<span class="hljs-built_in">key</span>.<span class="hljs-property">toString</span>());<br>                    <span class="hljs-type">int</span> index = (<span class="hljs-type">int</span>) (coupon.<span class="hljs-property">getId</span>() % <span class="hljs-number">10</span>);<br>                    <span class="hljs-built_in">String</span> resourceStockRedisKey = <span class="hljs-built_in">String</span>.<span class="hljs-property">format</span>(<span class="hljs-string">&quot;Stock:%s&quot;</span>, index);<br>                    redisTemplate.<span class="hljs-property">opsForHash</span>().<span class="hljs-property">put</span>(resourceStockRedisKey, <span class="hljs-built_in">key</span>, coupon.<span class="hljs-property">getAvailableStock</span>());<br><br><br><br>                &#125;<br><br>            &#125;<br><br><br><br>        &#125;<span class="hljs-title function_">catch</span> (Exception e)<br>    &#123;<br>        e.<span class="hljs-property">printStackTrace</span>();<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;库存同步失败&quot;</span>);<br>        <span class="hljs-comment">//异常处理</span><br>    &#125;&#125;&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h4><p>优惠卷id-我设置的String-用的uuid-一直有— 我设置了LOng的-后续抢卷脚本转long才能找到数据-设计序列化-哈希计算的问题</p><p>redis序列化-更换日期类型-设置日期格式</p><p>10&#x2F;5 内容</p><h4 id="抢卷脚本"><a href="#抢卷脚本" class="headerlink" title="抢卷脚本"></a>抢卷脚本</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--抢卷</span><br><span class="hljs-comment">--队列-抢卷成功队列 -设计库存-修改库存表的可用库存</span><br><span class="hljs-comment">---- key: 抢券同步队列，资源库存,抢券成功列表</span><br>  <span class="hljs-comment">-- argv：活动id,用户id</span><br><span class="hljs-comment">--优惠卷是否抢过--抢卷成功队列--key coupon</span><br><span class="hljs-keyword">local</span> couponNum = redis.<span class="hljs-keyword">call</span>(&quot;HGET&quot;, KEYS[<span class="hljs-number">3</span>], ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-comment">-- hget 获取不到数据返回false而不是nil</span><br><span class="hljs-keyword">if</span> couponNum ~= <span class="hljs-keyword">false</span> <span class="hljs-keyword">and</span> tonumber(couponNum) &gt;= <span class="hljs-number">1</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> &quot;-1&quot;;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--库存是否充足</span><br><span class="hljs-keyword">local</span> stockNum=redis.<span class="hljs-keyword">call</span>(&quot;HGET&quot;,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> stockNum == <span class="hljs-keyword">false</span> <span class="hljs-keyword">or</span>  tonumber(stockNum) &lt; <span class="hljs-number">1</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> &quot;-2&quot;;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--抢券列表</span><br><span class="hljs-keyword">local</span> listNum = redis.<span class="hljs-keyword">call</span>(&quot;HSET&quot;,KEYS[<span class="hljs-number">3</span>], ARGV[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> listNum == <span class="hljs-keyword">false</span> <span class="hljs-keyword">or</span>  tonumber(listNum) &lt; <span class="hljs-number">1</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> &quot;-3&quot;;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--减库存</span><br>stockNum=redis.<span class="hljs-keyword">call</span>(&quot;HINCRBY&quot;,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>],<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> tonumber(stockNum)&lt;<span class="hljs-number">0</span><br><span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> &quot;-4&quot;;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--写入抢卷成功队列</span><br><span class="hljs-keyword">local</span> result=redis.<span class="hljs-keyword">call</span>(&quot;HSETNX&quot;,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> result&gt;<span class="hljs-number">0</span><br><span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> ARGV[<span class="hljs-number">1</span>]..&quot;&quot;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> &quot;-5&quot;<br><br><br></code></pre></td></tr></table></figure><h4 id="抢卷开发"><a href="#抢卷开发" class="headerlink" title="抢卷开发"></a>抢卷开发</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs processing">@Configuration<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">kcyure</span> &#123;<br>    @Autowired<br>    RedisTemplate redisTemplate;<br>    @<span class="hljs-title function_">XxlJob</span>(value = <span class="hljs-string">&quot;kcyure&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kcyure</span>() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//Set&lt;String&gt; couponKeys  = redisTemplate.keys(&quot;*&quot;); // 假设你的优惠券键以 &quot;coupon:&quot; 开头</span><br>            <span class="hljs-comment">//拿出同步库存表的-进行id过滤掉已经同步过的库存</span><br>            <span class="hljs-comment">//拿去同步表ids</span><br>            Cursor&lt;<span class="hljs-type">byte</span>[]&gt; couponKeys = redisTemplate.<span class="hljs-property">getConnectionFactory</span>().<span class="hljs-property">getConnection</span>().<span class="hljs-property">scan</span>(ScanOptions.<span class="hljs-property">scanOptions</span>().<span class="hljs-property">match</span>(<span class="hljs-string">&quot;*coupon*&quot;</span>).<span class="hljs-property">count</span>(<span class="hljs-number">100</span>).<span class="hljs-property">build</span>());<br>            Set&lt;<span class="hljs-built_in">String</span>&gt; couponKeyss = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (couponKeys.<span class="hljs-property">hasNext</span>()) &#123;<br>                <span class="hljs-type">byte</span>[] <span class="hljs-built_in">key</span> = couponKeys.<span class="hljs-property">next</span>();<br>                <span class="hljs-built_in">String</span> keyStr = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(<span class="hljs-built_in">key</span>, StandardCharsets.<span class="hljs-property">UTF_8</span>); <span class="hljs-comment">// 转换为字符串</span><br><br>                <span class="hljs-comment">// 提取 coupon 后面的部分</span><br>                <span class="hljs-keyword">if</span> (keyStr.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;coupon&quot;</span>)) &#123;<br>                    <span class="hljs-built_in">String</span> suffix = keyStr.<span class="hljs-property">substring</span>(keyStr.<span class="hljs-property">indexOf</span>(<span class="hljs-string">&quot;coupon&quot;</span>) + <span class="hljs-string">&quot;coupon&quot;</span>.<span class="hljs-property">length</span>());<br>                    couponKeyss.<span class="hljs-property">add</span>(suffix);<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//拿去库存表</span><br>            Set&lt;<span class="hljs-built_in">String</span>&gt; stocks = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashSet</span>&lt;&gt;();<br>            Cursor&lt;<span class="hljs-type">byte</span>[]&gt; stocksi = redisTemplate.<span class="hljs-property">getConnectionFactory</span>().<span class="hljs-property">getConnection</span>()<br>                    .<span class="hljs-property">scan</span>(ScanOptions.<span class="hljs-property">scanOptions</span>().<span class="hljs-property">match</span>(<span class="hljs-string">&quot;stock*&quot;</span>).<span class="hljs-property">count</span>(<span class="hljs-number">100</span>).<span class="hljs-property">build</span>());<br>            <span class="hljs-keyword">while</span> (stocksi.<span class="hljs-property">hasNext</span>()) &#123;<br>                <span class="hljs-type">byte</span>[] <span class="hljs-built_in">key</span> = stocksi.<span class="hljs-property">next</span>();<br>                <span class="hljs-built_in">String</span> keyStr = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(<span class="hljs-built_in">key</span>, StandardCharsets.<span class="hljs-property">UTF_8</span>); <span class="hljs-comment">// 转换为字符串</span><br>                Map&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt; hashEntries = redisTemplate.<span class="hljs-property">opsForHash</span>().<span class="hljs-property">entries</span>(keyStr);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">Object</span> key1 : hashEntries.<span class="hljs-property">keySet</span>())<br>                &#123;<br>                        stocks.<span class="hljs-property">add</span>(keyStr);<br>                &#125;<br><br>            &#125;<br>            <span class="hljs-keyword">if</span> (couponKeyss != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> : couponKeyss) &#123;<br>                    <span class="hljs-keyword">if</span>(stocks.<span class="hljs-property">contains</span>(<span class="hljs-built_in">key</span>))<br>                    &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    Coupon coupon= (Coupon) redisTemplate.<span class="hljs-property">opsForValue</span>().<span class="hljs-property">get</span>(<span class="hljs-string">&quot;coupon&quot;</span>+<span class="hljs-built_in">key</span>.<span class="hljs-property">toString</span>());<br>                    <span class="hljs-type">int</span> index = (<span class="hljs-type">int</span>) (coupon.<span class="hljs-property">getId</span>() % <span class="hljs-number">10</span>);<br>                    <span class="hljs-built_in">String</span> resourceStockRedisKey = <span class="hljs-built_in">String</span>.<span class="hljs-property">format</span>(<span class="hljs-string">&quot;Stock:%s&quot;</span>, index);<br>                    redisTemplate.<span class="hljs-property">opsForHash</span>().<span class="hljs-property">put</span>(resourceStockRedisKey, <span class="hljs-built_in">key</span>, coupon.<span class="hljs-property">getAvailableStock</span>());<br><br><br><br>                &#125;<br><br>            &#125;<br><br><br><br>        &#125;<span class="hljs-title function_">catch</span> (Exception e)<br>    &#123;<br>        e.<span class="hljs-property">printStackTrace</span>();<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;库存同步失败&quot;</span>);<br>        <span class="hljs-comment">//异常处理</span><br>    &#125;&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="库存同步"><a href="#库存同步" class="headerlink" title="库存同步"></a>库存同步</h4><p>线程池-配合xxl-job</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">syncThreadPool</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;syncThreadPool&quot;)</span><br>    <span class="hljs-keyword">public</span> ThreadPoolExecutor <span class="hljs-title function_">syncThreadPool</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 核心线程数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 最大线程数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">120</span>; <span class="hljs-comment">// 线程空闲时间</span><br>        <span class="hljs-type">TimeUnit</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> TimeUnit.SECONDS; <span class="hljs-comment">// 时间单位</span><br>        <span class="hljs-comment">// 指定拒绝策略为 DiscardPolicy</span><br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">rejectedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy();<br>        <span class="hljs-comment">// 任务队列，使用SynchronousQueue容量为1，在没有线程去消费时不会保存任务</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span><br>                (corePoolSize, maxPoolSize, keepAliveTime, unit,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(),rejectedHandler);<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>xxl-job</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">getData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> int index;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">int index</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = index;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//读取任务-加锁-免得重复读取</span><br><br>        <span class="hljs-comment">//创建示例</span><br>        <span class="hljs-title class_">RedissonClient</span> redissonClient = <span class="hljs-title class_">Redisson</span>.<span class="hljs-title function_">create</span>();<br>        <span class="hljs-comment">//获取锁</span><br>        <span class="hljs-title class_">RLock</span> loc=redissonClient.<span class="hljs-title function_">getLock</span>(<span class="hljs-string">&quot;ying&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">boolean</span> isLock=loc.<span class="hljs-title function_">tryLock</span>(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>);<br>            <span class="hljs-keyword">if</span> (isLock) &#123;<br>                <span class="hljs-comment">//锁内执行   最大等待时间 持锁时间 分钟数</span><br>                <span class="hljs-comment">//-2看门狗机制-只要执行完成后才会放锁</span><br>                <span class="hljs-title class_">String</span> quene=<span class="hljs-title class_">String</span>.<span class="hljs-title function_">format</span>(<span class="hljs-string">&quot;ying:%s&quot;</span>,index);<br>                <span class="hljs-title function_">jgtb</span>(quene);<br><br><br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e)<br>        &#123;<br>            <span class="hljs-comment">// 处理中断异常</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(lock!=<span class="hljs-literal">null</span> &amp;&amp;)<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">jgtb</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> quene</span>)<br>    &#123;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="库存同步代码"><a href="#库存同步代码" class="headerlink" title="库存同步代码"></a>库存同步代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@XxlJob</span>(value = <span class="hljs-string">&quot;kctb&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qjtb_syncThreadPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        threadPool.execute(getData);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">getData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ICouponRedemptionService iCouponRedemptionService;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//读取任务-加锁-免得重复读取</span><br><br>        <span class="hljs-comment">//创建示例</span><br>        <span class="hljs-type">RedissonClient</span> <span class="hljs-variable">redissonClient</span> <span class="hljs-operator">=</span> Redisson.create();<br>        <span class="hljs-comment">//获取锁</span><br>        RLock loc=redissonClient.getLock(<span class="hljs-string">&quot;ying&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> isLock=loc.tryLock(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>            <span class="hljs-keyword">if</span> (isLock) &#123;<br>                <span class="hljs-comment">//锁内执行   最大等待时间 持锁时间 分钟数</span><br>                <span class="hljs-comment">//-2看门狗机制-只要执行完成后才会放锁</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<br>                String quene=String.format(<span class="hljs-string">&quot;ying:%s&quot;</span>,index);<br>                jgtb(quene);<br><br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            <span class="hljs-comment">// 处理中断异常</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (loc != <span class="hljs-literal">null</span> &amp;&amp; loc.isLocked()) &#123;<br>                loc.unlock();<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jgtb</span><span class="hljs-params">(String quene)</span><br>    &#123;<span class="hljs-comment">///  Cursor&lt;byte[]&gt; couponKeys = redisTemplate.getConnectionFactory()</span><br>        <span class="hljs-comment">// .getConnection().scan(</span><br>        <span class="hljs-comment">// ScanOptions.scanOptions().match(&quot;*coupon*&quot;).count(100).build());</span><br>        <span class="hljs-comment">//获取成功数据 -游标拿去</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; stocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            Cursor&lt;<span class="hljs-type">byte</span>[]&gt; stocksi = redisTemplate.getConnectionFactory().<br>                    getConnection().scan(ScanOptions.scanOptions()<br>                            .match(quene).count(<span class="hljs-number">100</span>).build());<br>            <span class="hljs-keyword">if</span>(stocksi==<span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (stocksi.hasNext()) &#123;<br>                <span class="hljs-type">byte</span>[] key = stocksi.next();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">keyStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(key, StandardCharsets.UTF_8); <span class="hljs-comment">// 转换为字符串-队列名字</span><br>                Map&lt;String, Object&gt; hashEntries = redisTemplate.opsForHash().entries(keyStr);<span class="hljs-comment">//根据队列名字找key集合</span><br>                <span class="hljs-keyword">for</span>(String key1 : hashEntries.keySet())<br>                &#123;<br><br>                    stocks.add(key1);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(stocks.size()==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>( String key:stocks)<br>            &#123;<br>                <span class="hljs-type">CouponRedemption</span> <span class="hljs-variable">couponRedemption</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CouponRedemption</span>();<br>                couponRedemption.setUserId(String.valueOf(key));<br>                <span class="hljs-comment">//真是神仙代码</span><br>                Long o= (Long) redisTemplate.opsForHash().get(quene,key);<br>                couponRedemption.setCouponId(String.valueOf(o));<br>                couponRedemption.setRedemptionTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                couponRedemption.setStatus(<span class="hljs-number">1</span>);<br>                iCouponRedemptionService.save(couponRedemption);<br>                redisTemplate.opsForHash().delete(quene,key);<br><br>            &#125;<br><br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="mysql外键错误"><a href="#mysql外键错误" class="headerlink" title="mysql外键错误"></a>mysql外键错误</h4><p>商品卷约束到父表user去了-笑死我了</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> coupon_redemption<br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> coupon_redemption_coupon_coupon_code_fk<br>        <span class="hljs-keyword">foreign key</span> (coupon_id) <span class="hljs-keyword">references</span> coupon (coupon_code);<br><br><br></code></pre></td></tr></table></figure><h4 id="优惠卷展示"><a href="#优惠卷展示" class="headerlink" title="优惠卷展示"></a>优惠卷展示</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> R <span class="hljs-title function_">lsit</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">//这里偷懒不用游标了</span><br>     <span class="hljs-comment">//权限校验</span><br>     <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">String</span>&gt; keys = redisTemplate.<span class="hljs-title function_">keys</span>(<span class="hljs-string">&quot;coupon*&quot;</span>);<br>     <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Object</span>&gt; values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> key : keys) &#123;<br>         values.<span class="hljs-title function_">add</span>(redisTemplate.<span class="hljs-title function_">opsForValue</span>().<span class="hljs-title function_">get</span>(key));<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> R.<span class="hljs-title function_">success</span>(values);<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="拦截器修复拦截knife4i"><a href="#拦截器修复拦截knife4i" class="headerlink" title="拦截器修复拦截knife4i"></a>拦截器修复拦截knife4i</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object <span class="hljs-keyword">handler</span>)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>      <span class="hljs-comment">/*  HttpSession session = request.getSession();</span><br><span class="hljs-comment">        String token= (String) session.getAttribute(&quot;session_account&quot;);*/</span><br>        HandlerMethod handlerMethod=(HandlerMethod)<span class="hljs-keyword">handler</span>;<br><span class="hljs-comment">//判断如果请求的类是swagger的控制器，直接通行。</span><br>        <span class="hljs-keyword">if</span>(handlerMethod.getBean().getClass().getName().equals(<span class="hljs-string">&quot;springfox.documentation.swagger.web.ApiResourceController&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span>  <span class="hljs-keyword">true</span>;<br>        &#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://gitee.com/laomaodu/anli01">https://gitee.com/laomaodu/anli01</a></p><p>api地址</p><p><a href="https://apifox.com/apidoc/shared-20ef25e6-5dfe-482f-88a0-ae48011048a3">https://apifox.com/apidoc/shared-20ef25e6-5dfe-482f-88a0-ae48011048a3</a></p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>对于代码逻辑来讲简单-但是总会涉及到很多bug-很多的bug都是再设计时候埋下的坑，下一次项目就会注重设计了</p><p><a href="https://www.bilibili.com/video/BV14N1qYNEbU/?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV14N1qYNEbU/?spm_id_from=333.999.0.0</a></p>]]></content>
    
    
    <categories>
      
      <category>后端实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 管理</title>
    <link href="/2024/10/01/mysql/mysql%E7%AE%A1%E7%90%86/mysql%E7%AE%A1%E7%90%86/"/>
    <url>/2024/10/01/mysql/mysql%E7%AE%A1%E7%90%86/mysql%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql管理"><a href="#Mysql管理" class="headerlink" title="Mysql管理"></a>Mysql管理</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/50e52325f000ebef03b8c0a9d406bd67.png" alt="在这里插入图片描述"></p><p>ps:不过脑子看了一遍。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql Er模型</title>
    <link href="/2024/10/01/mysql/Er%E6%A8%A1%E5%9E%8B/Er%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/10/01/mysql/Er%E6%A8%A1%E5%9E%8B/Er%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-Er模型"><a href="#Mysql-Er模型" class="headerlink" title="Mysql Er模型"></a>Mysql Er模型</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3d798c7ab8d7dfd55a274fcc0edaa1ae.png" alt="在这里插入图片描述"></p><p>ps:未了解</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 执行计划</title>
    <link href="/2024/10/01/mysql/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2024/10/01/mysql/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-执行计划"><a href="#Mysql-执行计划" class="headerlink" title="Mysql 执行计划"></a>Mysql 执行计划</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5a7aa3b0d5fc4375a0ed7edf3fa7391b.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>explain<br><span class="hljs-keyword">SELECT</span> id<br><span class="hljs-keyword">FROM</span> orders_0<br><span class="hljs-keyword">WHERE</span> (orders_status <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1716346406098296832</span> <span class="hljs-keyword">AND</span> display <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sort_by<span class="hljs-operator">&lt;</span><span class="hljs-number">1698924600022</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sort_by <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">10</span><br><br><br><br><br><br>[<br>  &#123;<br>    &quot;id&quot;: <span class="hljs-number">1</span>,  每个查询步骤的唯一标识符<br>    &quot;select_type&quot;: &quot;SIMPLE&quot;,  查询的类型，例如 SIMPLE（简单查询）或 <span class="hljs-keyword">PRIMARY</span>（主查询，嵌套子查询的最外层查询）。<br>    &quot;table&quot;: &quot;orders_0&quot;,查询涉及的表。<br>    &quot;partitions&quot;: <span class="hljs-keyword">null</span>, 使用的分区（如果有分区表的话）<br>    &quot;type&quot;: &quot;range&quot;,查询使用的连接类型，例如 <span class="hljs-keyword">ALL</span>（全表扫描）或 index（索引扫描）。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>数据扫描类型<br>    &quot;possible_keys&quot;: &quot;query_index_0,query_index_1&quot;,可能用于此查询的键列表。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>用到的索引<br>    &quot;key&quot;: &quot;query_index_0&quot;,实际用于此查询的键。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>实际索引<br>    &quot;key_len&quot;: &quot;26&quot;,实际用于此查询的键。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>索引字节数<br>    &quot;ref&quot;: <span class="hljs-keyword">null</span>,显示索引的哪一列被用于查询。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>查找值用到的索引<span class="hljs-operator">-</span>名字<br>    &quot;rows&quot;: <span class="hljs-number">1</span>,MySQL 估计将需要读取的行数。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>预计扫描行数<br>    &quot;filtered&quot;: <span class="hljs-number">100</span>,在表中的行数的百分比，表示查询的条件有多少行满足。<span class="hljs-operator">/</span>越大越好<br>    &quot;Extra&quot;: &quot;Using where; Using index&quot; 其他的额外信息，例如使用了哪些索引、是否使用了文件排序等。<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql范式</title>
    <link href="/2024/10/01/mysql/%E8%8C%83%E5%BC%8F/%E8%8C%83%E5%BC%8F/"/>
    <url>/2024/10/01/mysql/%E8%8C%83%E5%BC%8F/%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql范式"><a href="#mysql范式" class="headerlink" title="mysql范式"></a>mysql范式</h1><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式</strong>，英文名称为<code>Normal Form</code>，简称<code>NF</code>。可以理解为，<strong>一张数据表的设计结构需要满足的某种设计标准的级别</strong>。要想设计一个结构合理的关系型数据库，必须满足一定的范式</p><p>目前关系型数据库有六种常见范式，按照范式级别，从<strong>低到高</strong>分别是：<strong>第一范式</strong>（<code>1NF</code>）、<strong>第二范式</strong> （<code>2NF</code>）、<strong>第三范式</strong>（<code>3NF</code>）、<strong>巴斯-科德范式</strong>（<code>BCNF</code>）、<strong>第四范式</strong>(<code>4NF</code>）和<strong>第五范式</strong>（<code>5NF</code>，又称完美范式）。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/66b5891b241d191286f6db87f4c593df.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7b20dde77ec3710676394c37916274d.png" alt="在这里插入图片描述"></p><p>ps:类似于架构师了解-能提升项目的运行速度-对表字段处理，工作很难处理</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-锁</title>
    <link href="/2024/09/30/mysql/%E9%94%81/%E9%94%81/"/>
    <url>/2024/09/30/mysql/%E9%94%81/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/54d52160d5508c502fc7aca831290dd9.png" alt="在这里插入图片描述"></p><h5 id="1-全局锁演示"><a href="#1-全局锁演示" class="headerlink" title="1.全局锁演示"></a>1.全局锁演示</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/85e7f9ae75ed8aef4a4e2e92ac1046fa.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61d33f96df7baf15aaf47b04001d699d.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61d33f96df7baf15aaf47b04001d699d.png" alt="在这里插入图片描述"></p><p>全局锁缺点</p><ul><li>如果在<strong>主库</strong>上备份，那么在<strong>备份期间都不能执行更新，在此期间非查询业务无法正常执行</strong>。</li><li>如果在<strong>从库</strong>上备份，那么在<strong>备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</strong>。</li></ul><h5 id="2-表锁演示"><a href="#2-表锁演示" class="headerlink" title="2.表锁演示"></a>2.表锁演示</h5><p>共享锁</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/caa3aa202b4f3908e58b6632c3988f32.png" alt="在这里插入图片描述"></p><p>独占锁</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c827ade0130b2199aeb482565b390017.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d08c155cfb954f9537ec88427e45564b.png" alt="d08c155cfb954f9537ec88427e45564b"></p><h5 id="3-元数据锁"><a href="#3-元数据锁" class="headerlink" title="3.元数据锁"></a>3.元数据锁</h5><p>元数据锁（meta data lock），简写<code>MDL</code>。其加锁过程是<strong>系统自动控制的，无需显式调用，在访问一张表的时候会自动加上</strong>。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。</p><p>事务-不允许写</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240930102913710.png" alt="image-20240930102913710"></strong></p><h5 id="4-意向锁的具体作用"><a href="#4-意向锁的具体作用" class="headerlink" title="4.意向锁的具体作用"></a>4.意向锁的具体作用</h5><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5635460a65d87661a7d75c78d116ec9f.png" alt="在这里插入图片描述"></p><ul><li>首先客户端一，开启一个事务，然后根据索引执行DML操作，会对涉及到的行加行锁。当客户端二，想对这张表加表锁时，会逐行检查当前表是否有对应的行锁，如果没有，则添加表锁，由于会从第一行数据，检查到最后一行数据，效率较低。</li></ul><p>有了意向锁之后 :</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f88a67eafdc1659450b443811b9856c3.png" alt="在这里插入图片描述"></p><ul><li>客户端一，在执行DML操作时，在加行锁的同时也会对该表加上意向锁。此时其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了 ，极大的提高了效率。</li></ul><h6 id="意向锁分类"><a href="#意向锁分类" class="headerlink" title="意向锁分类"></a>意向锁分类</h6><p>意向锁又分为：</p><p><strong>意向共享锁(IS)</strong>: 由语句select … lock in share mode添加 。与 表<strong>锁共享锁 (read)兼容，与表锁独占锁(write)互斥。</strong></p><p><strong>意向排他锁(IX)</strong>: 由insert、update、delete、select…for update添加 。<strong>与表锁共享锁(read)及独占锁(write)都互斥，意向锁之间不会互</strong>斥。<br>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><p>意向共享锁与表读锁是兼容的：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1920b5dc0b0e0e6a50453b4f4bc41a38.png" alt="在这里插入图片描述"></p><p>意向排他锁与表读锁、写锁都是互斥的：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b3a52fb8af7672ba10977dc2a84b34e4.png" alt="在这里插入图片描述"></p><h5 id="5-行锁"><a href="#5-行锁" class="headerlink" title="5.行锁"></a>5.行锁</h5><p><strong>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</strong>，也就是说<strong>根据索引字段操作数据</strong>行才生效，否则行锁会升级为表锁。</p><h6 id="1-行锁"><a href="#1-行锁" class="headerlink" title="1.行锁"></a>1.行锁</h6><ul><li><strong>行锁</strong>（Record Lock）：<strong>锁定单个行记录的锁</strong>，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f93b1f4f1efae4c1ab3b52297d14b9cb.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/56bbc8d75de1ba5fd52386c30f710917.png" alt="56bbc8d75de1ba5fd52386c30f710917"></p><h6 id="2-间隙锁"><a href="#2-间隙锁" class="headerlink" title="2.间隙锁"></a>2.间隙锁</h6><ul><li><strong>间隙锁</strong>（Gap Lock）：<strong>锁定索引记录间隙</strong>（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240930105157928.png" alt="image-20240930105157928"></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7234d2e32be56fdd45839c6067e3e652.png" alt="在这里插入图片描述"></p><h6 id="3-临间锁"><a href="#3-临间锁" class="headerlink" title="3.临间锁"></a>3.临间锁</h6><p>行锁和间隙锁组合，<strong>同时锁住数据以及数据前面的间隙Gap</strong>。 在RR隔离级别下支持</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6eb7a7d58e33e3a19d9cd5ce49620b28.png" alt="在这里插入图片描述"></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用临键 (next-key) 锁进行搜索和索引扫描，以防止幻读。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 触发器</title>
    <link href="/2024/09/29/mysql/%E8%A7%A6%E5%8F%91%E5%99%A8/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2024/09/29/mysql/%E8%A7%A6%E5%8F%91%E5%99%A8/%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/435040c5d3ab07529ec0571e4230e04e.png" alt="在这里插入图片描述"></p><h5 id="1-执行器作用"><a href="#1-执行器作用" class="headerlink" title="1.执行器作用"></a>1.执行器作用</h5><p>drop</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bf6d4998e717364090e0b0f5abb38402.png" alt="在这里插入图片描述"></p><h5 id="2-相关语法"><a href="#2-相关语法" class="headerlink" title="2.相关语法"></a>2.相关语法</h5><h6 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1d2b49b223780af1529a2f070a97a3fa.png" alt="在这里插入图片描述"></p><p>触发器中的SQL语句不能出现 SELECT * FROM TABLE 形式的查询 ，因为其会返回一个结果集 ，使用时会抛出错误Not allowed to return a result set from a trigger，可以使用SELECT INTO 为变量设置值。</p><p><strong>在使用插入&#x2F;更新触发器时，由于MySQL的写锁，无法在触发器内再次定义对当前表的更新或插入SQL语句。</strong></p><h6 id="2-查看"><a href="#2-查看" class="headerlink" title="2.查看"></a>2.查看</h6><h6 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h6><h5 id="日志记录添加"><a href="#日志记录添加" class="headerlink" title="日志记录添加"></a>日志记录添加</h5><p>使用触发器可以快捷的记录表数据变更日志。接下来我们通过触发器记录 user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除，学习三种触发器的使用。</p><p>使用方法</p><h6 id="1-创建表-日志记录表"><a href="#1-创建表-日志记录表" class="headerlink" title="1.创建表+日志记录表"></a>1.创建表+日志记录表</h6><h6 id="2-创建insert触发器"><a href="#2-创建insert触发器" class="headerlink" title="2.创建insert触发器"></a>2.创建insert触发器</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> user_insert_trigger<br><span class="hljs-comment">-- 每次在user表执行完插入操作之后触发</span><br>after <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-comment">-- 在日志表插入操作日志</span><br><span class="hljs-comment">-- 通过 new 可以获得新插入的数据行记录</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="hljs-string">&#x27;插入的数据内容为: id=&#x27;</span>,new.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,new.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>,NEW.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, NEW.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, NEW.profession));<br><span class="hljs-keyword">end</span>;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0614efb1acbf4eae7fc2e356225ad288.png" alt="在这里插入图片描述"></p><h6 id="3-update"><a href="#3-update" class="headerlink" title="3.update"></a>3.update</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> user_update_trigger<br><span class="hljs-comment">-- 每次在user表执行完更新操作之后触发</span><br><span class="hljs-keyword">after</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <br><span class="hljs-keyword">VALUES</span><br><span class="hljs-comment">-- 在日志表插入操作日志</span><br><span class="hljs-comment">-- 通过 new 可以获得修改之后的数据行记录</span><br><span class="hljs-comment">-- 通过 old 可以获得修改之前的数据行记录</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;update&#x27;</span>, now(), <span class="hljs-built_in">new</span>.id,concat(<span class="hljs-string">&#x27;更新之前的数据: id=&#x27;</span>,<span class="hljs-built_in">old</span>.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,<span class="hljs-built_in">old</span>.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>, <br><span class="hljs-built_in">old</span>.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, <span class="hljs-built_in">old</span>.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, <span class="hljs-built_in">old</span>.profession,<span class="hljs-string">&#x27; | 更新之后的数据: id=&#x27;</span>,<span class="hljs-built_in">new</span>.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,<span class="hljs-built_in">new</span>.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>, <span class="hljs-built_in">NEW</span>.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, <span class="hljs-built_in">NEW</span>.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, <span class="hljs-built_in">NEW</span>.profession));<br><span class="hljs-keyword">end</span>;<br><br></code></pre></td></tr></table></figure><h6 id="4-delete型触发器"><a href="#4-delete型触发器" class="headerlink" title="4.delete型触发器"></a>4.delete型触发器</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> user_delete_trigger<br><span class="hljs-comment">-- 每次在user表执行完删除操作之后触发</span><br><span class="hljs-keyword">after</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <br><span class="hljs-keyword">VALUES</span><br><span class="hljs-comment">-- 在日志表插入操作日志</span><br><span class="hljs-comment">-- 通过 old 可以获得已经删除的数据行记录</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;delete&#x27;</span>, now(), <span class="hljs-built_in">old</span>.id,concat(<span class="hljs-string">&#x27;删除之前的数据: id=&#x27;</span>,<span class="hljs-built_in">old</span>.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,<span class="hljs-built_in">old</span>.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>, <span class="hljs-built_in">old</span>.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, <span class="hljs-built_in">old</span>.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, <span class="hljs-built_in">old</span>.profession));<br> <span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d339d141f23a9fe9c3f35a0364ad19e3.png" alt="在这里插入图片描述"></p><p>作用:自带一个快照记录-不需要spring我们写框架</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-树和二叉树</title>
    <link href="/2024/09/28/data%20structure/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/09/28/data%20structure/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h4 id="6-1-1-树的定义"><a href="#6-1-1-树的定义" class="headerlink" title="6.1.1 树的定义"></a>6.1.1 树的定义</h4><h5 id="6-1-1-1树的概念"><a href="#6-1-1-1树的概念" class="headerlink" title="6.1.1.1树的概念"></a>6.1.1.1树的概念</h5><p>树是一种非线性结构,它由节点和边组成。节点之间通过边连接.<br>由n(n&gt;&#x3D;o)个节点的有限集。n&#x3D;0表示空树</p><p> n&gt;1时满足:<br><strong>1.有且只有一个根结点并在最顶层</strong></p><p><strong>2.其余结点分成互不相交的 M 个子集,每个子集又是一颗树。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/01ae4e3f3ab40d0d6ee722cca213d94f.png" alt="01ae4e3f3ab40d0d6ee722cca213d94f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925214411226.png" alt="image-20240925214411226"></p><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c7899e91cf258a2e5aeb58cf6a8abf39.png" alt="c7899e91cf258a2e5aeb58cf6a8abf39"></p><h5 id="6-1-2-树的逻辑结构表示"><a href="#6-1-2-树的逻辑结构表示" class="headerlink" title="6.1.2 树的逻辑结构表示"></a>6.1.2 树的逻辑结构表示</h5><h5 id="6-1-3-树的基本术语"><a href="#6-1-3-树的基本术语" class="headerlink" title="6.1.3  树的基本术语"></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925214728851.png" alt="image-20240925214728851">6.1.3  树的基本术语</h5><p>6.2</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925215050252.png" alt="image-20240925215050252"></p><p>1234 探讨的是节点的度</p><p>节点位置探讨  5 6-&gt;对套 </p><p>抽象节点 7 -&gt;包括孩子和孙子</p><p>8 _&gt;H E C A 只要能找到对应父节点就继续</p><p>9  父节点下   同分支下-兄弟节点(节点层次相同 )</p><p>10 树的高度</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6283648c2434efb19dab8c70ed2347bb.png" alt="6283648c2434efb19dab8c70ed2347bb"></p><p>11 </p><h6 id="6-1-4-树的性质"><a href="#6-1-4-树的性质" class="headerlink" title="6.1.4  树的性质"></a>6.1.4  树的性质</h6><h6 id="1-树的节点数"><a href="#1-树的节点数" class="headerlink" title="1.树的节点数"></a>1.树的节点数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7b0b909debd7b65958998b710e0b4bc2.png" alt="7b0b909debd7b65958998b710e0b4bc2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b81c4239fcc6a1bd1ce83c3f1844d5be.png" alt="b81c4239fcc6a1bd1ce83c3f1844d5be"></p><p>节点数&#x3D;总度数(数线或者自己遍历)+1</p><p>例如 A的度数 2 B  C1 G 1省  3+2+1+1+2+3&#x3D;12-再加上A-就是总度数</p><h6 id="2-度为m的数第i层至多节点"><a href="#2-度为m的数第i层至多节点" class="headerlink" title="2.度为m的数第i层至多节点"></a>2.度为m的数第i层至多节点</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925221552376.png" alt="image-20240925221552376"></p><h6 id="3-高度为h-m次树至多有多少个节点"><a href="#3-高度为h-m次树至多有多少个节点" class="headerlink" title="3.高度为h  m次树至多有多少个节点"></a>3.高度为h  m次树至多有多少个节点</h6><p>例如高度4    -3次树</p><p>“m 次树”指的是 <strong>每个节点的度最多为 m 的树</strong>，即每个节点最多可以有 m 个子节点。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925221953903.png" alt="image-20240925221953903"></p><p>3<em>3</em>3*3&#x3D;81-1&#x3D;80&#x2F;2&#x3D;40</p><p>手算</p><p>A(3)  9 -              9*3&#x3D;27 -27+9+1&#x3D;37+BCD &#x3D;40手算也能对上</p><h5 id="6-1-5-树的基本运算"><a href="#6-1-5-树的基本运算" class="headerlink" title="6.1.5 树的基本运算"></a>6.1.5 树的基本运算</h5><h6 id="1-树的运算"><a href="#1-树的运算" class="headerlink" title="1.树的运算"></a>1.树的运算</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925222425649.png" alt="image-20240925222425649"></p><h6 id="2-树的遍历"><a href="#2-树的遍历" class="headerlink" title="2.树的遍历"></a>2.树的遍历</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a8c012d28887d403fce53fd6b0d2eb9.png" alt="2a8c012d28887d403fce53fd6b0d2eb9"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925215050252.png" alt="image-20240925215050252"></p><h5 id="6-1-6树的存储结构"><a href="#6-1-6树的存储结构" class="headerlink" title="6.1.6树的存储结构"></a>6.1.6树的存储结构</h5><p>计算机中-树存储着节点的值-还有节点与节点间的关系</p><h6 id="1-双亲存储结构"><a href="#1-双亲存储结构" class="headerlink" title="1.双亲存储结构"></a>1.双亲存储结构</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e0d9cb587ce9a54d3ffe777dfb242eb5.png" alt="e0d9cb587ce9a54d3ffe777dfb242eb5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/302b2416bd1ef27490005e7e122998bd.png" alt="302b2416bd1ef27490005e7e122998bd"></p><h6 id="2-孩子链表存储结构"><a href="#2-孩子链表存储结构" class="headerlink" title="2.孩子链表存储结构"></a>2.孩子链表存储结构</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e99ab18983dc7dabb1b8967997daed09.png" alt="e99ab18983dc7dabb1b8967997daed09"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0d79d9d1aac810a3ec7802fe69b5fb16.png" alt="0d79d9d1aac810a3ec7802fe69b5fb16"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0db38af72b0e41685ea731c78216f257.png" alt="0db38af72b0e41685ea731c78216f257"></p><p>用空间换来部分算法遍历</p><h6 id="3-孩子兄弟表示法"><a href="#3-孩子兄弟表示法" class="headerlink" title="3.孩子兄弟表示法"></a>3.孩子兄弟表示法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e4784c0f99fccd18533be7f3af34cde5.png" alt="e4784c0f99fccd18533be7f3af34cde5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925224029517.png" alt="image-20240925224029517"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925224041108.png" alt="image-20240925224041108"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树的每个节点最多只有2个后继节点，度最大为2</p><h4 id="6-2-1二叉树的定义"><a href="#6-2-1二叉树的定义" class="headerlink" title="6.2.1二叉树的定义"></a>6.2.1二叉树的定义</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a95b854c64b1ee12a514fef8416e13a4.png" alt="a95b854c64b1ee12a514fef8416e13a4"></p><p><strong>逻辑表示</strong></p><blockquote><p>注意“二叉树是度为2 的树”这句话是错的，二叉树可能度为0，度为1或者度为2，所以二叉树的度≤2</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/662d28dac95d48fce16b08859f1f7f6c.png" alt="662d28dac95d48fce16b08859f1f7f6c"></p><p>例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/25e4ad07ef50280efe9411bd04d624d5.png" alt="25e4ad07ef50280efe9411bd04d624d5"></p><h4 id="6-2-2-二叉树的性质"><a href="#6-2-2-二叉树的性质" class="headerlink" title="6.2.2 二叉树的性质"></a>6.2.2 二叉树的性质</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b10626d48c710df1a3750b31a7677610.png" alt="b10626d48c710df1a3750b31a7677610"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b3c33e0f0c0ff70793de170f1c269be.png" alt="1b3c33e0f0c0ff70793de170f1c269be"></p><p>n 0-&gt;叶子节点个数–</p><p>n2-是度&#x3D;2的节点个数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bab76beffd19b333ecde671999c88014.png" alt="bab76beffd19b333ecde671999c88014"></p><p>C</p><h5 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a><strong>特殊二叉树</strong></h5><h6 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1.斜树"></a>1.斜树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240927084532399.png" alt="image-20240927084532399"></p><h6 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2.满二叉树"></a>2.满二叉树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4474f58dbbba4b0fdbd67039efabe3d.png" alt="c4474f58dbbba4b0fdbd67039efabe3d"></p><p>高度为h–2h次方-1  -节点最多的情况</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fdcde068645aa8213c505f9cb0530bb4.png" alt="fdcde068645aa8213c505f9cb0530bb4"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240927095359810.png" alt="image-20240927095359810"></p><p>计算节点最多情况-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0456a0c483c46ebb194c776bbaadd82e.png" alt="0456a0c483c46ebb194c776bbaadd82e"></p><h6 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3.完全二叉树"></a>3.完全二叉树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/da5cec1b77459a3e828b2787860b6332.png" alt="da5cec1b77459a3e828b2787860b6332"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240927085503364.png" alt="image-20240927085503364"></p><p>完全二叉树特性 </p><p><strong>完全二叉树实际上-对应的是满二叉树删除叶节点最右边若干个节点得到的</strong></p><p>二叉树中至多只有最下边两层节点的读书小于2 ，并且二叉树中任意一个节点的右子树高度为h.则左子树的高度只能是h或h+1，因此高度为h的完全二叉树若按层次从上到下，从左到右自然数编号，它与高度为h的满二叉树中节点的编号一一对应</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a6c977d73728864a0eab7b144691e7c2.png" alt="a6c977d73728864a0eab7b144691e7c2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de3e93b1a8cad0f48552d2c5ec2897b2.png" alt="de3e93b1a8cad0f48552d2c5ec2897b2"></p><p>n 1是度为1</p><h6 id="3-1完全二叉树-父节点-左孩-右孩计算"><a href="#3-1完全二叉树-父节点-左孩-右孩计算" class="headerlink" title="3.1完全二叉树  父节点 左孩 右孩计算"></a>3.1完全二叉树  父节点 左孩 右孩计算</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/58572e8e7507955a5d1a96368b707eb6.png" alt="58572e8e7507955a5d1a96368b707eb6"></p><h6 id="4-完全二叉树叶子节点计算"><a href="#4-完全二叉树叶子节点计算" class="headerlink" title="4.完全二叉树叶子节点计算"></a>4.完全二叉树叶子节点计算</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241026224328393.png" alt="image-20241026224328393"></p><blockquote><p>满二叉树<br>2 h~1 4<br>节点书 7&#x3D;叶子节点+n2</p><p>叶子节点&#x3D;n2+1 度为2的所有节点+1</p><p>7&#x3D;n2+n2+1&#x3D;2n&#x3D;<br>n&#x3D;3</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241026224822857.png" alt="image-20241026224822857"></p><p>偶数情况</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241026225050498.png" alt="image-20241026225050498"></p><h4 id="6-2-3-二叉树的存储结构"><a href="#6-2-3-二叉树的存储结构" class="headerlink" title="6.2.3 二叉树的存储结构"></a>6.2.3 二叉树的存储结构</h4><h5 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5485d6355af906601e5a9fd3e33a3b53.png" alt="5485d6355af906601e5a9fd3e33a3b53"></p><p>双亲就是节点I&#x2F;2&#x3D;双亲</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b491c0176ee7c01a6a65ddeb325698ce.png" alt="b491c0176ee7c01a6a65ddeb325698ce"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0cc795511b49146f1acf2603434e87b8.png" alt="0cc795511b49146f1acf2603434e87b8"></p><p><strong>可以先画满的再自己擦除</strong></p><p>具有空间浪费<br>特点总结</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5b6b2e941ef139a1373de2bbfdf162aa.png" alt="5b6b2e941ef139a1373de2bbfdf162aa"></p><h5 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ad0feb90a20cbdbbf7e34fd211d3bc93.png" alt="ad0feb90a20cbdbbf7e34fd211d3bc93"></p><p>叶子节点特点-左右都为空<br>左 数据 右</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b02ee522a627db1efaf6e5de7e2f30c5.png" alt="b02ee522a627db1efaf6e5de7e2f30c5"></p><p>二叉树特点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c0f72288f4f5a88f2e2f3841557eeab6.png" alt="c0f72288f4f5a88f2e2f3841557eeab6"></p><p>—找双亲不方便 可以写三链式表</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20f493db431b79d51749bc0800751a2c.png" alt="20f493db431b79d51749bc0800751a2c"></p><p> 存储双亲链</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69e06d709b1f95592ac17e6c71cb337a.png" alt="69e06d709b1f95592ac17e6c71cb337a"></p><h4 id="6-2-4-递归算法设计"><a href="#6-2-4-递归算法设计" class="headerlink" title="6.2.4 递归算法设计"></a>6.2.4 递归算法设计</h4><h5 id="1-递归算法了解"><a href="#1-递归算法了解" class="headerlink" title="1.递归算法了解"></a>1.递归算法了解</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240928170946087.png" alt="image-20240928170946087"></p><p>递归模型 递归出口-递归的终止条件 递归体 递归求解的递推关系</p><h5 id="2-二叉树的递归算法设计"><a href="#2-二叉树的递归算法设计" class="headerlink" title="2.二叉树的递归算法设计"></a>2.二叉树的递归算法设计</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240928171809445.png" alt="image-20240928171809445"></p><blockquote><p>整个递归过程的关键在于，从树的最底层（叶节点）开始计算，每次计算当前节点的值并将结果返回给上一层，最终返回根节点的总和。图中箭头所示就是递归函数从叶节点向上返回的过程。</p><p>这个递归实现了树的后序遍历（左子树 -&gt; 右子树 -&gt; 根节点），每个节点都只被访问一次，因此时间复杂度为 O(n)，其中 n 是树中节点的总数。</p></blockquote><h4 id="6-4二叉树的基本运算"><a href="#6-4二叉树的基本运算" class="headerlink" title="6.4二叉树的基本运算"></a>6.4二叉树的基本运算</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3a084bee096c8c290d381bafe81ad77e.png" alt="3a084bee096c8c290d381bafe81ad77e"></p><h6 id="1-二叉树初始化"><a href="#1-二叉树初始化" class="headerlink" title="1.二叉树初始化"></a>1.二叉树初始化</h6><p>通过字符来规范树的结构-读取字符进行处理二叉树</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929091845554.png" alt="image-20240929091845554"></p><h6 id="2-销毁二叉树"><a href="#2-销毁二叉树" class="headerlink" title="2.销毁二叉树"></a>2.销毁二叉树</h6><p>递归算法-结束条件结束bt&#x3D;&#x3D;null</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de46920865c40f0027f69978f5cf953d.png" alt="de46920865c40f0027f69978f5cf953d">jhs</p><h6 id="3-高度计算"><a href="#3-高度计算" class="headerlink" title="3.高度计算"></a>3.高度计算</h6><p>f(bt)&#x3D;0; bt&#x3D;null </p><p>max(f(bt-&gt;lchild),f(bt-&gt;rchild))+1;&#x2F;&#x2F;遍历左右子树-谁高就是谁大</p><p>递归代码</p><p>递归结束-左右子树都为空</p><p>int BThight(BtNode *&amp;bt)</p><p>{</p><p>int lchildddep,rchildddep;</p><p>if(bt &#x3D;null) return 0;</p><p>else</p><p>{</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929093243686.png" alt="image-20240929093243686"></p><p>}</p><p>}</p><p>从根节点的左右子树遍历下去-嵌套很深</p><h6 id="4-求二叉树个数"><a href="#4-求二叉树个数" class="headerlink" title="4.求二叉树个数"></a>4.求二叉树个数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dba716586b9766fa6609c8ae656009f9.png" alt="dba716586b9766fa6609c8ae656009f9"></p><h6 id="5-求二叉树叶子节点个数"><a href="#5-求二叉树叶子节点个数" class="headerlink" title="5.求二叉树叶子节点个数"></a>5.求二叉树叶子节点个数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929094209725.png" alt="image-20240929094209725"></p><h6 id="6-输出二叉树"><a href="#6-输出二叉树" class="headerlink" title="6.输出二叉树"></a>6.输出二叉树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929094316839.png" alt="image-20240929094316839"></p><h4 id="6-5二叉树的遍历"><a href="#6-5二叉树的遍历" class="headerlink" title="6.5二叉树的遍历"></a>6.5二叉树的遍历</h4><h6 id="1-前序"><a href="#1-前序" class="headerlink" title="1.前序"></a>1.前序</h6><p>若二叉树不为空 -<strong>根-&gt;左右</strong></p><p>递归算法</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">void pRi(BtNode*ps)<br>&#123;<br><span class="hljs-comment">//打印</span><br><span class="hljs-function"><span class="hljs-title">pRi</span>（ps-&gt;</span>lchid);<br><span class="hljs-function"><span class="hljs-title">pRi</span>（ps-&gt;</span>light);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f138432e6f5e955d55bd5d98e141654.png" alt="2f138432e6f5e955d55bd5d98e141654"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929095621970.png" alt="image-20240929095621970"></p><h6 id="2-中序"><a href="#2-中序" class="headerlink" title="2.中序"></a>2.中序</h6><p>左根右</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929152947372.png" alt="image-20240929152947372"></p><p>D  </p><h6 id="3-后序"><a href="#3-后序" class="headerlink" title="3.后序"></a>3.后序</h6><p>左右根</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41fbf8580631e99424e120e5ca9a77aa.png" alt="41fbf8580631e99424e120e5ca9a77aa"></p><h6 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4.层次遍历"></a>4.层次遍历</h6><p>根节点开始-从上向下-同一层从左到右访问节点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241002113334235.png" alt="image-20241002113334235"></p><p>算法剖析</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/895fb13aedccbf010940ab93b8087956.png" alt="895fb13aedccbf010940ab93b8087956"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>遍历代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">void</span> <span class="hljs-keyword">function</span><span class="hljs-params">(bt )</span><br><br>&#123;<br><span class="hljs-keyword">if</span>(bt !=<span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-comment">//左子树递归</span><br><br><span class="hljs-comment">//右子树递归</span><br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>前序-中序-后续-的打印结束根据名字来定-考场如果立马思考还是需要时间的</p><p>其实依照打印顺序递归也是好想的</p><p>序名字-就是根的位置 根左右 左根右  左右 根</p><h4 id="6-6二叉树与树的转换"><a href="#6-6二叉树与树的转换" class="headerlink" title="6.6二叉树与树的转换"></a>6.6二叉树与树的转换</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7d9e0739061552757808aec6378120f.png" alt="e7d9e0739061552757808aec6378120f"></p><h5 id="树转换二叉树"><a href="#树转换二叉树" class="headerlink" title="树转换二叉树"></a>树转换二叉树</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/622b4d4f245461d8be3ca14d6e3b15dd.png" alt="622b4d4f245461d8be3ca14d6e3b15dd"></p><p>完整步骤-下面是取巧方法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5b4b9c524156637cc996abcffb0d8b42.png" alt="5b4b9c524156637cc996abcffb0d8b42"></p><p>二叉树-孩子兄弟表示法来表示</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf66ae5f78081ceed0bbcd68108269f0.png" alt="cf66ae5f78081ceed0bbcd68108269f0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/801021d1130c2d06689ee6fd40df4363.png" alt="801021d1130c2d06689ee6fd40df4363"></p><p>串糖葫芦就是右指针串</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c3b15ecc621f90209999ae47cc50ff1e.png" alt="c3b15ecc621f90209999ae47cc50ff1e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/32fabb4a65cd7c2321c855138a7fd4a5.png" alt="32fabb4a65cd7c2321c855138a7fd4a5"></p><h5 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h5><p>ps:基本不变-就是根节点线串完后-依次遍历每个节点下的数据</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0f7ad89c2a69e255c33462ca40776a1.png" alt="b0f7ad89c2a69e255c33462ca40776a1"></p><h6 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h6><p>1.过程转换</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/807d51501d1fe2e9a0df54469e5c575b.png" alt="807d51501d1fe2e9a0df54469e5c575b"></p><p>A-&gt;B右节点有节点-把整个右节点拆下来-同级</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e1b66ba68902f52be920db26447511ba.png" alt="e1b66ba68902f52be920db26447511ba"></p><p>层次顺序恢复</p><h6 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41d4761d60810b7afa9adc41a32d04d2.png" alt="41d4761d60810b7afa9adc41a32d04d2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fa16db114f3f3a7b83aa5fcff23d87c3.png" alt="fa16db114f3f3a7b83aa5fcff23d87c3"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/14c21c3116f7006f21055379645b964a.png" alt="14c21c3116f7006f21055379645b964a"></p><p>注意-简化二叉树下-什么是树-什么是森林</p><h4 id="6-7-哈夫曼树"><a href="#6-7-哈夫曼树" class="headerlink" title="6.7 哈夫曼树"></a>6.7 哈夫曼树</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/883c38cc630cab12b5a3220fd7a6e13f.png" alt="883c38cc630cab12b5a3220fd7a6e13f"></p><h5 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/84dfcde5443298f385743c0a30c4b59b.png" alt="84dfcde5443298f385743c0a30c4b59b"></p><p>树的带权路径长度</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ba23ebc2fc457072454df04454a73599.png" alt="ba23ebc2fc457072454df04454a73599"></p><p>*<em>叶子节点的权值-<em>根节点到达叶子经过的边数-之和</em></em></p><h5 id="哈夫曼树的定义-构造"><a href="#哈夫曼树的定义-构造" class="headerlink" title="哈夫曼树的定义-构造"></a>哈夫曼树的定义-构造</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c230d613341cbbe8987c5d8c24c0c64f.png" alt="c230d613341cbbe8987c5d8c24c0c64f"></p><p>哈夫曼树的构造</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79037578c43a7b2a4214a3b77a73db78.png" alt="79037578c43a7b2a4214a3b77a73db78"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/232fd0bc9072a29e517862fa4728481f.png" alt="232fd0bc9072a29e517862fa4728481f"></p><p><strong>将最小和的叶子节点结合-会生成新的节点-其中-必须是叶子节点</strong></p><h5 id="哈夫曼树的编码"><a href="#哈夫曼树的编码" class="headerlink" title="哈夫曼树的编码"></a>哈夫曼树的编码</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd09b925000470bf88be7e398862b5ed.png" alt="dd09b925000470bf88be7e398862b5ed"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1807433cf1f909098a45132e719e9dc9.png" alt="1807433cf1f909098a45132e719e9dc9"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a54437e61b3c0679bfc274267c4ce02.png" alt="0a54437e61b3c0679bfc274267c4ce02"></p><p>2.重新规范ABCD编码</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/23e2f727ac1a7378b3e3eb6f7913b2f8.png" alt="23e2f727ac1a7378b3e3eb6f7913b2f8"></p><p>前缀编码</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd74ab00537f2ddbf29be1294321dd55.png" alt="dd74ab00537f2ddbf29be1294321dd55"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/35ed23fa61ff32a789b564424a8a7fbc.png" alt="35ed23fa61ff32a789b564424a8a7fbc"></p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ff3d2e49788f93e7b2171b2b6cffdfdf.png" alt="ff3d2e49788f93e7b2171b2b6cffdfdf"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql SQL优化</title>
    <link href="/2024/09/27/mysql/sql%E4%BC%98%E5%8C%96/sql%E4%BC%98%E5%8C%96/"/>
    <url>/2024/09/27/mysql/sql%E4%BC%98%E5%8C%96/sql%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/56525dee22310c3f2e41b9350df824be.png" alt="在这里插入图片描述"></p><h4 id="1-插入优化"><a href="#1-插入优化" class="headerlink" title="1.插入优化"></a>1.插入优化</h4><h6 id="1-3-小规模"><a href="#1-3-小规模" class="headerlink" title="1-3 小规模"></a>1-3 小规模</h6><p>1.批量插入数据</p><p>由于每次<code>insert</code>都需要<strong>与数据库建立连接，进行网络传输导致一定的性能损失</strong>，我们可以选择一次性插入多条数据，代替一条一条插入。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">Insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure><p>2.手动控制事务</p><p>mysql-事务是默认开启的-我们避免多次开启事务</p><p>– 多条插入手动控制事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span>  transaction;   <span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;    <span class="hljs-comment">-- 提交事务</span><br></code></pre></td></tr></table></figure><p>3.主键顺序插入</p><p>由于主键索引的存在，每次插入数据都可能会重新组织索引结构，因此，主键顺序插入，性能要高于乱序插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-- 主键乱序插入 : <span class="hljs-number">8</span>  <span class="hljs-number">1</span>  <span class="hljs-number">9</span>  <span class="hljs-number">21</span>  <span class="hljs-number">88</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span>  <span class="hljs-number">15</span>  <span class="hljs-number">89</span>  <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">3</span>  <br>-- 主键顺序插入 : <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">15</span>  <span class="hljs-number">21</span>  <span class="hljs-number">88</span>  <span class="hljs-number">89</span><br>insert  into  tb_test  <span class="hljs-title function_">values</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>)</span>,(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);  -- 顺序插入<br>insert  into  tb_test  <span class="hljs-title function_">values</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>)</span>,(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);  -- 乱序插入<br><br></code></pre></td></tr></table></figure><h6 id="4大规模"><a href="#4大规模" class="headerlink" title="4大规模"></a>4大规模</h6><p>如果<strong>一次性需要插入大批量数</strong>据(比如: <strong>几百万</strong>的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的<code>load</code>指令进行插入。通过<code>load</code>指令我们可以一次性将本地文件当中的数据全部加载进数据库表结构中。<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/060eb4a390baed91d42dbafbb67d4bb1.png" alt="在这里插入图片描述"></p><p>教程分析</p><ul><li>（1）客户端连接服务端时，加上参数 <code>-–local-infile</code></li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">mysql –-<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span> -<span class="hljs-keyword">u</span> root -p <br>-- -–<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span> 表示需要加载本地文件<br><br></code></pre></td></tr></table></figure><p>2）设置全局参数local_infile为1，<strong>开启从本地加载文件导入数据的开关</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">set  global  local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>3.执行load指令将准备好的数据，加载到表结构中</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">load  data  local  <span class="hljs-keyword">infile</span>  <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span>  <span class="hljs-keyword">into</span>  <span class="hljs-keyword">table</span>  tb_user  fields  <br>terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;,&#x27;</span>  lines  terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;\n&#x27;</span> ; <br><br>--  local  <span class="hljs-keyword">infile</span>  <span class="hljs-string">&#x27;需要加载的文件路径&#x27;</span><br>--  <span class="hljs-keyword">into</span>  <span class="hljs-keyword">table</span>  需要插入到哪张表<br>--  fields terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;字段分隔符&#x27;</span><br>--  lines  terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;行分隔符&#x27;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ba34c5bb916b2d4568056afa7d1b1cd6.png" alt="在这里插入图片描述"></p><h4 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2.主键优化"></a>2.主键优化</h4><h6 id="1-长度优化、"><a href="#1-长度优化、" class="headerlink" title="1.长度优化、"></a>1.长度优化、</h6><p>对于一张表来说主键索引只有一个，但是二级索引可能会有很多个，在二级索引的叶子节点当中挂的就是数据的主键，因此，如果主键长度比较长且二级索引比较多，将会占用大量的磁盘空间。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed56d90914fcb7eb74b1dc528bedeca6.png" alt="在这里插入图片描述"></p><h6 id="2-顺序插入"><a href="#2-顺序插入" class="headerlink" title="2.顺序插入"></a>2.顺序插入</h6><p>在条件允许的情况下，使用<strong>AUTO_INCREMENT自增主键</strong>，顺序插入数据。</p><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，行数据都是存储在聚集索引的叶子节点上的。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/78ac6641a01aff35e1268d9bdda418a5.png" alt="在这里插入图片描述"></p><p>而数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2d46cccf85f29f6d184fb8869c2c448f.png" alt="在这里插入图片描述"></p><ul><li><strong>主键顺序插入效果</strong></li></ul><ol><li>从磁盘中申请页， 主键顺序插入</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/89aa4fd10beb58a5081e20dca93b12f5.png" alt="在这里插入图片描述"></p><ol><li>第一个页没有满，继续往第一页插入</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e09795c3279a42fa57d81077fc7897bf.png" alt="在这里插入图片描述"></p><ol><li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c5a5c659e3037fe313c6da8e2c798830.png" alt="在这里插入图片描述"></p><ol><li>当第二页写满了，再往第三页写入</li></ol><p>如此往复，没有任何额外损耗性能的情况。</p><hr><hr><hr><hr><hr><ul><li><strong>主键乱序插入效果</strong></li></ul><ol><li>假如1#,2#页都已经写满了</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/beecb78b62f4c4293c3941f4d6f7fc22.png" alt="在这里插入图片描述"></p><p>2.此时再插入id为50的记录</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8a37f6367be753c2b7dd632226de9120.png" alt="在这里插入图片描述"></p><ol><li>按照顺序，应该存储在47之后</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e726302bba2b570bdeb97b6794941f8a.png" alt="在这里插入图片描述"></p><ol><li>此时会开辟一个新的页 3#</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41561e3d67fb81472f003e4ccf361db5.png" alt="在这里插入图片描述"></p><ol><li>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/627ae2a4f6ea16c39adfd4883dbe4a3e.png" alt="在这里插入图片描述"></p><ol><li>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e613d530c9b354fd6eadc23f39ea0955.png" alt="在这里插入图片描述"></p><p>上述的这种现象，称之为 “<strong>页分裂</strong>”，是<strong>比较耗费性能的操作</strong>。</p><p>页分裂指的是：页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列</p><h6 id="3-避免修改主键"><a href="#3-避免修改主键" class="headerlink" title="3.避免修改主键"></a>3.避免修改主键</h6><p><strong>尽量不要使用有意义的值作为主键</strong>，如<strong>身份证号</strong>，避免在进行业务操作对主键产生修改操作。这是因为插入修改删除操作都会导致数据库重新组织索引结构。</p><h4 id="3-order-by"><a href="#3-order-by" class="headerlink" title="3..order by"></a>3..order by</h4><blockquote><p>MySQL的排序，有两种方式：</p><p>​       Using filesort : 通过表的索引或全表扫描，<strong>读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作</strong>，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。<br>​        Using index : <strong>通过有序索引顺序扫描直接返回有序数据</strong>，这种情况即为 using index，不需要 额外排序，操作效率高。<br>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序 操作时，尽量要优化为 Using index。</p></blockquote><ul><li>排序字段值没有索引，Using filesort</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bfbf5cb573a5f802a0feef7e5ddb0906.png" alt="在这里插入图片描述"></p><ul><li>为排序字段值创建索引后，Using index</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/040a4e4a9299a80247c2c3ccc211559a.png" alt="在这里插入图片描述"></p><hr><hr><hr><hr><hr><p>由于我们在MySQL中创建的索引，默认的叶子节点是<strong>从小到大</strong>排序的。如果我们在查询的时候，order by是从大到小即降序<strong>desc</strong>，那么除了出现 Using index， 也会出现了 <strong>Backward index scan，这个代表反向扫描索引。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/75d20fb4e48a34314567063cede4a652.png" alt="在这里插入图片描述"></p><p>– 语法<br>create index 索引名 on 表名(字段名 desc);</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1e51703ed292cf163b7d3fe6aa1aefea.png" alt="在这里插入图片描述"></p><hr><hr><hr><p>排序时,也需要满足最左前缀法则（与where条件不同的是，此时必须按照创建索引时的顺序进行排序）,否则也会出现 filesort。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c772524ca094db96a0cbb22e69097bee.png" alt="在这里插入图片描述"></p><p>因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort</p><hr><hr><hr><p>在条件允许的情况下，<strong>尽量使用覆盖索引代替</strong>*，否则由于回表查询依旧会出现Using filesort</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8c181657e433713b3bfe012a4c1dbfb0.png" alt="在这里插入图片描述"></p><h4 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4.group by优化"></a>4.group by优化</h4><p>与order by类似，分组就相当于大范围的排序。我们同样可以通过<strong>使用索引字段进行分组</strong>来提高效率。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ba73b7370f8289b90a0a0c156b0b110b.png" alt="img"></p><p>此外，对于分组操作，在使用联合索引时，也是符合最左前缀法则的。例如下面：我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f7fc0dc1171a2e7ed4a22b72e0e253f2.png" alt="在这里插入图片描述"></p><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f7fc0dc1171a2e7ed4a22b72e0e253f2.png" alt="在这里插入图片描述"></p><h4 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5..limit优化"></a>5..limit优化</h4><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。这是因为当在进行分页查询时，例如执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记 录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c133b1f99bc94db83f1d20357b16b3e0.png" alt="在这里插入图片描述"></p><p>通过测试我们会看到，分页越往后，查询效率越低。</p><ul><li>一般在进行分页查询时，我们可以通过 <strong>+ 子查询 使用覆盖索引 拿出id-进行筛选id</strong> 的形式进行优化以提高性能。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--  select  *  from  tb_sku limit 9000000,10;</span><br><span class="hljs-comment">-- 例如对于上述测试示例 9000000,10 我们可以进行如下优化</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>,<span class="hljs-number">10</span>) a <span class="hljs-keyword">where</span> t.id  <span class="hljs-operator">=</span>  a.id;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6677c2725704abac6ce8b7dda786329f.png" alt="在这里插入图片描述"></p><p>测试我们可以看到，耗费时间缩短了了近7秒，但是同时也增加了SQL语句复杂度，需要我们根据自身业务情况选择使用~</p><h4 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6..count优化"></a>6..count优化</h4><blockquote><p>在数据量很大的情况下，执行 <code>COUNT</code> 操作通常比较耗时。以下是针对不同存储引擎和优化方案的简化总结：</p><h3 id="MyISAM-与-InnoDB-的-COUNT-对比："><a href="#MyISAM-与-InnoDB-的-COUNT-对比：" class="headerlink" title="MyISAM 与 InnoDB 的 COUNT(*) 对比："></a>MyISAM 与 InnoDB 的 <code>COUNT(*)</code> 对比：</h3><ul><li><strong>MyISAM</strong>：表的总行数存储在磁盘上，执行 <code>COUNT(*)</code> 时可以直接返回结果，因此效率很高。</li><li><strong>InnoDB</strong>：需要逐行读取数据进行计数，因此 <code>COUNT(*)</code> 操作会较慢。</li></ul><h3 id="提升-InnoDB-表的-COUNT-效率："><a href="#提升-InnoDB-表的-COUNT-效率：" class="headerlink" title="提升 InnoDB 表的 COUNT(*) 效率："></a>提升 InnoDB 表的 <code>COUNT(*)</code> 效率：</h3><ol><li><strong>自定义计数</strong>：可以使用 Redis 等外部缓存数据库来存储计数。在插入&#x2F;删除数据时，分别进行加减操作，保持实时计数。</li><li><strong>优化 <code>COUNT</code> 的用法</strong>：<code>COUNT</code> 是聚合函数，计算时会逐行判断。如果参数不是 <code>NULL</code>，则进行累加。不同写法的效率不同。</li></ol><h3 id="COUNT-的不同用法："><a href="#COUNT-的不同用法：" class="headerlink" title="COUNT 的不同用法："></a><code>COUNT</code> 的不同用法：</h3><ul><li><p><code>COUNT(主键)</code>：遍历表，取出每一行的主键值并进行计数（主键不可能为 <code>NULL</code>）。</p></li><li><pre><code class="hljs">COUNT(字段)<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  ：<br><br>  - **无 `NOT NULL` 约束**：遍历表，取出每一行字段值，服务层判断是否为 `NULL`，不为 `NULL` 则累加。<br>  - **有 `NOT NULL` 约束**：直接累加。<br><br>- `COUNT(<span class="hljs-number">1</span>)`：遍历表，但不取值。服务层对每一行放入数字 “<span class="hljs-number">1</span>”，直接累加。<br><br>- `COUNT(*)`：引擎不取字段，直接逐行累加，效率较高。<br><br>### 效率排序：<br><br>- `COUNT(字段)` &lt; `COUNT(主键)` &lt; `COUNT(<span class="hljs-number">1</span>)` ≈ `COUNT(*)`，因此建议优先使用 `COUNT(*)`。<br><br>#### <span class="hljs-number">7</span>..update优化<br><br>InnoDB默认事务级别使用的是行锁，**但是行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁** 。也就是说在开启事务时：<br><br>- 我们能同时根据带有主**键索引的不同id字段修改行记录**-行锁<br><br></code></pre></td></tr></table></figure>update  course  set  name = &#39;javaEE&#39; where id  =  1 ;update  course  set  name = &#39;Vue&#39; where id  =  4 ;</code></pre></li></ul></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>但是无法同时根据不带索引的name字段修改行记录，因为此时行锁会升级为表锁，无法操作。<br><br></code></pre></td></tr></table></figure><p>update course set name &#x3D; ‘SpringBoot’ where name &#x3D; ‘PHP’ ;<br>update update course set name &#x3D; ‘SpringBoot’ where name &#x3D; ‘JS’ ;</p><pre><code class="hljs">**也就是说为了避免行锁升级为表锁影响执行效率，我们应当根据索引字段来进行更新操作。**</code></pre>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 存储过程</title>
    <link href="/2024/09/27/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/09/27/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5fc934f5c3f21ae0bf0e11fa1da2997.png" alt="在这里插入图片描述"></p><h4 id="存储过程的基本操作-1-2"><a href="#存储过程的基本操作-1-2" class="headerlink" title="存储过程的基本操作 (1-2)"></a>存储过程的基本操作 (1-2)</h4><h6 id="1-了解存储过程"><a href="#1-了解存储过程" class="headerlink" title="1.了解存储过程"></a>1.了解存储过程</h6><p>存储过程是<strong>事先经过编译并存储在数据库中的一段 SQL 语句的集合</strong>，调用存储过程可以简化应用开发人员的工作，<strong>可以减少数据在数据库和应用服务器之间的传输</strong>，提高数据处理的效率。 存储过程相当于数据库 SQL 语言层面的代码封装与重用。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/81a4dc8fae84dad88df4b91f4819f541.png" alt="在这里插入图片描述"></p><blockquote><p>可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。<br>类似于其他语言的函数(方法)，在使用存储过程中，可以传递参数，也可以接收返回值。<br>减少客户端与数据库的网络交互，提高执行效率，如果涉及到多条SQL执行，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></blockquote><p>在MySQL中，用户可以通过查询information_schema数据库下的Routines表的记录来查询存储过程的信息。</p><p>MySQL中用户可以使用SHOW STATUS语句或【SHOW CREATE PROCEDURE 存储过程名；】语句来查看存储过程，也可以直接从系统的information_schema数据库中查询。</p><p>在MySQL中可以使用【ALTER PROCEDURE 过程名称；】语句修改存储过程的特性。</p><h6 id="2-存储过程创建注意事项"><a href="#2-存储过程创建注意事项" class="headerlink" title="2.存储过程创建注意事项"></a>2.存储过程创建注意事项</h6><p>分号错误</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e9a127dff3080aec7ceae81b655ef24f.png" alt="在这里插入图片描述"></p><p>通过关键字 <code>delimiter</code><strong>重新指定SQL语句的结束符</strong>,</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62d1ca8ad004f80a5f8f8347a08c7d33.png" alt="在这里插入图片描述"></p><h6 id="3-存储的过程的修改"><a href="#3-存储的过程的修改" class="headerlink" title="3.存储的过程的修改"></a>3.存储的过程的修改</h6><h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><h5 id="1-变量探究"><a href="#1-变量探究" class="headerlink" title="1.变量探究"></a>1.变量探究</h5><p>系统变量</p><p>系统变量 是MySQL服务器提供，属于服务器层面，其中又分为全局变量、会话变量</p><ul><li>全局变量(<code>GLOBAL</code>): 设置后针对于所有的会话生效</li><li>会话变量(<code>SESSION</code>): 只对当前会话生效，在另外一个会话窗口就不生效了</li><li>mysql服务<strong>重新启动之后，所设置的全局参数会失效</strong>，要想不失效，可以在 <code>/etc/my.cnf</code> 中配置</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/98ceb5f33e3cfe4c02c460f5596a89bf.png" alt="在这里插入图片描述"></li></ul><p>用户自定义变量</p><p>用户根据需要自己定义的变量，可以不提前声明直接使用（返回null），在用的时候直接用 “<code>@变量名</code>” 就可以。其作用域为当前连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 赋值时，可以使用 = ，也可以使用 := <br>SET @var_name = expr [, @var_name = expr] ... ; <br>SET @var_name := expr [, @var_name := expr] ... ;<br><br>-- ===使用示例===<br>set @test1 := 111  -- 可为单个变量声明赋值<br>set @test2 := 222,@test3=333  -- 可为多个变量声明赋值<br><br></code></pre></td></tr></table></figure><ul><li>方式二</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr  [, <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr] ... <br><br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@var_name</span> <span class="hljs-keyword">FROM</span> 表名;<br><br><span class="hljs-comment">-- ===使用示例===</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@test4</span> :<span class="hljs-operator">=</span> <span class="hljs-number">444</span><br><span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@test5</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">-- 需确保结果为一个</span><br><br></code></pre></td></tr></table></figure><p>局部变量</p><p>定义在局部生效的变量，访问之前，需要先使用<code>DECLARE</code>声明。<strong>可用作存储过程内的局部变量和输入参数</strong>，局部变量的<strong>范围是在其内声明的</strong><code>BEGIN ... END</code>块。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> 存储过程名称 ([ 参数列表 ])<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> 变量名 变量类型 [<span class="hljs-keyword">DEFAULT</span> ... ];<br>    <span class="hljs-comment">-- ....</span><br>    <span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">end</span>;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-- 方式一</span><br><span class="hljs-comment">SET 变量名 = 值 ;</span><br><span class="hljs-comment">-- 方式二</span><br><span class="hljs-comment">SET 变量名 := 值 ;</span><br><span class="hljs-comment">-- 方式三</span><br><span class="hljs-comment">SELECT 字段名 INTO 变量名  FROM  表名 ... ;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/96b316f5e54279aa36ec0ad964538a76.png" alt="在这里插入图片描述"></p><h5 id="2-if判断"><a href="#2-if判断" class="headerlink" title="2.if判断"></a>2.if判断</h5><p>根据定义的分数score变量，判定当前分数对应的分数等级。 score &gt;&#x3D; 85分，等级为优秀。 score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。 score &lt; 60分，等级为不及格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建存储过程</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p3()<br> <span class="hljs-keyword">begin</span><br> <span class="hljs-comment">-- 定义变量</span><br>    <span class="hljs-keyword">declare</span> score <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">58</span>;<br>    <span class="hljs-keyword">declare</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">-- if判断</span><br>    if score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;优秀&#x27;</span>;<br>    elseif score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;及格&#x27;</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;不及格&#x27;</span>;<br>    <span class="hljs-keyword">end</span> if;<br>    <span class="hljs-comment">-- 查看参数值</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">result</span>;<br> <span class="hljs-keyword">end</span>;<br> <span class="hljs-comment">-- 调用存储过程</span><br> <span class="hljs-keyword">call</span> p3();<br><br></code></pre></td></tr></table></figure><h5 id="3-参数"><a href="#3-参数" class="headerlink" title="3.参数"></a>3.参数</h5><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>IN</code></td><td>表示输入参数，也就是调用时需要传入值</td></tr><tr><td><code>OUT</code></td><td>表示输出参数，也就是该参数可以作为返回值</td></tr><tr><td><code>INOUT</code></td><td>既可以作为输入参数，也可以作为输出参数</td></tr></tbody></table><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">-- 创建存储过程<br>-- <span class="hljs-keyword">in</span> score int 表示需要传入一个整数型的参数<br>-- <span class="hljs-keyword">out</span> <span class="hljs-keyword">result</span> varchar(<span class="hljs-number">10</span>) 表示返回一个varchar(<span class="hljs-number">10</span>)的字符串参数<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> <span class="hljs-title function_">p4</span><span class="hljs-params">(<span class="hljs-keyword">in</span> score int, <span class="hljs-keyword">out</span> <span class="hljs-keyword">result</span> varchar(10)</span>)<br> <span class="hljs-title function_">begin</span><br>    <span class="hljs-title function_">if</span> <span class="hljs-title function_">score</span> &gt;= 85 <span class="hljs-title function_">then</span><br>        <span class="hljs-title function_">set</span> <span class="hljs-title function_">result</span> := <span class="hljs-string">&#x27;优秀&#x27;</span><span class="hljs-punctuation">;</span><br>    elseif score &gt;= <span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br> <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> := <span class="hljs-string">&#x27;及格&#x27;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> := <span class="hljs-string">&#x27;不及格&#x27;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><span class="hljs-punctuation">;</span><br> <span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br> <br>-- 定义用户变量 @<span class="hljs-keyword">result</span>来接收返回的数据, 用户变量可以不用声明<br>-- 调用存储过程 <br>call p4(<span class="hljs-number">18</span>, @<span class="hljs-keyword">result</span>)<span class="hljs-punctuation">;</span><br>-- 查看变量值<br><span class="hljs-keyword">select</span> @<span class="hljs-keyword">result</span><span class="hljs-punctuation">;</span><br><br></code></pre></td></tr></table></figure><h5 id="4-case-流程控制"><a href="#4-case-流程控制" class="headerlink" title="4.case 流程控制"></a>4.case 流程控制</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5d5d48d883f0e8825d02b19912dd7e1.png" alt="在这里插入图片描述"></p><h5 id="5-循环"><a href="#5-循环" class="headerlink" title="5. 循环"></a>5. 循环</h5><h6 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fdc98bb98a69ca12802b8b0190543fff.png" alt="在这里插入图片描述"></p><h6 id="2-repeat"><a href="#2-repeat" class="headerlink" title="2.repeat"></a>2.repeat</h6><p>与while类似，repeat也是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><p><code>先执行一次</code>逻辑，然后判定<strong>UNTIL</strong>条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/161abeed68a1f50b90748a3a4309ba00.png" alt="在这里插入图片描述"></p><h6 id="3-loop"><a href="#3-loop" class="headerlink" title="3.loop"></a>3.loop</h6><p>LOOP 也可以用来实现循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。 LOOP可以配合一下两个语句使用：</p><ul><li><strong><code>LEAVE</code> ：配合循环使用，退出循环。</strong></li><li><strong><code>ITERATE</code>：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</strong></li><li>ITERATE语句用于将执行顺序转到语句段的开头处，它只可以出现在LOOP、REPEAT和WHILE语句内。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/11400f1726eebe19759860b613c2b24d.png" alt="在这里插入图片描述"></p><table><thead><tr><th>名称</th><th>区别</th></tr></thead><tbody><tr><td><code>while</code></td><td><strong>先判定条件</strong>，如果条件为true，则执行逻辑，否则不执行逻辑。</td></tr><tr><td><code>repeat</code></td><td><strong>先执行一次逻辑</strong>，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</td></tr><tr><td><code>loop</code></td><td>可以配合两个语句实现：死循环，退出循环，跳过剩余语句执行下一轮循环</td></tr></tbody></table><h6 id="4-游标"><a href="#4-游标" class="headerlink" title="4.游标"></a>4.游标</h6><p>我们的变量只能存储单个查询结果<strong>，而游标（CURSOR）是用来存储查询结果集的数据类型</strong> , 在存储过程和函数中可以使用游标对结果集进行循环的处理。</p><ul><li>声明游标</li><li>declare 变量名 变量类型 [DEFAULT … ];</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> 游标名称 <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> 查询语句;<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>打开游标</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">OPEN</span> 游标名称;<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>获取游标记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FETCH</span> 游标名称 <span class="hljs-keyword">INTO</span> 变量 [,变量 ];<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>关闭游标</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CLOSE</span> 游标名称;<br></code></pre></td></tr></table></figure><p>使用示例：根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4ed019020ad2479cbafa0a9df7c7ed93.png" alt="在这里插入图片描述"></p><p>在我们调用上述存储过程的过程中，由于while循环中并没有退出条件，当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。但是此时，user_pro表结构及其数据都已经插入成功了。 要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决</p><h4 id="5-条件处理程序"><a href="#5-条件处理程序" class="headerlink" title="5. 条件处理程序"></a>5. 条件处理程序</h4><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><blockquote><p>语法<br>DECLARE handler_action </p><p>HANDLER FOR </p><p>condition_value [,condition_value] …   statement;</p></blockquote><p>定义错误</p><p>DECLARE cmd_not_allow CONDITION FOR SQLSTATE’42000’;</p><p>DECLARE cmd_not_allow CONDITION FOR 1148;</p><p>1<br>handler_action 的取值：</p><blockquote><p>CONTINUE: 继续执行当前程序<br>EXIT: 终止执行当前程序   遇到错误默认的方式</p><p>UNDO 什么都不做</p><p>condition_value 的取值：</p></blockquote><blockquote><p>SQLSTATE sqlstate_value: 状态码，如 02000<br>SQLWARNING: 所有以01开头的SQLSTATE代码的简写<br>NOT FOUND: 所有以02开头的SQLSTATE代码的简写<br>SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写<br>我们来处理完善一下上一个案例所遇到的问题~</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6ead8aebc1af0bee4df72f6d0230fd86.png" alt="在这里插入图片描述"></p><h4 id="6-存储函数"><a href="#6-存储函数" class="headerlink" title="6.存储函数"></a>6.存储函数</h4><p>存储函数<strong>是有返回值的存储过程</strong>，存储函数的参数只能是<code>in</code>类型的。具体语法如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">CREATE  <span class="hljs-keyword">FUNCTION</span>   <span class="hljs-title">存储函数名称</span> ([ 参数列表 ])<br>RETURNS  type  [characteristic ...]<br>BEGIN<br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">RETURN</span> <span class="hljs-type">...</span>;<br><span class="hljs-keyword">END</span> ;<br><br></code></pre></td></tr></table></figure><ul><li><code>DETERMINISTIC</code>：相同类型的输入参数总是产生相同类型的结果</li><li><code>NO SQL</code> ：不包含 SQL 语句。</li><li><code>READS SQL DATA</code>：包含读取数据的语句，但不包含写入数据的语句。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/368d80234ab3ce11f8a7d64050292c65.png" alt="在这里插入图片描述"></p><p>注意：在mysql8.0版本中<code>binlog</code>默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql执行耗时</title>
    <link href="/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/sql%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6/"/>
    <url>/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/sql%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql执行耗时"><a href="#mysql执行耗时" class="headerlink" title="mysql执行耗时"></a>mysql执行耗时</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7f70e187ad24476e662c28723f3a81a9.png" alt="img"></p><h6 id="1-sql执行频率"><a href="#1-sql执行频率" class="headerlink" title="1.sql执行频率"></a>1.sql执行频率</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/34df6fc2b1e7174a47b7b0621aa03d48.png" alt="在这里插入图片描述"></p><blockquote><p>模糊匹配</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8648d68ee5e264a8765eab167ee255bc.png" alt="在这里插入图片描述"></p></blockquote><hr><p><strong>，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 <strong>如果是以查询为主，那么就要考虑对数据库的索引进行优化了</strong>。</strong></p><h6 id="2-慢日志开启"><a href="#2-慢日志开启" class="headerlink" title="2.慢日志开启"></a>2.慢日志开启</h6><blockquote><p>慢查询日志记录了<strong>执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志</strong>。 MySQL的慢查询日志<strong>默认没有开启</strong>，需要我们手动的开启，我们可以查看一下系统变量 <code>slow_query_log</code>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62f5b157978b1dc56bee39972d036af4.png" alt="在这里插入图片描述"></p><blockquote><p>如果要开启慢查询日志，需要在MySQL的配置文件（<code>/etc/my.cnf</code>）中配置如下信息：</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 1.开启MySQL慢日志查询开关</span><br>slow_query_log = <span class="hljs-number">1</span><br><br><span class="hljs-comment">-- 2.设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br>long_query_time = <span class="hljs-number">2</span><br><br><span class="hljs-comment">-- 3.配置完毕之后，重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 </span><br>systemctl <span class="hljs-keyword">restart</span> mysqld<br><br>g<span class="hljs-comment">-- 4. 随后我们可以在/var/lib/mysql/localhost-slow.log中</span><br><span class="hljs-comment">-- 查看慢日志文件中记录的信息</span><br>cat /var/lib/mysql/localhost-slow.lo<br></code></pre></td></tr></table></figure><blockquote><p>-<br>  – 查看慢日志文件中记录的信息<br>  cat &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.lo</p><ul><li>我们可以执行一条比较耗时的SQL语句（耗时超过指定的2s），然后看慢查询日志是否记录了相关信息。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/52fb5f6fedd2d5d96c0d6ccc21b8605b.png" alt="在这里插入图片描述"></p><h6 id="3-执行计划"><a href="#3-执行计划" class="headerlink" title="3.执行计划"></a>3.执行计划</h6><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">explain<br>SELECT id,user_id,serve_item_name<br>FROM <span class="hljs-keyword">orders_0</span><br><span class="hljs-keyword"></span>WHERE (<span class="hljs-keyword">orders_status </span>= <span class="hljs-number">0</span> <span class="hljs-keyword">AND </span>user_id = <span class="hljs-number">1716346406098296832</span> <span class="hljs-keyword">AND </span><span class="hljs-keyword">display </span>= <span class="hljs-number">1</span> <span class="hljs-keyword">and </span>sort_by&lt;<span class="hljs-number">1698924600022</span>)<br><span class="hljs-keyword">ORDER </span><span class="hljs-keyword">BY </span>sort_by DESC<br>LIMIT <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<br>  &#123;<br>    &quot;id&quot;: <span class="hljs-number">1</span>,  每个查询步骤的唯一标识符<br>    &quot;select_type&quot;: &quot;SIMPLE&quot;,  查询的类型，例如 SIMPLE（简单查询）或 <span class="hljs-keyword">PRIMARY</span>（主查询，嵌套子查询的最外层查询）。<br>    &quot;table&quot;: &quot;orders_0&quot;,查询涉及的表。<br>    &quot;partitions&quot;: <span class="hljs-keyword">null</span>, 使用的分区（如果有分区表的话）<br>    &quot;type&quot;: &quot;range&quot;,查询使用的连接类型，例如 <span class="hljs-keyword">ALL</span>（全表扫描）或 <span class="hljs-keyword">index</span>（索引扫描）。<br>    &quot;possible_keys&quot;: &quot;query_index_0,query_index_1&quot;,可能用于此查询的键列表。<br>    &quot;key&quot;: &quot;query_index_0&quot;,实际用于此查询的键。<br>    &quot;key_len&quot;: &quot;26&quot;,实际用于此查询的键。<br>    &quot;ref&quot;: <span class="hljs-keyword">null</span>,显示索引的哪一列被用于查询。<br>    &quot;rows&quot;: <span class="hljs-number">1</span>,MySQL 估计将需要读取的行数。<br>    &quot;filtered&quot;: <span class="hljs-number">100</span>,在表中的行数的百分比，表示查询的条件有多少行满足。<br>    &quot;Extra&quot;: &quot;Using where; Using index&quot; 其他的额外信息，例如使用了哪些索引、是否使用了文件排序等。<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 存储引擎</title>
    <link href="/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2d0e1a405212168834553b0697afe31a.png" alt="img"></p><p><code>MyISAM</code>是MySQL早期的默认存储引擎。它不支持事务，不支持外键，不支持行锁，但是它支持表锁，而且<strong>访问速度很快</strong>。</p><h6 id="1-体系结构"><a href="#1-体系结构" class="headerlink" title="1.体系结构"></a>1.体系结构</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5a3eb5c08370e63227fbfcdb8c84e7a1.png" alt="在这里插入图片描述"></p><blockquote><p>连接层：负责处理客户端连接请求，包括本地sock通信和基于TCP&#x2F;IP的客户端&#x2F;服务端通信，支持线程池和SSL安全连接。该层负责认证、授权及安全性检查。</p><p>服务层：执行SQL接口、查询缓存、SQL解析与优化，处理跨存储引擎功能，如函数、过程等，负责查询解析与优化。</p><p>存储引擎层：负责数据的存储与提取，通过API与服务器通信，支持多种存储引擎，索引结构随引擎不同。</p><p>数据存储层：将数据（如日志、索引）存储到文件系统，管理与存储引擎的交互。</p><p>MySQL的架构灵活，插件式存储引擎适应多种业务场景。————————————————</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 索引</title>
    <link href="/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197b41c9ff3284f61e102fa83bbaa0f.png"></p><h6 id="0-引用"><a href="#0-引用" class="headerlink" title="0.引用"></a>0.引用</h6><p><strong>数据库除了存储数据之外，还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 当我们在查找数据的时候，就可以在这些数据结构上实现高级查找算法，快速查找到我们想要的数据，这种数据结构就是索引</strong>。</p><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td><strong>提高数据检索的效率</strong>，降低数据库的IO成本</td><td>索引列也是要<strong>占用空间</strong>的</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，<strong>降低CPU的消耗</strong>。</td><td>索引大大提高了查询效率，同时却也<strong>降低更新表的速度</strong>， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dedb0bef3ead1be337fbb8c545872435.png" alt="在这里插入图片描述"></p><p>针对于这张表的age字段建立了索引，假设索引的数据结构就是二叉树（实际并不是，而是一种比二叉树更高效的数据结构），那么也就意味着，会对age这个字段建立一个二叉树的索引结构。此时我们在进行查询时，<strong>只需要扫描三次</strong>就可以找到数据了，极大的提高的查询的效率。</p><h6 id="2-索引结构"><a href="#2-索引结构" class="headerlink" title="2.索引结构"></a>2.索引结构</h6><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p><strong>特别说明</strong>：MySQL索引数据结构对经典的B+Tree进行了优化。<strong>在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree</strong>，提高区间访问的性能，利于排序。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aa4fb1c8e79c9e5a49a98b19eb5587e2.png" alt="在这里插入图片描述"></p><h4 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h4><p><strong>在MySQL数据库中</strong>，将索引的具体类型主要分为以下几类：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td><strong>主键</strong>索引</td><td><strong>针对于表中主键</strong>创建的索引</td><td>默认自动创建, <strong>只能有一个</strong></td><td><code>PRIMARY</code></td></tr><tr><td><strong>唯一</strong>索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有<strong>多个</strong></td><td><code>UNIQUE</code></td></tr><tr><td><strong>常规</strong>索引</td><td>快速定位特定数据</td><td>可以有<strong>多个</strong></td><td>index&#x2F;KEY</td></tr><tr><td><strong>全文</strong>索引</td><td>全文索引查找的是<strong>文本中的关键词</strong>，而不是比 较索引中的值  类型CHAR、VARCHAR或TEXT类型</td><td>可以有<strong>多个</strong></td><td><code>FULLTEXT</code></td></tr></tbody></table><h6 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241028151107884.png" alt="image-20241028151107884"></p><p>MySQL 的空间索引通常支持 <code>GEOMETRY</code>、<code>POINT</code>、<code>LINESTRING</code>、<code>POLYGON</code> 等空间数据类型。其他基本数据类型（如整数、字符串）不能创建空间索引。</p><p><strong>不支持 NULL 值</strong>：在空间索引中，字段不能包含 NULL 值。如果存在 NULL 值，则创建空间索引时会失败。</p><p>而<strong>在InnoDB存储引擎中</strong>，<strong>根据索引的存储形式</strong>，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><strong>聚集</strong>索引(<code>Clustered Index</code>)</td><td>将<strong>数据存储与索引放到了一块</strong>，索引结构的<strong>叶子节点保存了行数据</strong></td><td><strong>必须有</strong>,而且<strong>只有一个</strong></td></tr><tr><td><strong>二级</strong>（非聚集）索引(<code>Secondary Index</code>)</td><td>将<strong>数据与索引分开存储</strong>，索引结构的<strong>叶子节点关联的是对应的主键</strong></td><td><strong>可以存在多个</strong></td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个<strong>rowid</strong>作为隐藏的聚集索引</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/18faad393942fd691df45c49946a2189.png" alt="在这里插入图片描述"></p><ul><li><strong>聚集索引</strong>的叶子节点下<strong>挂的是这一行的数据</strong> 。</li><li><strong>二级（非聚集）索引</strong>的叶子节点下挂的是<strong>该字段值对应的主键值</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/745eaf5e00b49b4f5eca1cf7a3564648.png" alt="在这里插入图片描述"></p><p>当我们执行上述的SQL语句：</p><p><strong>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</strong><br><strong>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</strong><br>最终拿到这一行的数据，直接返回即可。<br>这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为<strong>回表查询</strong>。</p><p>由于存在回表查询，我们通过聚集索引查询值的方式要比通过二级索引查询值的方式快很多。因为走聚集索引，可以直接返回数据。 而走二级索引，需要先获取id值，然后再查询聚集索引获取值要慢许多。<br>————————————————</p><h4 id="4-创建索引"><a href="#4-创建索引" class="headerlink" title="4.创建索引"></a>4.创建索引</h4><p>索引创建要遵从最左前缀法则</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">UNIQUE</span> | FULLTEXT ] <span class="hljs-keyword">INDEX</span> 索引名 <span class="hljs-keyword">ON</span> table_name (字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>,... );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 为用户表的姓名name字段创建名为idx_user_name的唯一索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_user_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(name);<br><br><span class="hljs-comment">-- 为用户表的手机号phone字段创建名为idx_user_phone的普通索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_user_phone <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(phone);<br><br><span class="hljs-comment">-- 为用户表的profession,age,status字段创建名为idx_user_pro_age_stae的联合索引-不回表查询</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_user_pro_age_sta <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(profession,age,status);<br><br></code></pre></td></tr></table></figure><p>最左原则例子</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> <br>query_index_0 <br><span class="hljs-keyword">on</span> <br>jzo2o-orders<span class="hljs-number">-1.</span>orders_0<br>(orders_status <span class="hljs-keyword">asc</span>, user_id <span class="hljs-keyword">asc</span>, display <span class="hljs-keyword">asc</span>, sort_by <span class="hljs-keyword">desc</span>); <br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">explain<br>SELECT id<br>FROM <span class="hljs-keyword">orders_0</span><br><span class="hljs-keyword"></span>WHERE (<span class="hljs-keyword">orders_status </span>= <span class="hljs-number">0</span> <span class="hljs-keyword">AND </span>user_id = <span class="hljs-number">1716346406098296832</span> <span class="hljs-keyword">AND </span><span class="hljs-keyword">display </span>= <span class="hljs-number">1</span> <span class="hljs-keyword">and </span>sort_by&lt;<span class="hljs-number">1698924600022</span>)<br><span class="hljs-keyword">ORDER </span><span class="hljs-keyword">BY </span>sort_by DESC<br>LIMIT <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="5-索引失效情况"><a href="#5-索引失效情况" class="headerlink" title="5.索引失效情况"></a>5.索引失效情况</h4><h6 id="1-最左前缀法则"><a href="#1-最左前缀法则" class="headerlink" title="1.最左前缀法则"></a>1.最左前缀法则</h6><p>1.<strong>如果索引了多列（联合索引），要遵守最左前缀法则</strong>。</p><p>注：在where条件中索引最左列存在即可，在order by多字段排序中索引最左列必须为排序条件最左列。</p><h6 id="2-范围查询"><a href="#2-范围查询" class="headerlink" title="2.范围查询"></a>2.范围查询</h6><p>联合索引中，出现范围查询<code>(&gt;,&lt;</code>)，<strong>范围查询右侧的列索引失效</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age &gt; <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> status = <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p>根据长度**<code>key_len</code>我们可以知道：联合索引生效了，但是只有profession与age的索引生效了，status字段的索引没有生效。**</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb22fd01b4f7dc7d021a8025b3f2a61f.png" alt="在这里插入图片描述"></p><p><strong>值得注意的是</strong>：当范围查询使用<code>&gt;=</code> 或 <code>&lt;=</code> 时，则不会产生影响。 因此，在业务允许的情况下，进行范围查询时，为了避免索引失效，我们可以使用类似于 <code>&gt;=</code> 或 <code>&lt;=</code> 这类的范围查询，代替使用<code>&gt;</code> 或 <code>&lt;</code>。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9044380259b86c0ee14b88b788f79d28.png" alt="在这里插入图片描述"></p><h6 id="3-索引列运算"><a href="#3-索引列运算" class="headerlink" title="3.索引列运算"></a>3.索引列运算</h6><p>当我们在索引列上进行运算操作， 索引也将失效。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span>  <span class="hljs-keyword">select</span>  *  <span class="hljs-keyword">from</span>  <span class="hljs-keyword">user</span>  <span class="hljs-keyword">where</span>  substring(phone,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) = <span class="hljs-string">&#x27;15&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e77f250521e08c856951053745eedd5d.png" alt="在这里插入图片描述"></p><h6 id="4-字符串不加引号"><a href="#4-字符串不加引号" class="headerlink" title="4.字符串不加引号"></a>4.<strong>字符串不加引号</strong></h6><p>当我们对添加索引的字符串类型字段进行操作时，如果<strong>字符串不加引号</strong>，对于查询结果，没什么影响，但是数据库存在隐式类型转换，<strong>索引将失效</strong>。</p><ul><li>例如 phone 为 varchar类型字段</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/70cfc75173512170e116448195027897.png" alt="在这里插入图片描述"></p><h6 id="5-模糊查询"><a href="#5-模糊查询" class="headerlink" title="5.模糊查询"></a>5.模糊查询</h6><p>如果仅仅是<strong>尾部模糊匹配，索引不会失效</strong>。如果是<strong>头部模糊匹配，索引失效</strong></p><ul><li>我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/be218c2cb18370a2148ac42f5ecaf63f.png" alt="在这里插入图片描述"></p><h6 id="6-or连接条件"><a href="#6-or连接条件" class="headerlink" title="6.or连接条件"></a>6.or连接条件</h6><p>用or分割开的条件， <strong>如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</strong></p><ul><li>例如我们先删除age字段上的联合索引，再进行or连接查询</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3dc203f7379ec6635da67947b7ba8725.png" alt="在这里插入图片描述"></p><p>我们发现当or连接的条件，左右两侧字段都有索引时，索引才会生效~</p><h6 id="7-数据分布影响-索引使用情况"><a href="#7-数据分布影响-索引使用情况" class="headerlink" title="7.数据分布影响-索引使用情况"></a>7.数据分布影响-索引使用情况</h6><p>如果MySQL评估使用索引比全表扫描更慢，则不使用索引。</p><ul><li>例如，下面使用相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/918d8a2e9104654ba4d293844176d958.png" alt="在这里插入图片描述"></p><p>这是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p><h4 id="6-索引使用优化"><a href="#6-索引使用优化" class="headerlink" title="6.索引使用优化"></a>6.索引使用优化</h4><h6 id="1-SQL提示"><a href="#1-SQL提示" class="headerlink" title="1.SQL提示"></a>1.SQL提示</h6><blockquote><p>当我们的字段存在多个索引时，MySQL会进行评估自动选择一个索引进行使用。我们也可以<strong>借助于SQL提示指定MySQL使用哪个索引</strong>。</p></blockquote><ul><li><code>use index</code> ：建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估，即或许不会遵从建议）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 use index(索引名) <span class="hljs-keyword">where</span> 查询条件....;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e499ff8da49c252b9207ccdda6f446e.png" alt="在这里插入图片描述"></p><ul><li><p><code>force index</code> ： 强制使用索引</p></li><li><p><code>ignore index</code> ：忽略指定的索引</p></li></ul><h6 id="2-覆盖索引-聚集索引-介绍"><a href="#2-覆盖索引-聚集索引-介绍" class="headerlink" title="2.覆盖索引 聚集索引 介绍"></a>2.覆盖索引 聚集索引 介绍</h6><p>在需求允许的情况下，尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少<code>select *</code>的使用。</p><p>创建索引-防止回表查询  执行器返回</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>聚集索引查询</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/775bba4e48859a02efba1dbba92e33fa.png" alt="在这里插入图片描述"></p><p>覆盖索引</p><ul><li>根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索 引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9ada929f8b5ffa035c8ad17445bdaa2.png" alt="在这里插入图片描述"></p><p>回表查询</p><p>多查询一个gender字段，由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相 对较差一点。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/49f94fe8830483f549d0192ecf46dde1.png" alt="在这里插入图片描述"></p><h6 id="3-前缀索引"><a href="#3-前缀索引" class="headerlink" title="3.前缀索引"></a>3.前缀索引</h6><p>当字段类型为字符串（varchar，text，longtext等）时，有时候这些字段值会非常大（例如一段很长的文本），如果直接对此建立索引，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>create index 索引名 on 表名(字段名(索引长度)) ;</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/85353abee403daebd3eb39c1e601a2c5.png" alt="在这里插入图片描述"></p><p>有时候我们难以确定应该创建多长的索引，这时可以根据索引的选择性来决定。选择性是指<strong>不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高</strong>， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">-- 可以直接计算比值<br><span class="hljs-keyword">select</span>  count(<span class="hljs-keyword">distinct</span> 字段名) / count<span class="hljs-comment">(*) from 表名;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- 也可以使用函数截取部分数据进行计算</span><br><span class="hljs-comment"> select  count(distinct substring(字段名,开始位置,结束位置)) / count(*)</span> <span class="hljs-keyword">from</span> 表名<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cde495c86ccb9f2660001f19f45970e2.png" alt="在这里插入图片描述"></p><p>前缀索引的查询流程</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4e4ff3db963e37c8fbdb9220903ac42c.png" alt="在这里插入图片描述"></p><ul><li>对于类似身份证号、微信小程序openId这些，其长度比较长，但是其前几位区分度并不大，很显然不能直接创建前缀索引，于此，我们可以在数据库中对其倒序存储，再计算索引选择性创建合适长度的索引</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> openId <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> openId=reverse(<span class="hljs-string">&#x27;xxxxxx&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="7-索引设计原则"><a href="#7-索引设计原则" class="headerlink" title="7.索引设计原则"></a>7.索引设计原则</h4><p>针对于数据量较大，且查询比较频繁的表建立索引</p><p>。<br>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>在复合业务场景的情况下，尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</p><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p><p>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-视图详解</title>
    <link href="/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/"/>
    <url>/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e38cef8b1142a5e6cdecd852b8e0e64.png" alt="img"></p><h6 id="1-视图创建"><a href="#1-视图创建" class="headerlink" title="1.视图创建"></a>1.视图创建</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4adba23c36c21d29f7333ed1ca00b7b3.png" alt="在这里插入图片描述"></p><p>create view viewname as select * fromtable;</p><h6 id="2-操作数据"><a href="#2-操作数据" class="headerlink" title="2.操作数据"></a>2.操作数据</h6><p>视图也是一张表，我们可以像操作正常表一样操作视图。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/411a3256cd81babd17c4ab734204a1c8.png" alt="在这里插入图片描述"></p><h6 id="3-修改视图"><a href="#3-修改视图" class="headerlink" title="3. 修改视图"></a>3. 修改视图</h6><p>create or replace view viewname as select;</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1ca8bd5536cdcd2976a90d59018ebeb5.png" alt="在这里插入图片描述"></p><ul><li>方式二</li><li>alter view showview as select;</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9ad91dcd17d274ee645377d602307cc4.png" alt="在这里插入图片描述"></p><h4 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h4><p>由于视图是虚拟存在的表，<strong>我们对视图的操作都会反应到基表当中</strong>，</p><p>假设我们对视图表插入<strong>不符合视图where条件的数据</strong>，那么这条数据只会存在于基表当中，而<strong>我们在视图表无法获悉</strong>，这岂不是插入了一条无效数据？</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/859a6bc41a2feb3335f82e2140f0460b.png" alt="在这里插入图片描述"></p><h6 id="1-CASCADED级联"><a href="#1-CASCADED级联" class="headerlink" title="1 CASCADED级联"></a>1 CASCADED级联</h6><p>假设v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 <code>cascaded</code>，v1视图 创建时未指定检查选项（如果指定了则继续检查上一级，以此往复）。 则在对v2进行操作执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1，如果不满足条件则无法进行相关操作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ccfaf862ac5d565e8a314d7e3d9b929.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d8c8e73ecf50f96a59d1b336079c38f3.png" alt="在这里插入图片描述"></p><p>视图1当了当前</p><ul><li><code>u2</code>插入成功</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ee38d82249fb9ec346bbe6c3759d4922.png" alt="img"></p><ul><li><code>u1</code>插入情况</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cd39677ac7b14f045bc036a0340d2fd7.png" alt="在这里插入图片描述"></li></ul><h6 id="2-LOCAL本地"><a href="#2-LOCAL本地" class="headerlink" title="2. LOCAL本地"></a>2. LOCAL本地</h6><h4 id="4-视图更新"><a href="#4-视图更新" class="headerlink" title="4.视图更新"></a>4.视图更新</h4><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p><p>聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）<br>DISTINCT<br>GROUP BY<br>HAVING<br>UNION 或者 UNION ALL<br>例如我们创建视图时使用了聚合函数，破坏了一对一关系</p><p>create view stu_v_count as select count(*) from student;<br>1<br>如果我们对这个视图进行更新或插入的，将会报错。</p><p>insert into stu_v_count values(10);<br>1</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-限性表-栈-队列</title>
    <link href="/2024/09/24/data%20structure/%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A0%88%E9%98%9F%E5%88%97/"/>
    <url>/2024/09/24/data%20structure/%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A0%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h4 id="3-1栈"><a href="#3-1栈" class="headerlink" title="3.1栈"></a>3.1栈</h4><h5 id="3-1-1栈的基本概念"><a href="#3-1-1栈的基本概念" class="headerlink" title="3.1.1栈的基本概念"></a>3.1.1栈的基本概念</h5><p>栈（Stack）是一种<strong>后进先出</strong>（LIFO, Last In First Out）的数据结构。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/31223128ec51be79cbbaab3a516fbd79.png" alt="在这里插入图片描述"></p><p>栈的存储方式</p><ul><li>线性存储(顺序)</li><li>链接存储（链表）</li></ul><p><strong>栈的相关概念</strong></p><ul><li>栈顶和栈底：允许元素插入与删除的一段称为栈顶，另一端栈底</li><li>压栈：栈的插入操作，叫做进栈，也称压栈、入栈</li><li>弹栈：栈的删除操作，也叫作出栈</li></ul><h5 id="3-3-2栈的基本运算"><a href="#3-3-2栈的基本运算" class="headerlink" title="3.3.2栈的基本运算"></a>3.3.2栈的基本运算</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4a863233041de63d236d25cef8aa9bc8.png" alt="4a863233041de63d236d25cef8aa9bc8"></p><h4 id="3-1-2栈的顺序存储结构"><a href="#3-1-2栈的顺序存储结构" class="headerlink" title="3.1.2栈的顺序存储结构"></a>3.1.2栈的顺序存储结构</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cbb54aaeb6631dfefabaa6f13be1af80.png" alt="cbb54aaeb6631dfefabaa6f13be1af80"></p><h5 id="3-3-3栈的运算算法"><a href="#3-3-3栈的运算算法" class="headerlink" title="3.3.3栈的运算算法"></a>3.3.3栈的运算算法</h5><h6 id="1-初始化栈"><a href="#1-初始化栈" class="headerlink" title="1.初始化栈"></a>1.初始化栈</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2721032b154a905ca4d7d363ac5ca8b7.png" alt="2721032b154a905ca4d7d363ac5ca8b7"></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h6 id="2-销毁栈"><a href="#2-销毁栈" class="headerlink" title="2.销毁栈"></a>2.销毁栈</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fd1ccae8d6ebc042c2846cf1f9bf70d3.png" alt="fd1ccae8d6ebc042c2846cf1f9bf70d3"></p><h6 id="3-push进栈算法"><a href="#3-push进栈算法" class="headerlink" title="3.push进栈算法"></a>3.push进栈算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924122500463.png" alt="image-20240924122500463"></p><h6 id="4-pop出栈算法"><a href="#4-pop出栈算法" class="headerlink" title="4.pop出栈算法"></a>4.pop出栈算法</h6><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">int pop(sQsTACK &amp; <span class="hljs-keyword">ST</span>,ElemType x)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">st</span>.top==maxSizx-1)<br>&#123;<br><span class="hljs-keyword">return</span> 0;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>x=<span class="hljs-keyword">st</span>.data[<span class="hljs-keyword">st</span>.topp];<br><span class="hljs-keyword">st</span>.top--;<br><span class="hljs-keyword">return</span> 1;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-取栈顶元素"><a href="#5-取栈顶元素" class="headerlink" title="5.取栈顶元素"></a>5.取栈顶元素</h6><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata">int Getpop(sQsTACK &amp; <span class="hljs-keyword">ST</span>,ElemType x)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">st</span>.top==maxSizx-1)<br>&#123;<br><span class="hljs-keyword">return</span> 0;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>x=<span class="hljs-keyword">st</span>.data[<span class="hljs-keyword">st</span>.topp];<br><span class="hljs-keyword">return</span> 1;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="6-判断栈空运算算法"><a href="#6-判断栈空运算算法" class="headerlink" title="6.判断栈空运算算法"></a>6.判断栈空运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924122925102.png" alt="image-20240924122925102"></p><h4 id="3-1-3栈的链式存储结构"><a href="#3-1-3栈的链式存储结构" class="headerlink" title="3.1.3栈的链式存储结构"></a>3.1.3栈的链式存储结构</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/709b2460b69b0dbbca4f45040fd652f8.png" alt="709b2460b69b0dbbca4f45040fd652f8"></p><h5 id="3-1-4栈链的运算算法"><a href="#3-1-4栈链的运算算法" class="headerlink" title="3.1.4栈链的运算算法"></a>3.1.4栈链的运算算法</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79210cbcd65acdf5dabb14d8c5dc2b5e.png" alt="79210cbcd65acdf5dabb14d8c5dc2b5e"></p><h6 id="1-初始化栈算法"><a href="#1-初始化栈算法" class="headerlink" title="1.初始化栈算法"></a>1.初始化栈算法</h6><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack * &amp;ls)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>ls=<span class="hljs-keyword">null</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-销毁栈运算算法"><a href="#2-销毁栈运算算法" class="headerlink" title="2.销毁栈运算算法"></a>2.销毁栈运算算法</h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> DestroyStack(LinkStack * &amp;ls)<br><br>&#123;<br>LinkStack *pre=ls,*P;<br><span class="hljs-keyword">if</span>(pre==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//空栈</span><br>p=pre-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//指向栈顶</span><br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)<br>&#123;<br>free(pre)<br>pre=p;p=p-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br>free(pre);<br><br><br>&#125;<br>pre-代表的是栈-》p下一个栈<br></code></pre></td></tr></table></figure><h6 id="3-进栈运算算法（头插"><a href="#3-进栈运算算法（头插" class="headerlink" title="3.进栈运算算法（头插)"></a>3.进栈运算算法（头插)</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924124055740.png" alt="image-20240924124055740"></p><h6 id="4-出栈运算算法"><a href="#4-出栈运算算法" class="headerlink" title="4.出栈运算算法"></a>4.出栈运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5dd683269143f8f2d81a4d989b50eede.png" alt="5dd683269143f8f2d81a4d989b50eede"></p><h6 id="5-取栈顶元素运算算法"><a href="#5-取栈顶元素运算算法" class="headerlink" title="5.取栈顶元素运算算法"></a>5.取栈顶元素运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c340118ccfa67d3548153fec1942a337.png" alt="c340118ccfa67d3548153fec1942a337"></p><h6 id="6-判断栈空"><a href="#6-判断栈空" class="headerlink" title="6.判断栈空"></a>6.判断栈空</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0983520a7bf7899f352c74142fb0144a.png" alt="0983520a7bf7899f352c74142fb0144a"></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h4 id="3-2-1队列的基本概念"><a href="#3-2-1队列的基本概念" class="headerlink" title="3.2.1队列的基本概念"></a>3.2.1队列的基本概念</h4><p>队列（Queue）是一种<strong>先进先出</strong>（FIFO, First In First Out）的数据结构。其基本概念是：</p><ol><li><strong>先进先出（FIFO）</strong>：在队列中，第一个被添加的元素最先被移除。这类似于排队买票，最先进入队列的人最先得到服务。</li><li><strong>队列的操作</strong>：<ul><li><strong>入队（Enqueue）</strong>：将一个元素添加到队列的末尾。</li><li><strong>出队（Dequeue）</strong>：移除并返回队列的第一个元素。</li><li><strong>查看队头元素（Front&#x2F;Peek）</strong>：查看队列的第一个元素，但不移除它。</li></ul></li><li><strong>队列的类型</strong>：<ul><li><strong>普通队列</strong>：遵循标准的先进先出规则。</li><li><strong>双端队列（Deque）</strong>：允许在队列的两端进行入队和出队操作。</li><li><strong>循环队列</strong>：队列中的元素循环使用，队尾连接到队头。</li></ul></li><li><strong>用途</strong>：队列常用于广度优先搜索（BFS）、任务调度、缓冲区管理等场景。例如，操作系统中的任务排队、打印队列，或消息处理系统中的任务管理等。</li></ol><blockquote><p>队列的实现方式</p><p>在计算机科学中，队列通常使用数组或链表来实现。下面分别介绍这两种实现方式：</p><ol><li>数组实现</li></ol><p>使用数组实现的队列被称为<strong>顺序队列</strong>。</p><ol start="2"><li>链表实现</li></ol><p>使用链表实现的队列被称为<strong>链式队列</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8ee352aa77223d088608ab7c8cf3a29f.png" alt="栈示意图"></p><h4 id="3-2-2队列的基本运算"><a href="#3-2-2队列的基本运算" class="headerlink" title="3.2.2队列的基本运算"></a>3.2.2队列的基本运算</h4><p>**初始化队列 InitQueue(Qu)**：建立一个空队列 Qu。</p><p>**销毁队列 DestroyQueue(Qu)**：释放队列 Qu 占用的内存空间。</p><p>**进队列 EnQueue(Qu, z)**：将元素 z 插入到队列 Qu 的队尾。</p><p>**出队列 DeQueue(Qu, z)**：将队列 Qu 的队头元素出队并赋给 z。</p><p>**取队头元素 GetHead(Qu, z)**：取出队列 Qu 的队头元素并赋给 z，但该元素不出队。</p><p>**判断队空 QueueEmpty(Qu)**：判断队列 Qu 是否为空。</p><h4 id="3-2-3队列的顺序存储结构"><a href="#3-2-3队列的顺序存储结构" class="headerlink" title="3.2.3队列的顺序存储结构"></a>3.2.3队列的顺序存储结构</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aca8a15b20ba388f1102fec36f1b904e.png" alt="aca8a15b20ba388f1102fec36f1b904e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/54139a5b87ff159eac498b9e4fe2e7d4.png" alt="54139a5b87ff159eac498b9e4fe2e7d4"></p><p>先出的是front 队头指针</p><h5 id="3-2-3-4循环队列"><a href="#3-2-3-4循环队列" class="headerlink" title="3.2.3.4循环队列"></a>3.2.3.4循环队列</h5><p>偷个懒 看视频学习</p><h6 id="1-循环队列要素"><a href="#1-循环队列要素" class="headerlink" title="1.循环队列要素"></a>1.循环队列要素</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125151135.png" alt="image-20240924125151135"></p><h5 id="2-循环队列基本算法"><a href="#2-循环队列基本算法" class="headerlink" title="2.循环队列基本算法"></a>2.循环队列基本算法</h5><h6 id="1-初始化队列运算算法"><a href="#1-初始化队列运算算法" class="headerlink" title="1.初始化队列运算算法"></a>1.初始化队列运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125226253.png" alt="image-20240924125226253"></p><h6 id="2-销毁队列算法"><a href="#2-销毁队列算法" class="headerlink" title="2.销毁队列算法"></a>2.销毁队列算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125244039.png" alt="image-20240924125244039"></p><h6 id="3-进队运算算法"><a href="#3-进队运算算法" class="headerlink" title="3.进队运算算法"></a>3.进队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125307304.png" alt="image-20240924125307304"></p><h4 id="3-2-4队列的链式存储"><a href="#3-2-4队列的链式存储" class="headerlink" title="3.2.4队列的链式存储"></a>3.2.4队列的链式存储</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125417315.png" alt="image-20240924125417315"></p><h5 id="链式存储算法运算"><a href="#链式存储算法运算" class="headerlink" title="链式存储算法运算"></a>链式存储算法运算</h5><h6 id="1-初始化队列算法"><a href="#1-初始化队列算法" class="headerlink" title="1.初始化队列算法"></a>1.初始化队列算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3034d08132b1dc6fcd62d6a3bf7b4c8d.png" alt="3034d08132b1dc6fcd62d6a3bf7b4c8d"></p><h6 id="2-销毁队列算法-1"><a href="#2-销毁队列算法-1" class="headerlink" title="2.销毁队列算法"></a>2.销毁队列算法</h6><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DestroyQueue(LinkQueue *&amp;lq)<br>&#123;<br>Q<span class="hljs-function"><span class="hljs-title">type</span> *pre=lq-&gt;</span>front,*P;<span class="hljs-comment">///指向头数据</span><br><span class="hljs-keyword">if</span>(pre!=null)<span class="hljs-comment">//不为空</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span>(pre==lq-&gt;</span>rear)<span class="hljs-comment">//只有一个节点情况</span><br>&#123; free(pre);&#125;<span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">p</span>=pre-&gt;</span>next;<span class="hljs-comment">//下一个节点</span><br><span class="hljs-keyword">while</span>(p!=null)<span class="hljs-comment">//不为空</span><br><br>&#123;<br>free(pre)<span class="hljs-comment">//节点数据</span><br>pre=p;<span class="hljs-comment">//下节点赋值</span><br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<span class="hljs-comment">//指向下一个节点</span><br><br>&#125;<br>free(pre);<span class="hljs-comment">//最好节点释放</span><br><br><br>&#125;<br><br>&#125;<br>free(lq);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-进队运算算法-1"><a href="#3-进队运算算法-1" class="headerlink" title="3.进队运算算法"></a>3.进队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924130041703.png" alt="image-20240924130041703"></p><h6 id="4-出队运算算法"><a href="#4-出队运算算法" class="headerlink" title="4.出队运算算法"></a>4.出队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f2bbe46cd00c440b2507086fdad63213.png" alt="f2bbe46cd00c440b2507086fdad63213"></p><h6 id="5-取队头元素运算算法"><a href="#5-取队头元素运算算法" class="headerlink" title="5.取队头元素运算算法"></a>5.取队头元素运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924130214173.png" alt="image-20240924130214173"></p><h6 id="6-判断队空运算算法"><a href="#6-判断队空运算算法" class="headerlink" title="6.判断队空运算算法"></a>6.判断队空运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924130241344.png" alt="image-20240924130241344"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-事务详解</title>
    <link href="/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6e6181b34accccf653ace905a69d8652.png" alt="在这里插入图片描述"></p><h4 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h4><p>MySQL 事务的实现主要依赖于以下几个核心组件和机制：</p><ol><li><strong>InnoDB存储引擎</strong>：MySQL事务通常是由InnoDB存储引擎支持的。InnoDB提供了事务的核心功能，如ACID（原子性、一致性、隔离性、持久性）属性。</li></ol><p>​    2.<strong>Redo Log（重做日志）</strong>：为了确保事务的<strong>持久性</strong>（Durability），InnoDB使用了Redo Log。在事务提交时，MySQL会将事务的修改记录写入Redo Log，即使系统崩溃，也可以通过Redo Log进行数据恢复</p><p>​      3.<strong>Undo Log（回滚日志）</strong>：为了支持<strong>原子性</strong>（Atomicity）和<strong>一致性</strong>（Consistency），MySQL会在事务开始之前记录数据的原始状态，即Undo Log。这样，如果事务失败或者被回滚，MySQL可以通过Undo Log恢复到修改前的状态。。 AT模式</p><p>​     4.锁机制</p><ul><li><strong>行锁</strong>：InnoDB支持行级锁，以确保多事务并发执行时的数据一致性。</li><li><strong>表锁</strong>：MySQL也支持表级锁，但InnoDB引擎通常使用行锁来提高并发性。</li></ul><p>锁的机制确保了事务的<strong>隔离性</strong>（Isolation），使得事务在并发操作时不会互相干扰。</p><p>​          5.<strong>隔离级别</strong>：MySQL支持多种事务隔离级别，如读未提交、读已提交、可重复读、串行化。通过这些隔离级别，MySQL可以控制事务并发时的读写行为，以减少并发带来的数据一致性问题。</p><p>​      6.<strong>两阶段提交</strong>：为了保证数据的一致性，MySQL采用了两阶段提交机制（2PC），在事务提交时，首先会将事务的变更写入Redo Log，确保日志写入成功后，再将实际数据写入磁盘。这可以保证事务的原子性，即事务要么全部提交成功，要么回滚。</p><p>​     7.<strong>MVCC</strong>（多版本并发控制）**：MySQL通过MVCC来实现事务的隔离性，特别是在可重复读（Repeatable Read）隔离级别下，使用MVCC可以让事务在读取数据时看到的是某个固定的快照，而不会被其他事务的并发修改所影响。</p><h4 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h4><p>锁学后补充</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当前读和快照读<br></code></pre></td></tr></table></figure><blockquote><p>，<strong>MVCC</strong>（多版本并发控制，<strong>Multi-Version Concurrency Control</strong>）是一种常用的机制，可以帮助数据库系统实现事务的<strong>隔离性</strong>。MVCC 通过为每个事务提供数据库中数据的不同版本来实现隔离，从而避免了事务之间的直接冲突。</p></blockquote><p>隔离性</p><h4 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h4><h6 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1.脏读"></a>1.脏读</h6><p>不同事务读取</p><p><strong>定义</strong>：脏读是指一个事务可以读取到另一个事务尚未提交的修改。如果后续事务回滚，读取的数据就会变成无效的，从而导致数据不一致。</p><p><strong>场景</strong>：事务A修改了某条记录，但未提交，事务B读取了该记录的修改内容。如果事务A回滚，事务B读取的数据就是无效的。</p><p><strong>SQL示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span>复制代码<span class="hljs-comment">-- 假设表 `accounts` 有一行数据：id = 1, balance = 1000</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">900</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 修改余额为900，但未提交</span><br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> balance <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 读到了事务A未提交的余额900</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">ROLLBACK</span>;  <span class="hljs-comment">-- 事务A回滚，balance恢复为1000</span><br><br><span class="hljs-comment">-- 事务B现在读到的余额是900，但实际上余额已经恢复为1000，这是脏读</span><br></code></pre></td></tr></table></figure><p><strong>解决方法</strong>：设置隔离级别为<strong>读已提交</strong>（Read Committed）或更高，防止脏读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;<br></code></pre></td></tr></table></figure><h6 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2.不可重复读"></a>2.不可重复读</h6><p>不可重复读发生在<strong>事务多次读取同一条记录</strong>时，由于另一个事务提交了修改，导致读取结果不同。</p><p><strong>定义</strong>：不可重复读是指在一个事务中对同一条记录的多次读取结果不一致，因为另一事务在两次读取之间修改了该记录并提交了修改。</p><p><strong>场景</strong>：事务A第一次读取某条记录的数据，事务B修改并提交了这条记录，事务A再次读取该记录时，读取到了不同的结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设表 `accounts` 有一行数据：id = 1, balance = 1000</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> balance <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 第一次读取，余额为1000</span><br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">800</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 修改余额为800</span><br><span class="hljs-keyword">COMMIT</span>;  <span class="hljs-comment">-- 提交事务B</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">SELECT</span> balance <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 第二次读取，余额变为800</span><br><br><span class="hljs-comment">-- 事务A第一次读取到的是1000，第二次读取到的是800，发生了不可重复读</span><br></code></pre></td></tr></table></figure><p><strong>解决方法</strong>：设置隔离级别为<strong>可重复读</strong>（Repeatable Read）或更高，防止不可重复读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><h6 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3.幻读"></a>3.幻读</h6><p><strong>定义</strong>：幻读是指一个事务在读取某范围内的记录时，另一事务插入了新的记录。由于新的记录符合第一次查询的条件，因此再次读取时，前后结果不同。</p><p><strong>场景</strong>：事务A在查询某个条件范围内的记录，事务B插入了一条符合条件的新记录，导致事务A的再次查询结果中出现“幻影”记录。</p><p>幻读发生在事务读取<strong>一个数据范围</strong>时，另一个事务在该范围内<strong>插入、删除</strong>了数据，导致读取到的记录集不同</p><p><strong>SQL示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span>复制代码<span class="hljs-comment">-- 假设表 `orders` 有两行数据：id = 1, 2，对应的金额为500, 800</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">300</span>;  <span class="hljs-comment">-- 查询金额大于300的订单，返回两条记录：id = 1, 2</span><br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (id, amount) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-number">700</span>);  <span class="hljs-comment">-- 插入新订单，金额为700</span><br><span class="hljs-keyword">COMMIT</span>;  <span class="hljs-comment">-- 提交事务B</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">300</span>;  <span class="hljs-comment">-- 再次查询，发现多了一条新记录：id = 3</span><br><br><span class="hljs-comment">-- 事务A第一次查询结果中没有id为3的记录，第二次却出现了，这是幻读</span><br></code></pre></td></tr></table></figure><p><strong>解决方法</strong>：设置隔离级别为<strong>串行化</strong>（Serializable）或通过InnoDB的<strong>间隙锁</strong>（Gap Lock）防止幻读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br></code></pre></td></tr></table></figure><p><strong>脏读</strong>：<strong>读取了其他事务尚未提交的修改</strong>，解决方法是使用<code>READ COMMITTED</code>或更高的隔离级别。</p><p><strong>不可重复读</strong>：<strong>同一事务中多次读取同一数据得到不同的结果</strong>，解决方法是使用<code>REPEATABLE READ</code>。</p><p><strong>幻读</strong>：<strong>事务中读取的范围内的记录集在后续读取时发生变化</strong>，解决方法是使用<code>SERIALIZABLE</code>或Gap Lock。</p><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/30c55ef7b7688240c3ef12043d093524.png" alt="30c55ef7b7688240c3ef12043d093524"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c5f1b25ebb4c14d48080d1f0f5c2701b.png" alt="img"></p><h6 id="1-Read-Uncommitted（读未提交）"><a href="#1-Read-Uncommitted（读未提交）" class="headerlink" title="1.. Read Uncommitted（读未提交）"></a>1.. <strong>Read Uncommitted（读未提交）</strong></h6><blockquote><ul><li><strong>脏读（Dirty Read）</strong>：会出现，事务可以读取未提交的数据。</li><li><strong>不可重复读（Non-repeatable Read）</strong>：会出现，由于数据可以被修改并提交，导致多次读取不一致。</li><li><strong>幻读（Phantom Read）</strong>：会出现，由于插入或删除操作可以影响读取范围内的数据集。</li></ul><p>在该隔离级别下，没有有效的并发控制，允许读取未提交的数据，因此可能出现所有并发问题。这种隔离级别通常不用于生产环境，因为数据一致性无法得到保障。</p></blockquote><h6 id="2-Read-Committed（读已提交）"><a href="#2-Read-Committed（读已提交）" class="headerlink" title="2.Read Committed（读已提交）"></a>2.<strong>Read Committed（读已提交）</strong></h6><blockquote><ul><li><strong>脏读</strong>：× 不会出现，事务只能读取已经提交的数据，避免了读取未提交的数据。</li><li><strong>不可重复读</strong>：√ 仍然会出现，因为在一个事务中多次读取同一条记录时，其他事务可以修改并提交该记录，导致前后读取结果不同。</li><li><strong>幻读</strong>：√ 仍然会出现，因为其他事务可以插入或删除符合查询条件的新记录，导致数据集的变化。</li><li>在 RC 级别下，事务每次读取数据时都会获取当前最新的已提交数据的快照。也就是说，当事务在执行两次相同的查询时，如果在这两次查询之间有其他事务提交了新的数据变更，查询结果可能不同。</li></ul><p><strong>如何解决脏读</strong>：通过<strong>只允许读取已提交的数据</strong>，避免了脏读问题。换句话说，事务只能看到其他事务已经提交的结果，而不是中途修改的未提交数据。</p></blockquote><h6 id="3-Repeatable-Read（可重复读，MySQL默认隔离级别）"><a href="#3-Repeatable-Read（可重复读，MySQL默认隔离级别）" class="headerlink" title="3. Repeatable Read（可重复读，MySQL默认隔离级别）"></a>3. <strong>Repeatable Read（可重复读，MySQL默认隔离级别）</strong></h6><blockquote><ul><li><strong>脏读</strong>：× 不会出现，事务只能看到已经提交的修改。</li><li><strong>不可重复读</strong>：× 不会出现，事务在其生命周期内使用一致性视图（Snapshot），即使其他事务修改并提交了数据，本事务多次读取同一条记录时，仍然会看到初始读取时的数据。—在 RR 级别下，事务在第一次读取数据时，会生成一个一致性读快照（快照的时间点是事务开始时或第一次读取时）。<ul><li><strong><strong><strong>一致性视图（Snapshot）：当事务在 <code>Repeatable Read</code> 隔离级别下启动时，MySQL 会创建一个快照（Snapshot）。事务中所有的 <code>SELECT</code> 语句都会从这个快照中读取数据，而不会受到其他事务在该事务执行过程中对数据库所做的更改影响。</strong></strong></strong></li></ul></li><li><strong>幻读</strong>：√ 仍然可能出现，因为其他事务可以在查询范围内插入或删除新记录，影响结果集。</li></ul><blockquote><p>**  ********* 一致性视图**只能保护已有的数据的一致性，但它并不能防止新的数据插入 **********</p></blockquote><p><strong>如何解决脏读和不可重复读</strong>：</p><ul><li><strong>脏读</strong>通过只读取已提交的数据解决。</li><li><strong>不可重复读</strong>通过<strong>一致性视图（MVCC）</strong>解决。事务在开始时获取一个快照，后续查询将基于这个快照，即使其他事务修改了记录，本事务始终读取同一版本的数据，避免了多次读取时数据不一致。</li></ul><p><strong>如何解决幻读（MySQL特性）</strong>：</p><ul><li>InnoDB通过引入<strong>间隙锁（Gap Lock）</strong>来部分解决幻读问题。间隙锁不仅锁住查询到的记录，还锁定记录之间的“间隙”，防止其他事务在这些间隙内插入新记录。虽然这在一定程度上解决了幻读问题，但并不是完全解决，特别是在复杂的查询场景中。</li></ul></blockquote><h6 id="4-Serializable（串行化）"><a href="#4-Serializable（串行化）" class="headerlink" title="4. Serializable（串行化）"></a>4. <strong>Serializable（串行化）</strong></h6><blockquote><ul><li><strong>脏读</strong>：× 不会出现。</li><li><strong>不可重复读</strong>：× 不会出现。</li><li><strong>幻读</strong>：× 不会出现。</li></ul><p><strong>如何解决所有问题</strong>：</p><ul><li>在串行化隔离级别下，事务是<strong>串行执行</strong>的，仿佛事务是一个接一个顺序完成的，不存在并发问题。MySQL通过<strong>加锁机制</strong> <strong>元数据锁（meta data lock）</strong>保证这一点。每次读取数据时都会加锁，任何其他事务在该事务执行过程中都无法对相关数据进行修改或插入，确保了没有数据的并发修改或插入，从根本上防止了脏读、不可重复读和幻读。</li></ul><p><strong>代价</strong>：由于串行化隔离级别会对所有相关数据加锁，因此并发性能大大降低，所有事务必须一个接一个地执行，无法同时进行并发操作。因此，这种隔离级别通常只在对数据一致性要求极高的场景中使用，且性能开销较大。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>和平转区半火封包</title>
    <link href="/2024/09/22/%E5%92%8C%E5%B9%B3ios%E8%BD%AC%E5%8C%BA%E5%8D%8A%E7%81%AB/"/>
    <url>/2024/09/22/%E5%92%8C%E5%B9%B3ios%E8%BD%AC%E5%8C%BA%E5%8D%8A%E7%81%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="和平ios转区"><a href="#和平ios转区" class="headerlink" title="和平ios转区"></a>和平ios转区</h1><h6 id="1-kit安装"><a href="#1-kit安装" class="headerlink" title="1.kit安装"></a>1.kit安装</h6><p>自行百度</p><h6 id="2-规则集配置"><a href="#2-规则集配置" class="headerlink" title="2.规则集配置"></a>2.规则集配置</h6><p>半火</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[RuleSet(id=<span class="hljs-number">1</span>, remark=转ios区半火防封规则<span class="hljs-number">1.2</span>[支持的辅助以验证页面为准], content=[RoutingRule]<br># 全火规则<span class="hljs-number">2403192</span><br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,t3yan,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,downloadfiler,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,spark,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,down.pandora,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,down.qq,REJECT<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,nj.cschannel.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,mbgame,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,down,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,meizu,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,dlie,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,anticheatexpert,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,gamesafe,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cschannel,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,wsdvs,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,chnc,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cloudcsp,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,payba,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com.chnc.cloudcsp.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,jiazhang,DIRECT<br><span class="hljs-keyword">DOMAIN</span>,api.m.taobao.com,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,eydata,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,qlogo,REJECT<br><span class="hljs-keyword">DOMAIN</span>,api.paojiaoyun.com,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,t3data,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.ssl.msdk.qq.com,DIRECT<br><span class="hljs-keyword">DOMAIN</span>,cloud.tgpa.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cdn.wetest.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,android.crashsight.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,game.weixin.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.mobi,REJECT<br><span class="hljs-keyword">DOMAIN</span>,android.bugly.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cloudctrl.gcloud.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,h.trace.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.tpns.sh.tencent.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,gatherer.m.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,snowflake.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cgi.<span class="hljs-keyword">connect</span>.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cfg.imtt.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,tbs.imtt.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,api.unipay.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,szmg.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,<span class="hljs-keyword">log</span>.tbs.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,flow.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,idcconfig.gcloudsdk.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,mazu.m.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.tga.qq.com,REJECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">182.254</span><span class="hljs-number">.116</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">223.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">123.187</span><span class="hljs-number">.28</span><span class="hljs-number">.125</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.144</span><span class="hljs-number">.82</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.150</span><span class="hljs-number">.14</span><span class="hljs-number">.112</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">150.138</span><span class="hljs-number">.104</span><span class="hljs-number">.242</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.182</span><span class="hljs-number">.23</span><span class="hljs-number">.64</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.44</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">222.132</span><span class="hljs-number">.143</span><span class="hljs-number">.107</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.162</span><span class="hljs-number">.101</span><span class="hljs-number">.24</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.99</span><span class="hljs-number">.140</span><span class="hljs-number">.58</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.140</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">117.157</span><span class="hljs-number">.238</span><span class="hljs-number">.251</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.141</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">163.171</span><span class="hljs-number">.198</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.163</span><span class="hljs-number">.161</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.81</span><span class="hljs-number">.238</span><span class="hljs-number">.132</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">118.112</span><span class="hljs-number">.241</span><span class="hljs-number">.91</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.156</span><span class="hljs-number">.77</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">103.254</span><span class="hljs-number">.188</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">113.125</span><span class="hljs-number">.206</span><span class="hljs-number">.16</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.31</span><span class="hljs-number">.16</span><span class="hljs-number">.74</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.240</span><span class="hljs-number">.60</span><span class="hljs-number">.41</span>/<span class="hljs-number">32</span>,PROXY<br>PORT,<span class="hljs-number">80</span>,REJECT<br>PORT,<span class="hljs-number">442</span><span class="hljs-number">-444</span>,REJECT<br>PORT,<span class="hljs-number">843</span>,PROXY<br>PORT,<span class="hljs-number">666</span>,PROXY<br>PORT,<span class="hljs-number">1024</span>,PROXY<br>PORT,<span class="hljs-number">5692</span>,REJECT<br>PORT,<span class="hljs-number">14000</span>,REJECT<br>PORT,<span class="hljs-number">15692</span>,REJECT<br>PORT,<span class="hljs-number">10011</span><span class="hljs-number">-10013</span>,PROXY<br>PORT,<span class="hljs-number">17501</span>,PROXY<br>PORT,<span class="hljs-number">17005</span>,PROXY<br>PORT,<span class="hljs-number">7889</span>,REJECT<br>PORT,<span class="hljs-number">8085</span>,PROXY<br>PORT,<span class="hljs-number">8081</span>,REJECT<br>PORT,<span class="hljs-number">20000</span>,PROXY<br>PORT,<span class="hljs-number">31003</span>,PROXY<br>PORT,<span class="hljs-number">50000</span>,PROXY<br>PORT,<span class="hljs-number">3861</span>,REJECT<br>PORT,<span class="hljs-number">13861</span>,REJECT<br>PORT,<span class="hljs-number">23861</span>,REJECT<br>PORT,<span class="hljs-number">33861</span>,REJECT<br>PORT,<span class="hljs-number">43861</span>,REJECT<br>PORT,<span class="hljs-number">53861</span>,REJECT<br>PORT,<span class="hljs-number">63861</span>,PROXY<br>PORT,<span class="hljs-number">4863</span>,REJECT<br>PORT,<span class="hljs-number">14863</span>,REJECT<br>PORT,<span class="hljs-number">24863</span>,REJECT<br>PORT,<span class="hljs-number">34863</span>,REJECT<br>PORT,<span class="hljs-number">44863</span>,REJECT<br>PORT,<span class="hljs-number">54863</span>,REJECT<br>PORT,<span class="hljs-number">64863</span>,PROXY<br>PORT,<span class="hljs-number">1762</span>,REJECT<br>PORT,<span class="hljs-number">11762</span>,REJECT<br>PORT,<span class="hljs-number">21762</span>,REJECT<br>PORT,<span class="hljs-number">31762</span>,REJECT<br>PORT,<span class="hljs-number">41762</span>,REJECT<br>PORT,<span class="hljs-number">51762</span>,REJECT<br>PORT,<span class="hljs-number">61762</span>,PROXY<br>PORT,<span class="hljs-number">17500</span>,PROXY<br>FINAL,DIRECT<br><br>[RoutingDomainStrategy]<br>AsIs<br><br>[FreedomDomainStrategy]<br>AsIs<br><br>[LocalPolicy]<br>bufferSize = <span class="hljs-number">4096</span><br>connIdle = <span class="hljs-number">600</span><br>downlinkOnly = <span class="hljs-number">0</span><br>handshake = <span class="hljs-number">64</span><br>uplinkOnly = <span class="hljs-number">0</span><br><br>[DnsServer]<br><br>[DnsRule]<br><br>[DnsHost]<br><br>[DnsClientIp]<br><br>[<span class="hljs-keyword">Log</span>]<br>loglevel = <span class="hljs-keyword">none</span><br><br>[PerAppVpn]<br><br>[PerAppMode]<br><br>[PerAppAllow]<br><br>[PerAppDisallow], url=<span class="hljs-keyword">null</span>, lastUpdate=<span class="hljs-keyword">null</span>), RuleSet(id=<span class="hljs-number">2</span>, remark=仅供[扫码/更新游戏/地图/扫脸/异地],不可防封使用;扫设备脸需分代理勾选qqvx,否则人脸环境异常<span class="hljs-number">1.0</span>, content=[RoutingRule]<br># 扫码规则<span class="hljs-number">0710</span><br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.tpns.sh.tencent.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,snowflake.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,<span class="hljs-keyword">log</span>.tbs.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,idcconfig.gcloudsdk.com,REJECT<br><br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,nj.cschannel.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,meizu,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,anticheatexpert,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,gamesafe,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,wsdvs,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,chnc,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cloudcsp,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com.chnc.cloudcsp.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,qlogo,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,dlie,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,mbgame,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cschannel,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,anticheatexpert,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,payba,PROXY<br><span class="hljs-keyword">DOMAIN</span>,ry643.top,PROXY<br><span class="hljs-keyword">DOMAIN</span>,w.eydata.net,PROXY<br><span class="hljs-keyword">DOMAIN</span>,w5.eydata.net,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,lanzou,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,jiazhang,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,<span class="hljs-keyword">open</span>,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,google,DIRECT<br><span class="hljs-keyword">DOMAIN</span>,intldlgs.qq.com,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">182.254</span><span class="hljs-number">.116</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">223.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.136</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.217</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.93</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.116</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.179</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.52</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.151</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.119</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.228</span><span class="hljs-number">.118</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.18</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.99</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.171</span><span class="hljs-number">.23</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.73</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.249</span><span class="hljs-number">.82</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.251</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.206</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.211</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.100</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.204</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">117.89</span><span class="hljs-number">.177</span><span class="hljs-number">.167</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">222.94</span><span class="hljs-number">.109</span><span class="hljs-number">.22</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.186</span><span class="hljs-number">.200</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">182.50</span><span class="hljs-number">.10</span><span class="hljs-number">.74</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">59.83</span><span class="hljs-number">.207</span><span class="hljs-number">.176</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.251</span><span class="hljs-number">.15</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">109.244</span><span class="hljs-number">.228</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.137</span><span class="hljs-number">.190</span><span class="hljs-number">.80</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.119</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.137</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.18</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.85</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.8</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.135</span><span class="hljs-number">.105</span><span class="hljs-number">.28</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.204</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.192</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.246</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.140</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.164</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.93</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.185</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.230</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.111</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.182</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.249</span><span class="hljs-number">.33</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.228</span><span class="hljs-number">.242</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.22</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.43</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.171</span><span class="hljs-number">.46</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.171</span><span class="hljs-number">.203</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.253</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.46</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.249</span><span class="hljs-number">.84</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.32</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.250</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.222</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.152</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.228</span><span class="hljs-number">.234</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.73</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.95</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.185</span><span class="hljs-number">.128</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.76</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.53</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.67</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.177</span><span class="hljs-number">.246</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.185</span><span class="hljs-number">.85</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.67</span><span class="hljs-number">.163</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">220.194</span><span class="hljs-number">.120</span><span class="hljs-number">.73</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.192</span><span class="hljs-number">.160</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">60.28</span><span class="hljs-number">.172</span><span class="hljs-number">.70</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">220.194</span><span class="hljs-number">.120</span><span class="hljs-number">.90</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">60.29</span><span class="hljs-number">.239</span><span class="hljs-number">.218</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.192</span><span class="hljs-number">.202</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.179</span><span class="hljs-number">.246</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.184</span><span class="hljs-number">.84</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.78</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.171</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.186</span><span class="hljs-number">.37</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.185</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">183.2</span><span class="hljs-number">.143</span><span class="hljs-number">.21</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">14.22</span><span class="hljs-number">.9</span><span class="hljs-number">.124</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">14.22</span><span class="hljs-number">.9</span><span class="hljs-number">.210</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.112</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.178</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.209</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.231</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.169</span><span class="hljs-number">.81</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.167</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.240</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.169</span><span class="hljs-number">.110</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.28</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.19</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">14.22</span><span class="hljs-number">.9</span><span class="hljs-number">.201</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.168</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.94</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.60</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.127</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.110</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.203</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.58</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.87</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.150</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.215</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.172</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.32</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.225</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.107</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.126</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.189</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.69</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.153</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.90</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.125</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.23</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.5</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.65</span><span class="hljs-number">.237</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.27</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.27</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.27</span><span class="hljs-number">.62</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.6</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.35</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.37</span><span class="hljs-number">.101</span><span class="hljs-number">.66</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.105</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.249</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.47</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.94</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.19</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.229</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.60</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.57</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.53</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.37</span><span class="hljs-number">.101</span><span class="hljs-number">.56</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.84</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.214</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.152</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.208</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.177</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.33</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.35</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.11</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.94</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.149</span><span class="hljs-number">.19</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.93</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.80</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.150</span><span class="hljs-number">.78</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.143</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.199</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.161</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.37</span><span class="hljs-number">.101</span><span class="hljs-number">.103</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.102</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.150</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.22</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.68</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.203</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.31</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.70</span><span class="hljs-number">.196</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.27</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.238</span><span class="hljs-number">.41</span><span class="hljs-number">.116</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.70</span><span class="hljs-number">.219</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.70</span><span class="hljs-number">.162</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.238</span><span class="hljs-number">.41</span><span class="hljs-number">.103</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.70</span><span class="hljs-number">.252</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.69</span><span class="hljs-number">.12</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.228</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.238</span><span class="hljs-number">.41</span><span class="hljs-number">.36</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.170</span><span class="hljs-number">.35</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.183</span><span class="hljs-number">.51</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.179</span><span class="hljs-number">.205</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.183</span><span class="hljs-number">.164</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.219</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.194</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.152</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">123.187</span><span class="hljs-number">.28</span><span class="hljs-number">.125</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.144</span><span class="hljs-number">.82</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.150</span><span class="hljs-number">.14</span><span class="hljs-number">.112</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">150.138</span><span class="hljs-number">.104</span><span class="hljs-number">.242</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.182</span><span class="hljs-number">.23</span><span class="hljs-number">.64</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.44</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">222.132</span><span class="hljs-number">.143</span><span class="hljs-number">.107</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.162</span><span class="hljs-number">.101</span><span class="hljs-number">.24</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.99</span><span class="hljs-number">.140</span><span class="hljs-number">.58</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.140</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">117.157</span><span class="hljs-number">.238</span><span class="hljs-number">.251</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.141</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">163.171</span><span class="hljs-number">.198</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.163</span><span class="hljs-number">.161</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.81</span><span class="hljs-number">.238</span><span class="hljs-number">.132</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">118.112</span><span class="hljs-number">.241</span><span class="hljs-number">.91</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.156</span><span class="hljs-number">.77</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">103.254</span><span class="hljs-number">.188</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">113.125</span><span class="hljs-number">.206</span><span class="hljs-number">.16</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.31</span><span class="hljs-number">.16</span><span class="hljs-number">.74</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.240</span><span class="hljs-number">.60</span><span class="hljs-number">.41</span>/<span class="hljs-number">32</span>,PROXY<br>PORT,<span class="hljs-number">666</span>,PROXY<br>PORT,<span class="hljs-number">1024</span>,PROXY<br>PORT,<span class="hljs-number">10012</span>,PROXY<br>PORT,<span class="hljs-number">8085</span>,PROXY<br>PORT,<span class="hljs-number">20000</span>,PROXY<br>PORT,<span class="hljs-number">31003</span>,PROXY<br>PORT,<span class="hljs-number">50000</span>,PROXY<br>PORT,<span class="hljs-number">8081</span>,REJECT<br>PORT,<span class="hljs-number">7889</span>,PROXY<br>PORT,<span class="hljs-number">17500</span>,PROXY<br>PORT,<span class="hljs-number">843</span>,PROXY<br>PORT,<span class="hljs-number">5692</span>,REJECT<br>PORT,<span class="hljs-number">14000</span>,REJECT<br>PORT,<span class="hljs-number">15692</span>,REJECT<br>PORT,<span class="hljs-number">17501</span>,PROXY<br>PORT,<span class="hljs-number">17005</span>,PROXY<br>FINAL,DIRECT<br><br>[RoutingDomainStrategy]<br>AsIs<br><br>[FreedomDomainStrategy]<br>AsIs<br><br>[LocalPolicy]<br>bufferSize = <span class="hljs-number">4096</span><br>connIdle = <span class="hljs-number">600</span><br>downlinkOnly = <span class="hljs-number">0</span><br>handshake = <span class="hljs-number">64</span><br>uplinkOnly = <span class="hljs-number">0</span><br><br>[DnsServer]<br><br>[DnsRule]<br><br>[DnsHost]<br><br>[DnsClientIp]<br><br>[<span class="hljs-keyword">Log</span>]<br>loglevel = <span class="hljs-keyword">none</span><br><br>[PerAppVpn]<br><br>[PerAppMode]<br><br>[PerAppAllow]<br><br>[PerAppDisallow], url=<span class="hljs-keyword">null</span>, lastUpdate=<span class="hljs-keyword">null</span>)]<br></code></pre></td></tr></table></figure><h6 id="3-down映射-封包"><a href="#3-down映射-封包" class="headerlink" title="3.down映射  封包"></a>3.down映射  封包</h6><p>下载地址</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">假￥<span class="hljs-number">0</span>￥假￥<span class="hljs-number">0</span>￥假￥￥假￥<span class="hljs-number">0</span>￥<span class="hljs-number">0</span>￥真￥假￥假￥<span class="hljs-number">1</span>￥ 过滤器 <span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥假￥真￥假￥真￥<span class="hljs-number">0</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0</span><span class="hljs-symbol">$</span>￥<span class="hljs-number">0</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0</span><span class="hljs-symbol">$</span>￥<span class="hljs-number">1</span><span class="hljs-symbol">$</span><span class="hljs-number">1000000065</span><span class="hljs-symbol">$</span><span class="hljs-number">5</span><span class="hljs-symbol">$</span>￥<span class="hljs-number">5</span><span class="hljs-symbol">$</span><span class="hljs-number">66</span><span class="hljs-symbol">$</span><span class="hljs-number">1</span><span class="hljs-symbol">$</span>￥假￥<span class="hljs-number">0</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>￥￥<span class="hljs-number">1</span>￥<br></code></pre></td></tr></table></figure><p>过滤器 1勾选</p>]]></content>
    
    
    <categories>
      
      <category>杂言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sql  函数 约束 多表查询 新手02</title>
    <link href="/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(2)/"/>
    <url>/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql常见函数使用-二"><a href="#Mysql常见函数使用-二" class="headerlink" title="Mysql常见函数使用(二)"></a>Mysql常见函数使用(二)</h1><h4 id="1-思维导图"><a href="#1-思维导图" class="headerlink" title="1.思维导图"></a>1.思维导图</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f83095441457603846914321ac6d2732.png" alt="在这里插入图片描述"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="Mysql常见约束使用-三"><a href="#Mysql常见约束使用-三" class="headerlink" title="Mysql常见约束使用(三)"></a>Mysql常见约束使用(三)</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c8dc24ae2c02733b1e814ea10aa8f2e.png" alt="在这里插入图片描述"></p><h6 id="1-普通约束探究"><a href="#1-普通约束探究" class="headerlink" title="1.普通约束探究"></a>1.普通约束探究</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>(<br>    id <span class="hljs-type">int</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;ID唯一标识&#x27;</span>,<br>    <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;姓名&#x27;</span> ,<br>    age <span class="hljs-type">int</span> <span class="hljs-keyword">check</span> (age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt;= <span class="hljs-number">120</span>)  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;年龄&#x27;</span> ,<br>    status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span>  <span class="hljs-string">&#x27;1&#x27;</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;状态&#x27;</span>,<br>    test <span class="hljs-type">int</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;无约束对比测试字段&#x27;</span><br> );<br><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br></code></pre></td></tr></table></figure><h6 id="2-外键约束探究"><a href="#2-外键约束探究" class="headerlink" title="2.外键约束探究"></a>2.外键约束探究</h6><p>逻辑探究</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20c13f39af895a49334d1a1de9de0cbe.png" alt="在这里插入图片描述"></p><p>它们只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联。也就说emp表中的dept_id值可以为任意数值，即是dept表中不存在。而dept表中字段被emp使用了也可以随意删除。 因此无法保证数据的一致性和完整性的。这时候就需要我们严格的进行手动维护或者<strong>使用外键约束</strong>。</p><p>父子关系探究</p><p><strong>父表</strong>（也称为<strong>主表</strong>）是提供主键（或唯一键）的表</p><p><strong>数据依赖</strong>：父表中的主键数据必须先存在，子表中的外键才能引用这些数据。这意味着父表不依赖子表，而子表依赖父表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 必须先创建需要关联的父表 (dept)<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br> id  <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br> name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br> age  <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br> job <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br> salary <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br> entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br> managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导ID&#x27;</span>,<br> dept_id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span>,<br> <span class="hljs-keyword">CONSTRAINT</span> fk_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> dept(id)<br> )comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h1 id="Mysql常见多表查询-四"><a href="#Mysql常见多表查询-四" class="headerlink" title="Mysql常见多表查询(四)"></a>Mysql常见多表查询(四)</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eea4e831fb9433b06cdfb829a6f17155.png" alt="在这里插入图片描述"></p><h6 id="1-多表查询探究"><a href="#1-多表查询探究" class="headerlink" title="1.多表查询探究"></a>1.多表查询探究</h6><p>多表查询就是指一次性从多张表中查询数据。</p><p>原来我们查询单表数据，执行的SQL形式为：select 字段列表 from 表名;</p><p>现在我们想要执行多表查询，就只需要使用逗号分隔多张表即可，如： select 字段列表 from 表名1, 表名2;</p><p>但是我们这样使用却发现存在问题：的确同时查到了多张表的数据，但是数据形式和我们想要的并不一样,它排列组合了两张表中的所有数据项！</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3e30ec1139034dfb8e32d6a5074b5896.png" alt="img"></p><p>例如我们查询员工、部门表，本来我们预期是每个员工对应其所在的部门，但事实确实，每个员工都对应了所有部门。这种现象也称之为 <strong>笛卡尔积</strong> 。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c032561ec0a9cb631757c5c82194ed98.png" alt="在这里插入图片描述"></p><p>因此，在多表查询中，我们需要根据业务情况进行连接查询，消除无效的笛卡尔积，只保留两张表关联部分的有效数据。</p><p>例如在上述示例，我们通过<code>表名.字段名</code>指定员工表的外键等于部门表的主键即可获得预期数据~</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/74724d85cff811c118e2327a50b23133.png" alt="在这里插入图片描述"></p><h6 id="2-内链接探究"><a href="#2-内链接探究" class="headerlink" title="2.内链接探究"></a>2.内链接探究</h6><p>内连接是将两个或多个表根据指定条件连接在一起，只返回在所有连接表中都有匹配的记录。</p><p>内连接查询的是两张表交集部分的数据(也就是绿色部分的数据)。语法分为两种: 隐式内连接、显式内连接。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a368439562c0c96ffd6e306c72615448.png" alt="在这里插入图片描述"></p><p><strong>隐式内连接</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询每一个员工的姓名 , 及关联的部门的名称 <br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name,d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span>,dept d <span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><p>显式内连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询每一个员工的姓名 , 及关联的部门的名称 <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br><br></code></pre></td></tr></table></figure><h6 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3.外链接"></a>3.外链接</h6><p>外连接分为：左外连接 和 右外连接。左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4692bf13bf155811a9d1a0d8d6ba3eef.png" alt="在这里插入图片描述"></p><p>左外</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询emp表的所有数据, 和对应的部门信息<br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ef678e5b47e14a2c2e795cfe33c277d5.png" alt="在这里插入图片描述"></p><p>先出左表数据-右表数据拼接</p><p>右外链接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询emp表的所有数据, 和对应的部门信息 <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/49775a0ba7918f7e351015e047c8fa26.png" alt="在这里插入图片描述"></p><p>数据在右边-然后链接左表-包括null-没对应上的也会显示这就是查询范围</p><h6 id="4-内外区别探究"><a href="#4-内外区别探究" class="headerlink" title="4.内外区别探究"></a>4.内外区别探究</h6><p>在MySQL中，多表查询常常使用<strong>内连接（INNER JOIN）</strong>和<strong>外连接（OUTER JOIN）</strong>来实现。两者的区别在于查询结果集中是否包含没有匹配记录的行。以下是它们的区别及例子说明：</p><p>1.<strong>内连接</strong>只返回两个表中满足条件的记录。如果某一行在其中一个表中没有对应的匹配行，则该行不会出现在结果集中。</p><p>2.<strong>左外连接（LEFT JOIN）：</strong> 返回左表中的所有记录，即使在右表中没有匹配的记录，右表中没有匹配的地方会显示NULL。</p><p><strong>3.右外连接（RIGHT JOIN）：</strong> 返回右表中的所有记录，即使在左表中没有匹配的记录，左表中没有匹配的地方会显示NULL。</p><h6 id="5-自链接"><a href="#5-自链接" class="headerlink" title="5.自链接"></a>5.自链接</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 查询员工 及其 所属领导的名字,如果员工没有领导, 也需要查询出来<br><span class="hljs-keyword">select</span> a.name <span class="hljs-string">&#x27;员工&#x27;</span>, b.name <span class="hljs-string">&#x27;领导&#x27;</span> <span class="hljs-keyword">from</span> emp a <span class="hljs-keyword">left join</span> emp b <span class="hljs-keyword">on</span> a.managerid = <br>b.id;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d2a7ee93e7a0a2f9dbfc4b10ba44721a.png" alt="在这里插入图片描述"></p><h6 id="6-联合查询"><a href="#6-联合查询" class="headerlink" title="6.联合查询"></a>6.联合查询</h6><ul><li>注意事项<ul><li>对于联合查询的多张表的<strong>字段列表必须保持一致</strong>，<strong>字段类型也需要保持一致</strong>，如果不一致将会报错。</li><li><code>union all</code> 会将<strong>全部的数据直接合并</strong>在一起，<code>union</code> 会对合并之后的<strong>数据去重</strong>。</li></ul></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary &lt; <span class="hljs-number">5000</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age &gt; <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/acf531e80357c6afe3043efacc9b3b4c.png" alt="在这里插入图片描述"></p><p><code>union all</code>查询出来的结果，仅仅只对数据集进行简单的合并，查询结果中可能会存在重复数据项，使用<code>union</code>即可去除重复数据项。</p><h4 id="6-子查询"><a href="#6-子查询" class="headerlink" title="6.子查询"></a>6.子查询</h4><p><strong>子查询是指在一个 SQL 查询中嵌套的另一个查询。子查询可以用来返回单个值、多个值或一组记录。它们通常用于提供数据给外部查询的条件。</strong></p><blockquote><p><strong>嵌套性</strong>：子查询可以嵌入在 SELECT、INSERT、UPDATE 或 DELETE 语句中，也可以作为条件使用。</p><p><strong>独立性</strong>：子查询可以独立执行，通常会返回一个结果集，该结果集可以被外部查询使用。</p><p><strong>可以返回多种结果</strong>：子查询可以返回单个值（标量子查询）、单列多行（列子查询）或多列多行（表子查询）。</p><p><strong>执行顺序</strong>：子查询在外部查询执行之前先执行，外部查询使用子查询的结果。</p><p><strong>可用于过滤条件</strong>：子查询常用在 WHERE、HAVING 和 FROM 子句中，用于动态生成条件。</p></blockquote><h6 id="1-标量子查询"><a href="#1-标量子查询" class="headerlink" title="1.标量子查询"></a>1.标量子查询</h6><ul><li>使用示例：查询 “销售部” 的所有员工信息</li><li>返回单个值（例如，单个数值或字符串）。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 拆分<span class="hljs-number">1</span>： 查询 &quot;销售部&quot; 部门ID，返回单个id值<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span>;<br><br># 拆分<span class="hljs-number">2</span>：根据部门ID, 查询员工信息<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = xxx;<br><br># 完整版<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id = (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h6 id="2-列子查询"><a href="#2-列子查询" class="headerlink" title="2.列子查询"></a>2.列子查询</h6><p>子查询返回的结果是<strong>一列</strong>（可以是多行）。常用的操作符：<code>IN 、NOT IN 、 ANY 、SOME 、 ALL</code></p><ul><li>使用示例：查询比 财务部 所有人工资都高的员工信息</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> dept);<br></code></pre></td></tr></table></figure><h6 id="3-行子查询"><a href="#3-行子查询" class="headerlink" title="3.行子查询"></a>3.行子查询</h6><p>返回多行的结果集。</p><ul><li>这个查询将返回所有薪资高于部门 ID 为 1 的任意员工薪资的员工。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">WHERE</span> salary &gt; <span class="hljs-keyword">ANY</span> (<span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> dept_id = <span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><h6 id="4-表子查询"><a href="#4-表子查询" class="headerlink" title="4. 表子查询"></a>4. 表子查询</h6><ul><li>返回多个列和多行的结果集。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">e</span>.name, <span class="hljs-built_in">e</span>.salary <br><span class="hljs-keyword">FROM</span> emp <span class="hljs-built_in">e</span> <br><span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> location = <span class="hljs-string">&#x27;北京&#x27;</span>) d <br><span class="hljs-keyword">ON</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><blockquote><p><code>(SELECT id, name FROM dept WHERE location = &#39;北京&#39;)</code> 返回一个临时表，包含位于 ‘北京’ 的部门的 ID 和名称。外部查询则连接这个临时表与员工表 <code>emp</code>，以获取相应的员工信息。</p></blockquote><p>多表查询业务能实现相关需求的SQL往往会很多, 写法也多种多样，总之，能满足我们的需求，查询出符合条件的记录即可~</p><h6 id="5-常用关键字"><a href="#5-常用关键字" class="headerlink" title="5.常用关键字"></a>5.常用关键字</h6><p>1.in</p><p><code>IN</code> 用于检查某个值是否在一个给定的集合中，可以是多个值的列表或一个子查询的结果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">location</span> = <span class="hljs-string">&#x27;北京&#x27;</span>);<br>这个查询会返回所有在部门位于 <span class="hljs-string">&#x27;北京&#x27;</span> 的员工。<br><br><br></code></pre></td></tr></table></figure><p>2.any</p><p><code>ANY</code> 用于与比较操作符（如 <code>=</code>、<code>&gt;</code>、<code>&lt;</code> 等）结合使用，检查一个值是否与子查询结果中的任意值满足条件。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">WHERE</span> salary &gt; <span class="hljs-keyword">ANY</span> (<span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> dept_id = <span class="hljs-number">1</span>);<br>这个查询会返回所有薪资高于部门 ID 为 1 的任意员工薪资的员工。<br><br><br></code></pre></td></tr></table></figure><p>3.all</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALL</span> 也用于与比较操作符结合使用，检查一个值是否与子查询结果中的所有值满足条件。<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> emp <br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span> (<span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>);<br>这个查询会返回所有薪资高于部门 ID 为 <span class="hljs-number">2</span> 的所有员工薪资的员工。<br><br><br></code></pre></td></tr></table></figure><p>**<code>IN</code>**：用于检查某个值是否在集合中，适用于多个值的比较。</p><p>**<code>ANY</code>**：检查一个值是否与子查询结果中的任意值满足条件。</p><p>**<code>ALL</code>**：检查一个值是否与子查询结果中的所有值满足条件。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sql新手入门 ddl-dml-dql-dcl 01</title>
    <link href="/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <url>/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Sql新手入门-01"><a href="#Sql新手入门-01" class="headerlink" title="Sql新手入门 01"></a>Sql新手入门 01</h1><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本篇大部分内容来自csdn </p><p><a href="https://blog.csdn.net/m0_66570338/article/details/131730913">https://blog.csdn.net/m0_66570338/article/details/131730913</a></p><p>我对此进行修改-</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a5f4ea63bd6983a1d180f567908b5daa.png" alt="a5f4ea63bd6983a1d180f567908b5daa" style="zoom:80%;" /><h4 id="0-Sql分类"><a href="#0-Sql分类" class="headerlink" title="0.Sql分类"></a>0.Sql分类</h4><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><p>分类全称说明<br>DDLData Definition Language数据定义语言，用来定义数据库对象(数据库，表， 字段)<br>DMLData Manipulation Language数据操作语言，用来对数据库表中的数据进行增删改<br>DQLData Query Language数据查询语言，用来查询数据库中表的记录<br>DCLData Control Language数据控制语言，用来创建数据库用户、控制数据库的访问权限</p><p>书写规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span>语句可以单行或多行书写，以分号结尾。<br>MySQL数据库的<span class="hljs-keyword">SQL</span>语句不区分大小写，关键字建议使用大写。<br>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。<br>如果删除一个不存在的数据库，将会报错。<br>注释：<br>单行注释：<span class="hljs-comment">-- 注释内容 或 # 注释内容</span><br>多行注释：<span class="hljs-comment">/* 注释内容 */</span><br>————————————————<br><br></code></pre></td></tr></table></figure><h4 id="1-DDl语句"><a href="#1-DDl语句" class="headerlink" title="1.DDl语句"></a>1.DDl语句</h4><blockquote><p>Data Definition Language，数据定义语言，用来<strong>定义数据库对象(数据库，表，字段)</strong></p></blockquote><h6 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/85f114d7164ea6b8d14c8753f559e498.png" alt="在这里插入图片描述"></p><h6 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2.表操作"></a>2.表操作</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e4c611c8e61b11089a9668c45a904d00.png" alt="在这里插入图片描述"></p><h4 id="2-表字段类型"><a href="#2-表字段类型" class="headerlink" title="2.表字段类型"></a>2.表字段类型</h4><p><strong>数值类型</strong>、<strong>字符串类型</strong>、<strong>日期时间类型</strong>。</p><h6 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1.数值类型"></a>1.数值类型</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922162704845.png" alt="image-20240922162704845"></p><h6 id="2-日期和时间"><a href="#2-日期和时间" class="headerlink" title="2.日期和时间"></a>2.日期和时间</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922162753672.png" alt="image-20240922162753672"></p><h6 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3.字符串类型"></a>3.字符串类型</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922162817233.png" alt="image-20240922162817233"></p><h4 id="3-Dml"><a href="#3-Dml" class="headerlink" title="3.Dml"></a>3.Dml</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4fd1e47a99b734dc110abb78ade371fc.png" alt="img"></p><h4 id="4-Dql"><a href="#4-Dql" class="headerlink" title="4.Dql"></a>4.Dql</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/677d64d1d94c9eb05de365a77a53c84f.png" alt="在这里插入图片描述"></p><h6 id="0-条件查询"><a href="#0-条件查询" class="headerlink" title="0.条件查询"></a>0.条件查询</h6><blockquote></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922163541712.png" alt="image-20240922163541712"></p><h6 id="1-聚合函数查询"><a href="#1-聚合函数查询" class="headerlink" title="1.聚合函数查询"></a>1.聚合函数查询</h6><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>count</code></td><td>统计数量</td></tr><tr><td><code>max</code></td><td>最大值</td></tr><tr><td><code>min</code></td><td>最小值</td></tr><tr><td><code>avg</code></td><td>平均值</td></tr><tr><td><code>sum</code></td><td>求和</td></tr></tbody></table><h6 id="2-分组查询"><a href="#2-分组查询" class="headerlink" title="2.分组查询"></a>2.分组查询</h6><p>注意事项：</p><p>where与having区别<br>执行时机不同：where是分组之前进行过滤；<strong>having是分组之后对结果进行过滤。</strong><br>判断条件不同：<strong>where不能对聚合函数进行判断，而having可以</strong>。执行顺序: where &gt; 聚合函数 &gt; having。<br>支持多字段分组, 具体语法为 : group by 分组字段名1,分组字段名2</p><ul><li><strong>查询年龄小于45的员工</strong> , <strong>并根据工作地址分组</strong> , <strong>获取员工数量大于等于3的工作地址</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) address_count <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>workaddress <span class="hljs-keyword">having</span> address_count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a1f80af3ea4aa35c7f0ec97c1a9692ec.png" alt="img"></p><h6 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h6><p>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式,字段2 排序方式;</p><ul><li><p>排序方式类别</p><ul><li>ASC：升序(默认值)</li><li>DESC: 降序</li></ul></li><li><p>注意事项</p><ul><li>如果是升序, 可以不指定排序方式ASC ;</li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</li></ul></li><li><p>根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序</p></li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> , entrydate <span class="hljs-keyword">desc</span>;<br><br></code></pre></td></tr></table></figure><h6 id="4-分页查询"><a href="#4-分页查询" class="headerlink" title="4.分页查询"></a>4.分页查询</h6><p>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</p><ul><li><p>起始索引从0开始，计算规则为：（查询页码 - 1）* 每页显示记录数。</p></li><li><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p></li><li><p>查询第1页员工数据, 每页展示5条记录</p></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">limit</span> <span class="hljs-number">5</span>;<br><br></code></pre></td></tr></table></figure><ul><li>查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">limit</span> <span class="hljs-number">5</span>,<span class="hljs-number">5</span>;<br><br></code></pre></td></tr></table></figure><p>疑问 分页插件做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><span class="hljs-comment">/// 1 页 =多少大小 --2页多少大小</span><br>    <span class="hljs-comment">//转换为 limit x,x</span><br>    <span class="hljs-keyword">public</span> Page&lt;User&gt; <span class="hljs-title function_">getUsersByPage</span><span class="hljs-params">(<span class="hljs-type">int</span> currentPage, <span class="hljs-type">int</span> pageSize)</span> &#123;<br>        <span class="hljs-comment">// 创建 Page 对象</span><br>        Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(currentPage, pageSize);<br><br>        <span class="hljs-comment">// 创建 QueryWrapper 对象</span><br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        queryWrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 按照 id 降序排列</span><br><br>        <span class="hljs-comment">// 执行分页查询</span><br>        <span class="hljs-keyword">return</span> userMapper.selectPage(page, queryWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-复合使用"><a href="#5-复合使用" class="headerlink" title="5.复合使用"></a>5.复合使用</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cd2609707cb2bcce03cd4394e72495c2.png" alt="在这里插入图片描述"></p><ul><li>DQL语句复合使用系统执行顺序为： <code>from ... where ... group by ... having ... select ... order by ... limit ...</code></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">关于<span class="hljs-keyword">having</span>、<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>以及聚合函数的执行顺序问题，整个执行顺序可以这么理解：<br><br>先执行<span class="hljs-keyword">from</span>语句（表之间的笛卡尔积、交并差等），获得一个虚拟表<br>如果<span class="hljs-keyword">where</span>语句存在，从虚拟表中筛出符合<span class="hljs-keyword">where</span>条件的数据，不满足的被剔除<br>如果<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>语句存在，则目前存活的数据分组；如果不存在<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>，则将这些数据视为一个组<br>如果存在<span class="hljs-keyword">having</span>语句，则将满足<span class="hljs-keyword">having</span>条件的组留下，不满足的组被剔除<br>执行<span class="hljs-keyword">select</span>语句：对存活下来的每个组分别执行聚合函数，形成查询结果<br>执行<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 语句：对剩下的数据进行排序<br>执行<span class="hljs-keyword">limit</span> 语句：限制返回的数据条数<br>————————————————<br></code></pre></td></tr></table></figure><ul><li>查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序， 年龄相同按入职时间升序排序。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span> <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> ,entrydate <span class="hljs-keyword">asc</span> <br>limit <span class="hljs-number">5</span> ;<br></code></pre></td></tr></table></figure><h4 id="6-Dcl"><a href="#6-Dcl" class="headerlink" title="6.Dcl"></a>6.Dcl</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3eee03a3e74c60d2abf1179f360f5080.png" alt="在这里插入图片描述"></p><h6 id="0-权限控制列表"><a href="#0-权限控制列表" class="headerlink" title="0.权限控制列表"></a>0.权限控制列表</h6><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>ALL, ALL PRIVILEGES</code></td><td>所有权限</td></tr><tr><td><code>SELECT</code></td><td>查询数据</td></tr><tr><td><code>INSERT</code></td><td>插入数据</td></tr><tr><td><code>UPDATE</code></td><td>修改数据</td></tr><tr><td><code>DELETE</code></td><td>删除数据</td></tr><tr><td><code>ALTER</code></td><td>修改表</td></tr><tr><td><code>DROP</code></td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td><code>CREATE</code></td><td>创建数据库&#x2F;表</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dr自动踢人</title>
    <link href="/2024/09/21/Dr%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%BF%87%E6%BB%A4%E8%B8%A2%E5%87%BA/"/>
    <url>/2024/09/21/Dr%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%BF%87%E6%BB%A4%E8%B8%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/454.png" alt="454"></p><p>ps:由于校园网经常有人用，对此写了个白名单踢人爬虫。外加循环登录，和一个加密参数v</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务Spring Cloude</title>
    <link href="/2024/09/20/%E5%BE%AE%E6%9C%8D%E5%8A%A101/"/>
    <url>/2024/09/20/%E5%BE%AE%E6%9C%8D%E5%8A%A101/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务01"><a href="#微服务01" class="headerlink" title="微服务01"></a>微服务01</h1><blockquote><p>2024 10 1 更新 微服务事务的场景 cap-   ca   cp原则      Seata的模式</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1.png" alt="1"></p><p>总结-<br>微服务01</p><p>远程调用 RestTemplate-&gt;nacos-&gt;OpenFeign-&gt;</p><p>微服务02  GetWay网关-&gt;nacos进阶</p><p>微服务3 微服务保护-&gt;Sentinel-&gt;微服务事务</p><h4 id="微服务了解"><a href="#微服务了解" class="headerlink" title="微服务了解"></a>微服务了解</h4><h6 id="1-微服务和单体服务区别"><a href="#1-微服务和单体服务区别" class="headerlink" title="1.微服务和单体服务区别"></a>1.微服务和单体服务区别</h6><p>单体架构-项目的文件都在同一个工程中开发-项目部署简单<br>但是<br>团队协作不好分工<br>系统发布效率低<br>系统可用性差-无分布式效果-导致功能之间相互影响大</p><hr><p>微服务原则<br>单一职责-一个微服务辅助一部分业务功能-核心数据不依赖其他模块<br>团队自治-每个微服务都有独立的开发测试人员<br>服务自治-每个微服务独立部署</p><hr><ul><li>团队协作成本高？</li><li>系统发布效率低？</li><li>系统可用性差？</li></ul><h6 id="2-SpringCloude"><a href="#2-SpringCloude" class="headerlink" title="2.SpringCloude"></a>2.SpringCloude</h6><p>SpringCloud框架是Java领域的微服务组件的集合。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/da4945c334b905363d17af697d049ab0.png" alt="da4945c334b905363d17af697d049ab0"></p><p>SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本</p><p>Spring Cloud 是在 Spring Boot 之上构建的一组工具和框架，主要用于解决分布式系统中的常见问题，如服务注册与发现、负载均衡、配置管理、断路器等。它提供了一整套微服务架构下的解决方案。</p><h6 id="3-微服务拆分原则"><a href="#3-微服务拆分原则" class="headerlink" title="3.微服务拆分原则"></a>3.微服务拆分原则</h6><ul><li><p>什么时候拆？</p></li><li><p>如何拆？<br>大多数小型项目来说，一般是先采用单体架构，随着用户规模扩大、业务复杂后再逐渐拆分为微服务架构。</p></li><li><p>高内聚：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</p></li><li><p>低耦合：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</p></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/44368b18c4a6590fc1de4c06feb8ffd0.png" alt="44368b18c4a6590fc1de4c06feb8ffd0"></p><ul><li>纵向拆分<br>就是按照项目的功能模块来拆分。<br>例如黑马商城中，就有用户管理功能、订单管理功能、。按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</li><li>横向拆分<br>各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。<br>例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。</li></ul><h6 id="4-微服务拆分"><a href="#4-微服务拆分" class="headerlink" title="4.微服务拆分"></a>4.微服务拆分</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a901f2f7901587696846615aaf0ef1eb.png" alt="a901f2f7901587696846615aaf0ef1eb"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/894106143910c2cbb7708074f9256b47.png" alt="894106143910c2cbb7708074f9256b47"></p><h4 id="springcloude技术栈"><a href="#springcloude技术栈" class="headerlink" title="springcloude技术栈"></a>springcloude技术栈</h4><h4 id="1-远程调用"><a href="#1-远程调用" class="headerlink" title="1.远程调用"></a>1.远程调用</h4><h6 id="0-场景"><a href="#0-场景" class="headerlink" title="0.场景"></a>0.场景</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8ef363e77fbcac43b74e31bea4ea42e4.png" alt="8ef363e77fbcac43b74e31bea4ea42e4"></p><p>itmservice.chaxun(id);-&gt;改为远程调用</p><h6 id="1-RestTemplate"><a href="#1-RestTemplate" class="headerlink" title="1.RestTemplate"></a>1.RestTemplate</h6><p>同步客户端执行HTTP请求</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7c61f69d70066c2f618e3b78b5ab0ea.png" alt="e7c61f69d70066c2f618e3b78b5ab0ea"></p><p>使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/354729fe5f6622042462ec267dae5a42.png" alt="354729fe5f6622042462ec267dae5a42"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/38aa2eb16283ccac08085d7a12d3a698.png" alt="38aa2eb16283ccac08085d7a12d3a698"></p><p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p><ul><li><p>① 请求方式</p></li><li><p>② 请求路径</p></li><li><p>③ 请求参数<br>返回值类型</p></li></ul><p>缺点<br><strong>负载均衡麻烦-无法指定请求路径</strong><br><strong>-我们就需要一个注册中心-帮我们收集实例-当访问对应就给与一个</strong></p><hr><h4 id="Nacos-注册中心"><a href="#Nacos-注册中心" class="headerlink" title="Nacos-注册中心"></a>Nacos-注册中心</h4><h6 id="0-了解nacos"><a href="#0-了解nacos" class="headerlink" title="0.了解nacos"></a>0.了解nacos</h6><p><strong>Nacos</strong> 是阿里巴巴开源的一款用于动态服务发现、配置管理和服务管理的工具，主要用于微服务架构中的服务治理。它的核心目标是简化分布式系统中的服务注册、服务发现和配置管理，并提供一站式解决方案。</p><p>Nacos 是一个面向微服务架构的服务治理平台，它的主要作用包括：</p><ul><li><strong>动态服务注册与发现</strong>，帮助微服务自动化发现其他服务。</li><li><strong>配置管理</strong>，提供了强大的配置存储、版本控制、动态刷新功能，提升了微服务架构下的配置灵活性。</li><li><strong>健康检查</strong>，保障服务的高可用性和故障隔离能力。</li></ul><h5 id="1-注册中心入门"><a href="#1-注册中心入门" class="headerlink" title="1.注册中心入门"></a>1.注册中心入门</h5><ul><li><p>服务提供者：提供接口供其它微服务访问，比如item-service</p></li><li><p>服务消费者：调用其它微服务提供的接口，比如cart-service</p></li></ul><p>为了管理这些服务·务消费者三者间关系如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/905b852bbe9e52b6c85f8ef4b220e33e.png" alt="905b852bbe9e52b6c85f8ef4b220e33e"></p><h6 id="2-注册中心配置-Docker"><a href="#2-注册中心配置-Docker" class="headerlink" title="2.注册中心配置-Docker"></a>2.注册中心配置-Docker</h6><p>1.导入nacos表</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2382bee1bde9f36e4701b2bf0c9986dd.png" alt="2382bee1bde9f36e4701b2bf0c9986dd"></p><p>2.修改配置文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4c2ae85d3e2a4b4c39a8d840d28d3016.png" alt="4c2ae85d3e2a4b4c39a8d840d28d3016"></p><p>3.<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5287cf7a27091d5968a3b9b76965f182.png" alt="5287cf7a27091d5968a3b9b76965f182"></p><h6 id="2-注册中心配置-spring-cloude"><a href="#2-注册中心配置-spring-cloude" class="headerlink" title="2.注册中心配置-spring cloude"></a>2.注册中心配置-spring cloude</h6><p>服务注册</p><p>1.引入依赖<br>2.配置nacos地址<br>3.重启</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/152860dce440d1d9e73f5ef0c6818808.png" alt="152860dce440d1d9e73f5ef0c6818808"></p><p>在nacos的服务列表中即可看到</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1ab667da96d404a3693f73e8f3e61dbd.png" alt="1ab667da96d404a3693f73e8f3e61dbd"></p><p>服务发现<br>1.引入依赖</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95c8c6bd4312301e08eb279ca19c6f72.png" alt="95c8c6bd4312301e08eb279ca19c6f72"></p><p>2.配置nacos</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b00650836cc74d97154f0c19e0885e3b.png" alt="b00650836cc74d97154f0c19e0885e3b"></p><p>3.发现调用服务<br>负载均衡调用服务选择<br>随机-轮训-ip的hash-最少访问</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cc0c30e1121009042204d4d6e490b1a0.png" alt="cc0c30e1121009042204d4d6e490b1a0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8199919e0d3bd8725cdbd299ff19a5db.png" alt="8199919e0d3bd8725cdbd299ff19a5db"></p><p>但是代码还是非常嘈杂以及难看-</p><h4 id="OpenFeign-远程调用"><a href="#OpenFeign-远程调用" class="headerlink" title="OpenFeign-远程调用"></a>OpenFeign-远程调用</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a7daefd898024466d28967eea99da8c.png" alt="0a7daefd898024466d28967eea99da8c"></p><h6 id="1-快速入门案例"><a href="#1-快速入门案例" class="headerlink" title="1.快速入门案例"></a>1.快速入门案例</h6><p>1.导入案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png" alt="e73d3e068484e2e31915ba7653f1003c"></p><p>2.启动注解</p><p>快速入门案例 1.导入案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png" alt="img"><br>2.启动注解</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ed643292f8dcdbb4ff4d6e96ce00153.png" alt="img"><br>3.代码编写</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8241cb4042ea1e687948cd9b6c752e4b.png" alt="8241cb4042ea1e687948cd9b6c752e4b"></p><p>private final ItemClient itemclient;<br>List&lt;&gt;items&#x3D;itemclient.query();</p><p>如上feign帮我们进行了 <strong>服务拉取 负载均衡 -请发送的所有工作</strong></p><h6 id="2-OpenFeign连接池"><a href="#2-OpenFeign连接池" class="headerlink" title="2.OpenFeign连接池"></a>2.OpenFeign连接池</h6><p>我们发起请求的话-需要建立连接-再销毁-但连接池可以减少这个过程产生的消耗<br>使用ok-http连接池<br>1.导入依赖<br>2.配置启用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d0853161a442680c814a26edfd25d44b.png" alt="d0853161a442680c814a26edfd25d44b"></p><p>OkHttp连接池的操作如下：</p><pre><code class="hljs">连接的创建和管理: OkHttp连接池会在应用程序启动时创建一组HTTP连接，并在需要时将其保持在连接池中。这些连接可以被多个线程共享和重用，而不是每次请求都重新创建连接。连接的重用: 当一个线程需要执行一个HTTP请求时，它可以从连接池中获取一个可用的连接，而不必等待新连接的创建。如果连接池中没有可用的连接，线程可能会被阻塞，直到有连接可用为止。连接的释放: 当一个线程完成了对某个HTTP服务的请求，它会将连接放回连接池，而不是关闭连接。这样可以避免频繁地打开和关闭连接，提高了连接的重用率。</code></pre><p>OkHttp连接池可以加快效率的原因包括：</p><pre><code class="hljs">减少连接的创建和销毁开销：通过重用连接，可以避免频繁地创建和销毁连接，从而减少了系统资源的消耗和网络延迟。提高并发性能：连接池可以确保连接的有效重用，从而使多个线程能够并发地共享同一个连接，提高了系统的并发处理能力。降低网络延迟：通过重用连接和减少连接的创建次数，可以减少网络请求的等待时间，从而降低了网络延迟，提高了系统的响应速度。</code></pre><p>总的来说，OkHttp连接池的有效管理和重用HTTP连接可以显著提高应用程序的性能和效率，特别是在需要频繁进行HTTP通信的场景下。</p><p>这里的请求-是固定的 故此可以保存</p><h6 id="3-api抽取"><a href="#3-api抽取" class="headerlink" title="3.api抽取"></a>3.api抽取</h6><p>方案1 结构层次低-耦合度高<br>方案2 结构层次复杂-哦合度低<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f85cd781db72ba5994a9b7341f64c2f.png" alt="2f85cd781db72ba5994a9b7341f64c2f"></p><h6 id="包扫描问题"><a href="#包扫描问题" class="headerlink" title="包扫描问题"></a>包扫描问题</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/76f1f3f63bb3b8d05dc723f7f12117a2.png" alt="76f1f3f63bb3b8d05dc723f7f12117a2"></p><p>也是注册为bean-但我忘记常量注入了</p><h6 id="fegin日志配置"><a href="#fegin日志配置" class="headerlink" title="fegin日志配置"></a>fegin日志配置</h6><p>![2e098ace474e1339c04dd1aa450c100b](G:\360MoveData\Users\nixg\Documents\Tencent Files\2760045743\nt_qq\nt_data\Pic\2024-05\Ori\2e098ace474e1339c04dd1aa450c100b.png)</p><p>修改日志</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/670ebe6e23b9c09af17b4f1e53a3f249.png" alt="670ebe6e23b9c09af17b4f1e53a3f249"></p><h1 id="微服务02"><a href="#微服务02" class="headerlink" title="微服务02"></a>微服务02</h1><p>网关过滤器-全局-和指定-&gt;网关登录鉴权-&gt;</p><p>微服务到微服务-&gt;Feing拦截器</p><p>naocs-&gt;配置共享 -配置热更新-动态路由</p><h2 id="Getway网关"><a href="#Getway网关" class="headerlink" title="Getway网关"></a>Getway网关</h2><h6 id="1-网关了解"><a href="#1-网关了解" class="headerlink" title="1.网关了解"></a>1.网关了解</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/814cd85a1c02b2c0d6fcb82731791e49.png" alt="814cd85a1c02b2c0d6fcb82731791e49"></p><h6 id="2-SpringGetWay网关"><a href="#2-SpringGetWay网关" class="headerlink" title="2.SpringGetWay网关"></a>2.SpringGetWay网关</h6><p>1.创建网关微服务<br>2.引入依赖<br>3.编写启动类<br>4.配置网关路由</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/33c9a08d518a78765fcfda164468e9ed.png" alt="33c9a08d518a78765fcfda164468e9ed"></p><p>配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e602e00dfea1425d97903200ab20744d.png" alt="img"></p><p>规则合集</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/906530d2a10b4728e2e15ef674b795ab.png" alt="906530d2a10b4728e2e15ef674b795ab"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eba4edc2810d7f0f0c3a6af446baf9c6.png" alt="eba4edc2810d7f0f0c3a6af446baf9c6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a10173c12662023f3b425ef0fa1cf022.png" alt="a10173c12662023f3b425ef0fa1cf022"></p><h6 id="3-网关登录鉴权"><a href="#3-网关登录鉴权" class="headerlink" title="3.网关登录鉴权"></a>3.网关登录鉴权</h6><p>登录思路-很多敏感思路都需要鉴权-我们又不可能重复写鉴权代码<br>故此网关思路即可<br>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li><li></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7f0640d795ce3dfac74f1cd2921f308.png" alt="d7f0640d795ce3dfac74f1cd2921f308"></p><p>1.网关传递用户信息-加信息头<br>2.服务直接传递信息-&gt;加信息头</p><h3 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h3><h6 id="1-过滤器了解"><a href="#1-过滤器了解" class="headerlink" title="1.过滤器了解"></a>1.过滤器了解</h6><p>网关的请求转发-由于getway实现<br>具体实现</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8462748af036d85d5789334d705224cc.png" alt="8462748af036d85d5789334d705224cc"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c715d9286b13c80bef8c74b434f3eabc.png" alt="c715d9286b13c80bef8c74b434f3eabc"></p><p>定义一个网关过滤器<br>进行登录逻辑判断-&gt;再Nett….之前</p><p>网关过滤器<br>1.路由过滤器 GatewayFilter指定规则<br>2.全局过滤器 GlobalFilter 全局规则</p><p>过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。</p><p>FilteringWebHandeler处理会将全局-装饰为路由-放到同一过滤器链中<br>依次执行</p><p>spring cloude<br>指定的 路由过滤器<br><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories</a></p><h6 id="2-内置过滤器"><a href="#2-内置过滤器" class="headerlink" title="2.内置过滤器"></a>2.内置过滤器</h6><p>gateway内置的GatewayFilter过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个Route下，就作用于哪个Route.</p><p>AddRequestHeaderGatewayFilterFacotry<br>使用配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88ec0600e28b2a9d0ca37d52cefc3d1f.png" alt="88ec0600e28b2a9d0ca37d52cefc3d1f"></p><h6 id="3-网关路由器-GatewayFilter"><a href="#3-网关路由器-GatewayFilter" class="headerlink" title="3.网关路由器 GatewayFilter"></a>3.网关路由器 GatewayFilter</h6><p>自定义GatewayFilter不是直接实现GatewayFilter，而是实现AbstractGatewayFilterFactory</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1f41d6a93c5a68ed3df317daf479a836.png" alt="1f41d6a93c5a68ed3df317daf479a836"></p><p>该类的名称一定要以GatewayFilterFactory为后缀！</p><p>spring:<br>  cloud:<br>    gateway:<br>      default-filters:<br>            - PrintAny # 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</p><h6 id="4-动态配置参数-GatewayFilter"><a href="#4-动态配置参数-GatewayFilter" class="headerlink" title="4.动态配置参数 GatewayFilter"></a>4.动态配置参数 GatewayFilter</h6><p>过滤器动态配置参数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7fe049b96c1496d2914d63fb65f8a192.png" alt="7fe049b96c1496d2914d63fb65f8a192"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a4e216499c59db0b068a2d2adcfb6344.png" alt="a4e216499c59db0b068a2d2adcfb6344"></p><h6 id="5-全局过滤器-GlobalFilter"><a href="#5-全局过滤器-GlobalFilter" class="headerlink" title="5.全局过滤器 GlobalFilter"></a>5.全局过滤器 GlobalFilter</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b8745f34d893608b923694068caa317a.png" alt="b8745f34d893608b923694068caa317a"></p><h4 id="案例-网关登录鉴权"><a href="#案例-网关登录鉴权" class="headerlink" title="案例 -网关登录鉴权"></a>案例 -网关登录鉴权</h4><p>登录效验编写-<br>思路<br>全局过滤器中-对jwt进行解析-同时解析完毕将信息构造请求头中-以待微服务拿取-<br>如果解析失败-就直接返回</p><h6 id="1-网关拦截-转user-传递到请求头中"><a href="#1-网关拦截-转user-传递到请求头中" class="headerlink" title="1.网关拦截-转user-&gt;传递到请求头中"></a>1.网关拦截-转user-&gt;传递到请求头中</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d9d50e713326b10f6cbc455e35ac9982.png" alt="d9d50e713326b10f6cbc455e35ac9982"></p><h6 id="2-网关到微服务"><a href="#2-网关到微服务" class="headerlink" title="2.网关到微服务"></a>2.网关到微服务</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/21423572850708f447c70112b71b58fe.png" alt="21423572850708f447c70112b71b58fe"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4715d2573fb1cca2b0ad7ffd60d4cf77.png" alt="4715d2573fb1cca2b0ad7ffd60d4cf77"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/036abaa6e3c3efa4258a1ebb6a9a3f74.png" alt="036abaa6e3c3efa4258a1ebb6a9a3f74"></p><h6 id="3-微服务到微服务的传递"><a href="#3-微服务到微服务的传递" class="headerlink" title="3.微服务到微服务的传递"></a>3.微服务到微服务的传递</h6><p>OpenFeign传递<br>OpenFeign-提供了一个拦截器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5e22d64051c12080b52e137b3f2df8d1.png" alt="5e22d64051c12080b52e137b3f2df8d1"></p><h3 id="nacos配置管理"><a href="#nacos配置管理" class="headerlink" title="nacos配置管理"></a>nacos配置管理</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c302ab029433076c8f27b8b744e77da4.png" alt="c302ab029433076c8f27b8b744e77da4"></p><p>解决配置写死-以及重复配置等问题</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/788621b778db5d0475a1459c7f47f2ef.png" alt="788621b778db5d0475a1459c7f47f2ef"></p><h6 id="1-配置共享"><a href="#1-配置共享" class="headerlink" title="1.配置共享"></a>1.配置共享</h6><p>1.naocs<strong>添加配置</strong></p><p>password : ${hm.db.password:}</p><ul><li>数据库database：可以通过${hm.db.database:test}来设定，默认值test</li></ul><p>2.微服务拉取配置</p><p>将共享配置与本地的application.yaml配置合并</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/34f7f37b9b9c8cd0cf8312e5f077eeb4.png" alt="34f7f37b9b9c8cd0cf8312e5f077eeb4"></p><p>依赖</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c7b8cd24915878d194e94777d1dc125c.png" alt="c7b8cd24915878d194e94777d1dc125c"></p><p>bootstart.yaml</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d9ab61eb239f97e8060fb49f7e71f0e1.png" alt="d9ab61eb239f97e8060fb49f7e71f0e1"></p><p>hm.db.database:test<br>hm:<br>  db:<br>      database:hm</p><p>-&gt;指定参数</p><h6 id="2-配置热更新"><a href="#2-配置热更新" class="headerlink" title="2.配置热更新"></a>2.配置热更新</h6><p>例–如我们的购物车上线是10–我们想要通过配置管理-<br>这里也可以用数据库的方法进行控制-但是配置方法更节约资源<br>1.nacos添加配置<br>2.微服务读取配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb27fd15744a4ce0dbbebcec3c82fded.png" alt="bb27fd15744a4ce0dbbebcec3c82fded"></p><p>指定配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7bd5b3ef60ef4f21a05d38e55b3c9c97.png" alt="7bd5b3ef60ef4f21a05d38e55b3c9c97"></p><p>get读取即可</p><p>类似心跳检测机制一样的更新</p><h6 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3.动态路由"></a>3.动态路由</h6><p>动态路由</p><p>网关的路由配置全部是在项目启动时由org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，我们无法利用上节课学习的配置热更新来实现路由更新。</p><p>因此，我们必须<strong>监听Nacos的配置变更</strong>，然后手动把最新的路由更新到路由表中。</p><p>1.nacos配置实时更新</p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/247218cd325db9d0990af715191c506f.png"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">serverAddr:</span> Nacos 服务器的地址，用户需要将 &#123;serverAddr&#125; 替换为实际的 Nacos 服务地址。<br><span class="hljs-symbol">dataId:</span> 配置项的唯一标识符，Nacos 通过 dataId 来标记不同的配置文件。<br><span class="hljs-symbol">group:</span> 配置的组名，Nacos 允许将配置划分为不同的组以便管理，默认为 <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>。<br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">这里通过 <span class="hljs-built_in">Properties</span> 对象来存储 <span class="hljs-variable">Nacos</span> 的配置信息。特别是 <span class="hljs-variable">Nacos</span> 服务器地址 <span class="hljs-variable">serverAddr</span>。<br>通过 <span class="hljs-variable">NacosFactory</span><span class="hljs-operator">.</span><span class="hljs-variable">createConfigService</span><span class="hljs-punctuation">(</span><span class="hljs-variable">properties</span><span class="hljs-punctuation">)</span> 创建了一个 <span class="hljs-variable">ConfigService</span> 对象，用于与 <span class="hljs-variable">Nacos</span> 配置中心进行交互。<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">通过 addListener 方法为指定的 dataId 和 <span class="hljs-keyword">group</span> <span class="hljs-title">添加一个监听器，当该配置有变化时，Nacos</span> 会通知客户端。<br>receiveConfig<span class="hljs-literal">Inf</span>o 方法是监听器的回调函数，当配置发生变化时，该方法会接收到变化的配置信息，并打印出来。<br>getExecutor 方法允许用户自定义线程池执行监听回调任务，返回 null 表示使用 Nacos 内部的默认线程池。<br><br><br>getConfig 方法用于同步获取当前 dataId 和 <span class="hljs-keyword">group</span> <span class="hljs-title">对应的配置内容。</span><br><span class="hljs-title">其中 5000</span> 是超时时间，表示如果在 <span class="hljs-number">5</span> 秒内没有获取到配置内容则会超时。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0fccbe790ea662f50e4dc78e637dfeb9.png"></p><p>路由更新接口<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb2704aaff009260682661686d43a863.png" alt="eb2704aaff009260682661686d43a863"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3834ba9c13d5c8765637fa028b2d2540.png" alt="3834ba9c13d5c8765637fa028b2d2540"></p><p>如上-网关路由的检测-和网关路由的更改已经完毕-接下来就是实例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1be7a5e7b5ff63918edfb6a98a4df1e8.png" alt="1be7a5e7b5ff63918edfb6a98a4df1e8"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/21dbf7eb235492bb336c2ee5a9b1d495.png" alt="21dbf7eb235492bb336c2ee5a9b1d495"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9283c00f8a1b26caba5a8ea4a7d47102.png" alt="9283c00f8a1b26caba5a8ea4a7d47102"># 微服务02</p><p>网关过滤器-全局-和指定-&gt;网关登录鉴权-&gt;</p><p>微服务到微服务-&gt;Feing拦截器</p><p>naocs-&gt;配置共享 -配置热更新-动态路由</p><h2 id="微服务03"><a href="#微服务03" class="headerlink" title="微服务03"></a>微服务03</h2><h4 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h4><p><strong>服务保护方案</strong></p><ul><li><p>请求限流</p></li><li><p>隔离和熔断</p></li><li><p>分布式事务</p><ul><li><p>初识分布式事务</p></li><li><p>Seata</p></li><li><p>知道雪崩问题产生原因及常见解决方案</p></li><li><p>能使用Sentinel实现服务保护</p></li><li><p>理解分布式事务产生的原因</p></li><li><p>能使用Seata解决分布式事务问题</p></li><li><p>理解AT模式基本原理</p></li></ul></li></ul><h6 id="1-微服务问题"><a href="#1-微服务问题" class="headerlink" title="1.微服务问题"></a>1.微服务问题</h6><p>级联问题-雪崩问题</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5adedac41a06aa9d5d23e1c048f9aefc.jpg" alt="5adedac41a06aa9d5d23e1c048f9aefc"></strong></p><p>请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度</p><p>都是属于降级处理</p><h6 id="2-请求限流"><a href="#2-请求限流" class="headerlink" title="2.请求限流"></a>2.请求限流</h6><p>限制或控制接口访问的并发流量<strong>，避免服务因流量激增而出现故障。</strong></p><p>请求限有一个限流器，并发请求，经过限流器就变的平均。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aa552325c073f6eb535f3dbda6adf3c2.jpg" alt="aa552325c073f6eb535f3dbda6adf3c2"></p><h6 id="3-线程隔离"><a href="#3-线程隔离" class="headerlink" title="3.线程隔离"></a>3.线程隔离</h6><p><strong>当一个业务接口响应时间长，而且并发高时，我们可以控制该线程的数量。</strong><br>即便该微服务出现问题。浪费的也只是20线程的资源～这里的20是我们设置的线程数量</p><h6 id="4-服务熔断"><a href="#4-服务熔断" class="headerlink" title="4.服务熔断"></a>4.服务熔断</h6><p><strong>线程熔断虽然避免了雪崩问题。但是依然无法解决。浪费资源问题</strong></p><ul><li>编写服务降级逻辑：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li>异常统计和熔断：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><p>熔断后写一个心跳机制-如果不超时或者异常 </p><p> 让他恢复</p><h4 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h4><h6 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h6><p>微服务保护技术</p><p>Sentinel是阿里巴巴开源的一款服务保护框架</p><p>Sentinel 的使用可以分为两个部分:</p><ul><li><p>核心库（Jar包）：不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</p></li><li><p>控制台（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</p><p>控制台整合</p></li></ul><p><a href="https://sentinelguard.io/zh-cn/docs/dashboard.html">https://sentinelguard.io/zh-cn/docs/dashboard.html</a></p><p>微服务整合Sentinel</p><!--sentinel--><dependency>    <groupId>com.alibaba.cloud</groupId>     <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId></dependency><hr><p>spring:<br>  cloud:<br>    sentinel:<br>      transport:<br>        dashboard: localhost：8090</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3ec0f2747e58af51ff00c89fad2f637.jpg" alt="f3ec0f2747e58af51ff00c89fad2f637"></p><h6 id="2-簇点链路"><a href="#2-簇点链路" class="headerlink" title="2.簇点链路"></a>2.簇点链路</h6><p> <strong>簇点链路</strong>，指的是在一次请求中经过的各个资源点，例如一个 SpringMVC 的接口 <code>/carts</code>，这是一个被 Sentinel 监控的资源。在默认情况下，Sentinel 会将请求路径（如 <code>/carts</code>）作为唯一标识来识别和监控资源。但在 RESTful 风格的 API 中，同一路径可能会根据 HTTP 方法执行不同的操作，如查询、删除或修改。例如：</p><ul><li><code>GET /carts</code> 用于查询购物车</li><li><code>POST /carts</code> 用于添加购物车</li><li><code>DELETE /carts</code> 用于删除购物车</li></ul><p>由于默认情况下 Sentinel 不区分 HTTP 方法，这会导致多个不同功能的接口被 Sentinel 认为是同一个资源。如果某个操作发生限流、熔断，其他操作也会受到影响，显然是不合理的。</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把请求方式 + 请求路径作为簇点资源名：</p><p>spring:<br>  cloud:<br>    sentinel:<br>      transport:<br>        dashboard: localhost:8090<br>      http-method-specify: true # 开启请求方式前缀</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd6ad74e5a523414c5fa94e71ce26b44.png" alt="dd6ad74e5a523414c5fa94e71ce26b44"></p><h6 id="3-请求限流"><a href="#3-请求限流" class="headerlink" title="3.请求限流"></a>3.请求限流</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/513f93a0c1b54d9cf48340131857d35b.png" alt="513f93a0c1b54d9cf48340131857d35b"></p><p>QPS &#x3D; 总请求数 &#x2F; 时间（秒）<br>6&#x3D;6&#x2F;1</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8bea4b790cd4908a3b2c157b54a82324.png" alt="8bea4b790cd4908a3b2c157b54a82324"></p><h6 id="4-线程隔离"><a href="#4-线程隔离" class="headerlink" title="4.线程隔离"></a>4.线程隔离</h6><p>限流-一旦雪崩还是没能解决<br>对查询商品的FeignClient接口做线程隔离</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd258ef0eff928db8ad60a51fa901e21.png" alt="dd258ef0eff928db8ad60a51fa901e21"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/96bf2d1721a6ad24b4c4c57a0420950e.png" alt="96bf2d1721a6ad24b4c4c57a0420950e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61c54a305d589adf29b99e9e783df0d8_720.png" alt="61c54a305d589adf29b99e9e783df0d8_720"></p><p>即便服务有什么问题。该服务能使用的线程数一直是10</p><h6 id="5-服务熔断"><a href="#5-服务熔断" class="headerlink" title="5.服务熔断"></a>5.服务熔断</h6><p>服务熔断<br><strong>问题-我们设置了线程熔断和QPS限制-那么被拒绝的服务就会被抛出异常</strong><br><strong>我们应该给一个降级处理</strong><br>2-<br>查询的延迟极高-还是会一直消耗资源-我们可以设置阈值-到达就熔断服务</p><p>1.编写降级处理<br>FeignClient编写失败后的降级逻辑<br>1.FallbackClass，无法对远程调用的异常做处理<br>2.：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/56ceaa1b237096af7d548dff22f64079.png" alt="56ceaa1b237096af7d548dff22f64079"></p><p><strong>ItemClientFallback</strong> 类实现了 <code>FallbackFactory&lt;ItemClient&gt;</code>，当 <code>ItemClient</code> 调用失败时，<code>create()</code> 方法会被调用，并接收一个 <code>Throwable cause</code> 参数，表示引发失败的异常。</p><p>该方法为默认实现</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/46c47701adaebf8ecdf3bedffcebfcd2.png" alt="46c47701adaebf8ecdf3bedffcebfcd2"></p><p>注册为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b8be56aab96f78ab8cc6280a940b9654.png" alt="b8be56aab96f78ab8cc6280a940b9654"></p><p>指定回调</p><p>降级之后-我们就设置服务熔断</p><p><strong>断路器的工作模式</strong><br>Sentinel中的断路器不仅可以统计某个接口的慢请求比例，还可以统计异常请求比例。<strong>当这些比例超出阈值时，就会熔断该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c41d54b8f48ef781a5719d594365b351.png" alt="c41d54b8f48ef781a5719d594365b351"></p><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7186f713c807cd96f4f0736cfdf33eb9.png" alt="7186f713c807cd96f4f0736cfdf33eb9"></p><h4 id="微服务事务"><a href="#微服务事务" class="headerlink" title="微服务事务"></a>微服务事务</h4><h6 id="1-微服务事务了解"><a href="#1-微服务事务了解" class="headerlink" title="1.微服务事务了解"></a>1.微服务事务了解</h6><ul><li><ul><li>在单体应用中，事务是通过数据库的 <strong>ACID</strong> 特性（原子性、一致性、隔离性、持久性）来保证的。然而，在微服务架构中，每个服务都有自己独立的数据源（数据库、缓存等），通常无法再通过传统的本地事务管理工具来保证整体事务的一致性。这时会出现如下问题：<ul><li><strong>跨服务的事务一致性</strong>：比如用户下单时，订单服务、库存服务、支付服务需要在不同的数据库中进行操作，如何保证所有服务的数据操作要么全部成功，要么全部回滚？</li><li><strong>网络延迟与失败</strong>：微服务间的调用是通过网络进行的，网络的延迟或失败会使事务变得复杂。</li><li><strong>独立性与隔离性</strong>：不同的微服务通常需要尽量保持高自治性和松耦合性，但在分布式事务中，需要一定的协调性。</li></ul></li></ul></li></ul><h6 id="2-分布式事务场景"><a href="#2-分布式事务场景" class="headerlink" title="2.分布式事务场景"></a>2.分布式事务场景</h6><p>1,.单服务请求多数据库完成一次事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165833626.png" alt="image-20241001165833626"></p><p>2.多服务请求单数据库完成一次事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165844052.png" alt="image-20241001165844052"></p><p>1、跨服务完成一次事务</p><p>2、跨数据源完成一次事务</p><h6 id="3-Cap原则"><a href="#3-Cap原则" class="headerlink" title="3.Cap原则"></a>3.Cap原则</h6><p>CAP是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165924978.png" alt="image-20241001165924978"></p><p>C<strong>一致性:</strong> 向系统写一个新数据再次读取到的也一定是这个新数据。拿上图举例，请求订单服务下单，订单服务请求库存服务扣减库存，只要下单成功则库存扣减成功。</p><p><strong>A可用性：</strong>任何时间都可以访问订单服务和库存服务，系统保证可用。</p><p>p<strong>分区容忍性：</strong>也叫分区容错性，分布式系统在部署时服务器可能部署在不同的网络分区，比如上图中订单服务在北京，库存服务在上海，由于处于不同的网络分区如果网络通信异常就会导致节点 之间无法通信，当出现由于网络问题导致节点 之间无法通信，此时仍然是对外提供服务的这叫做满足分区容忍性。</p><p><strong>CAP理论要强调在<strong><strong>分布式</strong></strong>系统中C、A、P这三点不能全部满足。</strong></p><h6 id="4-CP"><a href="#4-CP" class="headerlink" title="4.CP"></a>4.CP</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165947190.png" alt="image-20241001165947190"></p><h6 id="5-Ap"><a href="#5-Ap" class="headerlink" title="5.Ap"></a>5.Ap</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001170026148.png" alt="image-20241001170026148"></p><h6 id="6-实际场景"><a href="#6-实际场景" class="headerlink" title="6.实际场景"></a>6.实际场景</h6><p>满足CP的要求：</p><p><strong>创建订单和优惠券核销要么都成功要么都失败，不能存在一个成功一个失败</strong>，如果要实现CP需要在下单和核销优惠券操作前进行一次预操作，如果预操作成功将优惠券锁定避免在执行事务期间优惠券被其它订单使用。</p><p>满足AP的要求：</p><p><strong>创建订单和优惠券核销要么都成功要么都失败，可以暂时存在一个成功一个失败，最终要保证数据的一致性</strong>，如果要实现AP，不需要提前锁定资源，在执行事务期间有一个失败则么另一个操作回滚即可，最终实现数据一致性。</p><p>基于上边的分析，实现CP更麻烦，实现AP同样满足的需求，本项目优惠券核销操作实现AP。</p><p>实现方案</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001170311395.png" alt="image-20241001170311395"></p><h4 id="2-Seata"><a href="#2-Seata" class="headerlink" title="2.Seata"></a>2.Seata</h4><h6 id="0-seata模式"><a href="#0-seata模式" class="headerlink" title="0.seata模式"></a>0.seata模式</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001170352060.png" alt="image-20241001170352060"></p><h6 id="1-Seata了解"><a href="#1-Seata了解" class="headerlink" title="1.Seata了解"></a>1.Seata了解</h6><p>分布式事务-<strong>各个单个事务直接无法感应对方的失败或者成功</strong><br>事务协调者，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。<br><strong>回调检查-或者建立通信协议</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c45f4302dfe6ec401b7166531e8d0ee.png" alt="0c45f4302dfe6ec401b7166531e8d0ee"></p><h6 id="2-Seata部署"><a href="#2-Seata部署" class="headerlink" title="2.Seata部署"></a>2.Seata部署</h6><p>部署TC-DOCKER<br>1.<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/13bdfa580099aaad3e6b5b6b3a658b23.png" alt="img"><br>2.<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/954d7d66dc6aede16d41e72775d344aa_720.png" alt="img"><br>3.<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/47128070412f9199c201de643d226dfe.png" alt="img"></p><hr><hr><p>微服务集成Seata</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4e467740c6cae0760dfeeec1f185a409.png" alt="4e467740c6cae0760dfeeec1f185a409"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/969b0797c9e9111080031504307f449a.png" alt="969b0797c9e9111080031504307f449a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5a81cb44028665de51944504b72b9d05.png" alt="5a81cb44028665de51944504b72b9d05"></p><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。<br>将课前资料的seata-at.sql-导入进行事务控制的数据库中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/661baa4e424fa939c19202b5b66381c0.png" alt="661baa4e424fa939c19202b5b66381c0"></p><h6 id="3-Seata使用"><a href="#3-Seata使用" class="headerlink" title="3.Seata使用"></a>3.Seata使用</h6><p>@Transactional注解改为Seata提供的@GlobalTransactional</p><p>微服务事务</p><p><strong>@GlobalTransactional注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。</strong></p><h6 id="4-分布式解决方案"><a href="#4-分布式解决方案" class="headerlink" title="4.分布式解决方案"></a>4.分布式解决方案</h6><p><strong>两阶段提交（2PC，Two-Phase Commit）</strong>：</p><ul><li>在第一阶段（准备阶段），所有涉及事务的服务都会“准备”它们的操作，并告知协调者准备状态。</li><li>在第二阶段（提交阶段），如果所有服务都准备成功，则协调者通知所有服务提交事务；否则，所有服务都回滚事务。</li><li>缺点：两阶段提交的锁定资源时间较长，可能导致性能问题和死锁。</li></ul><p><strong>TCC 模型（Try-Confirm-Cancel）</strong>：</p><ul><li>TCC 模型是一种细化的两阶段提交方案，服务在业务逻辑上实现 <code>Try</code>（准备）、<code>Confirm</code>（确认）、<code>Cancel</code>（取消）三个步骤。</li><li>在 <code>Try</code> 阶段，服务会预留资源（例如预扣库存）；在 <code>Confirm</code> 阶段，服务确认资源的操作；在 <code>Cancel</code> 阶段，取消预留操作。</li></ul><p><strong>基于消息的最终一致性</strong>：</p><ul><li>使用消息队列来保证跨服务的数据一致性。当事务的一部分成功后，其他微服务通过异步消息更新自己的数据，保证最终一致性。</li><li>优点：弱化了实时性，较适合对一致性要求不高的场景。</li></ul><p><strong>SAGA 模型</strong>：</p><ul><li>SAGA 是一种分布式事务模式，将每个服务的事务划分为多个小事务，每个小事务有对应的补偿操作。</li><li>如果某个小事务失败，已经完成的小事务会通过调用补偿逻辑（如回滚、撤销操作）来恢复到一致状态。</li></ul><h6 id="5-Xa模式"><a href="#5-Xa模式" class="headerlink" title="5.Xa模式"></a>5.Xa模式</h6><p>A是规范-原理是两阶段提交</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55c86dd3399de2a54a2a7529aba97425.png" alt="img"></p><p>一阶段：</p><p>tm告诉TC开启全局事务</p><p>tm-调用rm</p><ul><li>事务协调者TC通知每个事务参与者执行本地事务</li><li>rm执行sql</li><li>本地事务执行完成后报告事务执行状态给<strong>事务协调者</strong>，此时事务不提交，<strong>继续持有数据库锁</strong></li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><p>也就是-<strong>事务锁只有等一阶段所有RM执行完毕-等待通知-开启2阶段</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/709e85023e48ff24e13992252e2462ce.png" alt="709e85023e48ff24e13992252e2462ce"></p><p>优缺点<br>行锁的缺点-优点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7db161ff42213ab817db33e83bb099e7.png" alt="7db161ff42213ab817db33e83bb099e7"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eec304cd22421ef584ef0d4365467799_720.png" alt="eec304cd22421ef584ef0d4365467799_720"></p><h6 id="6-At模式"><a href="#6-At模式" class="headerlink" title="6.At模式"></a>6.At模式</h6><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/649c531678978500ca68bd26a8db0c6a_720.png" alt="649c531678978500ca68bd26a8db0c6a_720"></p><p>取消行锁-改为本地log缓存</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/15c2cee13194b25bd165d5980011e9ed.png" alt="15c2cee13194b25bd165d5980011e9ed"></p><h2 id="阶段一-每个数据库都直接提交-同时备份一个undo-log"><a href="#阶段一-每个数据库都直接提交-同时备份一个undo-log" class="headerlink" title="阶段一 每个数据库都直接提交-同时备份一个undo-log"></a>阶段一 每个数据库都直接提交-同时备份一个undo-log</h2><p>一旦某个地方出现异常-RM回滚-同时TC-检测-分发没个事务进行回滚</p><p>流程</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88b2c6ae733ee58267bce34f201a1f25.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/05e2129219408c89e3e555605e1ff6cd.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c8c093537f83c8d013dc24d35de1ca5.png" alt="0c8c093537f83c8d013dc24d35de1ca5"></p><p>AT模式下分支事务会立即提交，虽然回滚可以通过快照恢复原始数据，但在异常发生之前，其他事务读取的数据可能是已经修改但未最终确定的状态。因此，若需要保证严格的数据一致性，可能需要结合隔离级别控制和快照机制，或者对已读数据的后续处理进行特殊设计。</p><h6 id="Xa-At区别"><a href="#Xa-At区别" class="headerlink" title="Xa At区别"></a>Xa At区别</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e527cdc2f3f935ead60411649086b841.png" alt="e527cdc2f3f935ead60411649086b841"></p><p>tm-&gt;告知TC开启事务<br>RM执行sql-并且保存sql快照-&gt;提交</p><p>事务介绍-&gt;tm告知-&gt;tc结束</p><p>tc检查是否有异常-无异常提交-有异常回档</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-单链表02</title>
    <link href="/2024/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表-单链表探究"><a href="#线性表-单链表探究" class="headerlink" title="线性表-单链表探究"></a>线性表-单链表探究</h1><h4 id="2-3-1-单链表定义"><a href="#2-3-1-单链表定义" class="headerlink" title="2.3.1  单链表定义"></a>2.3.1  单链表定义</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dc7d4713cc2eff99fc5b308c557c8a30.png" alt="dc7d4713cc2eff99fc5b308c557c8a30"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">单链表分为带头结点和不带头结点两种类型。在许多情况下，带头结点的单链表能够简化运算的实现过程。<br>因此这里讨论的单链表除特别指出外均指带头结点的单链表<br></code></pre></td></tr></table></figure><p>单链表结构</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span><br>&#123;  ElemType data;<span class="hljs-comment">//数据域</span><br>   <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span> *next;<span class="hljs-comment">//指针域</span><br>&#125; SLinkNode;<span class="hljs-comment">//单链表结点类型</span><br><br></code></pre></td></tr></table></figure><p>尾节点next探究-  1.指向null 2.指向头节点-循环单链表</p><h4 id="2-3-2线性表基本运算在单链表上的"><a href="#2-3-2线性表基本运算在单链表上的" class="headerlink" title="2.3.2线性表基本运算在单链表上的"></a>2.3.2线性表基本运算在单链表上的</h4><p>数据结构</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d42879b92325190541fb4481ce40e7f.png" alt="8d42879b92325190541fb4481ce40e7f"></p><h6 id="1-初始化线性表运算算法"><a href="#1-初始化线性表运算算法" class="headerlink" title="1.初始化线性表运算算法"></a>1.<strong>初始化线性表运算算法</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">创建一个空的单链表，它只有一个头结点，由L指向它。该结点的next域为空，data域未设定任何值。对应的算法如下：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SLinkNode *&amp;L)</span>　　　<span class="hljs-comment">//L为引用型参数</span></span><br><span class="hljs-function"></span>&#123;  L=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode)); <span class="hljs-comment">//创建头结点L</span><br>   L-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法"><a href="#2-销毁线性表运算算法" class="headerlink" title="2.销毁线性表运算算法"></a>2.<strong>销毁线性表运算算法</strong></h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">一个单链表中的所有结点空间都是通过malloc函数分配的，在不再需要时需通过free函数释放所有结点的空间。 循环<span class="hljs-keyword">next</span>  <span class="hljs-keyword">delete</span>吗 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">DestroyList</span><span class="hljs-params">(SLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>SLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>   &#123;  <span class="hljs-built_in">free</span>(pre);<br>      pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-求线性表的长度运算算法"><a href="#3-求线性表的长度运算算法" class="headerlink" title="3.求线性表的长度运算算法"></a>3.<strong>求线性表的长度运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">设置一个整型变量<span class="hljs-selector-tag">i</span>作为计数器，<span class="hljs-selector-tag">i</span>初值为<span class="hljs-number">0</span>，<span class="hljs-selector-tag">p</span>初始时指向第一个数据结点。然后沿next域逐个往后查找，每移动一次，<span class="hljs-selector-tag">i</span>值增<span class="hljs-number">1</span>。当<span class="hljs-selector-tag">p</span>所指结点为空时，结束这个过程，<span class="hljs-selector-tag">i</span>之值即为表长。 <br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int GetLength(SLinkNode *L)<br>&#123;  <br>       <span class="hljs-attribute">int</span>=0;<br>       SLinkNode *<span class="hljs-attribute">p_next</span>=L-&gt;next;<br>       <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)<br>       &#123;<br>       i++;<br>       <span class="hljs-attribute">L</span>=p_next;<br>&#125;<br>return i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法"><a href="#4-求线性表中第i个元素运算算法" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用<span class="hljs-selector-tag">p</span>从头开始遍历单链表L中的结点，用计数器j累计遍历过的结点，其初值为<span class="hljs-number">0</span>。<br>在遍历时j等于<span class="hljs-selector-tag">i</span>时，若<span class="hljs-selector-tag">p</span>不为空，则<span class="hljs-selector-tag">p</span>所指结点即为要找的结点，查找成功，算法返回<span class="hljs-number">1</span>。<br>否则算法返回<span class="hljs-number">0</span>表示未找到这样的结点。<br><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int GetElem(SLinkNode *L,int i,ElemType &amp;e)<br>&#123;  int <span class="hljs-attribute">j</span>=0;<br>SLinkNode *<span class="hljs-attribute">P</span>=L;<br><span class="hljs-keyword">if</span>(i&lt;=0 )<br>&#123;<br>return 0;<br>&#125;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span> &amp;&amp;j&lt;I)<br>&#123;<br>j++;<br><span class="hljs-attribute">p</span>=p-&gt;next;<br>&#125;<br>j-节点数量 -第i个元素<br><span class="hljs-attribute">j</span>=i;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">p</span>==null)<br>&#123;<br>return 0;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-attribute">e</span>=p-&gt;data;<br>return 1;<br>&#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法"><a href="#5-按值查找运算算法" class="headerlink" title="5.按值查找运算算法"></a>5.<strong>按值查找运算算法</strong></h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在单链表L中从第一个数据结点开始查找第一个值域与e相等的结点，若存在这样的结点，则返回其逻辑序号；否则返回0。<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int Locate(SLinkNode *L,ElemType e)<br>&#123;  <br>SLinkNode *<span class="hljs-attribute">p</span>=L-&gt;next;<br>int <span class="hljs-attribute">j</span>=1;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span> &amp;&amp;p-&gt;data!=e)<br>&#123;<br><span class="hljs-attribute">p</span>=p.next;<br>j++;<br><br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">p</span>==null)<br>&#123;<br>rerturn -1;<br>&#125;<br>return j;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-插入元素运算算法"><a href="#6-插入元素运算算法" class="headerlink" title="6.插入元素运算算法"></a>6.<strong>插入元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">在单链表L中插入第<span class="hljs-selector-tag">i</span>个值为<span class="hljs-attribute">x</span>的结点。<br>先在单链表L中查找第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，若未找到返回<span class="hljs-number">0</span>；<br>找到后由<span class="hljs-selector-tag">p</span>指向该结点，创建一个以<span class="hljs-attribute">x</span>为值的新结点s，将其插入到<span class="hljs-selector-tag">p</span>指结点之后。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/439df81a0b8ea9dfe5d48ad618bad001.png" alt="439df81a0b8ea9dfe5d48ad618bad001"></p><p>头插</p><p>尾插</p><p><strong>中间插</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> InsElem(SLinkNode *&amp;L,ElemType x,<span class="hljs-keyword">int</span> i)<br>&#123;  <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>   SLinkNode *p=L,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span> &amp;&amp; j&lt;i-<span class="hljs-number">1</span>)  <span class="hljs-comment">//查找第i-1个结点p</span><br>   &#123;j++;<br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-comment">//找到替换位置指针</span><br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-keyword">NULL</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//未找到第i-1个结点时返回0</span><br>   <span class="hljs-keyword">else</span>  <span class="hljs-comment">//找到第i-1个结点p</span><br>   &#123;s=(SLinkNode *)malloc(sizeof(SLinkNode));<br>s-&gt;data=x;  <span class="hljs-comment">//创建存放元素x的新结点s</span><br>s-&gt;<span class="hljs-keyword">next</span>=p-&gt;<span class="hljs-keyword">next</span>;  <span class="hljs-comment">//将s结点插入到p结点之后</span><br>p-&gt;<span class="hljs-keyword">next</span>=s;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="7-删除操作"><a href="#7-删除操作" class="headerlink" title="7.删除操作"></a>7.删除操作</h6><p>中间删</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d483479c3492507a1d6036710c6ec846.png" alt="d483479c3492507a1d6036710c6ec846"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelElem</span><span class="hljs-params">(SLinkNode *&amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   SLinkNode *p=L,*q;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)  <span class="hljs-comment">//查找第i-1个结点</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//未找到第i-1个结点时返回0</span><br>   <span class="hljs-keyword">else</span>  <span class="hljs-comment">//找到第i-1个结点p</span><br>   &#123;q=p-&gt;next;  <span class="hljs-comment">//q指向被删结点</span><br><span class="hljs-keyword">if</span> (q==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//没有第i个结点时返回0</span><br><span class="hljs-keyword">else</span><br>&#123;   p-&gt;next=q-&gt;next;  <span class="hljs-comment">//从单链表中删除q结点</span><br>　　<span class="hljs-built_in">free</span>(q);  <span class="hljs-comment">//释放其空间</span><br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="8-输出线性表运算算法"><a href="#8-输出线性表运算算法" class="headerlink" title="8.输出线性表运算算法"></a>8.<strong>输出线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">从第一个数据结点开始，沿next域逐个往下遍历，输出每个遍历到结点的<span class="hljs-class"><span class="hljs-keyword">data</span>域，直到尾结点为止。</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">DispList</span><span class="hljs-params">(SLinkNode *L)</span><br>&#123;  SLinkNode *p=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=NULL)<br>   &#123;printf(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;data);<br>p=p-&gt;next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="整体创建单链表的算法"><a href="#整体创建单链表的算法" class="headerlink" title="整体创建单链表的算法"></a><strong>整体创建单链表的算法</strong></h4><p>可以通过调用基本运算算法来创建单链表，其过程是先初始化一个单链表，然后向其中一个一个地插入元素。<br>这里介绍是快速创建整个单链表的算法，也称为整体建表。<br><strong>假设给定一个含有n个元素的数组a，由它来创建单链表，这种建立单链表的常用方法有两种。</strong></p><h6 id="1-头插"><a href="#1-头插" class="headerlink" title="1.头插"></a>1.头插</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空单链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>将新结点s插入到当前链表的表头上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到单链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止。<br><br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> CreateListF(SLinkNode *&amp;L,ElemType a[],<span class="hljs-keyword">int</span> n)<br>&#123;  SLinkNode *s;  <span class="hljs-keyword">int</span> i;<br>   L=(SLinkNode *)malloc(sizeof(SLinkNode));<span class="hljs-comment">//创建头结点</span><br>   L-&gt;<span class="hljs-keyword">next</span>=<span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//头结点的next域置空，表示一个空单链表</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//遍历a数组所有元素</span><br>   &#123;s=(SLinkNode *)malloc(sizeof(SLinkNode));<br>s-&gt;data=a[i];<span class="hljs-comment">//创建存放a[i]元素的新结点s</span><br>s-&gt;<span class="hljs-keyword">next</span>=L-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//将s插在头结点之后</span><br>L-&gt;<span class="hljs-keyword">next</span>=s;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/86120495f4b2c71b0d16a605c858d0cf.png" alt="86120495f4b2c71b0d16a605c858d0cf"></p><h6 id="2-尾插"><a href="#2-尾插" class="headerlink" title="2.尾插"></a>2.尾插</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空单链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>将新结点s插入到当前链表的表尾上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到单链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止。<br>由于尾插法算法每次将新结点插到当前链表的表尾上，为此增加一个尾指针tc，使其始终指向当前链表的尾结点。<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateListR</span><span class="hljs-params">(SLinkNode *&amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;  SLinkNode *s,*tc;  <span class="hljs-type">int</span> i;<br>   L=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode));  <span class="hljs-comment">//创建头结点</span><br>   tc=L;<span class="hljs-comment">//tc始终指向尾结点,初始时指向头结点</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;s=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode));<br>s-&gt;data=a[i];<span class="hljs-comment">//创建存放a[i]元素的新结点s</span><br>tc-&gt;next=s;<span class="hljs-comment">//将s插入tc之后</span><br>tc=s;<br>   &#125;<br>   tc-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//尾结点next域置为NULL</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/12438238fcfd7d0f1b5b1b2d2ae161c8.png" alt="12438238fcfd7d0f1b5b1b2d2ae161c8"></h6><h4 id="单链表算法示例"><a href="#单链表算法示例" class="headerlink" title="单链表算法示例"></a>单链表算法示例</h4><h5 id="1-基于单链表基本操作的算法设计"><a href="#1-基于单链表基本操作的算法设计" class="headerlink" title="1. 基于单链表基本操作的算法设计"></a><strong>1.</strong> <strong>基于单链表基本操作的算法设计</strong></h5><h6 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h6><h6 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h6><h5 id="2-基于整体建表的算法设计"><a href="#2-基于整体建表的算法设计" class="headerlink" title="2. 基于整体建表的算法设计"></a><strong>2.</strong> 基于整体建表的算法设计</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">这类算法设计中需要根据条件产生新的结果单链表。<br>而创建结果单链表的方法有头插法和尾插法。<br><br></code></pre></td></tr></table></figure><h6 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h6><h5 id="3-有序单链表的二路归并算法"><a href="#3-有序单链表的二路归并算法" class="headerlink" title="3. 有序单链表的二路归并算法"></a><strong>3.</strong> 有序单链表的二路归并算法</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">有序单链表是有序表的单链表存储结构，同样可以利用有序表元素的有序性提高相关算法的效率。<br>当数据采用单链表存储时，对应的二路归并就是单链表二路归并算法。<br><br></code></pre></td></tr></table></figure><h6 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h6><h5 id="4-单链表的排序"><a href="#4-单链表的排序" class="headerlink" title="4. 单链表的排序"></a><strong>4.</strong> <strong>单链表的排序</strong></h5><h6 id="2-18"><a href="#2-18" class="headerlink" title="2.18"></a>2.18</h6><h1 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h1><h6 id="2-3-4-1-循环单链表定义"><a href="#2-3-4-1-循环单链表定义" class="headerlink" title="2.3.4.1 循环单链表定义"></a>2.3.4.1 循环单链表定义</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4253efe9dd66b03ed40ea343337ca5fd.png" alt="4253efe9dd66b03ed40ea343337ca5fd"></p><h4 id="2-3-1-2-算法定义"><a href="#2-3-1-2-算法定义" class="headerlink" title="2.3.1.2 算法定义"></a>2.3.1.2 算法定义</h4><h6 id="1-初始化线性表运算算法-1"><a href="#1-初始化线性表运算算法-1" class="headerlink" title="1.初始化线性表运算算法"></a>1.初始化线性表运算算法</h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">创建一个空的循环单链表，它只有头结点，由<span class="hljs-type">L</span>指向它。该结点的next域指向该头结点，<span class="hljs-class"><span class="hljs-keyword">data</span>域未设定任何值。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SLinkNode *&amp;L)</span>　　<span class="hljs-comment">//L为引用型参数</span></span><br><span class="hljs-function"></span>&#123;  L=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode));<br>   L-&gt;next=L;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法-1"><a href="#2-销毁线性表运算算法-1" class="headerlink" title="2.销毁线性表运算算法"></a>2.销毁线性表运算算法</h6><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">一个循环单链表中的所有结点空间都是通过<span class="hljs-keyword">malloc</span>函数分配的，在不再需要时需通过<span class="hljs-keyword">free</span>函数释放所有结点的空间。 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  SLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-built_in">free</span>(pre);<br>pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-求线性表的长度运算算法-1"><a href="#3-求线性表的长度运算算法-1" class="headerlink" title="3.求线性表的长度运算算法"></a>3.<strong>求线性表的长度运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">设置一个整型变量<span class="hljs-selector-tag">i</span>作为计数器，<span class="hljs-selector-tag">i</span>初值为<span class="hljs-number">0</span>，<span class="hljs-selector-tag">p</span>初始时指向第一个结点。然后沿next域逐个往下移动，每移动一次，<span class="hljs-selector-tag">i</span>值增<span class="hljs-number">1</span>。当<span class="hljs-selector-tag">p</span>所指结点为头结点时这一过程结束，<span class="hljs-selector-tag">i</span>之值即为表长。 <br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int GetLength(SLinkNode *L)<br>&#123;  int <span class="hljs-attribute">i</span>=0;<br>   SLinkNode *<span class="hljs-attribute">p</span>=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;i++;<br><span class="hljs-attribute">p</span>=p-&gt;next;<br>   &#125;<br>   return i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法-1"><a href="#4-求线性表中第i个元素运算算法-1" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用<span class="hljs-selector-tag">p</span>从头开始遍历循环单链表L中的结点（初值指向第一个数据结点），用计数器j累计遍历过的结点，其初值为<span class="hljs-number">1</span>。<br>当<span class="hljs-selector-tag">p</span>不为L且j&lt;<span class="hljs-selector-tag">i</span>时循环，<span class="hljs-selector-tag">p</span>后移一个结点，j增<span class="hljs-number">1</span>。<br>当循环结束时，若<span class="hljs-selector-tag">p</span>指向头结点则表示查找失败返回<span class="hljs-number">0</span>，否则<span class="hljs-selector-tag">p</span>所指结点即为要找的结点，查找成功，算法返回<span class="hljs-number">1</span>。 <br><br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> GetElem(SLinkNode *L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)<br>&#123;  <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>   SLinkNode *p=L-&gt;next;   <span class="hljs-comment">//p指向首结点，计数器j置为1</span><br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<span class="hljs-comment">//找第i个结点p</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;e=p-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//找到后返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法-1"><a href="#5-按值查找运算算法-1" class="headerlink" title="5.按值查找运算算法"></a>5.<strong>按值查找运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">用<span class="hljs-selector-tag">i</span>累计查找数据结点的个数，从第一个数据结点开始，由前往后依次比较单链表中各结点数据域的值。<br>若某结点数据域的值等于给定值<span class="hljs-attribute">x</span>，则返回<span class="hljs-selector-tag">i</span>；否则继续向后比较。<br>若整个单链表中没有这样的结点，则返回<span class="hljs-number">0</span>。 <br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> Locate(SLinkNode *L,ElemType x)<br>&#123;  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>   SLinkNode *p=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; p-&gt;data!=x)<br>                 <span class="hljs-comment">//从第1个数据结点开始查找data域为x的结点</span><br>   &#123;p=p-&gt;next;<br>i++;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//未找到值为x的结点返回0</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;   <span class="hljs-comment">//找到第一个值为x的结点返回其序号</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-插入元素运算算法-1"><a href="#6-插入元素运算算法-1" class="headerlink" title="6.插入元素运算算法"></a>6.<strong>插入元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">在循环单链表L中查找第<span class="hljs-selector-tag">i</span>个结点<span class="hljs-selector-tag">p</span>及其前驱结点pre。<br>若没有这样的结点<span class="hljs-selector-tag">p</span>返回<span class="hljs-number">0</span>。<br>否则创建一个以<span class="hljs-attribute">x</span>为值的新结点s，将结点s插入在pre结点之后，返回<span class="hljs-number">1</span>。<br><br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xl">int InsElem(SLinkNode *&amp;L,ElemType x,int i)<span class="hljs-comment">//插入结点算法</span><br>&#123;  int j=<span class="hljs-number">1</span>;<br>   SL<span class="hljs-function"><span class="hljs-title">inkNode</span> *pre=L,*p=pre-&gt;</span>next,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<span class="hljs-comment">//查找第i个结点p和其前驱结点pre</span><br>   &#123;j++;<br><span class="hljs-function"><span class="hljs-title">pre</span>=p; p=p-&gt;</span>next;<span class="hljs-comment">//pre、p同步后移一个结点</span><br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L &amp;&amp; i&gt;j+<span class="hljs-number">1</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i&gt;n+1时错误返回0</span><br>   <span class="hljs-keyword">else</span><span class="hljs-comment">//成功查找到第i个结点的前驱结点pre</span><br>   &#123;s=(SLinkNode *)malloc(sizeof(SLinkNode));<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-keyword">data</span>=x;<span class="hljs-comment">//创建新结点用于存放元素x</span><br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=pre-&gt;</span>next;<span class="hljs-comment">//将s结点插入到pre结点之后</span><br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span>next=s;<br>return <span class="hljs-number">1</span>;<span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">在循环链表中，用p指针扫描所有结点时，方式有两种：<br>以p!=L作为循环条件，当p==L时循环结束，此时p回过来指向头结点，所以p应该初始化指向第一个数据结点而不是头结点，否则循环内的语句不会执行。<br>扫描指针p的初始化为p=L，循环的条件应该为p-&gt;next!=L，当p-&gt;next==L时循环结束，此时p指向尾结点<br></code></pre></td></tr></table></figure><h6 id="7-删除元素运算算法"><a href="#7-删除元素运算算法" class="headerlink" title="7.删除元素运算算法"></a>7.<strong>删除元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">在循环单链表L中查找第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，若不存在这样的结点返回<span class="hljs-number">0</span>。<br>否则让<span class="hljs-selector-tag">p</span>指第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，<span class="hljs-selector-tag">q</span>指向后继结点，当<span class="hljs-selector-tag">q</span>为NULL时返回<span class="hljs-number">0</span>，否则将<span class="hljs-selector-tag">q</span>所指结点删除并释放其空间，返回<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> DelElem(SLinkNode *&amp;L,<span class="hljs-built_in">int</span> i)<br>&#123;  <span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;<br>   SLinkNode *p=L,*q;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p-&gt;<span class="hljs-keyword">next</span>!=L &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)<span class="hljs-comment">//查找第i-1个结点p</span><br>   &#123;j++;<br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p-&gt;<span class="hljs-keyword">next</span>==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到这样的结点返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;q=p-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//q指向被删结点</span><br><span class="hljs-keyword">if</span> (q==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//没有第i个结点时返回0</span><br><span class="hljs-keyword">else</span><br>&#123;   p-&gt;<span class="hljs-keyword">next</span>=q-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//从单链表中删除q结点</span><br>　　free(q);<span class="hljs-comment">//释放其空间</span><br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//成功删除返回1</span><br>&#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="8-输出线性表运算算法-1"><a href="#8-输出线性表运算算法-1" class="headerlink" title="8.输出线性表运算算法"></a>8.<strong>输出线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">从第一个数据结点开始，沿next域逐个往下遍历，输出每个遍历到结点的<span class="hljs-class"><span class="hljs-keyword">data</span>域，直到头结点为止。</span><br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DispList(SLinkNode *L)<br>&#123;  SL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%d &quot;,p-&gt;</span><span class="hljs-keyword">data</span>);<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-3-5-循环单链表算法"><a href="#2-3-5-循环单链表算法" class="headerlink" title="2.3.5 循环单链表算法"></a>2.3.5 循环单链表算法</h4><h6 id="2-19"><a href="#2-19" class="headerlink" title="2.19"></a>2.19</h6><h6 id="2-20"><a href="#2-20" class="headerlink" title="2.20"></a>2.20</h6><h6 id="2-21"><a href="#2-21" class="headerlink" title="2.21"></a>2.21</h6>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-顺序表01</title>
    <link href="/2024/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%A1%BA%E5%BA%8F%E8%A1%A80)/"/>
    <url>/2024/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%A1%BA%E5%BA%8F%E8%A1%A80)/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p><strong>2.1</strong> <strong>线性表的基本概念</strong></p><p><strong>2.2</strong> <strong>顺序表</strong></p><p><strong>2.3</strong> <strong>单链表和循环单链表</strong></p><p><strong>2.4</strong> <strong>双链表****和循环双链表</strong></p><p><strong>2.5</strong> <strong>线性表的应用</strong></p><h4 id="2-1-线性表基本概念"><a href="#2-1-线性表基本概念" class="headerlink" title="2.1 线性表基本概念"></a>2.1 线性表基本概念</h4><h6 id="1-认识线性表"><a href="#1-认识线性表" class="headerlink" title="1.认识线性表"></a>1.认识线性表</h6><p>线性表（Linear List）是计算机科学中的一种数据结构，用于存储有限数量的元素，并且这些元素具有线性关系，即每个元素除了第一个和最后一个之外，都有一个前驱和一个后继。线性表的元素之间具有明确的顺序关系，可以通过其位置进行访问和操作。</p><p><strong>有序性</strong>：线性表中的元素按照一定的顺序排列，每个元素都有确定的位置。</p><p><strong>唯一性</strong>：线性表中每个元素都有唯一的<strong>前驱</strong>和<strong>后继</strong>（<strong>除了第一个元素没有前驱，最后一个元素没有后</strong>继）。</p><p><strong>长度有限</strong>：<strong>线性表中的元素个数是有限的，可以为空表（长度为零）。</strong></p><p>双向链表规则</p><blockquote><p><strong>顺序存储结构</strong>：用一组地址连续的存储单元依次存储线性表中的元素，例如数组。顺序存储结构的优点是支持随机访问（通过下标访问），缺点是在插入和删除元素时需要大量的移动操作。</p><p><strong>链式存储结构</strong>：用一组任意的存储单元存储线性表的元素，并通过指针链接这些存储单元，例如链表。链式存储结构的优点是插入和删除操作较为高效，但访问速度较慢（需要从头遍历）。</p></blockquote><h6 id="2-线性表定义"><a href="#2-线性表定义" class="headerlink" title="2.线性表定义"></a>2.线性表定义</h6><p>1,线性表由n(n&gt;&#x3D;0)个相同类型的数据元素组成的有限序列</p><p>有序性</p><p>2.当n&#x3D;0时为空表 记为()  <strong>Φ</strong></p><p>3.线性表的表示</p><p>有序性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c3803f4fdf75b4424564fdf688ece46.png" alt="0c3803f4fdf75b4424564fdf688ece46"></p><p>4.线性表特殊</p><p>n&gt;1 只有唯一的开始元素和终端元素</p><p><strong>唯一性</strong>：</p><p>5.标号序</p><p>线性表每个元素都有序号( 1 2 3 4 5)逻辑上 程序上从0开始-同时允许存储多个元素</p><h6 id="3-线性表实现和运算"><a href="#3-线性表实现和运算" class="headerlink" title="3.线性表实现和运算"></a>3.线性表实现和运算</h6><p>思路构造为:单链表</p><p>链表基础代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义链表节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;      <span class="hljs-comment">// 节点存储的数据</span><br>    ListNode next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br><br>    <span class="hljs-comment">// 构造函数</span><br>    ListNode(<span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-keyword">private</span> ListNode head;  <span class="hljs-comment">// 链表头指针</span><br><br>    <span class="hljs-comment">// 构造函数，初始化链表为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入节点的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 插入新节点的逻辑 头插 记录old指针 新头+4指向old指针 尾插 尾next指向新开辟的节点地址 中间插  前链表+4-&gt;指向插入地址-插入地址+4指向下一个地址</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除节点的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 删除节点的逻辑-前链表指针指向删除节点地址+4的地址-即可删除-本地还需delete -头删:直接删除-新头指针指向old指针+4的地址 尾删-链表-1遍历到第2个链接位置 +4位置=null;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查找节点的方法</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 查找节点的逻辑-&gt;遍历头指针+4的地址就是下个链表地址</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 遍历并打印链表的逻辑-自写迭代器</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>线性表基本运算方法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/da15cc5e809c8c28b188b72abb581438.png" alt="da15cc5e809c8c28b188b72abb581438"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fbe2b89d6443062cd08447d07620a599.png" alt="fbe2b89d6443062cd08447d07620a599"></p><blockquote><h3 id="初始化-InitList-L"><a href="#初始化-InitList-L" class="headerlink" title="初始化 InitList(L)"></a><strong>初始化 <code>InitList(L)</code></strong></h3><ul><li><strong>逻辑</strong>：创建一个空的线性表 <code>L</code>，将其长度设为 <code>0</code>，或者创建一个数据结构（例如数组或链表）来表示空表。</li></ul><h3 id="销毁线性表-DestroyList-L"><a href="#销毁线性表-DestroyList-L" class="headerlink" title="销毁线性表 DestroyList(L)"></a><strong>销毁线性表 <code>DestroyList(L)</code></strong></h3><ul><li><strong>逻辑</strong>：释放线性表 <code>L</code> 所占的内存空间，将表设置为空，防止内存泄漏。</li><li>迭代器销毁吗?一个个mc</li></ul><h3 id="求线性表的长度-GetLength-L"><a href="#求线性表的长度-GetLength-L" class="headerlink" title="求线性表的长度 GetLength(L)**"></a>求线性表的长度 <code>GetLength(L)</code>**</h3><ul><li><strong>逻辑</strong>：返回线性表 <code>L</code> 的当前长度（即线性表中元素的数量）。</li><li>还是迭代-只有next有指向就++-直到没指向</li></ul><h3 id="求线性表中第-i-个元素-GetElem-L-i-e"><a href="#求线性表中第-i-个元素-GetElem-L-i-e" class="headerlink" title="求线性表中第 i 个元素 GetElem(L, i, e)**"></a>求线性表中第 <code>i</code> 个元素 <code>GetElem(L, i, e)</code>**</h3><ul><li><strong>逻辑</strong>：检查位置 <code>i</code> 是否有效（在范围内），如果有效，返回位置 <code>i</code> 处的元素 <code>e</code>；否则，返回一个错误或特殊值。</li><li>从头next尾 -找到i就返回</li></ul><h3 id="按值查找-Locate-L-x"><a href="#按值查找-Locate-L-x" class="headerlink" title="按值查找 Locate(L, x)"></a><strong>按值查找 <code>Locate(L, x)</code></strong></h3><ul><li><strong>逻辑</strong>：从线性表 <code>L</code> 的头开始，依次遍历每个元素，判断其值是否等于 <code>x</code>。如果找到，返回元素的位置索引；如果没有找到，返回一个表示未找到的特殊值（例如 <code>-1</code>）。</li><li>从头next尾</li></ul><h3 id="插入元素-InsElem-L-x-i"><a href="#插入元素-InsElem-L-x-i" class="headerlink" title="插入元素 InsElem(L, x, i)**"></a>插入元素 <code>InsElem(L, x, i)</code>**</h3><ul><li><strong>逻辑</strong>：首先检查插入位置 <code>i</code> 是否有效（例如是否在当前表的长度范围内）。然后从最后一个元素开始向后移动元素，腾出位置 <code>i</code>，最后在位置 <code>i</code> 插入新元素 <code>x</code>，并将线性表的长度加 1。</li><li>头插 尾插 中间插(上面代码思路-未考虑长度)</li></ul><h3 id="删除元素-DelElem-L-i"><a href="#删除元素-DelElem-L-i" class="headerlink" title="删除元素 DelElem(L, i)"></a><strong>删除元素 <code>DelElem(L, i)</code></strong></h3><ul><li><strong>逻辑</strong>：检查要删除的位置 <code>i</code> 是否有效。如果有效，从位置 <code>i+1</code> 开始的每个元素向前移动一位，覆盖位置 <code>i</code> 的元素。最后，减少线性表的长度。</li><li>next遍历索引</li></ul><h3 id="输出元素值-DispList-L"><a href="#输出元素值-DispList-L" class="headerlink" title="输出元素值 DispList(L)"></a><strong>输出元素值 <code>DispList(L)</code></strong></h3><ul><li><p><strong>逻辑</strong>：从线性表 <code>L</code> 的头开始，依次遍历每个元素，将其值按顺序打印或存储</p></li><li><p>netx到尾部-迭代器写法</p></li></ul></blockquote><p>List-&gt;线性表</p><blockquote><p>利用线性表List的基本运算，设计一个由线性表A和B中的公共元素产生线性表C的算法</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a44dd445a0470ae167ed779690fcbd4c.png" alt="a44dd445a0470ae167ed779690fcbd4c"></p><h4 id="2-2-顺序表"><a href="#2-2-顺序表" class="headerlink" title="2.2 顺序表"></a>2.2 顺序表</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb24d731f11ddcce85e4836fbc183460.png" alt="bb24d731f11ddcce85e4836fbc183460"></p><p>ps:纳闷了一下-以为ai归纳错了-把顺序结构也包含在线性表中了</p><h6 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h6><p><strong>顺序表</strong>是在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98">计算机内存</a>中以<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组</a>的形式保存的<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a>，是指用一组<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80">地址</a>连续的<a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83">存储单元</a>依次存储数据元素的线性结构，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<span class="hljs-comment">//假设顺序表中所有元素为int类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;  ElemType data[MaxSize];<span class="hljs-comment">//存放顺序表的元素-初始大小</span><br>   <span class="hljs-type">int</span> length;<span class="hljs-comment">//顺序表的实际长度</span><br>&#125; SqList;<span class="hljs-comment">//顺序表类型</span><br><br></code></pre></td></tr></table></figure><p>定义了数组长度为100的 int类型的数据</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">SqList list;   <span class="hljs-comment">// 定义一个顺序表</span><br>list.<span class="hljs-built_in">length</span> = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 初始化长度为 0</span><br>list.data[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 插入第一个元素</span><br>list.<span class="hljs-built_in">length</span>++;  <span class="hljs-comment">// 长度增加</span><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/724b39523239a1da419d0f99ca38b84d.png" alt="724b39523239a1da419d0f99ca38b84d"></p><p>**<code>ArrayList</code>**：适合大部分顺序表场景，动态数组实现，随机访问高效。</p><p>**<code>Vector</code>**：线程安全的动态数组，适合多线程环境，但性能略差。</p><p>**<code>LinkedList</code>**：双向链表，适合频繁插入和删除操作，但随机访问效率较低。</p><p>**<code>CopyOnWriteArrayList</code>**：线程安全，适合读多写少的场景。</p><p>**<code>Arrays.asList()</code>**：固定大小的顺序表，不能动态调整大小。</p><h4 id="顺序表的基本运算"><a href="#顺序表的基本运算" class="headerlink" title="顺序表的基本运算"></a>顺序表的基本运算</h4><h6 id="1-初始化线性表运算算法"><a href="#1-初始化线性表运算算法" class="headerlink" title="1.初始化线性表运算算法"></a>1.初始化线性表运算算法</h6><p>设置初始长度-存储个数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> InitList(SqList &amp;L) <span class="hljs-comment">//引用修改</span><br><span class="hljs-comment">//由于L要回传给实参，所以用引用类型</span><br>&#123;<br>　　L.<span class="hljs-built_in">length</span>=<span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法"><a href="#2-销毁线性表运算算法" class="headerlink" title="2.销毁线性表运算算法"></a>2.销毁线性表运算算法</h6><p>　L若在栈则return销毁 –也就是变量的生命周期</p><h6 id="3-线性表长度运算算法"><a href="#3-线性表长度运算算法" class="headerlink" title="3.线性表长度运算算法"></a>3.线性表长度运算算法</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span><br><span class="hljs-function"></span>&#123;<br>　　<span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法"><a href="#4-求线性表中第i个元素运算算法" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">在逻辑序号i无效时返回特殊值<span class="hljs-number">0</span>（假），有效时返回<span class="hljs-number">1</span>（真），并用引用型形参e返回第i个元素的值。<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L.length)<span class="hljs-comment">//无效的i值返回0 判断长度和下标合法性</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">else</span><br>   &#123;  e=L.data[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//取元素值并返回1</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ElemType &amp;e-取引用类型0类型是T泛型-这里没指定而且</p><h6 id="5-按值查找运算算法"><a href="#5-按值查找运算算法" class="headerlink" title="5.按值查找运算算法"></a>5.按值查找运算算法</h6><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl">在顺序表L找第一个值为x的元素，找到后返回其逻辑序号，否则返回<span class="hljs-number">0</span>（由于线性表的逻辑序号从<span class="hljs-number">1</span>开始，这里用<span class="hljs-number">0</span>表示没有找到值为x的元素）。<br><span class="hljs-type">int</span> Locate(SqList L,ElemType x)<br>&#123;  <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span> (i&lt;L.<span class="hljs-built_in">length</span> &amp;&amp; L.data[i]!=x)<br>     i++; <span class="hljs-comment">//查找值为x的第1个元素,查找范围为0～L.length-1</span><br>   <span class="hljs-keyword">if</span> (i&gt;=L.<span class="hljs-built_in">length</span>) <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>(i+<span class="hljs-number">1</span>);   <span class="hljs-comment">//找到后返回其逻辑序号</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>逻辑序号就是下标+1</p><h6 id="6-插入元素运算法"><a href="#6-插入元素运算法" class="headerlink" title="6.插入元素运算法"></a>6.插入元素运算法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">将新元素<span class="hljs-attribute">x</span>插入到顺序表L中逻辑序号为<span class="hljs-selector-tag">i</span>的位置（如果插入成功，元素<span class="hljs-attribute">x</span>成为线性表的第<span class="hljs-selector-tag">i</span>个元素）。<br>当<span class="hljs-selector-tag">i</span>无效时返回<span class="hljs-number">0</span>（表示插入失败）。<br>有效时将L<span class="hljs-selector-class">.data</span><span class="hljs-selector-attr">[i-1..L.length-1]</span>后移一个位置，在L<span class="hljs-selector-class">.data</span><span class="hljs-selector-attr">[i-1]</span>处插入<span class="hljs-attribute">x</span>，顺序表长度增<span class="hljs-number">1</span>，并返回<span class="hljs-number">1</span>（表示插入成功。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7759631b5998f2d56609e561e79b99d8.png" alt="7759631b5998f2d56609e561e79b99d8"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsElem</span><span class="hljs-params">(SqList &amp;L,ElemType x,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j;<br>   <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L.length<span class="hljs-number">+1</span>)<span class="hljs-comment">//无效的参数i</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (j=L.length;j&gt;i;j--)<span class="hljs-comment">//将位置为i的结点及之后的结点后移</span><br>   &#123;<br>       L.data[j]=L.data[j<span class="hljs-number">-1</span>];<br>    &#125;<br> <br> <br> L.data[i<span class="hljs-number">-1</span>]=x;<span class="hljs-comment">//在位置i处放入x</span><br>   L.length++;<span class="hljs-comment">//线性表长度增1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>j-i 是逻辑位置-下标+1所想</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">当<span class="hljs-attribute">i</span>=n+1时（插入尾元素），移动次数为0，呈现最好的情况。<br>当<span class="hljs-attribute">i</span>=1时（插入第一个元素），移动次数为n，呈现最坏的情况。<br><br></code></pre></td></tr></table></figure><p>n是最大下标</p><p>平均情况分析</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/32db9894cf39150fb84a0ee2cefe595d.png" alt="32db9894cf39150fb84a0ee2cefe595d"></p><p>回头看看这个公式的计算方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">插入算法的主要时间花费在元素移动上，所以算法<span class="hljs-built_in">InsElem</span>()的平均时间复杂度为<span class="hljs-built_in">O</span>(n)。<br></code></pre></td></tr></table></figure><h6 id="7-删除元素运算算法"><a href="#7-删除元素运算算法" class="headerlink" title="7.删除元素运算算法"></a>7.<strong>删除元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">删除顺序表L中逻辑序号为<span class="hljs-selector-tag">i</span>的元素。<br>在<span class="hljs-selector-tag">i</span>无效时返回<span class="hljs-number">0</span>（表示删除失败）。<br>有效时将L<span class="hljs-selector-class">.data</span><span class="hljs-selector-attr">[i..length-1]</span>前移一个位置，顺序表长度减<span class="hljs-number">1</span>，并返回<span class="hljs-number">1</span>（表示删除成功。<br><br><br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span> DelElem(SqList &amp;L,<span class="hljs-type">int</span> i)<br>&#123; <span class="hljs-type">int</span> j;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.<span class="hljs-built_in">length</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">for</span>(j=i,j&lt;L.<span class="hljs-built_in">length</span>;j++) <span class="hljs-comment">//将位置为i的结点之后的结点前移</span><br><br>&#123;<br>L.data[j<span class="hljs-number">-1</span>]=L.data[j];<br>&#125;<br>L.<span class="hljs-built_in">length</span>--;<span class="hljs-comment">//线性表长度减1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">当<span class="hljs-attribute">i</span>=n时（删除尾元素），移动次数为0，呈现最好的情况。<br>当<span class="hljs-attribute">i</span>=1时（删除第一个元素），移动次数为n-1，呈现最坏的情况。<br><br>删除算法的主要时间花费在元素移动上，所以算法DelElem()的平均时间复杂度为O(n)。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c419faf1b6160678f0145ea2ec2804cc.png" alt="c419faf1b6160678f0145ea2ec2804cc"></p><h6 id="8-输出元素值运算算法"><a href="#8-输出元素值运算算法" class="headerlink" title="8.输出元素值运算算法"></a>8.输出元素值运算算法</h6><p>迭代器写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispList</span><span class="hljs-params">(SqList L)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> i;<br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;L.length;i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,L.data[i]);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="9-顺序表测试"><a href="#9-顺序表测试" class="headerlink" title="9.顺序表测试"></a>9.顺序表测试</h6><blockquote><p>将顺序表类型声明及其基本运算函数存放在*SqList.cpp文件中</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &quot;SqList.cpp&quot;     //包括前面的顺序表基本运算函数</span><br>void main()<br>&#123;  <span class="hljs-keyword">int</span> i; ElemType e;<br>   SqList L;<span class="hljs-regexp">//</span>定义一个顺序表L<br>   InitList(L);<span class="hljs-regexp">//</span>初始化顺序表L<br>   InsElem(L,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">1</span><br>   InsElem(L,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">3</span><br>   InsElem(L,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">1</span><br>   InsElem(L,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">5</span><br>   InsElem(L,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">4</span><br>   InsElem(L,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">2</span><br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;线性表:&quot;</span>);DispList(L);<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;长度:<span class="hljs-variable">%d</span>\n&quot;</span>,GetLength(L));<br>   i=<span class="hljs-number">3</span>; GetElem(L,i,e);<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;第<span class="hljs-variable">%d</span>个元素:<span class="hljs-variable">%d</span>\n&quot;</span>,i,e);<br>   e=<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;元素<span class="hljs-variable">%d</span>是第<span class="hljs-variable">%d</span>个元素\n&quot;</span>,e,Locate(L,e));<br>   i=<span class="hljs-number">4</span>; <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;删除第<span class="hljs-variable">%d</span>个元素\n&quot;</span>,i);<br>   DelElem(L,i);<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;线性表:&quot;</span>);DispList(L);<br>   DestroyList(L);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<span class="hljs-comment">//假设顺序表中所有元素为int类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;  ElemType data[MaxSize];<span class="hljs-comment">//存放顺序表的元素-初始大小</span><br>   <span class="hljs-type">int</span> length;<span class="hljs-comment">//顺序表的实际长度</span><br>&#125; SqList;<span class="hljs-comment">//顺序表类型</span><br><br></code></pre></td></tr></table></figure><h6 id="10-数组值创建顺序表"><a href="#10-数组值创建顺序表" class="headerlink" title="10.数组值创建顺序表"></a>10.数组值创建顺序表</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">假设给定一个含有n个元素的数组a，由它来创建顺序表。<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList</span><span class="hljs-params">(SqList &amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> i,k=<span class="hljs-number">0</span>;<span class="hljs-comment">//k累计顺序表L中的元素个数</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;  L.data[k]=a[i];<span class="hljs-comment">//向L中添加一个元素</span><br>      k++;<span class="hljs-comment">//L中元素个数增1</span><br>   &#125;<br>   L.length=k;<span class="hljs-comment">//设置L的长度</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-2-3-顺序表的算法设计示例"><a href="#2-2-3-顺序表的算法设计示例" class="headerlink" title="2.2.3 顺序表的算法设计示例"></a><strong>2.2.3</strong> <strong>顺序表的算法设计示例</strong></h3><p>ps:上数据结构课的时候观看案例</p><h5 id="1-基于顺序表基本操作的算法设计"><a href="#1-基于顺序表基本操作的算法设计" class="headerlink" title="1.基于顺序表基本操作的算法设计"></a>1.基于顺序表基本操作的算法设计</h5><p><strong>这类算法设计中包括顺序表元素的查找、插入和删除等</strong></p><h6 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h6><h6 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h6><h6 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h6><h5 id="2-基于整体建表的算法设计"><a href="#2-基于整体建表的算法设计" class="headerlink" title="2.基于整体建表的算法设计"></a>2.基于整体建表的算法设计</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这类算法设计中需要根据条件产生新的结果顺序表。<br><br></code></pre></td></tr></table></figure><h6 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h6><h6 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h6><h5 id="3-有序顺序表的二路归并算法"><a href="#3-有序顺序表的二路归并算法" class="headerlink" title="3.有序顺序表的二路归并算法"></a>3.有序顺序表的二路归并算法</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">有序表是指按元素值递增或者递减排列的线性表。<br>有序顺序表是有序表的顺序存储结构。也可以采用链式存储结构。<br>对于有序表可以利用其元素的有序性提高相关算法的效率。<br>二路归并就是有序表的一种经典算法。<br><br></code></pre></td></tr></table></figure><h6 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h6><h6 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h6><h6 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h6>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring boot探究</title>
    <link href="/2024/09/15/Springboot%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/15/Springboot%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot复习"><a href="#Springboot复习" class="headerlink" title="Springboot复习"></a>Springboot复习</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Mybatis-plus.png" alt="Mybatis-plus"></p><h4 id="0-Spring不同"><a href="#0-Spring不同" class="headerlink" title="0.Spring不同"></a>0.Spring不同</h4><p><strong>Spring Framework</strong> 是一个全面的编程和配置模型，为基于 Java 的企业应用提供了一个全方位的基础设施支持。Spring 处理了 Java 应用的基础建设，如事务管理、依赖注入、面向切面编程等。</p><p><strong>Spring MVC</strong> 是 Spring 的一个模块，用于构建 Web 应用程序。Spring MVC 遵循 MVC（模型-视图-控制器）-vue 设计模式，并提供了一套丰富的功能来建立可扩展的动态 Web 应用。使用 Spring MVC，开发者需要配置大量的组件，如视图解析器、消息转换器、数据绑定器等，这些都需要在 Spring 的配置文件中明确设置。</p><blockquote><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><ul><li><p><strong>自动配置</strong>：自动配置 Spring 应用程序的大部分常用设置，尽可能减少开发者的配置代码。</p><p><strong>启动器依赖</strong>：提供了一系列的“启动器”依赖项来简化 Maven 配置。</p><p><strong>内嵌服务器</strong>：如 Tomcat、Jetty 或 Undertow，默认不需要部署 WAR 文件。</p><p><strong>运行独立应用</strong>：支持打包为 jar，并通过 <code>java -jar</code> 运行应用程序。</p><p><strong>操作和管理功能</strong>：提供生产级别的特性如健康检查、度量信息统计及外部配置。</p></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3></blockquote><blockquote><p><strong>配置</strong>：Spring MVC 需要详细的配置，包括 URL 到控制器方法的映射、视图解析等，而 Spring Boot 则提供自动配置，极大简化了这一过程。</p><p><strong>启动</strong>：Spring MVC 需要部署到一个外部的 Web 应用服务器，如 Tomcat 或 Jetty，而 Spring Boot 提供了内嵌的服务器，简化了部署和分发过程。</p><p><strong>项目依赖</strong>：Spring Boot 采用了起步依赖的概念，可以通过这些预先设定的依赖来简化构建配置。</p></blockquote><h4 id="1-Springboot启动类分析"><a href="#1-Springboot启动类分析" class="headerlink" title="1.Springboot启动类分析"></a>1.Springboot启动类分析</h4><p>springboot-简化了开发-比如-我们之前导入依赖–到需要自己写配置类-返回Bean</p><p>springboot 帮我们简化了这个工程</p><p>SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想</p><p>spring 缺点 1.配置繁琐 2.依赖繁琐</p><p>springboot -1.自动配置 2.起步依赖 3.辅助功能</p><p>再起步依赖中导入了很多依赖 这使得我们不需要一个个找版本</p><p>&#x2F;&#x2F;引导类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ItemApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><h4 id="启动类探究"><a href="#启动类探究" class="headerlink" title="启动类探究"></a>启动类探究</h4><p><strong>启动类</strong>（通常是带有 <code>@SpringBootApplication</code> 注解的类）是整个应用的入口点，负责启动并配置 Spring 应用的运行环境。</p><h5 id="1-启动-Spring-应用上下文"><a href="#1-启动-Spring-应用上下文" class="headerlink" title="1. 启动 Spring 应用上下文"></a>1. <strong>启动 Spring 应用上下文</strong></h5><p>启动类通过调用 <code>SpringApplication.run()</code> 方法来启动 Spring 应用上下文（Application Context）。Spring 应用上下文是 Spring 管理的所有 Bean、配置和依赖注入的核心。具体步骤包括：</p><ul><li><p><strong>扫描组件</strong>：启动类会触发组件扫描（Component Scan），自动发现并注册使用诸如 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code> 等注解的 Bean。</p></li><li><p><strong>加载配置</strong>：读取项目中的配置文件（如 <code>application.properties</code> 或 <code>application.yml</code>），并应用相应的配置。</p></li><li><p><strong>初始化 Bean</strong>：启动 Spring IoC 容器，管理 Bean 的生命周期，包括创建、依赖注入、初始化和销毁。</p></li><li><h5 id="2-自动配置"><a href="#2-自动配置" class="headerlink" title="2. 自动配置"></a>2. <strong>自动配置</strong></h5><p>Spring Boot 的核心之一是自动配置（Auto Configuration），启动类会启动自动配置机制：@EnableAutoConfiguration</p><p>@SpringBootApplication 注解包含了 @EnableAutoConfiguration</p><p>它告诉 Spring Boot 根据类路径中的依赖项、配置文件中的属性等来自动配置应用程序。</p><ul><li>例如，如果类路径中有 <code>spring-boot-starter-web</code> 依赖，Spring Boot 会自动配置 Tomcat 作为嵌入式服务器，并配置 Spring MVC 的相关 Bean。</li></ul></li></ul></blockquote><blockquote><h6 id="3-启用嵌入式服务器"><a href="#3-启用嵌入式服务器" class="headerlink" title="3. 启用嵌入式服务器"></a>3. <strong>启用嵌入式服务器</strong></h6><p>在传统的 Spring MVC 应用中，应用需要打包成 WAR 文件并部署到外部的应用服务器（如 Tomcat、Jetty 等）。而在 Spring Boot 中，启动类会启动嵌入式服务器（如嵌入式的 Tomcat、Jetty 或 Undertow），这使得应用可以独立运行，不依赖外部的容器环境。</p><ul><li>启动类通过调用 <code>SpringApplication.run()</code> 方法自动启动嵌入式服务器，并运行 Web 应用，这就是为什么你可以直接用 <code>java -jar</code> 来运行一个 Spring Boot 应用。</li></ul><h6 id="4-管理外部配置"><a href="#4-管理外部配置" class="headerlink" title="4. 管理外部配置"></a>4. <strong>管理外部配置</strong></h6><p>Spring Boot 提供了一种灵活的方式来管理应用程序的配置，启动类会加载并管理这些外部配置：</p><ul><li>启动类会加载默认的 <code>application.properties</code> 或 <code>application.yml</code> 配置文件。</li><li>如果需要，可以通过命令行参数或环境变量来覆盖配置。</li></ul><h6 id="5-支持生产级别特性"><a href="#5-支持生产级别特性" class="headerlink" title="5. 支持生产级别特性"></a>5. <strong>支持生产级别特性</strong></h6><p>Spring Boot 的启动类还会为应用程序自动启用一些生产环境的特性，如：</p><ul><li><p><strong>健康检查（Actuator）</strong>：提供运行时的健康检查、度量指标等。</p></li><li><p><strong>外部化配置</strong>：通过环境变量或命令行参数来外部化配置。</p></li><li><p><strong>安全性</strong>：默认提供了基础的安全配置，可以进行扩展。</p><h6 id="6-简化应用启动过程"><a href="#6-简化应用启动过程" class="headerlink" title="6.简化应用启动过程"></a>6.<strong>简化应用启动过程</strong></h6><p>启动类通过 <code>@SpringBootApplication</code> 注解，大大简化了应用的启动配置。该注解实际上是以下三个注解的组合：</p><ul><li><p>@SpringBootApplication</p><p> 等价于：</p><ul><li><code>@Configuration</code>：表示该类可以用作 Spring 的 Java 配置类，代替传统的 XML 配置文件。</li><li><code>@EnableAutoConfiguration</code>：启用自动配置，基于类路径中的依赖项和配置来自动创建 Spring Beans。</li><li><code>@ComponentScan</code>：启用组件扫描，默认扫描该类所在的包及其子包，自动发现并注册 Spring 组件。</li></ul></li></ul></li></ul></blockquote><p><strong>启动 Spring 应用上下文</strong>，初始化所有的 Spring 组件和依赖注入。</p><p><strong>启用自动配置</strong>，根据项目的依赖自动配置应用所需的 Bean 和配置。</p><p><strong>启动嵌入式服务器</strong>，使得应用可以直接运行，不依赖外部服务器。</p><p><strong>管理外部配置</strong>，从配置文件、环境变量等地方加载应用的配置。</p><p><strong>简化开发</strong>，通过 <code>@SpringBootApplication</code> 注解减少手动配置。</p><h4 id="2-起步依赖分析"><a href="#2-起步依赖分析" class="headerlink" title="2.起步依赖分析"></a>2.起步依赖分析</h4><p>1.继承父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>⚫ 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。</p><p> 2.导入起步依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--web开发的起步依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。 ⚫ 我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在 版本冲突等问题。</p><p>-&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starters<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../spring-boot-parent<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>-&gt;追到底-最后继承的父pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>-这里面规范了大量的依赖版本</p><h4 id="3-配置文件读取"><a href="#3-配置文件读取" class="headerlink" title="3.配置文件读取"></a>3.配置文件读取</h4><h6 id="1-配置文件了解"><a href="#1-配置文件了解" class="headerlink" title="1.配置文件了解"></a>1.配置文件了解</h6><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用 application.properties或者application.yml（application.yaml）进行配置。</p><p>properties： server.port&#x3D;8080</p><p> yml: server: port: 8080</p><p> 在同一级目录下优先级为：properties &gt; yml &gt; yaml</p><h6 id="2-yaml"><a href="#2-yaml" class="headerlink" title="2.yaml"></a>2.yaml</h6><p>yaml-是一种数据序列化格式-知识的它具有丰富的跨平台性</p><p>对比</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/420f1f189299beef2d6b83fd89aea2e9.png" alt="420f1f189299beef2d6b83fd89aea2e9"></p><hr><p>语法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/12f41b7bed6805dd726a730295af95c3.png" alt="12f41b7bed6805dd726a730295af95c3"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e5554d0928c36cb20902c0cc1e30017b.png" alt="e5554d0928c36cb20902c0cc1e30017b"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a0698b803cd925e2e094f38a2f2be6e8.png" alt="a0698b803cd925e2e094f38a2f2be6e8"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/63d0fdcc32b52981fab07613eae525f1.png" alt="63d0fdcc32b52981fab07613eae525f1"></p><h4 id="3-读取配置文件内容"><a href="#3-读取配置文件内容" class="headerlink" title="3.读取配置文件内容"></a>3.读取配置文件内容</h4><h6 id="1-读取大类"><a href="#1-读取大类" class="headerlink" title="1.读取大类"></a>1.读取大类</h6><p>@Value </p><p><code>@Value</code> 注解用于将配置文件中的单个属性注入到 Spring Bean 中，适合用于简单的配置读取。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">app.name</span>=MyApp<br><span class="hljs-attr">app.version</span>=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;app.name&#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> appName;<br><br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;app.version&#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> appVersion;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> appName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppVersion</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> appVersion;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Environment </p><blockquote><p><code>Environment</code> 接口用于访问 Spring 环境中的属性和配置，提供了一种灵活的方式来读取配置文件中的属性，适用于动态读取或者需要条件处理的场景。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Environment</span> env;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> env.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&quot;app.name&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppVersion</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> env.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&quot;app.version&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**<code>env.getProperty()</code>**：通过 <code>Environment</code> 获取属性值，支持动态读取。</p><p>如果属性不存在，返回 <code>null</code>。 </p><blockquote><p>适合动态获取配置属性。</p><p>灵活性更高，尤其适合条件性的属性获取。</p><p>可用于编写较复杂的配置处理逻辑。</p></blockquote><p>@ConfigurationProperties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">app.name</span>=MyApp<br><span class="hljs-attr">app.version</span>=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><span class="hljs-attr">app.description</span>=This is my application<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;app&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> version;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> description;<br><br>    <span class="hljs-comment">// getters and setters</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getVersion</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> version;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setVersion</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> version</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">version</span> = version;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getDescription</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setDescription</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> description</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">description</span> = description;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>**<code>@ConfigurationProperties(prefix = &quot;app&quot;)</code>**：指定配置项的前缀，所有以 <code>app</code> 开头的属性都会映射到 <code>AppConfig</code> 类中。</li><li>自动将配置属性注入到对应的类属性中。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>适合批量处理和嵌套配置，配置项较多时使用更加方便。</li><li>需要配合 Spring Boot 的 <code>@EnableConfigurationProperties</code> 或自动配置来启用。</li></ul></blockquote><p>总结</p><p>**<code>@Value</code>**：适合注入单个或少量配置属性，语法简单直观。</p><p>**<code>Environment</code>**：适合动态读取属性或者在运行时根据条件获取属性。</p><p>**<code>@ConfigurationProperties</code>**：适合批量读取属性，将多个配置项封装为对象，便于管理复杂的配置结构。</p><blockquote><p>对于少量的简单配置，使用 <code>@Value</code> 更直接。</p><p>当需要动态获取配置时，使用 <code>Environment</code> 提供了灵活性。</p><p>如果需要处理大量配置或复杂结构的配置，<code>@ConfigurationProperties</code> 是最佳选择。</p></blockquote><h6 id="2-profile"><a href="#2-profile" class="headerlink" title="2.profile"></a>2.profile</h6><p>多配置文件切换-比如我们生产环境-每一套生产环境有对应的配置文件</p><p>配置方式</p><p>profile配置方式 ⚫</p><p> 多profile文件方式：提供多个配置文件，每个代表一种环境。 </p><p>• application-dev.properties&#x2F;yml 开发环境</p><p> • application-test.properties&#x2F;yml 测试环境 •</p><p> application-pro.properties&#x2F;yml 生产环境</p><hr><p>激活方式</p><p>⚫ 配置文件： 再配置文件中配置：spring.profiles.active&#x3D;dev</p><p> ⚫ 虚拟机参数：在jVM options 指定：-Dspring.profiles.active&#x3D;dev </p><p>⚫ 命令行参数：java –jar xxx.jar –spring.profiles.active&#x3D;dev</p><h6 id="3-内部加载顺序"><a href="#3-内部加载顺序" class="headerlink" title="3.内部加载顺序"></a>3.内部加载顺序</h6><p>Springboot程序启动时，会从以下位置加载配置文件： </p><ol><li>file:.&#x2F;config&#x2F;：当前项目下的&#x2F;config目录下 </li><li><ol start="2"><li>file:.&#x2F; ：当前项目的根目录</li><li><ol start="3"><li>classpath:&#x2F;config&#x2F;：classpath的&#x2F;config目录</li><li><ol start="4"><li>classpath:&#x2F; ：classpath的根目录 加载顺序为上文的排列顺序，高优先级配置的属性会生效</li></ol></li></ol></li></ol></li></ol><p>加载顺序为上文的排列顺序，高优先级配置的属性会生</p><h4 id="Spring-整合框架"><a href="#Spring-整合框架" class="headerlink" title="Spring-整合框架"></a>Spring-整合框架</h4><h6 id="1-Spring-整合junit"><a href="#1-Spring-整合junit" class="headerlink" title="1.Spring 整合junit"></a>1.Spring 整合junit</h6><p>1.导入依赖-springboot 工程</p><p>2.编写测试类</p><p>3.添加注解</p><blockquote><p>Spring JUnit 是 Spring 框架和 JUnit 测试框架的结合，常用于测试 Spring 应用中的组件、服务和数据访问层。JUnit 是一个流行的 Java 测试框架，帮助开发者编写和运行单元测试，而 Spring 提供了丰富的依赖注入、事务管理等功能。</p><p>当使用 Spring 和 JUnit 进行测试时，通常会结合 Spring 的测试支持类，例如 <code>@SpringBootTest</code>、<code>@ContextConfiguration</code> 等注解，它们帮助你在测试中加载 Spring 应用上下文，方便测试 Spring 组件的行为。</p><h5 id="常用注解和功能"><a href="#常用注解和功能" class="headerlink" title="常用注解和功能"></a>常用注解和功能</h5><ol><li><strong>@SpringBootTest</strong>: 用于启动整个 Spring 应用上下文，可以测试多个组件之间的交互。</li><li><strong>@ContextConfiguration</strong>: 指定 Spring 配置文件或类，用于加载应用上下文。</li><li><strong>@MockBean</strong>: 用于在测试中模拟 Spring Bean。</li><li><strong>@Before</strong>: 在每个测试方法执行之前运行，用于初始化测试环境。</li><li><strong>@Test</strong>: 用于标记测试方法。</li></ol><p>通过结合 JUnit 和 Spring，你可以轻松地测试 Spring 应用中的各个部分，包括控制器、服务、DAO 等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest(classes = SpringbootJunitApplication.class )</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-number">111</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-Spring-整合redis"><a href="#2-Spring-整合redis" class="headerlink" title="2.Spring 整合redis"></a>2.Spring 整合redis</h6><p>① 搭建SpringBoot工程</p><p> ② 引入redis起步依赖</p><p> ③ 配置redis相关属性 </p><p>④ 注入RedisTemplate模板 </p><p>⑤ 编写测试方法，测试</p><p>redis-键值存储</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span>()</span> &#123;<br>    <span class="hljs-comment">//存入数据</span><br>    redisTemplate.boundValueOps(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>&#125;<br><br>@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span>()</span> &#123;<br>    <span class="hljs-comment">//获取数据</span><br>    Object name = redisTemplate.boundValueOps(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-keyword">get</span>();<br>    System.<span class="hljs-keyword">out</span>.println(name);<br>&#125;<br>---<br>redisTemplate<br><br>----<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BoundValueOperations&lt;K, V&gt; <span class="hljs-title">boundValueOps</span>(<span class="hljs-params">K key</span>)</span> &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span>(<span class="hljs-params">V var1</span>)</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultBoundValueOperations(key, <span class="hljs-keyword">this</span>);<br>    &#125;<br>---<br><br></code></pre></td></tr></table></figure><h6 id="3-spring-整合myBatis"><a href="#3-spring-整合myBatis" class="headerlink" title="3.spring 整合myBatis"></a>3.spring 整合myBatis</h6><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Mapper</span><br><span class="hljs-variable">@Repository</span><br>public interface UserMapper &#123;<br><br>    <span class="hljs-variable">@Select</span>(<span class="hljs-string">&quot;select * from t_user&quot;</span>)<br>    public List&lt;User&gt; <span class="hljs-built_in">findAll</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>放入依赖mapper-哦、配置文件放入配置</p><p> 搭建SpringBoot工程 </p><p>② 引入mybatis起步依赖，添加mysql驱动 </p><p>③ 编写DataSource和MyBatis相关配置 </p><p>④ 定义表和实体类</p><p> ⑤ 编写dao和mapper文件&#x2F;纯注解开发</p><p> ⑥ 测试</p><h1 id="Spring-boot高级"><a href="#Spring-boot高级" class="headerlink" title="Spring boot高级"></a>Spring boot高级</h1><h5 id="1-Spring-启动流程"><a href="#1-Spring-启动流程" class="headerlink" title="1.Spring 启动流程"></a>1.Spring 启动流程</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="SpringBoot启动流程"></p><p>四个步骤</p><blockquote><p><strong>启动 Spring 应用上下文</strong>，初始化所有的 Spring 组件和依赖注入。</p><p><strong>启用自动配置</strong>，根据项目的依赖自动配置应用所需的 Bean 和配置。</p><p><strong>启动嵌入式服务器</strong>，使得应用可以直接运行，不依赖外部服务器。</p><p><strong>管理外部配置</strong>，从配置文件、环境变量等地方加载应用的配置。</p><p><strong>简化开发</strong>，通过 <code>@SpringBootApplication</code> 注解减少手动配置。</p></blockquote><h5 id="2-Spring自动配置"><a href="#2-Spring自动配置" class="headerlink" title="2.Spring自动配置"></a>2.Spring自动配置</h5><h6 id="1-Condition"><a href="#1-Condition" class="headerlink" title="1.Condition"></a>1.Condition</h6><p>案例</p><blockquote><h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3></blockquote><p>Condition 是在Spring 4.0 增加的条件判断功能，通过这个可以功能可以实现选择性的创建 Bean 操作。</p><blockquote><p>Spring Boot 的自动配置依赖于 <code>@EnableAutoConfiguration</code> 注解，它会自动加载并配置合适的 Bean。Spring Boot 内部通过 <code>spring.factories</code> 文件定义了一系列的自动配置类，当应用启动时，这些配置类会被加载。</p></blockquote><p>SpringBoot是如何知道要创建哪个Bean的？比如SpringBoot是如 何知道要创建RedisTemplate的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># spring-boot-<span class="hljs-built_in">auto</span>configure jar 内的 spring.factories 文件<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.EnableAutoConfiguration=\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.redis.RedisAutoConfiguration,\<br>...<br><br></code></pre></td></tr></table></figure><p>–</p><p>条件配置的实现：<code>@Conditional</code></p><p>Spring Boot 使用了 <code>@Conditional</code> 注解来实现基于条件的自动配置。<code>RedisAutoConfiguration</code> 是 Spring Boot 为 Redis 提供的自动配置类，它的配置是有条件的。条件配置通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等注解实现。</p><p><strong>案例实现</strong></p><p>关键条件注解：</p><ul><li><strong>@ConditionalOnClass</strong>：当指定的类在类路径中存在时，才会执行配置。对于 Redis 来说，只有在 Redis 相关的类（如 <code>RedisTemplate</code>、<code>JedisConnectionFactory</code> 等）存在时，Spring Boot 才会去配置它们。</li><li><strong>@ConditionalOnMissingBean</strong>：如果 Spring 上下文中没有指定的 Bean，才会创建新的 Bean。</li><li><strong>@ConditionalOnProperty</strong>：根据配置属性（通常在 <code>application.properties</code> 或 <code>application.yml</code> 中）是否存在或其值来决定是否创建 Bean。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(RedisTemplate.class)</span> <span class="hljs-comment">// 只有在类路径中有 RedisTemplate 类时才进行配置</span><br><span class="hljs-meta">@ConditionalOnBean(RedisConnectionFactory.class)</span> <span class="hljs-comment">// RedisConnectionFactory Bean 存在时才进行配置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisAutoConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="hljs-comment">// 如果容器中没有名为 redisTemplate 的 Bean，才创建</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他配置</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>加载自动配置类</strong>：<code>@EnableAutoConfiguration</code> 会在 Spring Boot 启动时加载 <code>RedisAutoConfiguration</code> 类（通过 <code>spring.factories</code> 注册）。</p><p><strong>检查条件</strong>：</p><ul><li><code>@ConditionalOnClass(RedisTemplate.class)</code>：检查类路径中是否有 <code>RedisTemplate</code> 类。如果 Redis 依赖存在，类路径中会包含此类，条件成立。</li><li><code>@ConditionalOnBean(RedisConnectionFactory.class)</code>：检查 Spring 容器中是否已经有 <code>RedisConnectionFactory</code>。如果条件满足（通常会通过自动配置或手动配置创建 <code>RedisConnectionFactory</code>），继续执行。</li></ul><p><strong>创建 RedisTemplate</strong>：如果条件成立，且没有手动定义 <code>RedisTemplate</code> Bean，那么自动配置将为你创建一个默认的 <code>RedisTemplate</code>。</p></blockquote><h6 id="2-Enable-注解"><a href="#2-Enable-注解" class="headerlink" title="2.@Enable*注解"></a>2.@Enable*注解</h6><p><code>@Enable</code> 开头的注解在 Spring Boot 中非常常见，主要用于启用某些功能或模块。它们的核心原理是使用 <code>@Import</code> 注解来导入配置类或其他需要的 Bean，从而实现功能的动态开启。</p><blockquote><h5 id="Enable-注解的核心原理"><a href="#Enable-注解的核心原理" class="headerlink" title="@Enable* 注解的核心原理"></a><code>@Enable*</code> 注解的核心原理</h5><ol><li><strong><code>@Import</code> 注解</strong>：<code>@Enable</code> 开头的注解通常内部会使用 <code>@Import</code>，其作用是将指定的配置类或相关的组件导入到 Spring 容器中，参与 Bean 的定义和管理。</li><li><strong>配置类或自动配置</strong>：这些 <code>@Enable</code> 注解导入的通常是特定功能模块的配置类，可能包含多个 Bean 的定义，用来开启该模块的相关功能。例如 <code>@EnableScheduling</code> 用于启用 Spring 的定时任务功能，其底层导入了与任务调度相关的配置类。</li><li><strong>实现动态 Bean 加载</strong>：通过 <code>@Enable</code> 注解启用的功能是动态的，不需要手动在配置文件中去定义。注解本身相当于一个开关，当添加到某个类上时，会加载对应的配置，注册相关的 Bean。</li></ol></blockquote><p><em><strong>常见注解</strong></em></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EnableAutoConfiguration</span>：启用 Spring Boot 的自动配置机制，根据类路径中的依赖和自定义的配置自动配置 Spring 应用。<br><span class="hljs-comment">//启动类就有该注解 </span><br><br><span class="hljs-variable">@EnableScheduling</span>：启用定时任务支持。<br><span class="hljs-variable">@EnableAsync</span>：启用异步方法调用。<br><span class="hljs-variable">@EnableCaching</span>：启用缓存支持。<br><span class="hljs-variable">@EnableWebMvc</span>：启用 Spring MVC 的配置，常用于 Spring Web 应用。<br><span class="hljs-variable">@EnableJpaRepositories</span>：启用 JPA 仓库的支持。<br></code></pre></td></tr></table></figure><blockquote><h5 id="底层工作机制"><a href="#底层工作机制" class="headerlink" title="底层工作机制"></a>底层工作机制</h5><p>当使用 <code>@Enable*</code> 注解时，Spring 会扫描并导入指定的配置类，这些类通常会包含必要的 Bean 定义和配置。<code>@Import</code> 注解可以导入普通的 Java 配置类，也可以导入 <code>ImportSelector</code> 或 <code>ImportBeanDefinitionRegistrar</code>，后者可以提供更为灵活的控制和动态 Bean 注册。</p><p>通过这种机制，开发者可以非常方便地启用所需的功能，而不需要手动编写大量的配置代码。</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE&#125;)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Import</span>(&#123;SchedulingConfiguration.class&#125;)<br><span class="hljs-variable">@Documented</span><br>public <span class="hljs-variable">@interface</span> EnableScheduling &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-Import注解"><a href="#3-Import注解" class="headerlink" title="3.Import注解"></a>3.Import注解</h6><p>@Enable*底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用 法： </p><blockquote><p><strong>导入普通的 Bean 类</strong>：最简单的用法是直接将某个类通过 <code>@Import</code> 导入到 Spring IOC 容器中，Spring 会自动将该类作为 Bean 进行管理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 普通的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> String sayHello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, Spring!&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 @Import 导入类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyService.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 使用 MyService 的类</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyService myService;<br><br>    <span class="hljs-keyword">public</span> MyController(MyService myService) &#123;<br>        <span class="hljs-keyword">this</span>.myService = myService;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String hello() &#123;<br>        <span class="hljs-keyword">return</span> myService.sayHello();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>导入配置类</strong>：可以通过 <code>@Import</code> 导入一个配置类（通常带有 <code>@Configuration</code> 注解的类）。该配置类中的 Bean 定义会被 Spring 自动加载。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService myService() &#123;<br>        <span class="hljs-keyword">return</span> new MyService();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 @Import 导入配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(ServiceConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 使用 MyService 的类</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyService myService;<br><br>    <span class="hljs-keyword">public</span> MyController(MyService myService) &#123;<br>        <span class="hljs-keyword">this</span>.myService = myService;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String hello() &#123;<br>        <span class="hljs-keyword">return</span> myService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>导入 <code>ImportSelector</code> 实现类</strong>：<code>ImportSelector</code> 是一个接口，用于根据特定逻辑返回一组类名，Spring 会将这些类导入到容器中。这种方式通常用于根据条件动态地加载多个配置类或组件。通过实现 <code>ImportSelector</code>，你可以基于某些条件（如配置文件、依赖关系等）来决定哪些类需要被加载。</p><ul><li><p><em><strong><code>AutoConfigurationImportSelector</code></strong></em> 就是一个典型的 <code>ImportSelector</code> 实现类，它根据 <code>META-INF/spring.factories</code> 文件中的配置来决定哪些自动配置类需要被导入。</p></li><li><p>**<code>importingClassMetadata</code>**：代表的是使用 <code>@Import(MyImportSelector.class)</code> 注解的类的元数据。你可以通过它来获取导入这个 <code>ImportSelector</code> 的类的所有注解信息，包括该类上的注解、注解属性值等。</p></li><li></li><li><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface EnableFeatureX &#123;    boolean enable() default true;&#125;    <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br>```java<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-built_in">String</span>[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>        <span class="hljs-comment">// 获取使用 @EnableFeatureX 注解的类上的注解属性</span><br>        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; attributes = importingClassMetadata.getAnnotationAttributes(EnableFeatureX.<span class="hljs-keyword">class</span>.getName());<br>        boolean enable = (Boolean) attributes.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;enable&quot;</span>);<br>    <br>        <span class="hljs-comment">// 根据注解属性值决定要导入的类</span><br>        <span class="hljs-keyword">if</span> (enable) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;FeatureXService.<span class="hljs-keyword">class</span>.getName()&#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableFeatureX</span>(enable = true)<br><span class="hljs-variable">@Import</span>(MyImportSelector.class)<br>public class AppConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">在这个例子中，importingClassMetadata 允许你获取 <span class="hljs-meta">@EnableFeatureX</span> 注解的属性值，从而根据注解的配置动态决定是否导入 FeatureXService 类。<br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>导入 <code>ImportBeanDefinitionRegistrar</code> 实现类</strong>：<code>ImportBeanDefinitionRegistrar</code> 接口用于以编程的方式注册 Bean 定义，允许开发者手动控制 Bean 的注册过程，而不需要依赖注解或自动扫描。这提供了极大的灵活性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义 ImportBeanDefinitionRegistrar 实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanDefinitionRegistrar</span> <span class="hljs-title">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br>        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(MyService.<span class="hljs-keyword">class</span>);<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;myService&quot;</span>, beanDefinitionBuilder.getBeanDefinition());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 @Import 导入 ImportBeanDefinitionRegistrar</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyBeanDefinitionRegistrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 使用 MyService 的类</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyService myService;<br><br>    <span class="hljs-keyword">public</span> MyController(MyService myService) &#123;<br>        <span class="hljs-keyword">this</span>.myService = myService;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String hello() &#123;<br>        <span class="hljs-keyword">return</span> myService.sayHello();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h6 id="4-启动自动配置流程"><a href="#4-启动自动配置流程" class="headerlink" title="4.启动自动配置流程"></a>4.启动自动配置流程</h6><p>启动类探究</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">appmain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(appmain.<span class="hljs-property">class</span>,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入启动依赖</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE&#125;)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Inherited</span><br><span class="hljs-variable">@SpringBootConfiguration</span><span class="hljs-comment">//</span><br><span class="hljs-variable">@EnableAutoConfiguration</span><span class="hljs-comment">//启用自动配置-&gt;跟踪</span><br><span class="hljs-variable">@ComponentScan</span>(<br>    excludeFilters = &#123;<span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;TypeExcludeFilter.class&#125;<br>), <span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;AutoConfigurationExcludeFilter.class&#125;<br>)&#125;<br>)<br>public <span class="hljs-variable">@interface</span> SpringBootApplication &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@EnableAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><span class="hljs-comment">//根据路径匹配bean</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>AutoConfigurationImportSelector-&gt;返回全类名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> NO_IMPORTS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        AutoConfigurationEntry autoConfigurationEntry = <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);<br>        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">当 Spring Boot 应用启动时，@EnableAutoConfiguration 会被处理，AutoConfigurationImportSelector 会读取 META-INF/<span class="hljs-keyword">spring</span>.factories 中列出的所有自动配置类。<br><br>然后，它会根据配置类中的条件（@Conditional 等注解）进行判断，决定哪些 Bean 应该被加载。<br><br>满足条件的自动配置类会被导入，进而初始化相应的 Bean，完成自动配置。<br></code></pre></td></tr></table></figure><h4 id="3-Springboot监听机制"><a href="#3-Springboot监听机制" class="headerlink" title="3.Springboot监听机制"></a>3.Springboot监听机制</h4><p>Java 监听机制 SpringBoot 的监听机制，其实是对Java提供的事件监听机制的封装。 Java中的事件监听机制定义了以下几个角色： </p><p>① 事件：Event，继承 java.util.EventObject 类的对象 </p><p>② 事件源：产生事件的对象，通常是任意类型的 Java 对象</p><p>③ 监听器：实现 <code>java.util.EventListener</code> 接口的类，用来监听和处理事件。</p><p>SpringBoot 在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成 一些操作。 ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p><p>案例:ApplicationContextInitializer</p><p>该接口允许在 <code>ApplicationContext</code> 刷新之前进行自定义初始化操作。通过实现这个接口，你可以在 Spring 上下文创建前对其进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ApplicationContextInitializer: Application Context is initializing&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Springboot自动装配探究"><a href="#Springboot自动装配探究" class="headerlink" title="Springboot自动装配探究"></a>Springboot自动装配探究</h5><h6 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h6><p>概述 :某些对象自动存入IOC容器<br> 例子<br> 比如：配置类GsonAutoConfiguration里面有一个bean，bean的名字叫gson，它的类型是Gson。  -&gt;专门用来处理json数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgramApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Gson</span> gson;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">mmm</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title class_">String</span> json = gson.<span class="hljs-title function_">toJson</span>(<span class="hljs-title class_">Result</span>.<span class="hljs-title function_">success</span>());<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(json);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此处 我们没有手动将该gson对象放入ioc容器 但他确可以拿出来 这就是spring在启动时候 就完成了bean对象的创建</p><p>其实分析自动配置原理就是来解析在SpringBoot项目中，在引入依赖之后是如何将依赖jar包当中所定义的配置类以及bean加载到SpringIOC容器中的。</p><h4 id="2-自写自动装配"><a href="#2-自写自动装配" class="headerlink" title="2.自写自动装配"></a>2.自写自动装配</h4><h6 id="1-问题发现"><a href="#1-问题发现" class="headerlink" title="1.问题发现"></a>1.问题发现</h6><p>javen jar包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenParser</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;TokenParser ... parse ...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span>     <br><span class="hljs-keyword">private</span> ApplicationContext applicationContext;  <br><span class="hljs-meta">@Test</span>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTokenParse</span><span class="hljs-params">()</span>&#123;          System.out.println(applicationContext.getBean(TokenParser.class));   <br>&#125;<br></code></pre></td></tr></table></figure><p>&#96;<br> 报错 表示容器内没有找到这个bean</p><ul><li>原因在我们之前讲解IOC的时候有提到过，在类上添加@Component注解来声明bean对象时，还需要保证@Component注解能被Spring的组件扫描到。</li><li>SpringBoot项目中的@SpringBootApplication注解，具有包扫描的作用，但是它只会扫描启动类所在的当前包以及子包。</li><li>当前包：com.itheima， 第三方依赖中提供的包：com.example（扫描不到）</li></ul><h5 id="2-两种解决方法"><a href="#2-两种解决方法" class="headerlink" title="2.两种解决方法"></a>2.两种解决方法</h5><p>解决方法</p><ul><li>方案1：@ComponentScan 组件扫描</li><li>方案2：@Import 导入（使用@Import导入的类会被Spring加载到IOC容器中</li></ul><p>方案一 指定扫描<br> @ComponentScan({“com.example.program”,”com.example”})</p><p>但是每一个依赖包都要指定对应目录 太过麻烦 对此 进行方案2</p><h6 id="Import导入的三种方法"><a href="#Import导入的三种方法" class="headerlink" title="@Import导入的三种方法"></a>@Import导入的三种方法</h6><p> 1.普通类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@Import(<span class="hljs-params">TokenParser.<span class="hljs-keyword">class</span></span>) 自己加入bean容器</span><br></code></pre></td></tr></table></figure><p>2.配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeaderConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HeaderParser <span class="hljs-title function_">headerParser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderParser</span>();<br>    &#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> HeaderGenerator <span class="hljs-title function_">headerGenerator</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderGenerator</span>();<br>&#125;<br>&#125;<br>启动类--放到任意地方都行的<br><br><span class="hljs-meta">@Import(HeaderConfig.class)</span> <span class="hljs-comment">//导入配置类 </span><br>扫描到Bean 自动注册 其他地方就可以拿取该bean<br><br></code></pre></td></tr></table></figure><p>3.使用@Import导入ImportSelector接口实现类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Import</span>(<span class="hljs-title class_">MyImportSelector</span>.<span class="hljs-property">class</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span>[] <span class="hljs-title function_">selectImports</span>(<span class="hljs-params"><span class="hljs-title class_">AnnotationMetadata</span> importingClassMetadata</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.example.HeaderConfig&quot;</span>&#125;;<span class="hljs-comment">//返回全类名</span><br>    &#125;<br>&#125;<br><br>那两个 对象也会被加入进对应容器 <br></code></pre></td></tr></table></figure><p>你所提供的代码是Spring中ImportSelector接口的一个实现。ImportSelector接口是Spring的@Import注解处理的一部分，它允许我们动态加载（或导入）一些Spring的配置。</p><p>MyImportSelector类实现ImportSelector接口的selectImports方法，这个方法的作用是返回一个包含希望Spring加载的类全限定名称的字符串数组。</p><p>在你的例子中，selectImports方法返回一个字符串数组，包含一个元素”com.example.HeaderConfig”。这表示Spring会尝试将com.example.HeaderConfig这个类加载到Spring的应用上下文中。</p><hr><hr><hr><hr><hr><p>如图-三种方法都可以进行依赖注入</p><h5 id="第三方依赖探究"><a href="#第三方依赖探究" class="headerlink" title="第三方依赖探究"></a>第三方依赖探究</h5><p>如果基于以上方式完成自动配置，当要引入一个第三方依赖时，是不是还要知道第三方依赖中有哪些配置类和哪些Bean对象？</p><p>思考：当我们要使用第三方依赖，依赖中到底有哪些bean和配置类，谁最清楚？</p><ul><li>答案：第三方依赖自身最清楚。</li></ul><p><strong>结论：我们不用自己指定要导入哪些bean对象和配置类了，让第三方依赖它自己来指定。</strong>‘’</p><p>怎么让第三方依赖自己指定bean对象和配置类？</p><ul><li>比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解</li></ul><p>使用第三方依赖提供的 @EnableXxxxx注解</p><hr><p>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.TYPE)<br>@Import(MyImportSelector.class)&#x2F;&#x2F;指定要导入哪些bean对象或配置类<br>public @interface EnableHeaderConfig {<br>}</p><p>前两个注解详解</p><pre><code class="hljs">@Retention: 这个注解决定了被修饰的注解信息在什么级别可用。    RetentionPolicy.SOURCE：注解只保留在源码中，编译时会被丢弃，不会写入字节码。    RetentionPolicy.CLASS：注解在编译时被保留在字节码中，但JVM加载类时不会将其加载到反射数据中，这是默认的生命周期。    RetentionPolicy.RUNTIME：注解在编译后也会被保存在字节码中，JVM加载类时将其加载到反射数据中，所以它们能在运行时被读取到。因此，@Retention(RetentionPolicy.RUNTIME)意味着被修饰的注解在运行时仍然有效，可以通过反射机制读取到。@Target: 这个注解用来指定被修饰的注解可以用在哪些元素上。元素类型包括：CONSTRUCTOR（构造器声明），FIELD（字段声明），LOCAL_VARIABLE（局部变量声明），METHOD（方法声明），PACKAGE（包声明），PARAMETER（参数声明）, TYPE（类、接口或枚举声明）等。所以，@Target(ElementType.TYPE)表示被修饰的注解只能用来修饰类、接口或枚举。</code></pre><p>以上四种方式都可以完成导入操作，但是第4种方式会更方便更优雅，而这种方式也是SpringBoot当中所采用的方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootMybatisApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">SpringbootMybatisApplication</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE&#125;) 该注解意味着<span class="hljs-variable">@SpringBootApplication</span>只能用于类、接口或枚举类型。<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME) 表示<span class="hljs-variable">@SpringBootApplication</span>注解会被保留在运行时，因此可以通过反射获取其信息。<br><span class="hljs-variable">@Documented</span>  表明如果一个类使用了<span class="hljs-variable">@SpringBootApplication</span>注解，那么这个注解应该被包含在JavaDoc中。<br><span class="hljs-variable">@Inherited</span>    表示<span class="hljs-variable">@SpringBootApplication</span>注解可以被子类继承。<span class="hljs-comment">//配置类</span><br><span class="hljs-variable">@SpringBootConfiguration</span> <span class="hljs-comment">//起步依赖--通过 @SpringBootApplication 注解启动时，Spring Boot 会自动扫描并加载所有 @SpringBootConfiguration 注解的配置类，并根据配置类中的内容进行自动装配，从而实现对应用的自动配置和启动。</span><br><span class="hljs-variable">@EnableAutoConfiguration</span>启动Spring Boot的自动配置机制。<br><span class="hljs-variable">@ComponentScan</span>(<br>    excludeFilters = &#123;<span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;TypeExcludeFilter.class&#125;<br>), <span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;AutoConfigurationExcludeFilter.class&#125;<br>)&#125;<br>)使Spring Boot能够扫描当前类所在的包以及子包，查找Component，Configuration等。<br></code></pre></td></tr></table></figure><p>如上-跟踪自动装配的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span> <br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <br><span class="hljs-meta">@Documented</span> <br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><span class="hljs-comment">// 这是一个Spring Boot的内部注解，用于自动配置包扫描路径。Spring Boot将从声明@EnableAutoConfiguration的类的包开始，向下扫描包结构。</span><br><br><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br>AutoConfigurationImportSelector.class<br><br><br>在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration<br>  <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br><br><br><br><br><br><br>     <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> NO_IMPORTS;<br>            <span class="hljs-comment">/*这里调用了 isEnabled(annotationMetadata) 方法，它的作用是判断当前是否应该启用自动配置。通常，这种检查会依据某些条件，比如某些注解的存在与否、某个配置开关是否打开等。*/</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//配置导入</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">           调用 getAutoConfigurationEntry(annotationMetadata) 获取自动配置条目，通常这个条目会包含多个配置类。</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br>            <span class="hljs-comment">//第一个参数</span><br>         <br>       <br>            <span class="hljs-comment">//第一个参数加载代码-解释</span><br>            <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);<br>            <br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            将配置类名列表转换为字符串数组并返回，Spring 会根据返回的类名将它们导入到 IOC 容器中，作为自动配置的一部分。</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">///    AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br>    <br>-----------autoConfigurationMetadata<br>    <br>    <br>       <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);<br>    --&gt;load方法<br>        <br>        <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AutoConfigurationMetadata <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>        <span class="hljs-keyword">return</span> loadMetadata(classLoader, <span class="hljs-string">&quot;META-INF/spring-autoconfigure-metadata.properties&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><hr><hr><p>在META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-class">.GsonAutoConfiguration</span>,\<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-class">.GsonAutoConfiguration</span>,\<br></code></pre></td></tr></table></figure><p>—这就是要加入ioc容器的类<br> 这么多 不会累坏吗 spring怎么知道哪些要加入哪些不加入呢</p><p> org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//表面该类是自动配置类</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;Gson.class&#125;)</span><span class="hljs-comment">//类的是否创建 类在类路径生效才生效--在spirng中-要存在配置才导入</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;GsonProperties.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GsonAutoConfiguration</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GsonAutoConfiguration</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <br>    <br>      <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-comment">//条件注解 这意味着只有当Spring容器中不存在类型为Gson 的Bean时，该方法返回的实例才会被注册为Bean</span><br>    <span class="hljs-keyword">public</span> Gson <span class="hljs-title function_">gson</span><span class="hljs-params">(GsonBuilder gsonBuilder)</span> &#123;<br>        <span class="hljs-keyword">return</span> gsonBuilder.create();<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>条件注解详解<br> @Configuration<br> public class HeaderConfig {</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><br><span class="hljs-variable">@ConditionalOnClass</span>(name=<span class="hljs-string">&quot;io.jsonwebtoken.Jwts&quot;</span>)<span class="hljs-comment">//环境中存在指定的这个类，才会将该bean加入IOC容器</span><br>public HeaderParser <span class="hljs-built_in">headerParser</span>()&#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HeaderParser</span>();<br>&#125;<br><br><span class="hljs-comment">//省略其他代码...</span><br></code></pre></td></tr></table></figure><p>理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。</p><p>@ConditionalOnMissingBean &#x2F;&#x2F;不存在该类型的bean，才会将该bean加入IOC容器<br> @ConditionalOnMissingBean(name&#x3D;”deptController2”)&#x2F;&#x2F;不存在指定名称的bean，才会将该bean加入IOC容器<br> @ConditionalOnMissingBean(HeaderConfig.class)&#x2F;&#x2F;不存在指定类型的bean，才会将bean加入IOC容器<br> @ConditionalOnProperty(name &#x3D;”name”,havingValue &#x3D; “itheima”)&#x2F;&#x2F;配置文件中存在指定属性名与值，才会将bean加入IOC容器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197287-20231024124652432-47953813.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197287-20231023235331923-676978176.png" alt="image"></p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>总结-从启动类依赖开始找-&gt;自动装配依赖-&gt;自动装配依赖类的依赖-&gt;这个依赖的参数_&gt;selectImport函数-&gt;配置代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>-&gt;<span class="hljs-meta">@EnableAutoConfiguration</span>-&gt;<span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>-&gt;AutoConfigurationImportSelector-&gt;<br>-&gt;selectImport-&gt;<span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br>   -&gt; 探究方法参数<br> <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);-&gt;loadMetadata<br>           <br>    -&gt;代码方法-根据获取类全命名<br>    <br>    <br><br>-&gt;返回<br>      <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br></code></pre></td></tr></table></figure><p>这个过程就是spirng-boot-再启动的时候-&gt;会依据配置文件 去读取加载的Bean</p><p>bean中又包含了条件创建bean的结构</p><p>   @Bean<br>    @ConditionalOnMissingBean&#x2F;&#x2F;条件注解 这意味着只有当Spring容器中不存在类型为Gson 的Bean时，该方法返回的实例才会被注册为Bean<br>    public Gson gson(GsonBuilder gsonBuilder) {<br>        return gsonBuilder.create();<br>    }</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="/2024/09/14/MybitsPlus/"/>
    <url>/2024/09/14/MybitsPlus/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Mybatis-plus.png" alt="Mybatis-plus"></p><h4 id="MyBatis-Plus快速入门"><a href="#MyBatis-Plus快速入门" class="headerlink" title="MyBatis-Plus快速入门"></a>MyBatis-Plus快速入门</h4><p>MyBatis-Plus-&gt;基于MyBatis进行了一系列的开发</p><p>配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 数据库--&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mysql.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- MyBatis Plus 依赖 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用最新稳定版本 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">&quot;com.anli1.mapper&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Case01Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Case01Application</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>官方配置</p><p><a href="https://baomidou.com/introduce/">https://baomidou.com/introduce/</a></p><h6 id="0-了解mybatis封装"><a href="#0-了解mybatis封装" class="headerlink" title="0.了解mybatis封装"></a>0.了解mybatis封装</h6><p>1.自动生成sql</p><p><code>MyBatis-Plus</code> 提供了一套自动生成 CRUD（增删改查）操作的方法，这些方法包括：</p><ul><li><code>insert()</code>：插入数据。</li><li><code>deleteById()</code> &#x2F; <code>deleteBatchIds()</code>：根据 ID 或一组 ID 删除数据。</li><li><code>updateById()</code>：根据 ID 更新数据。</li><li><code>selectById()</code> &#x2F; <code>selectBatchIds()</code>：根据 ID 或一组 ID 查询数据。</li></ul><p>这些方法避免了手动编写重复的 SQL 语句和 DAO 层代码，显著提高了开发效率。</p><p>2.内置分页插件</p><p><code>MyBatis-Plus</code> 内置了分页插件，可以自动处理分页逻辑。开发者只需配置插件，调用相应的分页方法，框架会自动生成分页查询语句并返回分页结果。</p><p>3.<strong>条件构造器</strong></p><p><code>MyBatis-Plus</code> 提供了 <code>QueryWrapper</code>、<code>UpdateWrapper</code> 等条件构造器，使得开发者可以以更加简洁的方式构造复杂的查询或更新条件。例如，可以使用链式方法调用来构建查询条件，替代传统的手动拼接 SQL 的方式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();<br>queryWrapper.e<span class="hljs-string">q(&quot;name&quot;, &quot;Tom&quot;)</span>.ge(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>后续的就是不怎么用的内容</p><p>4.<strong>多种插件支持</strong></p><p><code>MyBatis-Plus</code> 提供了一系列插件，以扩展框架的功能，例如：</p><ul><li><strong>分页插件</strong>：支持自动分页。</li><li><strong>性能分析插件</strong>：帮助分析 SQL 性能。</li><li><strong>多租户插件</strong>：支持多租户应用程序开发。</li><li><strong>乐观锁插件</strong>：支持乐观锁控制，实现高并发场景下的数据安全。</li><li><strong>数据权限插件</strong>：可以在不同层级上控制数据访问权限。</li></ul><p>5.代码生成器</p><p><code>MyBatis-Plus</code> 提供了代码生成器工具，可以根据数据库表结构自动生成实体类、Mapper 接口、Service 类和 Controller 类。这样，大大减少了开发者的工作量，加快了开发速度。</p><p>6.逻辑删除</p><p><code>MyBatis-Plus</code> 支持逻辑删除功能，即在删除记录时，不是真的删除数据，而是将记录的某个标志位进行更新。<code>MyBatis-Plus</code> 会自动处理带有逻辑删除标记的数据，使其在查询时被自动排除。</p><p>7.自动填充功能</p><p>支持自动填充字段功能，例如创建时间、更新时间等字段，可以在插入或更新数据时自动填充指定的字段值。</p><p>8.sql性能优化</p><p><code>MyBatis-Plus</code> 对常见的 SQL 语句进行了优化，提高了执行效率。此外，还增强了 SQL 的功能，例如多表关联查询、Lambda 表达式构建器等。</p><p>总结</p><p>自动 CRUD 操作、内置分页、条件构造器、多种插件支持、代码生成器、逻辑删除、自动填充功能 sql优化</p><h6 id="1-BaseMapper类"><a href="#1-BaseMapper类" class="headerlink" title="1.BaseMapper类"></a>1.BaseMapper类</h6><p><code>BaseMapper</code> 是 <code>MyBatis-Plus</code> 提供的一个基础接口，它的作用是为所有的数据库实体类提供通用的 CRUD（增删改查）操作方法。通过继承 <code>BaseMapper</code>，开发者可以避免手动编写大量的重复性代码，大大简化了持久层的开发工作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/84af32c461349faaa0e4f957c97a049b.png" alt="84af32c461349faaa0e4f957c97a049b"></p><p>mapper-&gt;继承该方法-这些方法名也是说的非常易懂的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// Mapper 接口继承 </span><br>BaseMapper <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserMapper</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BaseMapper</span>&lt;<span class="hljs-symbol">User</span>&gt; &#123;   <br><span class="hljs-comment">// 你可以在这里定义自定义方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-Mybits-映射Pojo"><a href="#2-Mybits-映射Pojo" class="headerlink" title="2.Mybits 映射Pojo"></a>2.Mybits 映射Pojo</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3c3e138598f90a383add182c550745da.png" alt="3c3e138598f90a383add182c550745da"></p><p>驼峰命名法是一种命名约定，其中每个单词的首字母大写，没有空格或标点符号来分隔单词，例如：camelCase。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@TableName(<span class="hljs-string">&quot;user&quot;</span>)</span> <span class="hljs-comment">// 指定表名为 &#x27;user&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span> <span class="hljs-comment">// 指定主键策略</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id; <span class="hljs-comment">// 与表中的 &#x27;id&#x27; 字段对应</span><br><br>    <span class="hljs-meta">@TableField(<span class="hljs-string">&quot;name&quot;</span>)</span> <span class="hljs-comment">// 指定映射字段名为 &#x27;name&#x27;</span><br>    <span class="hljs-keyword">private</span> String username; <span class="hljs-comment">// 与表中的 &#x27;name&#x27; 字段对应</span><br>    <br>    <span class="hljs-keyword">private</span> Integer age; <span class="hljs-comment">// 与表中的 &#x27;age&#x27; 字段对应</span><br>    <br>    <span class="hljs-comment">// Getters and Setters...</span><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h6 id="3-注解-TableName-表名注解"><a href="#3-注解-TableName-表名注解" class="headerlink" title="3.注解@TableName -表名注解"></a>3.注解@TableName -表名注解</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5963a7ca700c1878c285ab9ae2347046.png" alt="5963a7ca700c1878c285ab9ae2347046"></p><h6 id="4-主键注解-Tableid"><a href="#4-主键注解-Tableid" class="headerlink" title="4.主键注解 @Tableid"></a>4.主键注解 @Tableid</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed012758973b1755cdcd1d1ddc0e991c.png" alt="ed012758973b1755cdcd1d1ddc0e991c"></p><p> @TableId<br>    private Long id;<br>属性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/242fd1966addaff8b3313118e48981a7.png" alt="242fd1966addaff8b3313118e48981a7"></p><h6 id="5-普通字段注解-TableField"><a href="#5-普通字段注解-TableField" class="headerlink" title="5.普通字段注解@TableField"></a>5.普通字段注解@TableField</h6><p>@TableField(“isMarried”)<br>    private Boolean isMarried;</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95e9bd49c3b791c708e964a2f4b15e2a.png" alt="95e9bd49c3b791c708e964a2f4b15e2a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5fe85caf87e0fab3483354cb7fd499ad.png" alt="5fe85caf87e0fab3483354cb7fd499ad"></p><h6 id="6-常见配置"><a href="#6-常见配置" class="headerlink" title="6.常见配置"></a>6.常见配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/034876e14a71af1ec8524063ba29c738.png" alt="034876e14a71af1ec8524063ba29c738"></p><hr><p>mybitspro 也支持手写sql</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7441706e396a4cab007d33e7e1dd4469.png" alt="7441706e396a4cab007d33e7e1dd4469"></p><p>mybitsx+mybitsplus-&gt;可以支持跳转写-具体方法就是mybits</p><h4 id="7-条件构造器"><a href="#7-条件构造器" class="headerlink" title="7.条件构造器"></a>7.条件构造器</h4><h6 id="1-构造器了解"><a href="#1-构造器了解" class="headerlink" title="1.构造器了解"></a>1.构造器了解</h6><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/52da0353c64f7992f277a55d5d69307d.png" alt="52da0353c64f7992f277a55d5d69307d"></p><p>Wrapper关系</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95aa614360e41a40e6eb3aeb95743c0a.png" alt="95aa614360e41a40e6eb3aeb95743c0a"></p><h6 id="1-AbstractWrapper"><a href="#1-AbstractWrapper" class="headerlink" title="1.AbstractWrapper"></a>1.AbstractWrapper</h6><p>提供了where中包含的所有条件构造方法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/336fb5b4722bff7397e6c30eb5dea9bf.png" alt="336fb5b4722bff7397e6c30eb5dea9bf"></p><h6 id="2-QueryWrapper"><a href="#2-QueryWrapper" class="headerlink" title="2.QueryWrapper"></a>2.QueryWrapper</h6><p>拓展了一个select方法，允许指定查询字段</p><p>-&gt;查询id</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/47543da4a82f7a8134c43b19b1e10502.png" alt="47543da4a82f7a8134c43b19b1e10502"></p><h6 id="3-UpdateWrapper"><a href="#3-UpdateWrapper" class="headerlink" title="3.UpdateWrapper"></a>3.UpdateWrapper</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c1893ba09ded9c12a23470e6000d7325.png" alt="c1893ba09ded9c12a23470e6000d7325"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/99ec8027977a2561dadf41ef09a948ad.png" alt="99ec8027977a2561dadf41ef09a948ad"></p><h6 id="4-LambdaQueryWrapper"><a href="#4-LambdaQueryWrapper" class="headerlink" title="4.LambdaQueryWrapper"></a>4.LambdaQueryWrapper</h6><blockquote><p>-无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。</p><p><code>QueryWrapper</code> 和 <code>UpdateWrapper</code> 常用于构建数据库查询或更新的条件。在使用这些类构造查询条件时，字段名是以字符串形式硬编码在代码中的。</p><p><strong>字符串魔法值</strong>：直接在代码中写死字段名是一个“魔法值”（Magic String），即无法直观地知道这个字符串代表什么意思，如果需要修改字段名，则必须在代码中找到所有使用该字符串的地方并手动更改。</p><p><strong>不安全且容易出错</strong>：硬编码的字符串字段名在编译时不会被检查，当字段名拼写错误或发生变化时，可能导致运行时错误（如 SQL 执行失败），但编译器无法检测到这个问题。</p><p><strong>难以维护</strong>：如果表的字段名称发生更改，代码中的所有字符串字段名都需要手动调整，增加了代码维护的成本。</p></blockquote><p>写死值案例</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();<br>queryWrapper.e<span class="hljs-string">q(&quot;name&quot;, &quot;John&quot;)</span>; <span class="hljs-regexp">//</span> 使用字符串字段名<br>queryWrapper.ge(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>MyBatis-Plus 提供了 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code> 来解决上述问题。这些类允许你使用 Lambda 表达式来引用字段，而不是直接使用字符串。这种方式有以下好处：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.e<span class="hljs-string">q(User::getName, &quot;John&quot;)</span>; <span class="hljs-regexp">//</span> 使用 Lambda 表达式引用字段 lambdaQueryWrapper.ge(User::getAge, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>使用 <code>User::getName</code> 和 <code>User::getAge</code> 作为字段的引用。<code>User</code> 是实体类，<code>getName</code> 和 <code>getAge</code> 是其字段的 Getter 方法。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b0ffa0bb1d852812ad294a35b8fd888.png" alt="1b0ffa0bb1d852812ad294a35b8fd888"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/46be4929662ae5ef628b043e12c85c09.png" alt="46be4929662ae5ef628b043e12c85c09"></p><h4 id="自定义sql-注解"><a href="#自定义sql-注解" class="headerlink" title="自定义sql-注解"></a>自定义sql-注解</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/96f49f3a8be18ed697e8915da140bed9.png" alt="96f49f3a8be18ed697e8915da140bed9"></p><p>改</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d725d5559e95de38132857f497800bd.png" alt="8d725d5559e95de38132857f497800bd"></p><p>基于注解写sql-是mybitsplus功能</p><h4 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h4><h6 id="1-Service了解"><a href="#1-Service了解" class="headerlink" title="1.Service了解"></a>1.Service了解</h6><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。如下</p><p><code>IService</code> 和 <code>ServiceImpl</code> 是用于简化对数据库操作的通用接口和默认实现。<code>IService</code> 提供了一套通用的服务接口，而 <code>ServiceImpl</code> 则是对这些接口的具体实现。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3dcaf6a956fe9fe726dd0f071b0c71bc.png" alt="3dcaf6a956fe9fe726dd0f071b0c71bc"></p><h6 id="2-新增"><a href="#2-新增" class="headerlink" title="2.新增"></a>2.新增</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/13c96b5cebd34752b567c130b95bf94f.png" alt="13c96b5cebd34752b567c130b95bf94f"></p><h6 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/223e551718256b2c4ccb496ab27fd928.png" alt="223e551718256b2c4ccb496ab27fd928"></p><h6 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/15250e865364a0a81ebc28c32da5d578.png" alt="15250e865364a0a81ebc28c32da5d578"></p><h6 id="4-查找单个"><a href="#4-查找单个" class="headerlink" title="4.查找单个"></a>4.查找单个</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4ae94dcbfb1f9c6c65304c24b0345a83.png" alt="4ae94dcbfb1f9c6c65304c24b0345a83"></p><h6 id="5-查询集合"><a href="#5-查询集合" class="headerlink" title="5.查询集合"></a>5.查询集合</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/49306fabfb10f5443ed6af5be333fd1e.png" alt="49306fabfb10f5443ed6af5be333fd1e"></p><h6 id="6-计数"><a href="#6-计数" class="headerlink" title="6.计数"></a>6.计数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c48dc029d0bd68c01a7dfbe8b5a6fc45.png" alt="c48dc029d0bd68c01a7dfbe8b5a6fc45"></p><h6 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7.分页查询"></a>7.分页查询</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1cd184ca76dc2163ff33cff11f550075.png" alt="1cd184ca76dc2163ff33cff11f550075"></p><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><blockquote><p>MyBatis（包括 MyBatis-Plus）中使用了 Lambda 表达式来简化查询操作，使代码更加简洁和易于维护。Lambda 表达式通常与 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code> 一起使用，提供一种类型安全的方式来编写条件查询和更新语句。</p></blockquote><h6 id="1-LambdaQueryWrapper"><a href="#1-LambdaQueryWrapper" class="headerlink" title="1.LambdaQueryWrapper"></a>1.<code>LambdaQueryWrapper</code></h6><p><code>LambdaQueryWrapper</code> 用于构建查询条件。它利用 Java 8 的 Lambda 表达式特性，使条件构造更加直观和安全。以下是一些常用的方法：\</p><p><code>eq</code>：相等查询</p><p><code>ne</code>：不等于查询</p><p><code>gt</code>：大于查询</p><p><code>ge</code>：大于等于查询</p><p><code>lt</code>：小于查询</p><p><code>le</code>：小于等于查询</p><p><code>like</code>：模糊查询</p><p><code>notLike</code>：不匹配查询</p><p><code>likeLeft</code>：左匹配查询</p><p><code>likeRight</code>：右匹配查询</p><p><code>between</code>：在区间内查询</p><p><code>notBetween</code>：不在区间内查询</p><p><code>isNull</code>：字段为空查询</p><p><code>isNotNull</code>：字段不为空查询</p><p><code>in</code>：包含查询</p><p><code>notIn</code>：不包含查询</p><p><code>orderByAsc</code>：升序排序</p><p><code>orderByDesc</code>：降序排序</p><h6 id="2-LambdaUpdateWrapper"><a href="#2-LambdaUpdateWrapper" class="headerlink" title="2.LambdaUpdateWrapper"></a>2.LambdaUpdateWrapper</h6><p><code>set</code>：设置要更新的字段和值</p><p><code>eq</code>：相等查询</p><p><code>ne</code>：不等于查询</p><p><code>gt</code>：大于查询</p><p><code>ge</code>：大于等于查询</p><p><code>lt</code>：小于查询</p><p><code>le</code>：小于等于查询</p><p><code>like</code>：模糊查询</p><p><code>between</code>：在区间内查询</p><p><code>isNull</code>：字段为空查询</p><p><code>isNotNull</code>：字段不为空查询</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">LambdaUpdateWrapper&lt;<span class="hljs-keyword">User</span>&gt; updateWrapper = <span class="hljs-built_in">new</span> LambdaUpdateWrapper&lt;&gt;();<br>updateWrapper.eq(<span class="hljs-keyword">User</span>::getId, <span class="hljs-number">1</span>)<br>             .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getName, &quot;李四&quot;)<br>             .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getAge, <span class="hljs-number">25</span>);<br>userMapper.<span class="hljs-keyword">update</span>(<span class="hljs-keyword">null</span>, updateWrapper);<br></code></pre></td></tr></table></figure><h6 id="3-lambda简化"><a href="#3-lambda简化" class="headerlink" title="3.lambda简化"></a>3.lambda简化</h6><p>如果你不想在 MyBatis-Plus 中每次都使用 <code>new LambdaQueryWrapper&lt;&gt;()</code> 或 <code>new LambdaUpdateWrapper&lt;&gt;()</code>，你可以使用 MyBatis-Plus 提供的静态方法来简化代码。MyBatis-Plus 的 <code>Wrappers</code> 类提供了多个静态方法，用于构建 Lambda 表达式的查询和更新条件。</p><p>MyBatis-Plus 提供了 <code>Wrappers.lambdaQuery()</code> 和 <code>Wrappers.lambdaUpdate()</code> 方法来创建 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code> 的实例。这些方法使代码更加简洁，省去了显式创建对象的步骤。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/23977048b3aead660e100eb55b7391b2.png" alt="23977048b3aead660e100eb55b7391b2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c243ec58a30cfb1eaaa8fe38a934fd14.png" alt="c243ec58a30cfb1eaaa8fe38a934fd14"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68eda2f47849ac7f17f343f9d71147bf.png" alt="68eda2f47849ac7f17f343f9d71147bf"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bbffabb2a6d9fd54b8984cbe194d1457.png" alt="bbffabb2a6d9fd54b8984cbe194d1457"></p><p>改造根据id修改用户余额的接口，要求如下</p><ul><li>如果扣减后余额为0，则将用户status修改为冻结状态（2）</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/467e0f04ce771a195c18e1c64970a3ae.png" alt="467e0f04ce771a195c18e1c64970a3ae"></p><p>动态sql</p><p>mybits批量处理</p><p>IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务</p><p>—也就是不需要构造条件-直接可以用lambda-进行查询</p><h4 id="Mybits批处理"><a href="#Mybits批处理" class="headerlink" title="Mybits批处理"></a>Mybits批处理</h4><p>逐条插入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/101b580959e40e749e63af58e1ac2bd9.png" alt="101b580959e40e749e63af58e1ac2bd9"></p><p>mybits批处理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/866ee7682e72520e58686b6b1bc60e46.png" alt="866ee7682e72520e58686b6b1bc60e46"></p><p>每1000条批量插入一次</p><p>为什么mybits插入速度就快</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-built_in">Transactional</span>(rollbackFor = Exception.<span class="hljs-keyword">class</span>)<br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">saveBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList, <span class="hljs-type">int</span> batchSize)</span> </span>&#123;<br><span class="hljs-comment">//传入集合和集合大小</span><br>    <br><span class="hljs-type">String</span> sqlStatement = <span class="hljs-built_in">getSqlStatement</span>(SqlMethod.INSERT_ONE);<br>获取预处理<span class="hljs-function">sql</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">executeBatch</span><span class="hljs-params">(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity))</span></span>;<br>&#125;<br>-&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-type">boolean</span> <span class="hljs-title">executeBatch</span><span class="hljs-params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="hljs-type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;<br>    Assert.<span class="hljs-built_in">isFalse</span>(batchSize &lt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;batchSize must not be less than one&quot;</span>);<span class="hljs-comment">///断言语句</span><br><span class="hljs-comment">///三元运算</span><br>    <span class="hljs-keyword">return</span> <br>!CollectionUtils.<span class="hljs-built_in">isEmpty</span>(list)<span class="hljs-comment">//检查集合是否为空</span><br> &amp;&amp; <span class="hljs-built_in">executeBatch</span>(entityClass, log, sqlSession -&gt; &#123;<br>        <span class="hljs-type">int</span> size = list.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> idxLimit = Math.<span class="hljs-built_in">min</span>(batchSize, size);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (E element : list) &#123;<br>            consumer.<span class="hljs-built_in">accept</span>(sqlSession, element);<br>            <span class="hljs-keyword">if</span> (i == idxLimit) &#123;<br>                sqlSession.<span class="hljs-built_in">flushStatements</span>();<br>                idxLimit = Math.<span class="hljs-built_in">min</span>(idxLimit + batchSize, size);<br>            &#125;<br>            i++;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>executeBatch(entityClass, log, sqlSession -&gt; { … }): 这是一个方法调用，调用了名为 executeBatch 的方法，并传递了 entityClass、log 和一个 Lambda 表达式作为参数。Lambda 表达式中的代码块将会在 executeBatch 方法内部执行。</p><p>Lambda 表达式内部的逻辑：</p><pre><code class="hljs">首先，获取集合 list 的大小，并将其存储在变量 size 中。然后，计算循环的上限索引 idxLimit，它等于批处理大小 batchSize 和集合大小 size 中的较小值。接着，初始化变量 i 为 1，用于追踪当前处理的元素索引。在循环中，遍历集合 list 中的每个元素 element：    使用 consumer.accept(sqlSession, element) 方法处理当前元素，其中 consumer 是一个函数接口，用于执行特定的操作。    如果当前处理的索引 i 等于上限索引 idxLimit，则调用 sqlSession.flushStatements() 方法来刷新 SQL 语句，并更新上限索引 idxLimit 为下一个批次的上限索引。    最后，增加索引变量 i 的值，进入下一轮循环。</code></pre><p>整个 Lambda 表达式的执行结果将作为 executeBatch 方法的返回值。</p><p>}</p><p>以发现其实MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0d893a2bdab9ed10ad0c7284e6823446.png" alt="0d893a2bdab9ed10ad0c7284e6823446"></p><p>——-开启重新批处理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e5d8dd6fc91bf3b8183f433d705a8485.png" alt="e5d8dd6fc91bf3b8183f433d705a8485">****</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/accd1ecdecd550e717eaffb8a07860cc.png" alt="accd1ecdecd550e717eaffb8a07860cc"></p><h4 id="mybitsplus-代码生成"><a href="#mybitsplus-代码生成" class="headerlink" title="mybitsplus-&gt;代码生成"></a>mybitsplus-&gt;代码生成</h4><p>在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/640804c8b4ef9653c763c7c457d5c1e9.png" alt="640804c8b4ef9653c763c7c457d5c1e9"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8be53fe79baa68053e1013376f8ea342.png" alt="8be53fe79baa68053e1013376f8ea342"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/42bb2850b64b4a5daa22cf5a3e19e92a.png" alt="42bb2850b64b4a5daa22cf5a3e19e92a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/465db4382ca68f36c25c79a80bbce054.png" alt="465db4382ca68f36c25c79a80bbce054"></p><h4 id="MybitsPlus静态"><a href="#MybitsPlus静态" class="headerlink" title="MybitsPlus静态"></a>MybitsPlus静态</h4><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c1f46709369d86eee7c03df671545992.png" alt="c1f46709369d86eee7c03df671545992"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/59a15e1243bd819dbc3e3d4869dd7b79.png" alt="59a15e1243bd819dbc3e3d4869dd7b79"></p><p>案例</p><p>改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9982422351f6ecc277ededc0e803296.png" alt="c9982422351f6ecc277ededc0e803296"></p><h4 id="逻辑删除优化"><a href="#逻辑删除优化" class="headerlink" title="逻辑删除优化"></a>逻辑删除优化</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/edb312802503c8139e9606f8ae74f0d8.png" alt="edb312802503c8139e9606f8ae74f0d8"></p><p>确实<br>比如云盘项目-就是要过滤这些条件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c7bda4e8f8266db45e4908e922627b8a.png" alt="c7bda4e8f8266db45e4908e922627b8a"></p><p>配置逻辑删除</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0dd9aceaa2940ed98150df3ea6b48312.png" alt="0dd9aceaa2940ed98150df3ea6b48312"></p><p>查询测试</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/64779cb8ce59b7e93069adc874ce93ed.png" alt="64779cb8ce59b7e93069adc874ce93ed"></p><h4 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/60a018a6f80a6f46b6c5c4f5bf7fb176.png" alt="60a018a6f80a6f46b6c5c4f5bf7fb176"></p><p>mybits-&gt;提供枚举类型与数据库类型自动转换</p><p>MyBatis-Plus  通过注解 <code>@EnumValue</code> 指定数据库字段和枚举字段的映射。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cb75a3b930d23430174c125921d14601.png" alt="cb75a3b930d23430174c125921d14601"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4934929e1a9c7b79d79f04adf975105.png" alt="c4934929e1a9c7b79d79f04adf975105"></p><p>同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/28cfbac5f5fa1ffc563eb851a3f65f25.png" alt="28cfbac5f5fa1ffc563eb851a3f65f25"></p><p>0—会自动根据数字-对应正常或者冻结</p><h4 id="json类型处理器"><a href="#json类型处理器" class="headerlink" title="json类型处理器"></a>json类型处理器</h4><blockquote><p>在 MyBatis-Plus 中，我们可以使用 <code>JacksonTypeHandler</code> 类型处理器来自动将 JSON 数据库字段与 Java 对象之间进行转换，这样就不需要手动进行字符串与 JSON 对象之间的转换了。<code>JacksonTypeHandler</code> 使用了 Jackson 库来进行 JSON 序列化和反序列化操作。</p></blockquote><p>在 MyBatis-Plus 中，我们可以使用 <code>JacksonTypeHandler</code> 类型处理器来自动将 JSON 数据库字段与 Java 对象之间进行转换，这样就不需要手动进行字符串与 JSON 对象之间的转换了。<code>JacksonTypeHandler</code> 使用了 Jackson 库来进行 JSON 序列化和反序列化操作。</p><p>假设你有一个 <code>user</code> 表，其中 <code>info</code> 字段是 JSON 类型。在 <code>User</code> 实体类中，我们希望将 <code>info</code> 映射为一个 Java 对象（如 <code>Map</code> 或一个自定义的 Java 类），而不是 <code>String</code>。我们可以使用 <code>JacksonTypeHandler</code> 来实现这种自动转换。</p><blockquote><p>在实体类的对应字段上使用 <code>@TableField</code> 注解，并指定 <code>typeHandler</code> 为 <code>JacksonTypeHandler</code>。</p><p>如果 <code>info</code> 字段是一个 Map 或者自定义对象类型，<code>JacksonTypeHandler</code> 会自动完成 JSON 与 Java 对象之间的转换。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6d0855f286d0ffdb19096463987947fb.png" alt="6d0855f286d0ffdb19096463987947fb"></p><p><code>JacksonTypeHandler</code> 会将数据库中的 JSON 数据自动转换为 <code>UserInfo</code> 对象，并且在保存时会自动将 <code>UserInfo</code> 转换为 JSON 字符串。</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><h6 id="1-配置分页插件"><a href="#1-配置分页插件" class="headerlink" title="1.配置分页插件"></a>1.配置分页插件</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/12944f422088ff0097b7beb2b0d835d3.png" alt="12944f422088ff0097b7beb2b0d835d3"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><br><span class="hljs-variable">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br>    <span class="hljs-variable">@Bean</span><br>    public PaginationInterceptor paginationInterceptor() &#123;<br>        <span class="hljs-keyword">return</span> new PaginationInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>PaginationInterceptor</code> 插件是 MyBatis-Plus 提供的分页插件，它会自动处理分页逻辑，支持多种数据库。</p><h6 id="2-分页api"><a href="#2-分页api" class="headerlink" title="2.分页api"></a>2.分页api</h6><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-keyword">public</span> Page&lt;User&gt; getUsersByPage(<span class="hljs-keyword">int</span> currentPage, <span class="hljs-keyword">int</span> pageSize) &#123;<br>        <span class="hljs-comment">// 创建 Page 对象</span><br>        Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(currentPage, pageSize);<br><br>        <span class="hljs-comment">// 创建 QueryWrapper 对象</span><br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>        queryWrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 按照 id 降序排列</span><br><br>        <span class="hljs-comment">// 执行分页查询</span><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> userMapper.<span class="hljs-title">selectPage</span><span class="hljs-params">(page, queryWrapper)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 <code>Page</code> 类创建了一个分页对象，并指定了当前页码和每页显示的记录数。<code>selectPage</code> 方法会执行分页查询，并将结果封装在 <code>Page</code> 对象中返回。</p></blockquote><h6 id="3-Page-对象的属性"><a href="#3-Page-对象的属性" class="headerlink" title="3.,Page 对象的属性"></a>3.,<code>Page</code> 对象的属性</h6><p><code>Page</code> 对象包含以下属性：</p><ul><li>**<code>current</code>**：当前页码。</li><li>**<code>size</code>**：每页显示的记录数。</li><li>**<code>total</code>**：总记录数。</li><li>**<code>pages</code>**：总页数。</li><li>**<code>records</code>**：当前页的数据记录列表。</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">Page<span class="hljs-variable">&lt;User&gt;</span> <span class="hljs-keyword">user</span>Page = <span class="hljs-keyword">user</span>Service.getUsersByPage(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>List<span class="hljs-variable">&lt;User&gt;</span> users = <span class="hljs-keyword">user</span>Page.getRecords(); // 当前页的数据记录<br>long total = <span class="hljs-keyword">user</span>Page.getTotal(); // 总记录数<br>long pages = <span class="hljs-keyword">user</span>Page.getPages(); // 总页数<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring mvc</title>
    <link href="/2024/09/13/Spring%20mvc%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/13/Spring%20mvc%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-mvc复习"><a href="#Spring-mvc复习" class="headerlink" title="Spring mvc复习"></a>Spring mvc复习</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/SpringMvc.png" alt="SpringMvc"></p><h4 id="0-spring-springmvc"><a href="#0-spring-springmvc" class="headerlink" title="0.spring-springmvc"></a>0.spring-springmvc</h4><p>Spring 和 Spring MVC 是两个相关但独立的框架，它们解决了不同的问题。简单来说，<strong>Spring</strong> 是一个通用的应用框架，而 <strong>Spring MVC</strong> 是一个基于 Spring 的 Web 框架，用于构建 Web 应用程序。</p><blockquote><p><strong>Spring 的主要作用</strong>：</p><ul><li><strong>依赖注入（Dependency Injection, DI）</strong>：Spring 最主要的功能是依赖注入，它通过控制反转（Inversion of Control, IoC）容器来管理对象之间的依赖关系，使代码更加模块化和可测试。</li><li><strong>面向切面编程（Aspect-Oriented Programming, AOP）</strong>：Spring 支持 AOP，允许在不修改原始代码的情况下添加额外的行为，例如日志记录、事务管理和安全检查。</li><li><strong>数据访问集成</strong>：Spring 提供对多种数据访问技术（如 JDBC、JPA、Hibernate）的集成和支持，简化了与数据库的交互。</li><li><strong>事务管理</strong>：Spring 提供了声明性事务管理，可以让开发者更轻松地管理事务。</li><li><strong>其他支持</strong>：如邮件发送、消息队列集成、缓存等。</li></ul><p><strong>Spring MVC 的主要作用</strong>：</p><ul><li><strong>专门用于 Web 开发</strong>：Spring MVC 是 Spring 框架中用于构建 Web 应用的部分，它遵循 Model-View-Controller (MVC) 设计模式，帮助开发者更容易地构建基于 HTTP 协议的 Web 应用程序。</li><li><strong>请求处理流程</strong>：Spring MVC 提供了一整套用于处理 HTTP 请求和响应的机制，例如 <code>DispatcherServlet</code> 作为前端控制器，将请求分发给适当的处理器（Controller）。</li><li><strong>视图解析</strong>：Spring MVC 提供视图解析机制，将模型数据绑定到视图（例如 JSP、Thymeleaf、Freemarker 等）。</li><li><strong>数据绑定与验证</strong>：提供了数据绑定功能，将请求参数绑定到 Java 对象，还支持数据验证和格式化。</li><li><strong>国际化（I18n）支持</strong>：Spring MVC 提供了内置的国际化支持，方便开发多语言 Web 应用程序。</li><li><strong>集成与扩展</strong>：与 Spring 生态系统中的其他模块（如 Spring Security、Spring Data 等）无缝集成。</li></ul></blockquote><p>Spring 和 Spring MVC 的关系</p><p>Spring MVC 是 Spring 框架中的一个模块，它依赖于 Spring 核心容器（Core Container）来工作。它利用了 Spring 的 IoC 和 AOP 功能来管理 Web 应用程序的组件（如控制器、服务、数据访问层等）。因此，Spring MVC 本质上是一个基于 Spring 的 Web 框架。</p><h4 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h4><p>Spirngmvc-Servlet</p><p>Controller-&gt;Springmvc 产物</p><p>1.SpringMVC是一种表现层框架技术–</p><p>SpringMVC用于进行表现层功能开发</p><p>使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标</p><p>创建Springfmvc控制器类</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a20b723675912525bb7fa4b6861f2445.png" alt="a20b723675912525bb7fa4b6861f2445"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/804db24f3395fe5d5940d26edfc3ea33.png" alt="804db24f3395fe5d5940d26edfc3ea33"></p><p>springmvc0需要设定springmcv加载对应Bean</p><h4 id="1-1-Springmvc配置"><a href="#1-1-Springmvc配置" class="headerlink" title="1.1 Springmvc配置"></a>1.1 Springmvc配置</h4><p><code>ServletContainersInitConfig</code> 类扩展了 <code>AbstractDispatcherServletInitializer</code>，这个类是 Spring MVC 提供的一个抽象类，用于快速初始化基于 Servlet 3.0 的 Web 容器（如 Tomcat）。它通过实现三个方法来配置 Spring 和 Spring MVC 的应用上下文以及 Servlet 的映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContainersInitConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDispatcherServletInitializer</span> &#123;<br>    <br>    <span class="hljs-comment">//加载springMVC配置 -第一个接口 创建Servlet容器时，加载SpringMVC对应的bean并放入</span><br>    <span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createServletApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//初始化WebApplicationContext对象</span><br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        <span class="hljs-comment">//加载指定配置类</span><br>        ctx.register(SpringMvcConfig.class);<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>作用：</p><ul><li>创建和配置 Spring MVC 的应用上下文（<code>WebApplicationContext</code>）<ul><li><code>WebApplicationContext</code> 是 Spring 中用于 Web 应用程序的应用上下文，它扩展了 <code>ApplicationContext</code>，提供了面向 Web 的额外功能。</li></ul></li><li>在这个方法中：<ul><li><strong>创建 <code>AnnotationConfigWebApplicationContext</code> 对象</strong>：这是一个基于注解配置的 <code>WebApplicationContext</code> 实现，能够扫描和加载配置类。</li><li><strong>注册配置类</strong>：<code>ctx.register(SpringMvcConfig.class)</code>，将指定的配置类 <code>SpringMvcConfig</code> 注册到 <code>WebApplicationContext</code> 中，这样 Spring MVC 就可以根据这个配置类初始化它所需的 bean 和其他配置。</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置Tomcat接收的请求哪些归SpringMVC处理</span><br><span class="hljs-comment">//getServletMappings()方法，设定SpringMVC对应的请求映射路径，设置为/表示拦截所有请求，任意请求都将转入到SpringMVC进行处理</span><br><br><span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>&#125;<br><br><span class="hljs-comment">//设置spring相关配置 如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，</span><br><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createRootApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解</p><blockquote><p>Controller 设定SpringMVC的核心控制器bean</p><p>@RequestMapping  设置当前控制器方法请求访问路径</p><p>@ResponseBody  设置当前控制器方法响应内容为当前返回值，无需解析</p></blockquote><p>综上-我们要导入spirngmvc容器</p><blockquote><p>1.导入springmvc坐标 2.创建springmvc核心控制器bean 3.再配置类中进行指定加载4.配置tocat的路径哪些被springmvc管理</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/67f41aab7f091ea29d50d4b977866e31.png" alt="67f41aab7f091ea29d50d4b977866e31"></p><p>* </p><h4 id="2-bean加载控制"><a href="#2-bean加载控制" class="headerlink" title="2.bean加载控制"></a>2.bean加载控制</h4><p>在 Spring 应用程序中，通常会有两种类型的配置：</p><ol><li><strong>Spring 容器配置</strong>：用于管理应用程序的核心业务逻辑组件，例如服务层（Service）、数据访问层（DAO）等。</li><li><strong>Spring MVC 容器配置</strong>：用于管理 Web 层的组件，例如控制器（Controller）、视图解析器（View Resolver）等。</li></ol><p>当一个应用程序使用了 Spring 和 Spring MVC 时，通常会有两个 <code>ApplicationContext</code>：</p><ul><li><strong>根应用上下文（Root ApplicationContext）</strong>：由 Spring 容器管理，包含业务逻辑层的 bean（如 Service、DAO 等）。</li><li><strong>Web 应用上下文（WebApplicationContext）</strong>：由 Spring MVC 容器管理，包含 Web 层的 bean（如 Controller、视图解析器等）。</li></ul><p>我们就需要避免加载</p><p>springmvc-controller –mvc  bean</p><p>业务层的service–注册为spirngbean的bean</p><blockquote><p><strong>将业务层的 bean（如 Service、DAO）注册到根应用上下文中</strong>，这些 bean 应该由 Spring 容器管理。</p><p><strong>将 Web 层的 bean（如 Controller）注册到 Web 应用上下文中</strong>，这些 bean 应该由 Spring MVC 容器管理。</p></blockquote><p>1.因为功能不同，如何避免Spring错误的加载到SpringMVC的bean——加载Spring控制的bean的时候排除掉SpringMVC控制的bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48eb36fe246fbb47facf7e8f5eb31ff6.png" alt="48eb36fe246fbb47facf7e8f5eb31ff6"></p><p>非常麻烦 –还需要分开加载</p><p>案例、</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f924b648ab257fbefa08c871b796ebb5.png" alt="f924b648ab257fbefa08c871b796ebb5"></p><p>这里就排除加载了springmvc的bean- 我们需要在写一个配置类来导入spirngmvc的bena </p><p>@Configuration<br>@ComponentScan(“com.itheima.controller”)—自动扫描<br>public class SpringMvcConfig {<br>}</p><h4 id="3-springmvc容器的简化开发"><a href="#3-springmvc容器的简化开发" class="headerlink" title="3.springmvc容器的简化开发"></a>3.springmvc容器的简化开发</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b0641d49bc4e25a589d46b048d0c712.png" alt="1b0641d49bc4e25a589d46b048d0c712"></p><h4 id="4-请求响应"><a href="#4-请求响应" class="headerlink" title="4.请求响应"></a>4.请求响应</h4><h6 id="1-请求映射路径"><a href="#1-请求映射路径" class="headerlink" title="1.请求映射路径"></a>1.请求映射路径</h6><p>@RequestMapping</p><p>l设置当前控制器方法请求访问路径，如果设置在类上统一设置当前控制器方法请求访问路径前缀</p><h6 id="2-请求传参"><a href="#2-请求传参" class="headerlink" title="2.请求传参"></a>2.请求传参</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ae8f28c7e68ec356172c7f4f322aabc.png" alt="0ae8f28c7e68ec356172c7f4f322aabc"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5fd3828d3099bff24bbf90834041bff.png" alt="d5fd3828d3099bff24bbf90834041bff"></p><h3 id="2-请求传参-1"><a href="#2-请求传参-1" class="headerlink" title="2.请求传参"></a>2.请求传参</h3><h5 id="1-普通参数"><a href="#1-普通参数" class="headerlink" title="1.普通参数"></a>1.普通参数</h5><p>1.url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数</p><p>2.请求参数名与形参变量名不同，使用@RequestParam绑定参数关系</p><p><strong>@RequestParam</strong>(“name”)String userName </p><h6 id="2-pojo类型参数"><a href="#2-pojo类型参数" class="headerlink" title="2.pojo类型参数"></a>2.pojo类型参数</h6><p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</p><h6 id="3-嵌套pojo参数"><a href="#3-嵌套pojo参数" class="headerlink" title="3.嵌套pojo参数"></a>3.嵌套pojo参数</h6><p>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><h6 id="4-数组类型"><a href="#4-数组类型" class="headerlink" title="4.数组类型"></a>4.数组类型</h6><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数 String[] likes</p><p>l</p><h6 id="5-集合类型-RequestParam"><a href="#5-集合类型-RequestParam" class="headerlink" title="5.集合类型 RequestParam"></a>5.集合类型 RequestParam</h6><p>l集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系</p><p>@RequestParam List<String> likes</p><h4 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2.JSON"></a>2.JSON</h4><p>添加json数据转换相关坐标</p><dependency>  <groupId>com.fasterxml.jackson.core</groupId>  <artifactId>jackson-databind</artifactId>  <version>2.9.0</version> </dependency><p>开启自动转换json数据的支持</p><p>@Configuration<br> @ComponentScan(“com.itheima.controller”)<br> <strong>@EnableWebMvc</strong>@EnableWebMvc注解功能强大，该注解整合了多个功能，此处仅使用其中一部分功能，即json数据进行自动类型转换<br> public class SpringMvcConfig {<br> }</p><h6 id="1-json数组-RequestBody"><a href="#1-json数组-RequestBody" class="headerlink" title="1.json数组 @RequestBody"></a>1.json数组 @RequestBody</h6><p>将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</p><p>@RequestBody List<String> likes</p><h6 id="2-json对象"><a href="#2-json对象" class="headerlink" title="2.json对象"></a>2.json对象</h6><p>json数据与形参对象属性名相同，定义POJO类型形参即可接收参数</p><p>@RequestBody User user</p><h6 id="3-json对象数组"><a href="#3-json对象数组" class="headerlink" title="3.json对象数组"></a>3.json对象数组</h6><p>json数组数据与集合泛型属性名相同，定义List类型形参即可接收参数</p><p>@RequestBody List<User> list</p><h6 id="0-区别"><a href="#0-区别" class="headerlink" title="0.区别"></a>0.区别</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/697f5240f2ca11734b8ddf804fa935bc.png" alt="697f5240f2ca11734b8ddf804fa935bc"></p><h6 id="3-日期传参"><a href="#3-日期传参" class="headerlink" title="3.日期传参"></a>3.日期传参</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/192cc0e58e4cc136b34168f56ccf355a.png" alt="192cc0e58e4cc136b34168f56ccf355a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab3b6686ddb4ec826f2990c1c925d36b.png" alt="ab3b6686ddb4ec826f2990c1c925d36b"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240414172132046.png" alt="image-20240414172132046"></p><h4 id="3-响应传递"><a href="#3-响应传递" class="headerlink" title="3.响应传递"></a>3.响应传递</h4><h6 id="1-文本返回"><a href="#1-文本返回" class="headerlink" title="1.文本返回"></a>1.文本返回</h6><p>  @ResponseBody -不仅仅可以将JSON对应类-还能告诉编译器转的是文本,而不是文件</p><h6 id="2-json返回"><a href="#2-json返回" class="headerlink" title="2.json返回"></a>2.json返回</h6><p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖&#x3D;&#x3D;@ResponseBody&#x3D;&#x3D;注解和&#x3D;&#x3D;@EnableWebMvc&#x3D;&#x3D;注解</p><h6 id="3-响应pojo集合"><a href="#3-响应pojo集合" class="headerlink" title="3.响应pojo集合"></a>3.响应pojo集合</h6><p>开对象-然后存进list集合中-返回list集合 默认返回的就是集合</p><p> List<User> userList &#x3D; new ArrayList<User>();<br>        userList.add(user1);<br>        userList.add(user2);</p><h6 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h6><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;方法\类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法定义上方和控制类上</td></tr><tr><td>作用</td><td>设置当前控制器返回值作为响应体,<br/>写在类上，该类的所有方法都有该注解功能</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>该注解可以写在类上或者方法上</li><li>写在类上就是该类下的所有方法都有@ReponseBody功能</li><li>当方法上有@ReponseBody注解后<ul><li>方法的返回值为字符串，会将其作为文本内容直接响应给前端</li><li>方法的返回值为对象，会将对象转换成JSON响应给前端</li></ul></li></ul><p>此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:</p><ul><li>对象转Json数据(POJO -&gt; json)</li><li>集合转Json数据(Collection -&gt; json)</li></ul><h4 id="Rest风格"><a href="#Rest风格" class="headerlink" title="Rest风格"></a>Rest风格</h4><h6 id="1-rest风格介绍"><a href="#1-rest风格介绍" class="headerlink" title="1.rest风格介绍"></a>1.rest风格介绍</h6><p>传统风格</p><ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul><p>REST</p><ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li><li>根据路径 无法看出对应功能–具有隐私保护性</li><li></li></ul><p>请求的方式比较多，但是比较常用的就4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。</p><p>按照不同的请求方式代表不同的操作类型。</p><ul><li>发送GET请求是用来做查询</li><li>发送POST请求是用来做新增</li><li>发送PUT请求是用来做修改</li><li>发送DELETE请求是用来做删除</li><li></li></ul><p>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范</p><h6 id="2-路径传参-PathVariable"><a href="#2-路径传参-PathVariable" class="headerlink" title="2.路径传参 @PathVariable"></a>2.路径传参 @PathVariable</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置当前请求方法为DELETE，表示REST风格中的删除操作</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/users/&#123;id&#125;/&#123;name&#125;&quot;,method = RequestMethod.DELETE)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id,<span class="hljs-meta">@PathVariable</span> String name)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>@PathVariable</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;形参注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</td></tr></tbody></table><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h4 id="springmvc开发特性"><a href="#springmvc开发特性" class="headerlink" title="springmvc开发特性"></a>springmvc开发特性</h4><h6 id="1-知识点1：-RestController"><a href="#1-知识点1：-RestController" class="headerlink" title="1.知识点1：@RestController"></a>1.知识点1：@RestController</h6><table><thead><tr><th>名称</th><th>@RestController</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>基于SpringMVC的RESTful开发控制器类定义上方</td></tr><tr><td>作用</td><td>设置当前控制器类为RESTful风格，<br/>等同于@Controller与@ResponseBody两个注解组合功能</td></tr></tbody></table><h6 id="知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping"></a>知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping</h6><table><thead><tr><th>名称</th><th align="right">@GetMapping @PostMapping @PutMapping @DeleteMapping</th></tr></thead><tbody><tr><td>类型</td><td align="right">&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td align="right">基于SpringMVC的RESTful开发控制器方法定义上方</td></tr><tr><td>作用</td><td align="right">设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，<br/>例如@GetMapping对应GET请求</td></tr><tr><td>相关属性</td><td align="right">value（默认）：请求访问路径</td></tr></tbody></table><h4 id="Spring-mvc-异常处理机制"><a href="#Spring-mvc-异常处理机制" class="headerlink" title="Spring mvc 异常处理机制"></a>Spring mvc 异常处理机制</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a4c33d1fd830a4bf2508db2f6b98e836.jpeg" alt="a4c33d1fd830a4bf2508db2f6b98e836"></p><p><code>@ControllerAdvice</code> 是一个全局异常处理注解，用于定义一个全局的异常处理类。这个类中的方法可以处理所有控制器中抛出的异常</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler</span>(<span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>)<span class="hljs-comment">//异常捕获</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">handleAllExceptions</span>(<span class="hljs-params"><span class="hljs-title class_">Exception</span> ex</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(<span class="hljs-string">&quot;Handled Exception: &quot;</span> + ex.<span class="hljs-title function_">getMessage</span>(), <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">INTERNAL_SERVER_ERROR</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b59e8bf4c2fbcc6be6fc912192f6f2df.jpg" alt="b59e8bf4c2fbcc6be6fc912192f6f2df"></p><p><code>@ExceptionHandler</code> 是 Spring MVC 提供的一种注解，用于定义处理特定异常的方法。可以在控制器类中使用该注解来捕获和处理特定类型的异常。</p><p>–增强类上指定-异常拦截器处理–基于AOP切面编程实现</p><hr><p>案例处理-如题 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/42419f57ee0003c58e6c059ba4fc1f58.jpeg" alt="42419f57ee0003c58e6c059ba4fc1f58"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b3b21d20c96ae90d732ce3cac09d5f68.jpeg" alt="b3b21d20c96ae90d732ce3cac09d5f68"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2bb0878bbc88b02c0ce024647e49ec70.jpeg" alt="2bb0878bbc88b02c0ce024647e49ec70"></p><p>自写异常-根据异常严重程度来进行对应的出来</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6241b3e5f0b6762d7a7166eac8e101ba.jpeg" alt="6241b3e5f0b6762d7a7166eac8e101ba"></p><p>抛出异常</p><p>拦截处理异常</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4cc146a7a81d28def5a9f72534f22ad3.jpeg" alt="4cc146a7a81d28def5a9f72534f22ad3"></p><h4 id="Springmvc-拦截器"><a href="#Springmvc-拦截器" class="headerlink" title="Springmvc -拦截器"></a>Springmvc -拦截器</h4><p> Spring MVC 中，拦截器（Interceptor）是一种用于对请求进行预处理和后处理的机制。拦截器类似于 Servlet 的过滤器（Filter），但提供了更灵活和强大的功能。它们可以用于权限检查、日志记录、性能监控等场景。</p><hr><p>Spring MVC 的拦截器基于 <code>HandlerInterceptor</code> 接口，它允许我们在处理 HTTP 请求的过程中插入自定义的逻辑。拦截器可以在以下三个阶段执行：</p><ol><li><strong>预处理阶段（preHandle）</strong>：在请求到达控制器之前执行。</li><li><strong>后处理阶段（postHandle）</strong>：在请求被控制器处理之后，但在视图渲染之前执行。</li><li><strong>完成后处理阶段（afterCompletion）</strong>：在整个请求完成之后执行，通常用于资源清理。</li></ol><h6 id="1-拦截器案例"><a href="#1-拦截器案例" class="headerlink" title="1.拦截器案例"></a>1.拦截器案例</h6><p>1.声明拦截器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/50fccfc54a1ef08467fab507b7fbce62.jpeg" alt="50fccfc54a1ef08467fab507b7fbce62"></p><p>实现HandlerInt接口</p><p>–</p><blockquote><p>在 Spring Boot 或 Spring MVC 的 Java 配置中，可以通过实现 <code>WebMvcConfigurer</code> 接口的 <code>addInterceptors</code> 方法来添加拦截器</p></blockquote><p>添加拦截器指定路径</p><p>在 Spring Boot 或 Spring MVC 的 Java 配置中，可以通过实现 <code>WebMvcConfigurer</code> 接口的 <code>addInterceptors</code> 方法来添加拦截器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>) &#123;<br>        <span class="hljs-comment">// 注册自定义的拦截器，并指定拦截路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截所有请求</span><br>                .<span class="hljs-title function_">excludePathPatterns</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/error&quot;</span>); <span class="hljs-comment">// 排除某些路径不拦截</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>addInterceptors(InterceptorRegistry registry)</code>：添加拦截器的方法。</p><p><code>addInterceptor(new MyInterceptor())</code>：注册自定义拦截器。</p><p><code>addPathPatterns(&quot;/**&quot;)</code>：设置拦截器拦截的路径模式，例如，<code>/**</code> 表示拦截所有请求。</p><p><code>excludePathPatterns(&quot;/login&quot;, &quot;/error&quot;)</code>：设置不需要拦截的路径模式，例如登录页和错误页。</p><h6 id="2-拦截器流程"><a href="#2-拦截器流程" class="headerlink" title="2.拦截器流程"></a>2.拦截器流程</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4caa6002de9cae7bb61d1f4dc79fbf40.jpeg" alt="4caa6002de9cae7bb61d1f4dc79fbf40"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d63b5afd7e7aaff800a0a7fa06a00c25.jpeg" alt="d63b5afd7e7aaff800a0a7fa06a00c25"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/267baa636fd682717e63a956def32ec5.jpeg" alt="267baa636fd682717e63a956def32ec5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4b425f5665648fd64d2371a8e70aa4b7.jpeg" alt="4b425f5665648fd64d2371a8e70aa4b7"></p><h6 id="3-多拦截器"><a href="#3-多拦截器" class="headerlink" title="3.多拦截器"></a>3.多拦截器</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4698693771084332a51d147c5cdd2e7.jpeg" alt="c4698693771084332a51d147c5cdd2e7"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>) &#123;<br>        <span class="hljs-comment">// 注册第一个拦截器，拦截所有路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>);<br><br>        <span class="hljs-comment">// 注册第二个拦截器，拦截所有路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>addInterceptor()</code> 方法按顺序注册拦截器，Spring MVC 将按照注册顺序执行这些拦截器的 <code>preHandle()</code> 方法，<code>postHandle()</code> 和 <code>afterCompletion()</code> 方法则按相反顺序执行。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95d7648e9ae71b1f8e4a5ccf424adb04.jpeg" alt="95d7648e9ae71b1f8e4a5ccf424adb04"></p><h6 id="4-基于AOP实现拦截器"><a href="#4-基于AOP实现拦截器" class="headerlink" title="4.基于AOP实现拦截器"></a>4.基于AOP实现拦截器</h6><p><strong>MVC 拦截器</strong>：基于 <code>HandlerInterceptor</code> 接口，可以在处理 HTTP 请求的生命周期的特定点执行代码。适用于 Web 层的请求预处理和后处理。</p><p>使用 AOP 实现类似的拦截功能，可以在控制器方法执行前后插入一些通用的逻辑。使用 AOP 可以更灵活地选择何时何地应用这些逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>   <br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">annotatedMethod</span><span class="hljs-params">(CustomAnnotation customAnnotation)</span> &#123;&#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">   这个切入点表达式 `@annotation(customAnnotation)` 的作用是匹配所有被 `@CustomAnnotation` 注解标记的方法。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">`@annotation(customAnnotation)` 是 AspectJ 提供的一个语法，用来匹配方法级别的注解。这里，`customAnnotation` 是一个参数，它表示目标方法上使用的 `@CustomAnnotation`。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">同时`annotatedMethod` f方法的主要用处是可以在通知（Advice）方法中使用一个更清晰、易读的命名标识来引用切入点。*/</span><br><br>    <span class="hljs-comment">// 在控制器中的任何方法执行之前执行</span><br>    <span class="hljs-meta">@Before(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeControllerMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之前执行的逻辑&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在控制器方法执行之后执行</span><br>    <span class="hljs-meta">@After(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterControllerMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之后执行的逻辑&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知，可以在方法执行前后都进行拦截</span><br>    <span class="hljs-meta">@Around(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundControllerMethod</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之前执行的逻辑&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();  <span class="hljs-comment">// 执行目标方法</span><br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之后执行的逻辑&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">public <span class="hljs-keyword">@interface</span> CustomAnnotation &#123;<br>    String <span class="hljs-built_in">value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="WebApplicationContext探究"><a href="#WebApplicationContext探究" class="headerlink" title="WebApplicationContext探究"></a>WebApplicationContext探究</h4><blockquote><p><code>WebApplicationContext</code> 是一个容器类，它是 Spring 框架中专门用于 Web 应用程序的应用上下文（<code>ApplicationContext</code>）接口的扩展。</p><h3 id="什么是-WebApplicationContext？"><a href="#什么是-WebApplicationContext？" class="headerlink" title="什么是 WebApplicationContext？"></a>什么是 <code>WebApplicationContext</code>？</h3><p><code>WebApplicationContext</code> 是 Spring 框架中的一个接口，它继承了 <code>ApplicationContext</code> 接口，并添加了特定于 Web 应用程序的功能。它提供了一些额外的方法和功能来处理 Web 应用程序的特定需求，例如管理与 Servlet、过滤器和监听器相关的 Web 组件。</p><h3 id="WebApplicationContext-的特点"><a href="#WebApplicationContext-的特点" class="headerlink" title="WebApplicationContext 的特点"></a><code>WebApplicationContext</code> 的特点</h3><ol><li><p>**扩展 <code>ApplicationContext</code>**：</p><ul><li><code>WebApplicationContext</code> 继承自 <code>ApplicationContext</code>，而 <code>ApplicationContext</code> 是 Spring 的核心容器接口，用于管理和配置应用程序中的 bean。<code>ApplicationContext</code> 提供了 Spring IoC 容器的基本功能，如依赖注入、事件发布、国际化支持等。</li><li><code>WebApplicationContext</code> 是 <code>ApplicationContext</code> 的一个特化版本，增加了与 Web 环境相关的特性。</li></ul></li><li><p><strong>面向 Web 应用程序</strong>：</p><ul><li><pre><code class="hljs">WebApplicationContext</code></pre><p> 是为 Web 应用程序设计的，它能够处理 Web 相关的上下文信息，例如：</p><ul><li><strong>ServletContext</strong>：<code>WebApplicationContext</code> 可以访问 Servlet 容器的 <code>ServletContext</code>，这使它能够与 Servlet API 集成，并提供与 Web 容器的交互能力。</li><li><strong>会话作用域和请求作用域</strong>：<code>WebApplicationContext</code> 支持 Web 特定的作用域（如会话作用域和请求作用域），这对于 Web 应用程序非常有用。</li></ul></li></ul></li><li><p><strong>Web 应用程序的根上下文</strong>：</p><ul><li>在典型的 Spring Web 应用程序中，<code>WebApplicationContext</code> 通常是应用程序的根上下文（Root Context），它在 Web 应用程序启动时由 Spring 的前端控制器 <code>DispatcherServlet</code> 或 <code>ContextLoaderListener</code> 创建。</li><li>它管理 Web 应用程序的所有 bean，包括控制器、服务层组件、数据访问层组件等。</li></ul></li></ol><h3 id="WebApplicationContext-的具体实现类"><a href="#WebApplicationContext-的具体实现类" class="headerlink" title="WebApplicationContext 的具体实现类"></a><code>WebApplicationContext</code> 的具体实现类</h3><p>在 Spring 中，<code>WebApplicationContext</code> 有多个实现类，其中最常用的是：</p><ol><li><p><code>XmlWebApplicationContext</code></p><p>：</p><ul><li>基于 XML 配置文件的 <code>WebApplicationContext</code> 实现，它从指定的 XML 文件中加载 bean 定义。</li></ul></li><li><p><code>AnnotationConfigWebApplicationContext</code></p><p>：</p><ul><li>基于 Java 注解的 <code>WebApplicationContext</code> 实现，通常用于配置类（使用 <code>@Configuration</code> 注解的类）而非 XML 文件的方式进行 bean 定义的加载。</li></ul></li><li><p><code>GenericWebApplicationContext</code></p><p>：</p><ul><li>通用的 <code>WebApplicationContext</code> 实现，它既可以从 XML 文件加载配置，也可以使用注解或其他方式加载配置。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>WebApplicationContext</code> 是一个面向 Web 的 Spring 容器类，它继承了 <code>ApplicationContext</code> 并扩展了与 Web 相关的功能。它能够管理 Web 应用程序的 bean，处理与 Web 环境相关的上下文信息，并与 Servlet 容器紧密集成。因此，<code>WebApplicationContext</code> 是 Spring Web 应用程序中非常重要的容器类。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构概论 01</title>
    <link href="/2024/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构概论"><a href="#数据结构概论" class="headerlink" title="数据结构概论"></a>数据结构概论</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章-概述"></a>第一章-概述</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><h5 id="1-1-1-什么是数据结构"><a href="#1-1-1-什么是数据结构" class="headerlink" title="1.1.1:什么是数据结构"></a>1.1.1:什么是数据结构</h5><blockquote><h4 id="数据与信息"><a href="#数据与信息" class="headerlink" title="数据与信息"></a>数据与信息</h4><ul><li><strong>数据</strong>是信息的载体，可以被计算机识别、存储和加工处理。数据包括文字、表格、图像等形式。</li><li><strong>信息</strong>是数据的内涵，即数据所表达的意义。例如，成绩单中某次考试的成绩是数据，但平均分就是信息。</li></ul><h4 id="数据元素和数据项"><a href="#数据元素和数据项" class="headerlink" title="数据元素和数据项"></a>数据元素和数据项</h4><ul><li><strong>数据元素</strong>是数据的基本单位（有时称为元素、结点或记录等），通常作为一个整体进行处理。例如，一个学生的成绩单包含了若干个数据元素。</li><li><strong>数据对象</strong>是具有相同类型的数据元素的集合。</li><li><strong>数据项</strong>是数据元素的不可分割的最小标识单元。例如，一个学生记录可以包含姓名、学号等数据项。</li></ul><h4 id="数据的结构"><a href="#数据的结构" class="headerlink" title="数据的结构"></a>数据的结构</h4><ul><li>数据的结构化表示方式便于数据的存储和处理。在数据结构中，除非特别指明，数据通常都是数据对象。</li></ul><p>：</p><h3 id="数据结构的定义和内容"><a href="#数据结构的定义和内容" class="headerlink" title="数据结构的定义和内容"></a>数据结构的定义和内容</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素不是孤立存在的，而是相互之间通过某种关系连接，形成一个整体结构。数据结构的主要内容包括以下三个方面：</p><ol><li><strong>逻辑结构</strong>：描述数据元素之间的逻辑关系，是数据结构的抽象形式。逻辑结构通常通过图形表示，例如线性结构、树形结构和图结构等。</li><li><strong>存储结构</strong>：也称为“物理结构”或“存储映像”，是将数据的逻辑结构映射到计算机存储器中的形式。数据的存储结构决定了数据在计算机内存中的布局方式，包括顺序存储、链式存储等。</li><li><strong>数据运算</strong>：指的是在数据结构上进行的各种操作，是数据结构的功能体现。例如，常见的数据操作包括查找、插入、删除、排序等。这些操作通常是通过特定的算法在存储结构上实现的。</li></ol></blockquote><h5 id="1-1-2-逻辑结构探究"><a href="#1-1-2-逻辑结构探究" class="headerlink" title="1.1.2 逻辑结构探究"></a>1.1.2 逻辑结构探究</h5><blockquote><h3 id="逻辑结构的定义"><a href="#逻辑结构的定义" class="headerlink" title="逻辑结构的定义"></a>逻辑结构的定义</h3><ul><li><p><strong>逻辑结构</strong>是指数据元素之间的逻辑关系，它表示数据元素之间如何相互关联。逻辑结构不涉及数据在计算机中的存储方式，只描述数据元素之间的关系。</p></li><li><h3 id="逻辑结构的四种类型"><a href="#逻辑结构的四种类型" class="headerlink" title="逻辑结构的四种类型"></a>逻辑结构的四种类型</h3><ol><li><p><strong>集合结构</strong>：所有数据元素之间没有任何关系。</p></li><li><p><strong>线性结构</strong>：所有数据元素之间存在一对一的关系。</p></li><li><p><strong>树形结构</strong>：数据元素之间存在一对多的层次关系。</p></li><li><p><strong>图形结构</strong>（网状结构）：数据元素之间存在多对多的任意关系。</p><h3 id="逻辑结构的表示方法-书中是公式"><a href="#逻辑结构的表示方法-书中是公式" class="headerlink" title="逻辑结构的表示方法-书中是公式"></a>逻辑结构的表示方法-书中是公式</h3><ul><li><p><strong>线性结构（Linear Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间具有一对一的关系，即每个数据元素除了第一个和最后一个之外，都有唯一的前驱和后继。常见的线性结构有数组、链表、栈和队列等。</li><li><strong>特点</strong>：数据按照一定的顺序排成一条直线，每个元素只有一个前驱和一个后继（除第一个和最后一个元素）。</li><li><strong>例子</strong>：数组是一种典型的线性结构，数据元素按顺序存储在内存中，元素之间的关系通过索引来表示。</li></ul><p><strong>树形结构（Tree Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间具有一对多的层次关系。树形结构中，每个元素称为“节点”，顶层节点称为“根节点”，其余节点有且仅有一个父节点，可能有多个子节点。</li><li><strong>特点</strong>：数据以层级形式组织，每个节点有一个父节点和零个或多个子节点，除了根节点外，每个节点只有一个父节点。</li><li><strong>例子</strong>：二叉树是一种常见的树形结构，其中每个节点最多有两个子节点（左子节点和右子节点）。</li></ul><p><strong>图形结构（Graph Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间可以有任意多的关系，数据元素称为“节点”或“顶点”，它们之间的关系称为“边”。</li><li><strong>特点</strong>：数据元素之间的关系不再是简单的一对一或一对多，可以是多对多的关系。图可以是有向的或无向的，有环的或无环的。</li><li><strong>例子</strong>：社交网络中的好友关系可以用图来表示，用户是节点，好友关系是边。</li></ul><p><strong>逻辑表示</strong>：学生按学号从小到大排列，每个学生只有一个前驱和一个后继（除了第一个和最后一个）。这种逻辑表示方式告诉我们数据元素的相对关系和结构。</p><p><strong>物理表示</strong>：在计算机中，可以用一个数组来顺序存储这些学生信息，或者用一个链表来链式存储这些学生信息。</p></li><li><p><strong>逻辑结构图的表示</strong></p></li><li><p>：</p><ul><li>数据逻辑结构可以通过二元组 (D,R)(<em>D</em>,<em>R</em>) 来表示，其中 D<em>D</em> 是数据元素的集合，R<em>R</em> 是数据元素之间的逻辑关系集合。</li></ul></li><li><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf1f08b63104c88f692a527f21308624.png" alt="cf1f08b63104c88f692a527f21308624"></p></li></ul></li></ol></li></ul></blockquote><blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/53667aed05cf29e331afb013cad99845.png" alt="53667aed05cf29e331afb013cad99845"></p></blockquote><h4 id="1-1-3-存储结构探究"><a href="#1-1-3-存储结构探究" class="headerlink" title="1.1.3 存储结构探究"></a>1.1.3 存储结构探究</h4><h6 id="存储结构定义"><a href="#存储结构定义" class="headerlink" title="存储结构定义"></a><strong>存储结构定义</strong></h6><blockquote><ol><li><h6 id="存储结构定义："><a href="#存储结构定义：" class="headerlink" title="存储结构定义："></a><strong>存储结构定义</strong>：</h6><ul><li>数据的存储结构是指数据逻辑结构在计算机存储器中的表示，它也被称为物理结构。</li></ul></li></ol></blockquote><ol><li><blockquote><p><strong>存储结构与逻辑结构的关系</strong>：</p><ul><li>同一种逻辑结构可以设计成多种不同的存储结构。</li><li>在不同的存储结构中，实现相同运算的算法可能会有所不同。</li></ul></blockquote></li><li><blockquote><p><strong>逻辑结构、存储结构和运算之间的关系</strong>：</p><ul><li>逻辑结构通过映射到存储结构，进而实现具体的运算。</li><li>运算定义和运算实现之间存在映射关系，逻辑结构是运算定义的基础，而存储结构是运算实现的基础。</li></ul></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/37a0f47f6721fdf22db0eb82ac7865b2.png" alt="37a0f47f6721fdf22db0eb82ac7865b2"></p><h6 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h6><p><img src="https://majorli.github.io/algo_guide/_images/311_sequence_list.png" alt="../../_images/311_sequence_list.png"></p><p>顺序存储结构通过连续存储单元实现数据的逻辑结构映射，具有存储空间节省和快速随机存取的优点，但同时也存在修改不便的缺点。这种存储方式适用于数据元素数量固定或变动较少的场景。</p><ol><li><strong>顺序存储结构定义</strong>：<ul><li>顺序存储结构是使用一组连续的存储单元来存放所有数据元素，其中逻辑上相邻的元素在物理存储上也是相邻的。</li><li>元素之间的逻辑关系通过存储单元地址的相邻关系隐含表示，即将数据的逻辑结构直接映射到存储结构。</li></ul></li><li><strong>顺序存储结构的实现示例</strong>：<ul><li>以“Score”逻辑结构为例，假设每个元素占用30字节（B），从100号存储单元开始，按低地址到高地址方向存储。</li></ul></li><li><strong>顺序存储结构的优点</strong>：<ul><li><strong>节省存储空间</strong>：分配给数据的存储单元全部用于存放元素值，元素之间的逻辑关系表示不占用额外存储空间。</li><li><strong>随机存取</strong>：可以实现对数据元素的快速随机存取。给定元素的逻辑序号，可以在常量时间内查找到对应的元素值。</li></ul></li><li><strong>随机存取的计算公式</strong>：<ul><li>存储地址计算公式为： LOC(ai)&#x3D;p+(i−1)×k<em>L**OC</em>(<em>a**i</em>)&#x3D;<em>p</em>+(<em>i</em>−1)×<em>k</em></li><li>其中，k<em>k</em> 是每个元素所占的存储单元数，p<em>p</em> 是第一个元素所占存储单元的首地址。</li></ul></li><li><strong>顺序存储结构的缺点</strong>：<ul><li><strong>不便于修改</strong>：在进行元素的插入或删除操作时，可能需要移动一系列元素，这在大规模数据操作时效率较低。</li></ul></li></ol><blockquote><p>ArrayList- Vector CopyOnWriteArrayList</p><p>如上都实现了 <code>List</code> 接口，并具有顺序访问的特点。</p></blockquote><h6 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h6><p><img src="https://majorli.github.io/algo_guide/_images/317_linkedlist.png" alt="../../_images/317_linkedlist.png"></p><ol><li><blockquote><p><strong>链式存储结构定义</strong>：</p><ul><li>链式存储结构不要求所有元素在内存中连续存放，每个节点独立存储，不需要占用一整块连续的存储空间。</li><li>为了表示节点之间的关系，每个节点包含一个或多个指针字段，用于存放相邻节点的存储地址。</li></ul></blockquote></li></ol><blockquote><ol><li><strong>链式存储结构的优点</strong>：<ul><li><strong>便于修改</strong>：在进行插入、删除操作时，只需修改节点的指针域，不需要移动节点本身。</li></ul></li><li><strong>链式存储结构的缺点</strong>：<ul><li><strong>存储空间利用率较低</strong>：分配给数据元素的存储单元中有一部分被用来存放节点之间的逻辑关系。</li><li><strong>不能进行随机存取</strong>：由于逻辑上相邻的节点在存储器中不一定相邻，因此不能对节点进行随机存取。</li></ul></li></ol></blockquote><p>LinkedList  双向链表</p><p>ConcurrentLinkedQueue  线程安全的非阻塞队列 </p><p><strong><code>LinkedBlockingQueue</code></strong> 和 <strong><code>LinkedBlockingDeque</code></strong></p><h6 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h6><ol><li><p><strong>索引存储结构定义</strong>：</p><ul><li>索引存储结构是在存储数据（主数据表）的同时，建立一个附加的索引表。</li><li>索引表中的每一项称为索引项，通常包含关键字和对应的地址。</li></ul></li><li><p><strong>索引项的一般形式</strong>：</p><ul><li>索引项的一般形式为：(关键字, 对应地址)</li><li>索引表中的关键字有序排列（如递增），每个关键字的对应地址指向该关键字记录在数据表中的存储地址。</li></ul></li><li><p><strong>索引存储结构的查找过程</strong>：</p><ul><li>在进行关键字（如学号）查找时，先在索引表中快速查找（因为索引表中按关键字有序排列，可以采用二分查找）到相应的关键字。</li><li>然后通过对应地址在数据表中找到该记录的数据。</li></ul></li><li><p><strong>索引存储结构的优点</strong>：</p><ul><li><strong>查找效率高</strong>：由于索引表中关键字有序排列，可以采用二分查找等高效查找算法。</li></ul></li><li><p><strong>索引存储结构的缺点</strong>：</p><ul><li><strong>增加时间和空间开销</strong>：需要建立索引表，从而增加了存储空间的开销。</li><li><strong>维护成本</strong>：在数据表更新（插入、删除、修改）时，需要同步更新索引表，增加了维护成本。</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2efbc94f98d8f0fe441857b7f84d636d.png" alt="2efbc94f98d8f0fe441857b7f84d636d"></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2022080309560424.jpg" alt="img"></p><p><strong><code>HashMap</code></strong> &#x2F; <strong><code>TreeMap</code></strong>  键可以视作索引，值为实际数据类似</p><h6 id="哈希结构"><a href="#哈希结构" class="headerlink" title="哈希结构"></a>哈希结构</h6><ol><li><p><strong>哈希存储结构定义</strong>：</p><ul><li>哈希存储结构根据元素的关键字来确定其存储地址。</li><li>通过哈希函数 H(key)<em>H</em>(<em>k**ey</em>)（或散列函数）计算关键字对应的函数值，该函数值用作元素的存储地址。</li></ul></li><li><p><strong>哈希函数的选择</strong>：</p><ul><li><p>以学号作为自变量，选择一个合适的哈希函数，例如 h(学号)&#x3D;学号−201201<em>h</em>(学号)&#x3D;学号−201201。</p></li><li></li></ul></li><li><p><strong>哈希存储结构的查找过程</strong>：</p><ul><li>要查找学号为 id<em>i**d</em> 的学生记录，只需计算 h(id)<em>h</em>(<em>i**d</em>)，以它为地址在哈希表中直接找到该学号的学生记录。</li></ul></li><li><p><strong>哈希存储结构的优点</strong>：</p><ul><li><strong>查找速度快</strong>：只要给出待查找节点的关键字，就可以立即计算出对应记录的存储地址。</li><li><strong>存储效率高</strong>：只存储数据元素本身，不存储数据元素之间的逻辑关系。</li></ul></li><li><p><strong>哈希存储结构的缺点</strong>：</p><ul><li><strong>冲突处理</strong>：不同的关键字可能通过哈希函数计算得到相同的地址，需要处理这种“冲突”。</li><li><strong>哈希函数的选择</strong>：选择合适的哈希函数和冲突解决策略是关键。</li></ul></li><li><p><strong>哈希存储结构的应用场合</strong>：</p><ul><li>适用于要求对数据能够进行快速查找、插入的场合。</li></ul></li></ol><p><code>HashMap</code> 和 <code>HashSet</code> 提供了基础的哈希功能；<code>LinkedHashMap</code> 和 <code>LinkedHashSet</code> 在保证哈希效率的同时维护插入顺序；<code>ConcurrentHashMap</code> 提供线程安全的哈希表实现，而 <code>WeakHashMap</code> 和 <code>IdentityHashMap</code> 提供了特定应用场景的支持。</p><h4 id="1-14-数据运算"><a href="#1-14-数据运算" class="headerlink" title="1.14 数据运算"></a>1.14 数据运算</h4><blockquote><ol><li><strong>数据运算的定义</strong>：<ul><li>数据运算是施加于数据的操作，它包括对数据进行的各种处理活动。</li></ul></li><li><strong>运算的两个部分</strong>： <strong>分离思想</strong><ul><li><strong>运算定义</strong>：描述运算的功能和目的，是抽象的描述，不涉及具体的实现细节。</li><li><strong>运算实现</strong>：在特定的数据存储结构上设计算法来实现这些运算，是具体的实现步骤。</li></ul></li></ol></blockquote><h4 id="1-15-数据结构-数据类型-和抽象数据类型"><a href="#1-15-数据结构-数据类型-和抽象数据类型" class="headerlink" title="1.15 数据结构  数据类型 和抽象数据类型"></a>1.15 数据结构  数据类型 和抽象数据类型</h4><h6 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h6><p>数据结构 :带结构的数据元素的集合 包含数据逻辑 存储逻辑 运算运算逻辑</p><h6 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h6><p>数据类型显示或隐式的定义了数据的存储格式 数据范围 允许进行的计算</p><p>1.c++基本数据类型</p><p>省</p><p>2.指针类型</p><p>int * a&#x3D;&b; -&gt;   b(地址)-&gt;123(真实数据)</p><p>int ** &#x3D;&a; 嵌套类-不知道行不行</p><p>3.c++数组类型</p><p>int a[10];</p><p>4.结构体类型</p><p>struct t{</p><p>int a;</p><p>char a;</p><p>}</p><p>集体占的大小还要适配内存对齐-防止缓存失效解决</p><p>5.共用体类型</p><p>省</p><p>6.自定义类型</p><p>typedef struct ttudent{<br>}studtype</p><p>别名 -&gt;根结构体差不多</p><h6 id="3-抽象数据类型"><a href="#3-抽象数据类型" class="headerlink" title="3.抽象数据类型"></a>3.抽象数据类型</h6><p>抽象数据类型是一种数据模型的抽象，描述了数据类型的操作和功能，而不关心其具体实现。ADT提供了一组操作和数学模型，用于定义数据类型的行为和性质。ADT定义时包含了操作的逻辑及功能描述，具体实现则留给程序设计者。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dcc57cf60c33af3dd920d15376ccad4a.png" alt="dcc57cf60c33af3dd920d15376ccad4a"></p><p>ps:说白了就是想像一个结构体出来-但是没有具体实现</p><h4 id="1-1-总结"><a href="#1-1-总结" class="headerlink" title="1.1 总结"></a>1.1 总结</h4><p>概念上的东西，没刷题不知道-但是非常概念的就是-抽象数据类型 数据运算 概述和数据结构</p><h3 id="1-2-算法和算法分析"><a href="#1-2-算法和算法分析" class="headerlink" title="1.2 算法和算法分析"></a>1.2 算法和算法分析</h3><h4 id="1-2-1算法及描述"><a href="#1-2-1算法及描述" class="headerlink" title="1.2.1算法及描述"></a>1.2.1算法及描述</h4><h6 id="1-算法特性"><a href="#1-算法特性" class="headerlink" title="1.算法特性"></a>1.算法特性</h6><p>算法-对特定问题求解步骤的描述</p><p>算法设计满足目标</p><p><strong>正确性</strong>：算法必须能够正确执行其规定的功能和性能要求，这是最重要的标准。</p><p><strong>可使用性</strong>：算法应易于理解和使用，即具有用户友好性。</p><p><strong>可读性</strong>：算法应该便于人的理解，逻辑必须明确、简单、结构良好。</p><p><strong>健壮性</strong>：算法应具备很好的容错能力，即使遇到异常数据，也能处理或防止崩溃。</p><p><strong>高效性与低存储性</strong>：算法应在执行时间和存储空间上高效，对同一问题，算法的效率越高越好，同时要求其存储消耗低。</p><p>算法特性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4a5032bae80dd2445ae8a06cb1ea232e.png" alt="4a5032bae80dd2445ae8a06cb1ea232e"></p><h6 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2.算法描述"></a>2.算法描述</h6><p>算法描述:算法可由多种语言来描述-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7121e96e74080a4416b2c76d17c7908a.png" alt="7121e96e74080a4416b2c76d17c7908a"></p><p>如上-代码-s&#x3D;s+i-&gt;修改是地址的值-栈压得值-可修改call栈外的局部变量-</p><p>ps:前提是s&#x3D;s+1-是对外部指针指向的数据操作-而不是拷贝了一份-(cpp好久没看过了)</p><p>这里应该表面 -算法的输入 输出 是s-同一个吗-不知道，文字太多不想看</p><h4 id="1-2-3算法分析"><a href="#1-2-3算法分析" class="headerlink" title="1.2.3算法分析"></a>1.2.3算法分析</h4><h6 id="1-算法时间复杂度"><a href="#1-算法时间复杂度" class="headerlink" title="1.算法时间复杂度"></a>1.算法时间复杂度</h6><p><strong>时间复杂度</strong>（Time Complexity）是用来估计一个算法运行时间的一个指标，<strong>表示算法执行所需时间相对于输入规模的增长关系。它反映了算法随着输入数据量增大，运行时间增加的情况。</strong></p><p>时间复杂度通常使用大O符号（Big O Notation）表示，如 <code>O(1)</code>、<code>O(n)</code>、<code>O(n^2)</code> 等。大O符号描述了最坏情况下算法的运行时间。</p><p>常见时间复杂度及其含义</p><ol><li><p><strong>O(1) - 常数时间复杂度</strong></p><ul><li><p>算法的执行时间不依赖于输入数据的规模。例如，访问数组中的某个元素。</p></li><li><p>示例：<code>a = array[5]</code> 这个操作总是执行一个步骤，因此时间复杂度是 <code>O(1)</code>。</p></li><li><p>2.<strong>O(n) - 线性时间复杂度</strong></p></li><li><p>算法的执行时间随着输入数据的规模 <code>n</code> 线性增长。也就是说，输入数据翻倍，运行时间也会翻倍。</p></li><li><p>示例：一个简单的 <code>for</code> 循环遍历 <code>n</code> 个元素。</p></li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">python</span>复制代码<span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-variable">n</span>):</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>O(n^2) - 二次时间复杂度</strong></p><ul><li>算法的执行时间与输入规模的平方成正比。通常出现在嵌套循环中，外层和内层都循环 <code>n</code> 次。</li><li>示例：双重嵌套循环遍历二维数组。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python复制代码<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">i</span>, j)<br></code></pre></td></tr></table></figure><p>O(log n) - 对数时间复杂度</p><ul><li>算法的执行时间随着输入数据的规模呈对数增长，通常出现在“二分”算法中，比如二分查找。每次操作将问题规模减半。</li><li>示例：在一个排序数组中查找元素的位置。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LogarithmicTimeExample &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> result = binarySearch(<span class="hljs-keyword">array</span>, target);<br>        <br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Element not found.&quot;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Element found at index: &quot; + result);<br>        &#125;<br>    &#125;<br><br>    // 二分查找实现<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> binarySearch(<span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span>, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-keyword">array</span>.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span>[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span>[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; // 未找到目标元素<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>O(n log n) - 线性对数时间复杂度</strong></p><ul><li><p>常见于高效的排序算法，如快速排序（Quick Sort）和归并排序（Merge Sort）。它的时间复杂度是 <code>n</code> 和 <code>log n</code> 的乘积。</p></li><li><p>示例：归并排序。</p></li><li><pre><code class="hljs">import java.util.Arrays;public class MergeSortExample &#123;    public static void main(String[] args) &#123;        int[] array = &#123;38, 27, 43, 3, 9, 82, 10&#125;;        mergeSort(array, 0, array.length - 1);        System.out.println(&quot;Sorted array: &quot; + Arrays.toString(array));    &#125;    // 归并排序算法    public static void mergeSort(int[] array, int left, int right) &#123;        if (left &lt; right) &#123;            int mid = (left + right) / 2;            mergeSort(array, left, mid); // 递归排序左半部分            mergeSort(array, mid + 1, right); // 递归排序右半部分            merge(array, left, mid, right); // 合并两部分        &#125;    &#125;    // 合并两个子数组的函数    public static void merge(int[] array, int left, int mid, int right) &#123;        int n1 = mid - left + 1;        int n2 = right - mid;        int[] leftArray = new int[n1];        int[] rightArray = new int[n2];        for (int i<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br>**O(<span class="hljs-number">2</span>^<span class="hljs-built_in">n</span>) - 指数时间复杂度**<br><br>- 随着输入规模增加，算法运行时间以指数方式增长。通常出现在解决递归问题（如斐波那契数列）时。<br><br>- 示例：递归计算斐波那契数列。<br><br>- ```<br>  def fibonacci(<span class="hljs-built_in">n</span>)<span class="hljs-symbol">:</span><br>      <span class="hljs-built_in">if</span> <span class="hljs-built_in">n</span> &lt;= <span class="hljs-symbol">1:</span><br>          return <span class="hljs-built_in">n</span><br>      el<span class="hljs-symbol">se:</span><br>          return fibonacci(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + fibonacci(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>)<br>  <br></code></pre></td></tr></table></figure>  **O(n!) - 阶乘时间复杂度**  最糟糕的时间复杂度，通常出现在解决组合问题时，如全排列生成或旅行商问题（TSP）。  示例：生成一个数组的所有排列。</code></pre></li></ul><p>如何计算时间复杂度</p><ol><li><strong>分析算法的基本操作</strong>：找出算法中最常执行的基本操作（如循环中的一次迭代）。</li><li><strong>确定基本操作的执行次数</strong>：计算该操作在最坏情况下的执行次数。</li><li><strong>去掉低阶项和常数</strong>：只关注增长速度最快的项，并忽略常数因子（如 <code>5n</code> 和 <code>n</code> 都视为 <code>O(n)</code>）。</li></ol><p>总结 </p><p><strong>O(1)</strong> - 常数时间复杂度</p><p><strong>O(log n)</strong> - 对数时间复杂度</p><p><strong>O(n)</strong> - 线性时间复杂度</p><p><strong>O(n log n)</strong> - 线性对数时间复杂度</p><p><strong>O(n^2)</strong> - 二次时间复杂度</p><p><strong>O(n^3)</strong> - 三次时间复杂度</p><p><strong>O(2^n)</strong> - 指数时间复杂度</p><p><strong>O(n!)</strong> - 阶乘时间复杂度</p><p>案例:<a href="https://www.cnblogs.com/Agtw/p/17173051.html">https://www.cnblogs.com/Agtw/p/17173051.html</a> -</p><h6 id="2-算法空间复杂度"><a href="#2-算法空间复杂度" class="headerlink" title="2.算法空间复杂度"></a>2.算法空间复杂度</h6><p>1.空间复杂度<br>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。空间复杂度不是程序占用<br>了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计<br>算规则基本跟实践复杂度类似，也使用大O渐进表示法.-<br>就是一段函数在堆栈中开辟的堆栈大小</p><p><strong>空间复杂度衡量了算法所需的额外内存空间</strong>，帮助我们理解和优化程序的内存使用。</p><p>选择合适的算法时，既要考虑时间复杂度，也要考虑空间复杂度，特别是在处理大规模数据或资源有限的情况下。</p><p><strong>O(1)</strong> - 常数空间复杂度</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan">public <span class="hljs-type">int</span> findMax(<span class="hljs-type">int</span>[] <span class="hljs-type">array</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-type">array</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// O(1) 空间复杂度，仅使用一个额外变量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-type">array</span>.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">array</span>[i] &gt; <span class="hljs-built_in">max</span>) &#123;<br>            <span class="hljs-built_in">max</span> = <span class="hljs-type">array</span>[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>O(log n)</strong> - 对数空间复杂度</p><p><strong>O(n)</strong> - 线性空间复杂度\</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title function_ invoke__">copyArray</span>(<span class="hljs-keyword">int</span>[] <span class="hljs-keyword">array</span>) &#123;<br>    <span class="hljs-keyword">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">array</span>.length]; <span class="hljs-comment">// O(n) 空间复杂度，因需分配与输入规模相同的空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">array</span>.length; i++) &#123;<br>        newArray[i] = <span class="hljs-keyword">array</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArray;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>O(n log n)</strong> - 线性对数空间复杂度</p><p><strong>O(n^2)</strong> - 二次空间复杂度</p><p><strong>O(n^3)</strong> - 三次空间复杂度</p><p><strong>O(2^n)</strong> - 指数空间复杂度</p><p><strong>O(n!)</strong> - 阶乘空间复杂度</p><h3 id="1-3-数据程序结构设计"><a href="#1-3-数据程序结构设计" class="headerlink" title="1.3 数据程序结构设计"></a>1.3 数据程序结构设计</h3><h4 id="1-3-1-数据结构程序设计步骤"><a href="#1-3-1-数据结构程序设计步骤" class="headerlink" title="1.3.1 数据结构程序设计步骤"></a>1.3.1 数据结构程序设计步骤</h4><ol><li><strong>设计数据结构程序的步骤</strong>：<ul><li><strong>第一步</strong>：分析问题的数据和求解功能，使用抽象数据类型（ADT）来描述问题，包括数据逻辑结构和运算定义。</li><li><strong>第二步</strong>：设计逻辑结构对应的存储结构。</li><li><strong>第三步</strong>：在选定的存储结构上设计实现运算定义的算法。</li></ul></li></ol><h4 id="1-3-2-应用程序结构"><a href="#1-3-2-应用程序结构" class="headerlink" title="1.3.2 应用程序结构"></a>1.3.2 应用程序结构</h4><p>![a1b9aa105652fe4d7386574ca6429d89](G:\360MoveData\Users\nixg\Documents\Tencent Files\1332425260\nt_qq\nt_data\Pic\2024-09\Ori\a1b9aa105652fe4d7386574ca6429d89.png)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些文件提供了关于数据结构、算法以及它们在程序设计中应用的全面概述。以下是核心内容的整理：</p><ol><li><p><strong>数据结构的定义</strong>：</p><ul><li>数据结构是存在特定关系的数据元素集合，包括数据项和数据元素。</li></ul></li><li><p><strong>数据结构的组成</strong>：</p><ul><li><strong>包括数据逻辑结构、数据存储结构和数据运算。</strong> +1</li></ul></li><li><p><strong>数据逻辑结构的分类</strong>：</p><ul><li>集合、线性结构、树状结构和图形结构，其中树状和图形结构是非线性结构。</li></ul></li><li><p><strong>数据存储结构的类型</strong>：</p><ul><li>顺序存储、链式存储、索引存储和哈希存储。 +1 *</li></ul></li><li><p><strong>存储结构的设计</strong>：</p><ul><li>存储结构设计需考虑存储元素及其逻辑关系，同一逻辑结构可对应多个存储结构。</li></ul></li><li><p><strong>抽象数据类型</strong>：</p><ul><li>由数据逻辑结构和抽象运算组成。</li></ul></li><li><p><strong>算法的定义</strong>：</p><ul><li>算法是特定问题求解步骤的描述，具有有限性、确定性、可行性、输入性和输出性。</li></ul></li><li><p><strong>算法描述</strong>：</p><ul><li>算法通常用C&#x2F;C++函数的形式描述，复杂算法可能需要多个函数。</li></ul></li><li><p><strong>算法设计考虑</strong>：</p><ul><li>明确算法的输入和输出，通常作为函数的形参和返回值。</li></ul></li><li><p><strong>算法条件的有效性</strong>：</p><ul><li>条件有效时返回1（真），否则返回0（假）。</li></ul></li><li><p><strong>算法分析</strong>：</p><ul><li>包括时间复杂度和空间复杂度分析，目的是提高算法效率。</li></ul></li><li><p><strong>时间复杂度分析</strong>：</p><ul><li>选取基本运算，求其频度，取最高阶并置系数为1。</li></ul></li><li><p><strong>存储结构与算法的关系</strong>：</p><ul><li>良好的存储结构可以提高算法效率。</li></ul></li><li><p><strong>求解问题的步骤</strong>：</p><ul><li>建立抽象数据类型，设计合理的存储结构，在此基础上设计高效算法。</li></ul></li></ol><hr><hr><hr><hr><p>本文大部分内容来自数据结构 数据结构简明教程(第2版)</p><p>由本人经过gdp润色后+加上自己理解所抄录笔记-</p><hr><hr><p>第一章算是润色把 自我感觉有用的就是1</p><p>.数据结构的定义和组成</p><p>逻辑结构+存储结构</p><p>算法-算法的五要素 算法时间复杂度和空间复杂度</p><p>这些内容以前学比特数据结构1h学完</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-双向链表探究</title>
    <link href="/2024/09/12/data%20structure/%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E4%B8%8B/"/>
    <url>/2024/09/12/data%20structure/%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表-下"><a href="#线性表-下" class="headerlink" title="线性表 下"></a>线性表 下</h1><h3 id="双线性表链表和循环双链表"><a href="#双线性表链表和循环双链表" class="headerlink" title="双线性表链表和循环双链表"></a>双线性表链表和循环双链表</h3><h5 id="2-4-1双链表"><a href="#2-4-1双链表" class="headerlink" title="2.4.1双链表"></a>2.4.1双链表</h5><p><strong>算法不同的只有插入和删除</strong></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">双链表中用两个指针表示结点间的逻辑关系。<br>指向其前驱结点的指针域<span class="hljs-built_in">prior</span>。<br>指向其后继结点的指针域<span class="hljs-built_in">next</span>。<br><br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">T9 ypedef <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span><br>&#123;  ElemType data;<span class="hljs-comment">//数据域</span><br>   <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span> *prior,*next;<span class="hljs-comment">//分别指向前驱结点</span><br><span class="hljs-comment">//和后继结点的指针</span><br>&#125; DLinkNode;<span class="hljs-comment">//双链表结点类型</span><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c573523b45ca172d7da989dc240d1574.png" alt="c573523b45ca172d7da989dc240d1574"></p><p><strong>双链表基本运算算法</strong></p><h6 id="1-初始化线性表运算算法"><a href="#1-初始化线性表运算算法" class="headerlink" title="1.初始化线性表运算算法"></a>1.<strong>初始化线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">创建一个空的双链表，它只有一个头结点，由<span class="hljs-type">L</span>指向它，该结点的next域和prior域均为空，<span class="hljs-class"><span class="hljs-keyword">data</span>域未设定任何值。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(DLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  L=(DLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DLinkNode));  <br><span class="hljs-comment">//创建头结点L</span><br>   L-&gt;prior=L-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法"><a href="#2-销毁线性表运算算法" class="headerlink" title="2.销毁线性表运算算法"></a>2.<strong>销毁线性表运算算法</strong></h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">销毁一个双链表中的所有结点的算法思路与单链表的销毁算法相同。 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(DLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  DLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>   &#123;<span class="hljs-built_in">free</span>(pre);<br>pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-求线性表长度运算算法"><a href="#3-求线性表长度运算算法" class="headerlink" title="3.求线性表长度运算算法"></a>3.<strong>求线性表长度运算算法</strong></h6><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> GetLength(DLinkNode *L)<br>&#123;  <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//p指向第一个数据结点</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span>)<br>   &#123;i++;<span class="hljs-comment">//i累加数据结点个数</span><br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法"><a href="#4-求线性表中第i个元素运算算法" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(DLinkNode *L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L;<span class="hljs-comment">//p指向头结点，计数器j置为0</span><br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i)<br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;e=p-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//找到后返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法"><a href="#5-按值查找运算算法" class="headerlink" title="5.按值查找运算算法"></a><strong>5.按值查找运算算法</strong></h6><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> Locate(DLinkNode *L,ElemType e)<br>&#123;  DLinkNode *p=L-&gt;<span class="hljs-keyword">next</span>;<br>   <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<span class="hljs-comment">//p指向第一个数据结点，i置为其序号1</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span> &amp;&amp; p-&gt;data!=e)<br>   &#123;p=p-&gt;<span class="hljs-keyword">next</span>;<br>i++;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//找到后返回其序号</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>6.<strong>插入元素运算算法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">先在双链表中查找到第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，若成功找到该结点（由<span class="hljs-selector-tag">p</span>所指向），创建一个以<span class="hljs-attribute">x</span>为值的新结点s，将s结点插入到<span class="hljs-selector-tag">p</span>之后即可。<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd8d02c1e5b1665943a48ad7fb2100b9.png" alt="dd8d02c1e5b1665943a48ad7fb2100b9"></p><p>若插入节点为i位置 需要修改i内存的前 后指针</p><p>同时i-1位置的next  i+1的前置  prior</p><p>需要修改四个位置-找到2个内存地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsElem</span><span class="hljs-params">(DLinkNode *&amp;L,ElemType x,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)<span class="hljs-comment">//查找第i-1个结点p</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<span class="hljs-comment">////找到了需要修改的节点的位置 </span><br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;<br>    s=(DLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DLinkNode));<br>s-&gt;data=x;<span class="hljs-comment">//创建一个存放元素x的新结点</span><br>s-&gt;next=p-&gt;next;<span class="hljs-comment">//对应插入操作的步骤①</span><br><span class="hljs-keyword">if</span> (p-&gt;next!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//对应插入操作的步骤②</span><br>　　p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<span class="hljs-comment">//对应插入操作的步骤③</span><br>p-&gt;next=s;<span class="hljs-comment">//对应插入操作的步骤④</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-删除结点运算算法"><a href="#6-删除结点运算算法" class="headerlink" title="6.删除结点运算算法"></a>6.<strong>删除结点运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">先在双链表中查找到第<span class="hljs-selector-tag">i</span>个结点，若成功找到该结点（由<span class="hljs-selector-tag">p</span>所指向），通过前驱结点和后继结点的指针域改变来删除<span class="hljs-selector-tag">p</span>结点<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922224934131.png" alt="image-20240922224934131"></p><p>假设删除i -i-1的next指向改变 i+1的prior改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">DelElem</span><span class="hljs-params">(DLinkNode *&amp;L,<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//删除结点</span><br>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L,*pre;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=NULL &amp;&amp; j&lt;i)<span class="hljs-comment">//查找第i个结点p</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==NULL) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到第i个结点时返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;pre=p-&gt;prior;<span class="hljs-comment">//pre指向被删结点的前驱结点</span><br><span class="hljs-keyword">if</span> (p-&gt;next!=NULL)<span class="hljs-comment">//从单链表中删除p结点</span><br>　　p-&gt;next-&gt;prior=pre;<br>pre-&gt;next=p-&gt;next;<br>free(p);<span class="hljs-comment">//释放其空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="7-输出线性表运算算法"><a href="#7-输出线性表运算算法" class="headerlink" title="7.输出线性表运算算法"></a>7.<strong>输出线性表运算算法</strong></h6><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DispList(DLinkNode *L)<br>&#123;  DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next;<br>   <span class="hljs-keyword">while</span> (p!=NULL)<br>   &#123;<span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%d &quot;,p-&gt;</span><span class="hljs-keyword">data</span>);<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="整体创建双链表的算法"><a href="#整体创建双链表的算法" class="headerlink" title="整体创建双链表的算法"></a>整体创建双链表的算法</h4><h6 id="1-头插法"><a href="#1-头插法" class="headerlink" title="1.头插法"></a>1.头插法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空双链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>然后将新结点s插入到当前链表的表头上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到双链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateListF</span><span class="hljs-params">(DLinkNode *&amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span><br>&#123;  DLinkNode *s;<span class="hljs-type">int</span> i;<br>   L=(DLinkNode *)malloc(sizeof(DLinkNode));  <span class="hljs-comment">//创建头结点</span><br>   L-&gt;next=NULL;<br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;  s=(DLinkNode *)malloc(sizeof(DLinkNode)); <span class="hljs-comment">//创建新结点</span><br>      s-&gt;data=a[i];<br>      s-&gt;next=L-&gt;next;<span class="hljs-comment">//将s插入到头结点之后</span><br>      s-&gt;prior=L;<br>      <span class="hljs-keyword">if</span> (L-&gt;next!=NULL)<span class="hljs-comment">//若s不是作为尾结点插入</span><br>L-&gt;next-&gt;prior=s;<br>      L-&gt;next=s;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-尾插法"><a href="#2-尾插法" class="headerlink" title="2.尾插法"></a>2.尾插法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空双链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>然后将新结点s插入到当前链表的表尾上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到双链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止。<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateListR</span><span class="hljs-params">(DLinkNode *&amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span><br>&#123;  DLinkNode *s,*tc; <span class="hljs-type">int</span> i;<br>   L=(DLinkNode *)malloc(sizeof(DLinkNode)); <span class="hljs-comment">//创建头结点</span><br>   tc=L;<span class="hljs-comment">//tc始终指向尾结点,开始时指向头结点</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;s=(DLinkNode *)malloc(sizeof(DLinkNode));<span class="hljs-comment">//创建新结点</span><br>s-&gt;data=a[i];<br>tc-&gt;next=s;<span class="hljs-comment">//将s插入tc之后</span><br>s-&gt;prior=tc;<br>tc=s;<br>   &#125;<br>   tc-&gt;next=NULL;<span class="hljs-comment">//尾结点next域置为NULL</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="双链表的算法设计示例"><a href="#双链表的算法设计示例" class="headerlink" title="双链表的算法设计示例"></a><strong>双链表的算法设计示例</strong></h4><h6 id="2-22"><a href="#2-22" class="headerlink" title="2.22"></a>2.22</h6><h6 id="2-18"><a href="#2-18" class="headerlink" title="2.18"></a>2.18</h6><h3 id="2-4-4循环双链表"><a href="#2-4-4循环双链表" class="headerlink" title="2.4.4循环双链表"></a>2.4.4循环双链表</h3><h4 id="了解循环双链表"><a href="#了解循环双链表" class="headerlink" title="了解循环双链表"></a>了解循环双链表</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">与循环单链表一样，也可以使用循环双链表。<br>循环双链表的结点类型与双链表的结点类型相同，也采用前面声明的DLinkNode类型。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/397fa82d4cb7db052147d65dcaea0689.png" alt="397fa82d4cb7db052147d65dcaea0689"></p><h6 id="1-初始化线性表运算算法-1"><a href="#1-初始化线性表运算算法-1" class="headerlink" title="1.初始化线性表运算算法"></a>1.<strong>初始化线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">创建一个空的循环双链表，它只有一个头结点，由<span class="hljs-type">L</span>指向它，该结点的next域和prior域均指向该头结点，<span class="hljs-class"><span class="hljs-keyword">data</span>域未设定任何值</span><br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-function"><span class="hljs-title">InitList</span>(<span class="hljs-variable">DLinkNode</span> *&amp;<span class="hljs-variable">L</span>)</span><br>&#123;  <span class="hljs-variable">L</span>=(<span class="hljs-variable">DLinkNode</span> *)<span class="hljs-function"><span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-variable">DLinkNode</span>));</span><br><span class="hljs-function">   <span class="hljs-variable">L</span>-&gt;<span class="hljs-variable">prior</span>=<span class="hljs-variable">L</span>-&gt;<span class="hljs-variable">next</span>=<span class="hljs-variable">L</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表"><a href="#2-销毁线性表" class="headerlink" title="2.销毁线性表"></a>2.销毁线性表</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(DLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  DLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-built_in">free</span>(pre);<br>pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-求线性表长度运算算法-1"><a href="#3-求线性表长度运算算法-1" class="headerlink" title="3.求线性表长度运算算法"></a>3.<strong>求线性表长度运算算法</strong></h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> GetLength(DLinkNode *L)<span class="hljs-comment">//求表长运算</span><br>&#123;  <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L-&gt;<span class="hljs-keyword">next</span>;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;i++;<br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法-1"><a href="#4-求线性表中第i个元素运算算法-1" class="headerlink" title="4.**求线性表中第i个元素运算算法"></a>4.**求线性表中第i个元素运算算法</h6><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> GetElem(DLinkNode *L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)<br>&#123;  <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>   DLinkNode *p=L-&gt;next;<span class="hljs-comment">//p指向第一个数据结点，j置为1</span><br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;e=p-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//找到后返回1</span><br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法-1"><a href="#5-按值查找运算算法-1" class="headerlink" title="5.按值查找运算算法"></a>5.<strong>按值查找运算算法</strong></h6><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> Locate(DLinkNode *L,ElemType x)<br>&#123;  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>   DLinkNode *p=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; p-&gt;data!=x)<br>            <span class="hljs-comment">//从第1个结点开始查找data域为x的结点</span><br>   &#123;p=p-&gt;next;<br>i++;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-插入元素运算算法"><a href="#6-插入元素运算算法" class="headerlink" title="6.插入元素运算算法"></a>6.<strong>插入元素运算算法</strong></h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">先在循环双链表L中查找第i个结点<span class="hljs-keyword">p</span>及其前驱结点<span class="hljs-keyword">pre</span>，用<span class="hljs-keyword">j</span>记录<span class="hljs-keyword">p</span>结点的序号。<br>当<span class="hljs-keyword">p</span>==L且i&gt;<span class="hljs-keyword">j</span>+<span class="hljs-number">1</span>时表示i参数错误（如循环双链表中只有<span class="hljs-number">3</span>个结点，当i&gt;<span class="hljs-number">4</span>时出现这种错误）。<br>当成功找到<span class="hljs-keyword">pre</span>结点后，创建data域为<span class="hljs-keyword">x</span>的结点s。<br>在<span class="hljs-keyword">pre</span>结点之后插入s结点<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">int InsElem(DLinkNode *&amp;L,ElemType x,int i)<br>&#123;  int j=<span class="hljs-number">0</span>;<br>   DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *pre=L,*p=pre-&gt;</span>next,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i-<span class="hljs-number">1</span>)<span class="hljs-comment">//查找第i个结点p和其前驱结点pre</span><br>   &#123;j++;<br><span class="hljs-function"><span class="hljs-title">pre</span>=p; p=p-&gt;</span>next;<span class="hljs-comment">//pre、p同步后移一个结点</span><br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L &amp;&amp; i&gt;j+<span class="hljs-number">1</span>) return <span class="hljs-number">0</span>;  <span class="hljs-comment">//参数i&gt;n+1时错误返回0</span><br>   <span class="hljs-keyword">else</span><span class="hljs-comment">//成功查找到p结点的前驱结点pre</span><br>   &#123;s=(DLinkNode *)malloc(sizeof(DLinkNode));<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-keyword">data</span>=x;<span class="hljs-comment">//创建新结点s用于存放元素x</span><br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prior=s;<span class="hljs-comment">//将s结点插入到pre结点之后</span><br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=pre-&gt;</span>next;<br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span>next=s;<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span>prior=pre;<br>return <span class="hljs-number">1</span>;<span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="7-删除元素运算算法"><a href="#7-删除元素运算算法" class="headerlink" title="7.删除元素运算算法"></a>7.<strong>删除元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">先在循环双链表L中查找第<span class="hljs-selector-tag">i</span>个结点<span class="hljs-selector-tag">p</span>，若成功找到后通过其前驱结点pre将<span class="hljs-selector-tag">p</span>结点删除。 <br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">int DelElem(DLinkNode *&amp;L,int i) <span class="hljs-comment">//删除结点算法</span><br>&#123;  int j=<span class="hljs-number">1</span>;<br>   DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next,*pre;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-function"><span class="hljs-title">if</span> (L-&gt;</span>next==L) return <span class="hljs-number">0</span>;<span class="hljs-comment">//空循环双链表不能删除，返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<span class="hljs-comment">//查找第i个结点p</span><br>   &#123;j++;<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) return <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到第i个结点返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;<span class="hljs-function"><span class="hljs-title">pre</span>=p-&gt;</span>prior;<span class="hljs-comment">//pre指向被删结点的前驱结点</span><br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prior=pre;<br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=p-&gt;</span>next;<br>free(p);<span class="hljs-comment">//释放其空间</span><br>return <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="8-输出线性表运算算法"><a href="#8-输出线性表运算算法" class="headerlink" title="8.输出线性表运算算法"></a>8.<strong>输出线性表运算算法</strong></h6><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DispList(DLinkNode *L)<br>&#123;  DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%d &quot;,p-&gt;</span><span class="hljs-keyword">data</span>);<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="循环双链表的算法设计示例"><a href="#循环双链表的算法设计示例" class="headerlink" title="循环双链表的算法设计示例"></a><strong>循环双链表的算法设计示例</strong></h4><h6 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h6><h6 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h6><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h6 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">　当通过分析确定了求解问题中数据逻辑结构为线性关系时，设计线性表应用程序的一般步骤如下：<br>　　（1）根据求解功能的特点设计相应的存储结构。<br>　　（2）设计相应的基本运算算法。<br>　　（3）设计求解问题的主程序。<br><br></code></pre></td></tr></table></figure><h6 id="2-顺序存储和线性存储区别"><a href="#2-顺序存储和线性存储区别" class="headerlink" title="2.顺序存储和线性存储区别"></a>2.顺序存储和线性存储区别</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9a2f7bc0ba094ad50f1764926b9b59c.png" alt="c9a2f7bc0ba094ad50f1764926b9b59c"></p><h1 id="java线性结构探究"><a href="#java线性结构探究" class="headerlink" title="java线性结构探究"></a>java线性结构探究</h1><h4 id="顺序存储结构的代表："><a href="#顺序存储结构的代表：" class="headerlink" title="顺序存储结构的代表："></a><strong>顺序存储结构的代表：</strong></h4><ul><li>数组（Array）   在 Java 中，数组是一种基础的顺序存储结构，元素连续存储在内存中。</li><li>ArrayList     <code>ArrayList</code> 是 Java 中基于数组实现的动态数组，容量可以根据需要自动扩展。</li><li>String     java 中的 <code>String</code> 本质上是一个字符数组，它也是顺序存储的经典例子。</li><li>Vector     <code>Vector</code> 和 <code>ArrayList</code> 类似，但它是线程安全的。它内部也是基于数组实现的。</li><li>Stack       Java 中的 <code>Stack</code> 是基于 <code>Vector</code> 实现的，元素按顺序存储，具有先进后出的特点。</li></ul><h4 id="链式存储结构的代表："><a href="#链式存储结构的代表：" class="headerlink" title="链式存储结构的代表："></a><strong>链式存储结构的代表：</strong></h4><ul><li>LinkedList       <code>LinkedList</code> 是 Java 中的双向链表，节点通过指针相互链接。</li><li>HashMap 中的链表         <code>HashMap</code> 和 <code>HashTable</code> 的底层实现之一是链表，在发生哈希冲突时，将多个冲突的键值对存储在链表中。 </li><li>Queue         Java 中的 <code>LinkedList</code> 也可以用作队列，队列是先进先出（FIFO）的数据结构。</li><li>PriorityQueue       <code>PriorityQueue</code> 是一种特殊的队列，元素按优先级排序，而不是按插入顺序存储。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mybatis框架</title>
    <link href="/2024/09/11/mybits/"/>
    <url>/2024/09/11/mybits/</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis框架"><a href="#mybatis框架" class="headerlink" title="mybatis框架"></a>mybatis框架</h1><p>ps：mybits-&gt;mybatis-&gt;本人以前未在意 后续才发现一直拼错了</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Mybits.png" alt="Mybits"></p><h1 id="Mybits"><a href="#Mybits" class="headerlink" title="Mybits"></a>Mybits</h1><h4 id="了解mybits"><a href="#了解mybits" class="headerlink" title="了解mybits"></a>了解mybits</h4><blockquote><p>“MyBatis” 是一个用于 Java 的持久层框架，它简化了数据库访问的过程。其主要作用包括：</p><ol><li><strong>简化数据库操作</strong>：MyBatis 可以通过 XML 或注解的方式，将 SQL 语句直接写在代码中，避免了使用传统 JDBC 时需要编写大量重复的代码，使得数据库操作更加简洁。</li><li><strong>灵活的 SQL 映射</strong>：MyBatis 允许开发人员编写自定义的 SQL 语句，然后将其与 Java 对象映射。这种方式提供了高度的灵活性，特别适用于复杂的查询操作。</li><li><strong>自动映射结果集</strong>：MyBatis 能够将 SQL 查询的结果集自动映射到 Java 对象中，这样开发者不需要手动解析 ResultSet，大大简化了开发过程。</li><li><strong>动态 SQL 支持</strong>：MyBatis 提供了一种动态 SQL 的能力，通过标签（如 <code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code> 等）来生成动态 SQL 语句，满足各种复杂的查询需求。</li></ol><p>MyBatis 可以进行数据库操作的原因是，它封装了 <strong>JDBC</strong> 操作，将 SQL 查询的执行与结果的处理自动化，并且与 Java 应用程序的对象模型无缝集成。这使得开发人员可以专注于业务逻辑，而不需要关心底层的数据库操作细节。</p></blockquote><h4 id="mybits原理"><a href="#mybits原理" class="headerlink" title="mybits原理"></a>mybits原理</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6daa7e673d972cdd3a904b3bc10d63ee.png" alt="6daa7e673d972cdd3a904b3bc10d63ee"></p><blockquote><p><strong>MyBatis 配置文件</strong>：</p><ul><li><code>SqlMapConfig.xml</code> 是 MyBatis 的全局配置文件，用于配置 MyBatis 的运行环境等信息。</li><li><code>mapper.xml</code> 是用于 SQL 语句和对象映射的文件，这些文件配置了操作数据库的 SQL 语句，需要在 <code>SqlMapConfig.xml</code> 中加载这些文件。</li></ul></blockquote><blockquote><p><strong>通过 MyBatis 环境配置创建 SqlSessionFactory（会话工厂）</strong>：</p><ul><li>通过 MyBatis 的环境配置信息构造一个 <code>SqlSessionFactory</code>，它用于创建会话（<code>SqlSession</code>）实例。</li></ul></blockquote><blockquote><p><strong>会话（SqlSession）的作用</strong>：</p><ul><li>由会话工厂创建的 <code>SqlSession</code> 用于执行数据库操作，开发者在代码中使用 <code>SqlSession</code> 对象来执行 SQL 语句。</li></ul></blockquote><blockquote><p><strong>Executor 执行器</strong>：</p><ul><li>MyBatis 底层定义了 <code>Executor</code> 执行器接口，负责接收并执行 SQL 语句，有两个实现：一个是批量执行器（Batch Executor），一个是缓存执行器（Caching Executor）。</li></ul></blockquote><blockquote><p><strong>Mapped Statement</strong>：-mapper</p><ul><li><code>Mapped Statement</code> 是 MyBatis 底层封装的对象，包含了 MyBatis 配置信息、SQL 映射信息等。</li><li>在 <code>mapper.xml</code> 文件中，每个 SQL 语句对应一个 <code>Mapped Statement</code> 对象，SQL 的 <code>id</code> 对应 Mapped Statement 的 <code>id</code>。</li></ul></blockquote><blockquote><p><strong>输入参数映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输入参数进行定义，包括 <code>HashMap</code>、基本类型、POJO（普通的 Java 对象）。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 前将输入的 Java 对象映射为 SQL 中的参数，类似于 JDBC 编程中 <code>PreparedStatement</code> 的设定参数的过程。</li></ul></blockquote><blockquote><p><strong>输出结果映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输出结果进行定义，包括 <code>HashMap</code>、基本类型、POJO。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 后将输出结果映射至 Java 对象，类似于 JDBC 编程中结果集（<code>ResultSet</code>）的解析处理过程。</li></ul></blockquote><h4 id="Mybits入门"><a href="#Mybits入门" class="headerlink" title="Mybits入门"></a>Mybits入门</h4><h6 id="1-mybits使用"><a href="#1-mybits使用" class="headerlink" title="1.mybits使用"></a>1.mybits使用</h6><p>1.创建工程<br>2.导入依赖<br>3.创建配置文件</p><p>以下是一个 MyBatis 使用案例，包括配置文件 <code>mybatis-config.xml</code>、映射文件 <code>UserMapper.xml</code>、实体类 <code>User</code>、映射接口 <code>UserMapper</code>，以及一个使用 MyBatis 的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;!DOCTYPE configuration<br>  PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br>  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;<br>&lt;configuration&gt;<br>  &lt;!-- 环境配置 --&gt;<br>  &lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>    &lt;environment id=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>      &lt;!-- 使用 JDBC 事务管理器 --&gt;<br>      &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span> /&gt;<br>      &lt;!-- 配置数据源 --&gt;<br>      &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb?useSSL=false&amp;serverTimezone=UTC&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;root&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;password&quot;</span> /&gt;<br>      &lt;/dataSource&gt;<br>    &lt;/environment&gt;<br>  &lt;/environments&gt;<br>  <br>  &lt;!-- 指定映射文件 --&gt;<br>  &lt;mappers&gt;<br>    &lt;mapper resource=<span class="hljs-string">&quot;com/example/mapper/UserMapper.xml&quot;</span> /&gt;<br>  &lt;/mappers&gt;<br>&lt;/configuration&gt;<br><br></code></pre></td></tr></table></figure><p> 映射文件 <code>UserMapper.xml</code></p><p>这个文件包含 SQL 语句和 Java 方法的映射。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="language-xml">  ///对应路径映射</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="language-xml">///</span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 插入用户 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="language-xml">    INSERT INTO user (name, age) VALUES (#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">, #</span><span class="hljs-template-variable">&#123;age&#125;</span><span class="language-xml">)</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>映射接口 <code>UserMapper</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//会生成代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserMapper</span> &#123;<br>    <span class="hljs-built_in">void</span> insertUser(User user);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程</p><p><strong>配置加载</strong>：读取 MyBatis 配置文件，初始化 <code>SqlSessionFactory</code>。</p><p><strong>会话创建</strong>：通过 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code>，作为数据库操作的会话</p><p><strong>Mapper 映射</strong>：获取映射接口（Mapper）的代理对象，映射接口方法与 SQL 语句对应。</p><blockquote><p>通过 <code>SqlSession</code> 实例的 <code>getMapper(UserMapper.class)</code> 方法，获取 <code>UserMapper</code> 映射接口的代理对象。</p><p>MyBatis 底层会根据 <code>UserMapper.xml</code> 映射文件中定义的 SQL 语句和 <code>UserMapper</code> 接口中的方法进行绑定。</p></blockquote><p><strong>执行 SQL</strong>：使用 <code>Executor</code> 执行映射 SQL 语句，对数据库进行 CRUD 操作。</p><p><strong>参数映射</strong>：在执行 SQL 前，将输入参数映射到 SQL 语句中；执行 SQL 后，将结果集映射为 Java 对象。</p><p><strong>事务控制</strong>：通过 <code>SqlSession</code> 的 <code>commit()</code> 和 <code>rollback()</code> 控制事务。</p><p><strong>会话关闭</strong>：操作完成后，关闭 <code>SqlSession</code>，释放资源。</p><h6 id="2-占位符"><a href="#2-占位符" class="headerlink" title="2.占位符"></a>2.占位符</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;insertUser&quot; parameterType=&quot;com.example.model.User&quot;&gt;    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (<span class="hljs-type">name</span>, age) <span class="hljs-keyword">VALUES</span> (#&#123;<span class="hljs-type">name</span>&#125;, #&#123;age&#125;)  &lt;/<span class="hljs-keyword">insert</span>&gt;<br></code></pre></td></tr></table></figure><p>#{} 实现向占位符添加值-自动进行java类型和jdbc类型转换-可以防止sql注入-可接收简单类型值和pojo属性值</p><p> ￥s{}拼接sql传&#x3D;不进行类型转换&#x3D;</p><h6 id="3-parameterType-resultType"><a href="#3-parameterType-resultType" class="headerlink" title="3.parameterType-resultType"></a>3.parameterType-resultType</h6><p>parameterType-传入的参数类型</p><p>resultType返回值类型</p><h6 id="4-selectOne和selectList"><a href="#4-selectOne和selectList" class="headerlink" title="4..selectOne和selectList"></a>4..selectOne和selectList</h6><p>selectOne查询一条记录</p><p>selectList查询多条记录</p><h6 id="5-mybits-主键"><a href="#5-mybits-主键" class="headerlink" title="5.mybits-主键"></a>5.mybits-主键</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f2a7da3c2707062c15cbbfc7c5f51f9.png" alt="3f2a7da3c2707062c15cbbfc7c5f51f9"></p><p>使用</p><p>SqlSession.insert(“test.insertUser”,user);</p><p>selectkey-&gt;select Last_INSERT_ID–用户添加后自动返回主键-</p><p>—返回主键 </p><p>uuid生成主键</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69eddd3b9e877d74e91d107aad7b6940.png" alt="69eddd3b9e877d74e91d107aad7b6940"></p><h6 id="6-mybits-删除"><a href="#6-mybits-删除" class="headerlink" title="6.mybits-删除"></a>6.mybits-删除</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f16033409c2f9eb00418ede68cffc228.png" alt="f16033409c2f9eb00418ede68cffc228"></p><p>sqlSession.delete(“test.deleteUser”,39);</p><h6 id="7-mybiits-更新用户"><a href="#7-mybiits-更新用户" class="headerlink" title="7.mybiits-&gt;更新用户"></a>7.mybiits-&gt;更新用户</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95864300169e8c1df1b79f4d0102505e.png" alt="95864300169e8c1df1b79f4d0102505e"></p><p>sqlSession.update(“test.updateUser”,user);</p><h4 id="mybits-Dao开发"><a href="#mybits-Dao开发" class="headerlink" title="mybits-Dao开发"></a>mybits-Dao开发</h4><h6 id="1-Dao开发配置入门"><a href="#1-Dao开发配置入门" class="headerlink" title="1.Dao开发配置入门"></a>1.Dao开发配置入门</h6><p>Impl层</p><p>前言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个请求 都会创建 SqlSessionFactory  SqlSessionFactoryBuilder-影响资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61928ee9fd81bc3528cdddda96a0d8be.png" alt="61928ee9fd81bc3528cdddda96a0d8be"></p><p><code>SqlSessionFactoryBuilder</code> 只是一个构建器，它的生命周期是短暂的，只需在创建 <code>SqlSessionFactory</code> 时使用一次。创建好 <code>SqlSessionFactory</code> 后，就不需要再保留 <code>SqlSessionFactoryBuilder</code> 实例。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a59f5c6efc930fdf24b4753e2d6c0165.png" alt="a59f5c6efc930fdf24b4753e2d6c0165"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8f73ed7437e15b3fd61ff570da0b265.png" alt="e8f73ed7437e15b3fd61ff570da0b265"></p><p>解决多次创建后代码–bean-单例bena实现 -如图还未bean 也就是简单的单例模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f89faf38a206b6547777bbea1aa5e14.png" alt="8f89faf38a206b6547777bbea1aa5e14"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d751486c93be306c26947fa45914c821.png" alt="d751486c93be306c26947fa45914c821"></p><p>dao层面-有非常多的重复代码-比如释放资源-拿取selSession-</p><h6 id="2-Mapper开发"><a href="#2-Mapper开发" class="headerlink" title="2.Mapper开发"></a>2.Mapper开发</h6><p>mapper代理方法（程序员只需要mapper接口）<br>程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a8d02d56bb89ffa8d43fd55385bb115a.png" alt="a8d02d56bb89ffa8d43fd55385bb115a"></p><p>需要一一对应进行映射</p><p>也就是mapper-函数映射到xml文件中–需要进行一一对应</p><h6 id="3-mapper代理"><a href="#3-mapper代理" class="headerlink" title="3.mapper代理"></a>3.mapper代理</h6><p>xml定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab74d1f694af3fb743e294f135a4041a.png" alt="ab74d1f694af3fb743e294f135a4041a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5eea9b8887ac8e1894fd8520adf4dcec.png" alt="5eea9b8887ac8e1894fd8520adf4dcec"></p><p>加载</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/922160ede6004b8fb5aea389641d68c2.png" alt="922160ede6004b8fb5aea389641d68c2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45e07e2b4ddd60cd021dcc2f31c066c8.png" alt="45e07e2b4ddd60cd021dcc2f31c066c8"></p><p>—如图–userMapper-来调用方法0由sqlSession-来生成代理对象</p><p>   代理对象内部调用selectOne或selectList<br>如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。<br>如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库</p><hr><p>mapper接口方法参数只能有一个，系统是否不利于扩展维护。</p><p>系统 框架中，dao层的代码是被业务层公用的。<br>即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。</p><p>注意：持久层方法的参数可以包装类型、map。。。，service方法中建议不要使用包装类型（不利于业务层的可扩展）。</p><h6 id="4-l配置"><a href="#4-l配置" class="headerlink" title="4.l配置"></a>4.l配置</h6><p>SqlMapConfig.xm</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a05192e83f10245208db8c09e74468f.png" alt="0a05192e83f10245208db8c09e74468f"></p><p> properties属性</p><p>将数据库连接参数只配置在db.properties中，原因：方便对参数进行统一管理，其它xml可以引用该db.properties</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5afb2ae748e665a0957970ae4a909e5d.png" alt="5afb2ae748e665a0957970ae4a909e5d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a29db16646c4c42d5d9896bd292741d.png" alt="2a29db16646c4c42d5d9896bd292741d"></p><p> settings全局参数配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0070c06383100dde987ddc21ea4a4b3a.png" alt="0070c06383100dde987ddc21ea4a4b3a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62169f009b19205c6220b75f7a4bcb5a.png" alt="62169f009b19205c6220b75f7a4bcb5a"></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><blockquote><p>类型别名（Type Alias）是为了简化和减少 XML 配置文件中的类全限定名而引入的一种便捷方式。通过定义类型别名，你可以使用更短的名称来引用 Java 类，从而使得 Mapper XML 文件更简洁和易读。</p></blockquote><blockquote><p><strong>定义类型别名</strong>：在 MyBatis 配置文件 (<code>mybatis-config.xml</code>) 中，可以为 Java 类指定一个别名。</p><p><strong>使用类型别名</strong>：在 Mapper XML 文件中使用别名来代替类的全限定名。</p></blockquote><h6 id="1-普通类型别名"><a href="#1-普通类型别名" class="headerlink" title="1.普通类型别名"></a>1.普通类型别名</h6><p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p><p>自定义别名-当我们参数的pojo大部分一致的时候 定义别名可以减少代码繁杂</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e1d9343cb1eb8b59a484042657ed0f6.png" alt="8e1d9343cb1eb8b59a484042657ed0f6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7ae2a441a846072ed1c64575f9fa045.png" alt="d7ae2a441a846072ed1c64575f9fa045"></p><p>批量别名-常用-扫描po文件 给所有pojo注册别名</p><h6 id="3-mybits-类型处理器"><a href="#3-mybits-类型处理器" class="headerlink" title="3.mybits 类型处理器"></a>3.mybits 类型处理器</h6><blockquote><p>在 MyBatis 中，<strong>类型处理器（Type Handlers）</strong> 用于处理 Java 类型与 JDBC 类型之间的转换。它们在 MyBatis 从数据库中读取数据（结果集映射）或将数据写入数据库（参数映射）时起着关键作用。<br>例子</p><p><strong>Java 类型到 JDBC 类型的转换</strong>：将 Java 对象类型转换为 SQL 参数，发送到数据库。例如，将 <code>Integer</code> 类型的 Java 对象转换为数据库的 <code>INTEGER</code> 类型。</p><p><strong>JDBC 类型到 Java 类型的转换</strong>：将从数据库查询的结果转换为 Java 对象。例如，将数据库查询结果中的 <code>INTEGER</code> 类型转换为 Java 的 <code>Integer</code> 或 <code>int</code>。</p></blockquote><h6 id="4-mappers-映射配置"><a href="#4-mappers-映射配置" class="headerlink" title="4.  mappers 映射配置"></a>4.  mappers 映射配置</h6><ol><li><p>通过resource加载单个映射文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/982f90b2b3ead1f97c7560fa9326b4fe.png" alt="982f90b2b3ead1f97c7560fa9326b4fe"></p></li><li><p>通过mapper接口加载单个mapper</p></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5c7c2136386dd9b06663cdf3631c412c.png" alt="5c7c2136386dd9b06663cdf3631c412c"></p><p>按照上边的规范，将mapper.java和mapper.xml放在一个目录 ，且同名</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de35b2cb9ffb9c7af48ac36f9586f000.png" alt="de35b2cb9ffb9c7af48ac36f9586f000"></p><p>3 .  批量加载mapper(推荐使用)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3cc05d3339e8ebae691aaac0073392fa.png" alt="3cc05d3339e8ebae691aaac0073392fa"></p><p>4.输入映射</p><p>通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/80e95beb88e2a055ee91e47d12c5bc6e.png" alt="80e95beb88e2a055ee91e47d12c5bc6e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/16e891a8f40288f28679241a5f4a6dd0.png" alt="16e891a8f40288f28679241a5f4a6dd0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eec86ff7c8c1cc0c909076d9d0827b36.png" alt="eec86ff7c8c1cc0c909076d9d0827b36"></p><h5 id="Mybits高级"><a href="#Mybits高级" class="headerlink" title="Mybits高级"></a>Mybits高级</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ec78fe0039ba4d7a0f0e93edde34ffd.png" alt="3ec78fe0039ba4d7a0f0e93edde34ffd"></p><h6 id="1-一对一查询"><a href="#1-一对一查询" class="headerlink" title="1.一对一查询"></a>1.一对一查询</h6><p>查询订单信息，关联查询创建订单的用户信息<br>sql语句<br>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS,USER WHRE ORDERS.USER_ID&#x3D;USER.ID;</p><p>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS JOIN USER ON ORDERS.USER_ID&#x3D;USER.ID;</p><p>实现该查询</p><p>1.创建pojo</p><p>2.mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;SELECT ID=<span class="hljs-string">&quot;FINDorderUser&quot;</span> resultType=<span class="hljs-string">&#x27;pojo&#x27;</span>&gt;<br>select orders.*,user.username,user.sexmuser.address from orders,user WHRE ORDERS.USER_ID=USER.ID;<br><br>&lt;/lelect&gt;<br></code></pre></td></tr></table></figure><p>3.mapper.java</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5efc0b312fab4d35aa879dd46fae93a0.png" alt="5efc0b312fab4d35aa879dd46fae93a0"></p><p>这个时候-只需要获取即可使用该sql语句<br>–    使用resultMap映射的思路<br>使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f8a7cbf8b3875476e103b0733ac7f7f5.png" alt="f8a7cbf8b3875476e103b0733ac7f7f5"></p><p>定义resultMap</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ee4c7227c01ec39fa1bfa811976628dc.png" alt="ee4c7227c01ec39fa1bfa811976628dc"></p><p>S定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e92a4eb35812042de17a350aa5405bc7.png" alt="e92a4eb35812042de17a350aa5405bc7"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55906bbde71b042c14daf40325e2734a.png" alt="55906bbde71b042c14daf40325e2734a"></p><h6 id="2-一对多查询"><a href="#2-一对多查询" class="headerlink" title="2.一对多查询"></a>2.一对多查询</h6><p>查询订单及订单明细的信息。<br>SELECT<br>  orders.*,<br>  USER.username,<br>  USER.sex,<br>  USER.address,<br>  orderdetail.id orderdetail_id,<br>  orderdetail.items_id,<br>  orderdetail.items_num,<br>  orderdetail.orders_id<br>from<br> orders,<br>  USER,<br>  orderdetail<br>whrer<br>orders.user_id &#x3D; user.id AND orderdetail.orders_id&#x3D;orders.id</p><hr><hr><hr><hr><p>使用resultType将上边的 查询结果映射到pojo中，订单信息的就是重复<br>要求：<br>对orders映射不能出现重复记录。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/affb5c09f23f5c042208c4323940698f.png" alt="affb5c09f23f5c042208c4323940698f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6c2accdfd7490aa05255bb2aaa6f9807.png" alt="6c2accdfd7490aa05255bb2aaa6f9807"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7c536bcee1988bbddfd784e6de1204ec.png" alt="7c536bcee1988bbddfd784e6de1204ec"></p><p>map-&gt;映射关系<br>将数据库字段-&gt;对象的字段中<br>同时会指定映射的属性和集合中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/44c0fb3e4d6de667636651db0026ad85.png" alt="44c0fb3e4d6de667636651db0026ad85"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e59fc4b2bdacf3621426fec322ad24c3.png" alt="e59fc4b2bdacf3621426fec322ad24c3"></p><h6 id="3-多对多查询案例"><a href="#3-多对多查询案例" class="headerlink" title="3.多对多查询案例"></a>3.多对多查询案例</h6><hr><p>查询主表是：用户表<br>关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：<br>orders、orderdetail、items</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5d503cb8e549dc16e9fb2f3d9f972be9.png" alt="5d503cb8e549dc16e9fb2f3d9f972be9"></p><p>映射</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c9ea555f307b956af31dbce8415170.png" alt="b4c9ea555f307b956af31dbce8415170"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb9ca63b64a989b5b020ebe231fb555d.png" alt="bb9ca63b64a989b5b020ebe231fb555d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/314f0ba042424242c4135b4302a65f13.png" alt="314f0ba042424242c4135b4302a65f13"></p><h4 id="resultmap总结"><a href="#resultmap总结" class="headerlink" title="resultmap总结"></a>resultmap总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/863ba0486e9be85c0c64ea7eccdead9a.png" alt="863ba0486e9be85c0c64ea7eccdead9a"></p><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>如果查询两张表-如果只需要查询一张表即可满足条件的情况下-那么就不需要查询下一章表<br>关联查询-&gt;单表查询<br>1.使用association实现延迟加载</p><p>查询订单并且关联查询用户信息</p><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf67701ceb62d4d73d31491daee4f282.png" alt="cf67701ceb62d4d73d31491daee4f282"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>resultMap type<span class="hljs-operator">=</span>&quot;orders&quot; id&quot;map&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--对订单信息进行映射配置  --&gt;</span><br>            <span class="hljs-operator">&lt;</span>id <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;id&quot; property<span class="hljs-operator">=</span>&quot;id&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot; property<span class="hljs-operator">=</span>&quot;userId&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;number&quot; property<span class="hljs-operator">=</span>&quot;number&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;createtime&quot; property<span class="hljs-operator">=</span>&quot;createtime&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;note&quot; property<span class="hljs-operator">=</span>&quot;note&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 实现对用户信息进行延迟加载</span><br>            <span class="hljs-keyword">select</span>：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）<br>            要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace<br>            <span class="hljs-keyword">column</span>：订单信息中关联用户信息查询的列，是user_id<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span>association property<span class="hljs-operator">=</span>&quot;user&quot; javaType<span class="hljs-operator">=</span>&quot;user&quot;<br>  <span class="hljs-keyword">select</span><span class="hljs-operator">=</span>&quot;cn.itcast.mybatis.mapper.UserMapper.findUserById&quot; <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>association<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>resultMap<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62a5de17ceb2efb1cb23ce43c27b6311.png" alt="62a5de17ceb2efb1cb23ce43c27b6311"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/83717cda1037366a4cc5b930afeefd1d.png" alt="83717cda1037366a4cc5b930afeefd1d"></p><p>也就是-我们编译器没有访问到user内容就不会去加载吗 2.延迟加载配置<br>mybits默认没有开启延迟加载-需要自己手动开启<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3055bee2e2c581a6d17f4c89b04fb4c.png" alt="img"><br>3.</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41591507899361a44254c502150f44f5.png" alt="img"></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h6 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h6><p>第一层查询-如果没有-从数据库查 再添加进缓存中<br>sqlSession去执行增删改-清空一级缓存<br>2次发起-&gt;缓存有直接返回</p><p>redis缓存思路</p><p>mybits默认支持一级缓存<br>Sqlsession sqlsession&#x3D;sqlsessionfactry.ioensession();<br>UserMapper userMapper&#x3D;sqlsession.getMapper(usermapper.class);<br>User user&#x3D;usermapper.finduserbyid(1);第一层查询-如果没有-从数据库查 再添加进缓存中</p><p>User user&#x3D;usermapper.finduserbyid(1); 2次发起-&gt;缓存有直接返回</p><p>usermapper.updateuser(user1);sqlSession去执行增删改-清空一级缓存</p><p>一级缓存应用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ada7a24f8aeae89ccbcdb1d4e103400.png" alt="2ada7a24f8aeae89ccbcdb1d4e103400"></p><h6 id="2-2级缓存"><a href="#2-2级缓存" class="headerlink" title="2.2级缓存"></a>2.2级缓存</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0e49bf45af19e07fa4ee06a0b7335180.png" alt="0e49bf45af19e07fa4ee06a0b7335180"></p><p>二级缓存范围大-多个sqlsession可以共享一个usermapper二级缓存区域<br>二级缓存区域是按照namespace分-其他不同的mapper也有自己的二级缓存区域</p><p>一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同 的二级缓存区域中。</p><p>开启二级缓存<br>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a1dafc8e5fd22b6cf93d8e8aae31c4e.png" alt="0a1dafc8e5fd22b6cf93d8e8aae31c4e"></p><h4 id="mybits整合ehcache"><a href="#mybits整合ehcache" class="headerlink" title="mybits整合ehcache"></a>mybits整合ehcache</h4><p>mybits整合ehcache<br>ehcache是一个分布式缓存框架<br>缓存的数据-进行集中管理-分布式集中访问 整合方法</p><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。<br>mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45eaa4a652048030f4b17712288fbc56.png" alt="img"><br>ehcache配置<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/687820640853663a040469325cfb6a5b.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68e729a0da44d9d806007bc8178478d5.png" alt="img"></p><h6 id="二级应用场景"><a href="#二级应用场景" class="headerlink" title="二级应用场景"></a>二级应用场景</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fcf22de20a326941945b31d902fd8608.png" alt="fcf22de20a326941945b31d902fd8608"></p><h4 id="Mybits整合Spring"><a href="#Mybits整合Spring" class="headerlink" title="Mybits整合Spring"></a>Mybits整合Spring</h4><h6 id="1-bean配置"><a href="#1-bean配置" class="headerlink" title="1.bean配置"></a>1.bean配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/af73e0779b8e3e14680320c06a1d3e29_720.jpg" alt="af73e0779b8e3e14680320c06a1d3e29_720"></p><p>bean的配置</p><p> user.xml</p><p>![b13f504c2f17c64e26097dff4834aed8](G:\360MoveData\Users\nixg\Documents\Tencent Files\2760045743\nt_qq\nt_data\Pic\2024-04\Ori\b13f504c2f17c64e26097dff4834aed8.jpg)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/92c073b510f63afca1597faf32e1d6be.jpg" alt="92c073b510f63afca1597faf32e1d6be"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68ba41b8d0cb810134cb064e6eed67c5.jpg" alt="68ba41b8d0cb810134cb064e6eed67c5"></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4b6944e971eb9c6af10fdffe3f6cd943.jpeg" alt="4b6944e971eb9c6af10fdffe3f6cd943"></strong></p><p>以上bean去读xml配置<br>然后mybits去注册 在接口实现类进行查询<br>之后注册为bean</p><p>后续直接使用</p><h6 id="2-mapper"><a href="#2-mapper" class="headerlink" title="2.mapper"></a>2.mapper</h6><p>还是要在同级目录以下 </p><p>注册为bean 扫描xml文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dad5b70ff70703d57a807c3d9a740926_720.jpg" alt="dad5b70ff70703d57a807c3d9a740926_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/38fcb7f3871e63a3686786685b0671b7.jpg" alt="38fcb7f3871e63a3686786685b0671b7"></p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java字节码</title>
    <link href="/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <url>/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>1</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架</title>
    <link href="/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h1 id="Spring复习"><a href="#Spring复习" class="headerlink" title="Spring复习"></a>Spring复习</h1><h4 id="1-了解Spirng"><a href="#1-了解Spirng" class="headerlink" title="1.了解Spirng"></a>1.了解Spirng</h4><p>spirng-&gt;spring mvc -&gt;spring boot -&gt;spring cloud</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48b2da9ced4cd0074a9fdd4f7c0a4318.png" alt="48b2da9ced4cd0074a9fdd4f7c0a4318"></p><p>层层递进–</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3a684778fcbcadf529eaad2b4e9ca34d.png" alt="3a684778fcbcadf529eaad2b4e9ca34d"></p><h4 id="2-IOC-Di-了解"><a href="#2-IOC-Di-了解" class="headerlink" title="2.IOC -Di 了解"></a>2.IOC -Di 了解</h4><p>由分层解耦引出的依赖注入 以及依赖反转</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab5ce66c757c262b95bdbeb4ec1862ad.png" alt="ab5ce66c757c262b95bdbeb4ec1862ad"></p><p>如图 -&gt;当我们想更改对象 BookDaoImp12 名字时候-&gt;时 -&gt;所有业务代码都需要改动改动过大-&gt;</p><p>Ioc-&gt;控制反转<br>使用对象–由主动new-改为外部提供对象-&gt;对象控制器转移到外部</p><p>对此-spring提供容器-&gt;ioc容器 -&gt;提供了对象的创建和管理</p><p>依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1f0310fa78da12366d47e8d7844a002a.png" alt="1f0310fa78da12366d47e8d7844a002a"></p><p>IOC-&gt;容器管理Bean-&gt;容器管理bookdaoimpl</p><p>DI-&gt;将具有依赖关系的Bean进行关系绑定-&gt;例如上面的bookdao-&gt;与bookdaoimpl进行绑定  Spring利用依赖注入机制来处理这些Bean之间的依赖关系，从而实现对象之间的松耦合。</p><h4 id="3-加入IOC-容器"><a href="#3-加入IOC-容器" class="headerlink" title="3.加入IOC 容器"></a>3.加入IOC 容器<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed3173cdd0c9bc6ba6d44953a8c38e0a.png" alt="ed3173cdd0c9bc6ba6d44953a8c38e0a"></h4><h6 id="1-配置Bean"><a href="#1-配置Bean" class="headerlink" title="1.配置Bean"></a>1.配置Bean</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/19c1fd155ec41e2182592cffc5262d96.png" alt="19c1fd155ec41e2182592cffc5262d96"></p><p>2.获取Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/506c12b2db4dd7aca712594fa5e279fa.png" alt="506c12b2db4dd7aca712594fa5e279fa"></p><p>当我们配置bean的时候–容器内就保存了我们的对象地址-&gt;单例-&gt;谁需要就给予</p><h6 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/838a65e2572d2c5fafc8c03d3a3ffd44.png" alt="838a65e2572d2c5fafc8c03d3a3ffd44"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dace05b9aa02d6ab02fd488a060b202e.png" alt="dace05b9aa02d6ab02fd488a060b202e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eed54b5a29e21c9568ee7b195168d180.png" alt="eed54b5a29e21c9568ee7b195168d180"></p><p>set容器执行-&gt;最后还是容器将Bean给予了</p><p>spring-&gt;编译 –自动找set 依赖方法注入</p><h4 id="4-Bean配置"><a href="#4-Bean配置" class="headerlink" title="4.Bean配置"></a>4.Bean配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a1a6f9cec7eca02be1d7807228f64ae.png" alt="2a1a6f9cec7eca02be1d7807228f64ae"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/316948bfd792a80f844396040f862c94.png" alt="316948bfd792a80f844396040f862c94"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f41e07fcd21e2e60e49873e445f8656.png" alt="8f41e07fcd21e2e60e49873e445f8656"></p><p>spring-&gt;默认的Bean是单例的</p><p>如果需要多例 就需要修改配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20bd78b82f85ef5660348295b0f97bf6.png" alt="20bd78b82f85ef5660348295b0f97bf6"></p><p>为什么bean要单例–<br>开对象-&gt;耗费内存</p><p>由于是单例-&gt;需要改变的数据就不能加入spring管理-&gt;除非开多例</p><h4 id="5-Bean实例化"><a href="#5-Bean实例化" class="headerlink" title="5.Bean实例化"></a>5.Bean实例化</h4><h6 id="1-ioc过程"><a href="#1-ioc过程" class="headerlink" title="1.ioc过程"></a>1.ioc过程</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2509eb7c62e476183b724c53e7881f29.png" alt="2509eb7c62e476183b724c53e7881f29"></p><p>给接口内-&gt;一个构造-&gt;通过xml解析出 需要构造的对象-&gt;通过反射 -&gt;创建出对象返回-&gt;默认单例</p><p>通过类名动态加载类的方法</p><p>在使用 <code>Class.forName()</code> 方法时，情况会根据加载的类是否已存在而有所不同：</p><ol><li><strong>类已存在</strong>：<ul><li>如果使用 <code>Class.forName()</code> 加载的类在类路径中已经存在，则会返回对应的 Class 对象，而不会创建新的对象。这意味着它只是获取已加载类的引用，不会触发类的初始化和实例化。</li></ul></li><li><strong>类不存在</strong>：<ul><li>如果要加载的类在类路径中不存在，则会抛出 <code>ClassNotFoundException</code> 异常，而不会创建新的类对象。在这种情况下，不会创建新的类对象，因为类根本就没有被加载到内存中</li></ul></li></ol><h6 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h6><p>工厂模式 -&gt;由一个类中的静态方法-&gt;返回对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 静态工厂方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyService <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;通过静态工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createInstance()</code> 是静态工厂方法，负责返回 <code>MyService</code> 类型的对象。</p><p>在 Spring 配置文件中使用 <code>&lt;bean&gt;</code> 标签指定静态工厂方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span> <span class="hljs-attribute">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p> Java 注解配置静态工厂方法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-variable">@Bean</span><br>    public MyService myService() &#123;<br>        <span class="hljs-keyword">return</span> MyServiceFactory.createInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-实例工厂"><a href="#3-实例工厂" class="headerlink" title="3.实例工厂-"></a>3.实例工厂-</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 实例工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyService <span class="hljs-title">createInstance</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;通过实例工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Spring 配置文件（<code>applicationContext.xml</code>）中，通过 <code>&lt;bean&gt;</code> 标签配置实例工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-comment">&lt;!-- 配置工厂类的 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用工厂类的实例方法创建 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>获取bean</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br>MyService myService <span class="hljs-operator">=</span> (MyService) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>)<span class="hljs-comment">;</span><br>myService.doSomething()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Spring 容器首先会创建 <code>MyServiceFactory</code> 的实例，然后调用其 <code>createInstance</code> 方法来创建 <code>MyService</code> 实例。</p><p> Java 注解配置实例工厂方法</p><p>&#x2F;&#x2F;多了一步-先获取到实例工厂bean才能够注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyServiceFactory <span class="hljs-title function_">myServiceFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceFactory</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> myServiceFactory().createInstance();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h6><p>在 Spring 框架中，<code>FactoryBean</code> 是一个特殊的接口，用于自定义 Bean 的创建逻辑</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Object <span class="hljs-title">getObject</span>(): 返回要创建的 Bean 实例。这个方法用于定义实际的对象创建逻辑。</span><br><span class="hljs-function">Class&lt;?&gt; <span class="hljs-title">getObjectType</span>(): 返回创建的 Bean 的类型。</span><br><span class="hljs-function">boolean <span class="hljs-title">isSingleton</span>(): 指示这个 Bean 是否是单例模式。返回 <span class="hljs-literal">true</span> 表示单例，<span class="hljs-literal">false</span> 表示每次请求都会创建一个新的实例。</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd082cfbea4d7e4b13aa31843b6f35c3.jpeg" alt="dd082cfbea4d7e4b13aa31843b6f35c3"></p><p>指定类-扫描</p><p>Spring 容器会创建一个 <code>CarFactoryBean</code> 的实例，并调用它的 <code>getObject()</code> 方法来获取 <code>Car</code> 对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br><br>// 获取由 CarFactoryBean 创建的 UserDao 实例<br>UserDao car <span class="hljs-operator">=</span> (Car) context.getBean(<span class="hljs-string">&quot;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(car)<span class="hljs-comment">;</span><br><br>// 获取 CarFactoryBean 实例本身<br>CarFactoryBean factoryBean <span class="hljs-operator">=</span> (CarFactoryBean) context.getBean(<span class="hljs-string">&quot;&amp;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(factoryBean)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="6-Bean生命周期"><a href="#6-Bean生命周期" class="headerlink" title="6.Bean生命周期"></a>6.Bean生命周期</h4><h6 id="1-生命周期配置"><a href="#1-生命周期配置" class="headerlink" title="1.生命周期配置"></a>1.生命周期配置</h6><p>1.配置法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f411aabb27ce975d2121258bbe3d082.jpeg" alt="3f411aabb27ce975d2121258bbe3d082"></p><p>2.接口法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a1a7897db2e6c6a81a71ae18c1629103.jpg" alt="a1a7897db2e6c6a81a71ae18c1629103"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0b42710ae7bb291a8a7f65ac715b86bc.png" alt="0b42710ae7bb291a8a7f65ac715b86bc"></p><h6 id="2-bean销毁时间"><a href="#2-bean销毁时间" class="headerlink" title="2.bean销毁时间"></a>2.bean销毁时间</h6><p>为了体现生命周期-&gt;我们提前销毁bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/87ed0bfac3a4d77291ac594173873a77.jpeg" alt="87ed0bfac3a4d77291ac594173873a77"></p><h4 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7.依赖注入"></a>7.依赖注入</h4><h6 id="1-了解依赖注入"><a href="#1-了解依赖注入" class="headerlink" title="1.了解依赖注入"></a>1.了解依赖注入</h6><p>有Bean关系的类进行自动注入 —向类传递数据方式-set 传递 –构造传参</p><hr><p>参数–引用类型和简单类型</p><h6 id="2-引用注入"><a href="#2-引用注入" class="headerlink" title="2.引用注入"></a>2.引用注入</h6><p><strong>引用注入</strong> 是指将一个对象作为另一个对象的属性注入。例如，在一个类中注入另一个类的实例。在 XML 配置或基于注解的方式中，都可以实现引用注入。</p><p><strong>引用注入是指将一个 Bean 注入到另一个 Bean 中，这个 Bean 可以通过构造器、Setter 方法、或其他方式注入。引用注入强调的是一种</strong>引用关系**。</p><p><code>Person</code> 类需要 <code>Address</code> 类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String street;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">// 引用注入</span><br><span class="hljs-comment">// getters and setters</span><br><br><span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <span class="hljs-comment">//构造器</span><br>Person(Address address)<br>&#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Person</code> 类依赖于 <code>Address</code> 类，即 <code>Person</code> 拥有一个 <code>Address</code> 类型的属性。我们可以通过 Spring 配置文件来实现引用注入。</p><p>XML 配置引用注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;New York&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5th Avenue&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John Doe&quot;</span>/&gt;</span>//属性注入<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 引用注入 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>///ref 属性表示引用另一个 Bean。<br></code></pre></td></tr></table></figure><p>基于注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <br><span class="hljs-keyword">private</span> String name;    <br><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 注解方式引用注入    </span><br><span class="hljs-keyword">private</span> Address address;   <br>/<br>/ getters and setters    <span class="hljs-comment">//... &#125;</span><br></code></pre></td></tr></table></figure><h6 id="3-setter注入"><a href="#3-setter注入" class="headerlink" title="3.setter注入"></a>3.setter注入</h6><p><strong>Setter 注入</strong> 是一种通过提供 setter 方法来实现依赖注入的方式</p><p>Setter 注入通常用于将简单数据类型（如 <code>String</code>、<code>int</code>）或引用类型注入到 Bean 中。在 XML 配置中使用 <code>&lt;property&gt;</code> 标签来定义：</p><p><code>&lt;property&gt;</code> 标签的 <code>name</code> 属性表示要注入的属性名称，<code>value</code> 属性表示简单数据类型的值，<code>ref</code> 属性表示对其他 Bean 的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;Jane Doe&quot;</span>/&gt; &lt;!-- 简单类型 --&gt;<br>    &lt;property name=<span class="hljs-string">&quot;address&quot;</span> ref=<span class="hljs-string">&quot;address&quot;</span>/&gt; &lt;!-- 引用类型 --&gt;<br>&lt;/bean&gt;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Address</span> address;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Address</span> <span class="hljs-title function_">getAddress</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">Address</span> address</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="4-构造器注入"><a href="#4-构造器注入" class="headerlink" title="4.构造器注入"></a>4.构造器注入</h6><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ac8de3631e734a2817de72f0e21076e.jpeg" alt="2ac8de3631e734a2817de72f0e21076e"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/906d5345ed81c62f2ca79c2c87182043.jpeg" alt="906d5345ed81c62f2ca79c2c87182043"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/37aa8dfa1862573eb20ad4710135f7a0.jpeg" alt="37aa8dfa1862573eb20ad4710135f7a0"></strong></p><h6 id="4-依赖注入方式选择"><a href="#4-依赖注入方式选择" class="headerlink" title="4.依赖注入方式选择"></a>4.依赖注入方式选择</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7f4076b8a85df6389a465186386ba9f.jpeg" alt="d7f4076b8a85df6389a465186386ba9f"></p><h6 id="5-依赖自动装配"><a href="#5-依赖自动装配" class="headerlink" title="5.依赖自动装配"></a>5.依赖自动装配</h6><p>IOC容器根据bean所依赖的资源在容器中自动查找并注入到bena的过程称为自动装配</p><p>1.按类型</p><p>2.按名称</p><p>3.按构造方法</p><p>4.不启用自动装配</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d604dff0d944968b0f83ef5e0ed9148f.png" alt="d604dff0d944968b0f83ef5e0ed9148f"></strong></p><p>更改自动装配为按照类型</p><p>比如bookServcice依赖BookDao–我们不需要描述其关系 程序会自动根据名字找到对应类的bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入 不需要`&lt;property&gt;来描述引用关系</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">BookDao</span> bookDao</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">bookDao</span> = bookDao;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="8-集合注入"><a href="#8-集合注入" class="headerlink" title="8.集合注入"></a>8.集合注入</h4><h6 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6956e79faab9804acbd6a47b860b0245.png" alt="6956e79faab9804acbd6a47b860b0245"></p><h6 id="2-list"><a href="#2-list" class="headerlink" title="2.list"></a>2.list</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/43ed876a380305fa263d981c7a984c74.png" alt="43ed876a380305fa263d981c7a984c74"></p><h6 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;p&gt;</span><br><span class="hljs-section">&lt;set&gt;</span><br><br><span class="hljs-section">&lt;/set&gt;</span><br><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ca7bbcd65d882884d7297dd75609d006.png" alt="ca7bbcd65d882884d7297dd75609d006"></p><h6 id="5-Properties"><a href="#5-Properties" class="headerlink" title="5.Properties"></a>5.Properties</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2fac8b9f2d57b4c92547d6a8235169a4.png" alt="2fac8b9f2d57b4c92547d6a8235169a4"></p><h4 id="9-案例分析-bean注入"><a href="#9-案例分析-bean注入" class="headerlink" title="9.案例分析-bean注入"></a>9.案例分析-bean注入</h4><p>我们要拿到druid的连接</p><p>1.配置bean -注入参数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/00252469c47ede33f309cf222de6d27a.png" alt="00252469c47ede33f309cf222de6d27a"></p><p>我们就可以进行拿取</p><p>Set注入–进行注入传普通参数</p><h4 id="10-加载properties文件"><a href="#10-加载properties文件" class="headerlink" title="10.加载properties文件"></a>10.加载properties文件</h4><p><code>.properties</code> 文件的结构和格式</p><ul><li><strong>文件扩展名</strong>：<code>.properties</code></li><li><strong>基本格式</strong>：每行包含一个键值对，格式为 <code>key=value</code></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3259185201691e092710f1c19ad74f73.png" alt="3259185201691e092710f1c19ad74f73"></p><p>加载模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e482c7cd8837d44f0b1684ae235838c7.png" alt="e482c7cd8837d44f0b1684ae235838c7"></p><h4 id="11-容器"><a href="#11-容器" class="headerlink" title="11.容器"></a>11.容器</h4><p>创建过程包括多个关键步骤，从加载配置文件、解析 Bean 定义，到创建和初始化 Bean，再到处理 Bean 的生命周期和容器的启动与关闭。</p><h6 id="1-初始化容器"><a href="#1-初始化容器" class="headerlink" title="1.初始化容器"></a>1.初始化容器</h6><p><strong>加载配置</strong>：Spring 容器从配置文件或注解中加载应用程序的配置。这些配置文件可以是 XML 文件、Java 配置类（使用 <code>@Configuration</code> 注解）、或通过其他方式如 YAML 文件等</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88afb0e3109da0ceb049ce45b2ea81dd.png" alt="88afb0e3109da0ceb049ce45b2ea81dd"></p><p>创建 ApplicationContext 实例</p><p>ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p><h6 id="2-加载-Bean-定义"><a href="#2-加载-Bean-定义" class="headerlink" title="2.加载 Bean 定义"></a>2.加载 Bean 定义</h6><p>流程</p><p><strong>解析配置</strong>：Spring 容器解析配置文件中的 Bean 定义（包括 Bean 的类名、构造器参数、属性值等），或扫描标注有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类。</p><p><strong>注册 Bean 定义</strong>：将解析得到的 Bean 定义注册到容器中。这包括 Bean 的名称、类型、作用域（如单例或原型）、依赖关系等信息。</p><p><strong>创建 Bean 实例</strong>：根据 Bean 定义，Spring 容器创建 Bean 实例。Spring 使用反射机制调用 Bean 的构造函数（若是构造器注入）或默认构造函数。</p><p><strong>依赖注入</strong>：在 Bean 实例创建后，Spring 容器根据 Bean 定义的依赖关系注入所需的依赖。这包括构造器注入、Setter 注入、字段注入等方式。</p><p><strong>执行初始化方法</strong>：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6441e65ec06a343800d7d118ec915bf7.png" alt="6441e65ec06a343800d7d118ec915bf7"></p><p>处理 Bean 的生命周期</p><p><strong>Bean 销毁</strong>：在容器关闭时，Spring 会销毁 Bean。-&gt;bean生命周期方法</p><p> <strong>容器的启动和关闭</strong></p><p><strong>启动容器</strong>：Spring 容器在创建完成后会启动并准备好处理应用程序的请求和交互。此时，所有的 Bean 都已经被创建和初始化完毕，可以使用它们提供的功能。</p><p><strong>关闭容器</strong>：容器可以通过调用 <code>ApplicationContext</code> 的 <code>close</code> 方法来关闭。在关闭过程中，容器会执行 Bean 的销毁操作，释放资源，完成容器的清理工作。</p><h6 id="3-容器接口分析"><a href="#3-容器接口分析" class="headerlink" title="3.容器接口分析"></a>3.容器接口分析</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d310da378a35e1bc86067389adf5c3b.png" alt="8d310da378a35e1bc86067389adf5c3b"></p><h6 id="4-BeanFactory初始化"><a href="#4-BeanFactory初始化" class="headerlink" title="4.BeanFactory初始化"></a>4.BeanFactory初始化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ccb6cf9576f42e82a4190ea129f29b18.png" alt="ccb6cf9576f42e82a4190ea129f29b18"></p><h2 id="IOC-DI-Bean总结"><a href="#IOC-DI-Bean总结" class="headerlink" title="IOC DI Bean总结"></a>IOC DI Bean总结</h2><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aec185bb8dc978e09e302c6e168d677e.jpeg" alt="aec185bb8dc978e09e302c6e168d677e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/18abb534418dab1c205c287cd041975f.jpeg" alt="18abb534418dab1c205c287cd041975f"></p><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h4 id="12-注解"><a href="#12-注解" class="headerlink" title="12.注解"></a>12.注解</h4><h6 id="1-声明为Bean"><a href="#1-声明为Bean" class="headerlink" title="1.@声明为Bean"></a>1.@声明为Bean</h6><p>将一个类声明为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/86b345941eab120771d71166dbf2beb3.png" alt="86b345941eab120771d71166dbf2beb3"></p><p>为了适配MVC-&gt;故此还有 @Controller @Service @Repository</p><h6 id="2-纯注解配置"><a href="#2-纯注解配置" class="headerlink" title="2.纯注解配置"></a>2.纯注解配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/547c0427ec597688cc1c0ec42b75f8a2.png" alt="547c0427ec597688cc1c0ec42b75f8a2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e5159d69c7dd85c33f019d20ac3be99.png" alt="8e5159d69c7dd85c33f019d20ac3be99"></p><h6 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ede5cccd6b754d10bd7e5d2dfb4db131.png" alt="ede5cccd6b754d10bd7e5d2dfb4db131"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f4d394d6384f8e1211f0b8775862a884.png" alt="f4d394d6384f8e1211f0b8775862a884"></p><p>简单类型注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2cde566b050a6d34fbe85be5502e6c50.png" alt="2cde566b050a6d34fbe85be5502e6c50"></p><h6 id="4-加载properties文件"><a href="#4-加载properties文件" class="headerlink" title="4.加载properties文件"></a>4.加载properties文件</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/73301e328b26e40279005a10ac179d9b.png" alt="73301e328b26e40279005a10ac179d9b"></p><p>![22a1fbb70d0306860f7d4ce5107158b5](G:\360MoveData\Users\nixg\Documents\Tencent Files\819429207\nt_qq\nt_data\Pic\2024-03\Ori\22a1fbb70d0306860f7d4ce5107158b5.png)</p><h6 id="5-第三方bean管理例子"><a href="#5-第三方bean管理例子" class="headerlink" title="5.第三方bean管理例子"></a>5.第三方bean管理例子</h6><p>1.注册为bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b515a9216fdb4b0cf13229af949a5107.png" alt="b515a9216fdb4b0cf13229af949a5107"></p><p>2.加入管理-导入式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/26e0669596d4e65ef8badc876869a654.png" alt="26e0669596d4e65ef8badc876869a654"></p><p>扫描式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f1c3b59e56b859a8a04b94fa9cc65876.png" alt="f1c3b59e56b859a8a04b94fa9cc65876"></p><p>简单依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240330164305805.png" alt="image-20240330164305805"></p><p>—连接池配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f09511581cde24e3c7dfcb783c3dc4c.png" alt="2f09511581cde24e3c7dfcb783c3dc4c"></p><h4 id="XML与注解-配置区别"><a href="#XML与注解-配置区别" class="headerlink" title="XML与注解 配置区别"></a>XML与注解 配置区别</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4f6fbbd9134d7813d17dec19a77cd8c.jpeg" alt="b4f6fbbd9134d7813d17dec19a77cd8c"></p><h4 id="13-aop"><a href="#13-aop" class="headerlink" title="13.aop"></a>13.aop</h4><h5 id="1-Aop基础"><a href="#1-Aop基础" class="headerlink" title="1.Aop基础"></a>1.Aop基础</h5><h6 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h6><p>AOP的原理主要是通过使用代理对象来实现，在Spring中，AOP通过代理对象包装目标对象（被代理的对象），在代理对象中插入切面（aspect），实现对目标对象方法的增强。Spring AOP主要采用动态代理技术来实现AOP，其中包括JDK动态代理和CGLIB动态代理两种方式。</p><blockquote><p>只有那些被 Spring 容器管理的 Bean（例如使用 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, 或 <code>@Controller</code> 等注解的类，或者通过 XML 配置的 Bean），Spring 才能为它们创建代理对象。</p></blockquote><p>代理对象的工作原理</p><ol><li><p><strong>代理对象的生成</strong>：</p><ul><li>当容器启动并扫描到 <code>@EnableAspectJAutoProxy</code> 注解时，Spring AOP 框架会自动创建一个代理对象来包装原始的 <code>UserServiceImpl</code> 对象。</li><li>根据 <code>UserService</code> 接口类型，Spring 将使用 <strong>JDK 动态代理</strong> 创建代理对象。</li></ul></li><li><p><strong>切面拦截方法</strong>：</p><ul><li>代理对象接收到方法调用时，它会拦截调用并根据 AOP 配置执行相应的切面逻辑。</li><li>在这个例子中，代理对象会在方法执行前和执行后调用 <code>LoggingAspect</code> 中的切面方法 <code>logBeforeMethod()</code> 和 <code>logAfterMethod()</code>。</li></ul></li><li><p><strong>方法调用的委托</strong>：</p><ul><li><p>在执行完切面方法后，代理对象会将方法调用委托给实际的目标对象 (<code>UserServiceImpl</code>) 以完成核心业务逻辑4</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserService</span> <span class="hljs-title function_">userService</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-title function_">loggingAspect</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingAspect</span>();<br>    &#125;<br>&#125;<br>---------------------------------<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">&quot;execution(* com.example.service.UserService.*(..))&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">allUserServiceMethods</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logBeforeMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: Before method execution&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logAfterMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: After method execution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><p>再框架中添加了个拦截器-&gt;依据正则过滤</p><h6 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h6><ol><li><strong>日志记录</strong>：记录方法的调用、参数、返回值等信息。</li><li><strong>事务管理</strong>：管理事务的开始、提交、回滚等操作。</li><li><strong>安全性</strong>：实现权限控制、加密解密等安全相关功能。</li><li><strong>性能监控</strong>：统计方法的执行时间、次数等性能指标。</li></ol><h6 id="3-连接点-切面-切入点-通知"><a href="#3-连接点-切面-切入点-通知" class="headerlink" title="3.连接点 切面 切入点 通知"></a>3.连接点 切面 切入点 通知</h6><hr><p>切面 @Aspect</p><p>定义一个类为切面类 -通知和切入点</p><p>@Aspect注解标识一个类为切面类，Spring会在扫描到这个注解的类时，自动创建代理对象，并将切面逻辑织入到目标方法中。</p><hr><p>通知</p><p>通知（Advice）是指切面（Aspect）中定义的在程序执行过程中插入的代码片段，它们是在指定的连接点（Join Point）处执行的行为逻辑。通知的主要作用是定义在目标方法执行前后、异常抛出时等特定情况下，应该执行的动作或逻辑。</p><p>@Before和@After</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeMethod</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Before method execution&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>切入点</p><p>它用于定义通知（Advice）应用的具体位置（方法或类）。切入点决定了通知在哪些连接点（Join Point）上执行。切入点的主要作用是<strong>定义通知的应用范围</strong>，即通知应该在什么情况下、对哪些方法或类生效。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* Calculator.divide(..)</span></span>)<br><br></code></pre></td></tr></table></figure><p>-通知+切入点-哪个方法被aop进行管理-再什么时候运行</p><hr><p>连接点</p><p>连接点是代码执行过程中的具体位置，可以被切面（Aspect）拦截并注入相应的增强逻辑。</p><p>当切入点表达式匹配到一个被 AOP 管理的类的方法时，这些方法就被认为是 <strong>连接点（Join Points）</strong>。</p><hr><p>@Before(“execution(* Calculator.add(..))”)</p><p>通知+切入点</p><p>代表了 Calculator类的add方法上执行增强操作</p><p>案例代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-comment">//连接点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-comment">//切面</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* Calculator.add(..))&quot;)</span><br>    <span class="hljs-comment">///通知 切入点 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeAdd</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging before the add method is called&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;execution(* Calculator.divide(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterDivide</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging after the divide method is called&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">&lt;aop:aspectj-autoproxy/&gt;<br>&lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="2-Aop进阶"><a href="#2-Aop进阶" class="headerlink" title="2.Aop进阶"></a>2.Aop进阶</h5><h6 id="1-通知类型"><a href="#1-通知类型" class="headerlink" title="1.通知类型"></a>1.通知类型</h6><ol><li><p>前置通知（Before Advice）：在目标方法执行之前调用通知方法。</p><p>对应注解：<code>@Before</code></p></li><li><p>后置通知（After Returning Advice）：在目标方法成功执行之后调用通知方法。</p><p>对应注解：<code>@AfterReturning</code></p></li><li><p>后置异常通知（After Throwing Advice）：在目标方法抛出异常后调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@AfterThrowing</span><br></code></pre></td></tr></table></figure></li><li><p>后置通知（After (finally) Advice）：无论目标方法是否成功执行，都会调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@After</span><br></code></pre></td></tr></table></figure></li><li><p>环绕通知（Around Advice）：在目标方法之前和之后执行通知方法，可以控制目标方法的执行过程。</p><p>对应注解：<code>@Around</code></p></li><li><p>引入通知（Introduction Advice）：向现有的对象添加新的方法或属性。</p></li><li><p>织入通知（AspectJ Advice）：在AOP中指定切点和通知的组合。</p></li></ol><hr><p>案例</p><ol><li><p>前置通知（Before Advice）：在用户进行结账操作时，检查用户的权限，确保用户具有足够的权限进行结账操作。</p></li><li><p>后置通知（After Returning Advice）：在用户提交订单成功后，记录订单信息到日志中，或者发送确认邮件给用户。</p></li><li><p>后置异常通知（After Throwing Advice）：如果订单处理过程中出现异常，比如库存不足，就发送通知给相关人员进行处理。</p></li><li><p>后置最终通知（After (finally) Advice）：无论订单处理成功与否，都需要关闭数据库连接或释放其他资源。</p></li><li><p>环绕通知（Around Advice）：在处理订单之前和之后记录订单处理时间，以及性能监控等功能。</p></li><li><p>引入通知（Introduction Advice）：向订单类引入一个新的接口，比如可追踪变更历史的接口。</p></li><li><p>织入通知（AspectJ Advice）：定义一个切面，将上述的各种通知类型织入到订单处理的流程中。</p></li></ol><p>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.aspectj.lang.annotation.AfterReturning;<br>import org.aspectj.lang.annotation.AfterThrowing;<br>import org.aspectj.lang.annotation.After;<br>import org.aspectj.lang.annotation.Around;<br>import org.aspectj.lang.ProceedingJoinPoint;</p><p>@Aspect<br>public class LoggingAspect {</p><pre><code class="hljs">@Before(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void beforeProcessOrder() &#123;    System.out.println(&quot;Before processing order...&quot;);&#125;@AfterReturning(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, returning = &quot;result&quot;)public void afterProcessOrder(Object result) &#123;    System.out.println(&quot;After processing order. Result: &quot; + result);&#125;@AfterThrowing(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, throwing = &quot;exception&quot;)public void afterThrowingProcessOrder(Exception exception) &#123;    System.out.println(&quot;Exception thrown during order processing: &quot; + exception.getMessage());&#125;@After(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void afterProcessOrderCompletion() &#123;    System.out.println(&quot;After processing order completion...&quot;);&#125;@Around(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123;    long startTime = System.currentTimeMillis();    Object result = joinPoint.proceed();    long endTime = System.currentTimeMillis();    System.out.println(&quot;Order processing time: &quot; + (endTime - startTime) + &quot; milliseconds&quot;);    return result;&#125;</code></pre><h6 id="2-通知顺序"><a href="#2-通知顺序" class="headerlink" title="2.通知顺序"></a>2.通知顺序</h6><p>当多个切面匹配到同一个类时，可以按照切入点所在类的字母顺序来决定通知方法的执行顺序</p><p>1.类字母</p><p>按照匹配到的切入点的类字母决定先后顺讯</p><p>1.前置-字母排名靠前的先执行</p><p>2.后置-字母排名靠前的后执行</p><p>2.@Order</p><p>可以使用<code>@Order</code>注解来控制多个通知方法的执行顺序。通过<code>@Order</code>注解可以指定通知方法的执行顺序，数值越小的通知方法优先执行。</p><p>具体步骤如下：</p><ol><li>在定义通知方法的类上添加<code>@Component</code>或其他相关注解，使其成为Spring容器中的Bean。</li><li>在通知方法上添加<code>@Order</code>注解，并指定执行顺序的数值，数值越小优先级越高。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(1)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 前置通知的实现</span><br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 后置通知的实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标前-数字小的先执行</p><p>目标后-数字小的后执行</p><h6 id="3-切入点"><a href="#3-切入点" class="headerlink" title="3.切入点"></a>3.切入点</h6><p>1.execution</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0484d9f1bbe10d4207d84882472bf29.png" alt="b0484d9f1bbe10d4207d84882472bf29"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e0a84ff1d8ccee34eb3876e12a63ef97.png" alt="e0a84ff1d8ccee34eb3876e12a63ef97"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ce5a2480e7eaf7f880d1624f4013487.png" alt="3ce5a2480e7eaf7f880d1624f4013487"></p><h4 id="2-注解aop开发"><a href="#2-注解aop开发" class="headerlink" title="2.注解aop开发"></a>2.注解aop开发</h4><p>代码案例</p><p>首先，定义一个自定义注解<code>CustomAnnotation</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-comment">//@Target(ElementType.METHOD)：表示该注解可以用于方法上。这意味着CustomAnnotation只能用于方法的声明中，而不能用于其他地方，比如类、字段等。</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-comment">///@Retention(RetentionPolicy.RUNTIME)：表示该注解在运行时可以被反射读取。这意味着在运行时，我们可以通过Java的反射机制来获取并处理带有CustomAnnotation注解的方法。</span><br>public <span class="hljs-variable">@interface</span> CustomAnnotation &#123;<br>    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">value</span>();<br>&#125;<br>这两个元数据的设定确保了<span class="hljs-selector-tag">CustomAnnotation</span>注解的使用方式和其在程序运行期间的可见性，使其可以被<span class="hljs-selector-tag">AOP</span>或其他机制所识别并进行相应的处理。<br></code></pre></td></tr></table></figure><p>接着，在一个服务类中使用<code>CustomAnnotation</code>注解：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Service</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;<br><br>    <span class="hljs-variable">@CustomAnnotation</span>(<span class="hljs-string">&quot;Custom Annotation Example&quot;</span>)<br>    public void myMethod() &#123;<br>        <span class="hljs-regexp">//</span> 方法实现<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>@CustomAnnotation(&quot;Custom Annotation Example&quot;)</code>这个注解中，双引号里面的参数是注解的属性值。在定义自定义注解时，可以为注解定义属性，并在使用注解时为这些属性赋值。</p><p>在这个示例中，自定义注解<code>CustomAnnotation</code>定义了一个名为<code>value</code>的属性，因此在使用这个注解时，需要为<code>value</code>属性赋值。双引号中的内容 <code>&quot;Custom Annotation Example&quot;</code> 就是为<code>value</code>属性赋的具体数值。</p><p>当在切面类中通过反射获取带有<code>CustomAnnotation</code>注解的方法时，可以通过访问注解的属性值来获取这里传入的参数值，从而实现根据不同的属性值执行不同的逻辑处理。</p><hr><p>然后，在切面类中使用<code>@annotation</code>注解匹配带有<code>CustomAnnotation</code>注解的方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Aspect</span><br>public class MyAspect &#123;<br><br>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;@annotation(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">annotatedMethod</span>(CustomAnnotation customAnnotation) &#123;&#125;<br><br>    <span class="hljs-variable">@Before</span>(<span class="hljs-string">&quot;annotatedMethod(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">beforeAnnotatedMethod</span>(CustomAnnotation customAnnotation) &#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Before advice for method with custom annotation: &quot;</span> + customAnnotation.<span class="hljs-built_in">value</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个切入点表达式 <code>@annotation(customAnnotation)</code> 的作用是匹配所有被 <code>@CustomAnnotation</code> 注解标记的方法。</p><p><code>@annotation(customAnnotation)</code> 是 AspectJ 提供的一个语法，用来匹配方法级别的注解。这里，<code>customAnnotation</code> 是一个参数，它表示目标方法上使用的 <code>@CustomAnnotation</code>。</p><p>同时<code>annotatedMethod</code> f方法的主要用处是可以在通知（Advice）方法中使用一个更清晰、易读的命名标识来引用切入点。</p><hr><p><code>@Before(&quot;annotatedMethod(customAnnotation)&quot;)</code> 表示在所有匹配 <code>@annotation(customAnnotation)</code> 切入点的方法执行之前，执行 <code>beforeAnnotatedMethod</code> 这个方法。</p><p><code>beforeAnnotatedMethod</code> 方法将会在任何被 <code>@CustomAnnotation</code> 标记的方法执行之前运行。它可以访问这个自定义注解实例 <code>customAnnotation</code>，并获取该注解中的属性（例如 <code>value()</code> 方法）。</p><h6 id="4-连接点"><a href="#4-连接点" class="headerlink" title="4.连接点"></a>4.连接点</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9a1881e71612ce58b920331bae4d304.png" alt="c9a1881e71612ce58b920331bae4d304"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6ecb0785b0a6a59af4c08f919aeb6b9e.png" alt="6ecb0785b0a6a59af4c08f919aeb6b9e"></p><h4 id="14-事务"><a href="#14-事务" class="headerlink" title="14.事务"></a>14.事务</h4><h6 id="0-事务的声明式管理"><a href="#0-事务的声明式管理" class="headerlink" title="0.事务的声明式管理"></a>0.事务的声明式管理</h6><p><strong>Spring 事务管理</strong> 依赖于 <strong>AOP 的思想和机制</strong> 来实现声明式事务管理。</p><p>在 Spring 中，当你使用 <code>@Transactional</code> 注解声明一个方法或类需要事务管理时，Spring AOP 会在运行时为这些方法或类创建一个代理对象（Proxy）。代理对象负责在方法调用之前开始事务，在方法调用之后提交或回滚事务。</p><p>Spring 使用 AOP 机制来织入事务管理代码。<code>@Transactional</code> 注解背后是通过 AOP 来实现的。在方法执行的前后，AOP 拦截器会自动进行事务管理操作（如事务开启、提交和回滚），而这些操作对业务代码是透明的。</p><p>这种方式被称为 <strong>声明式事务管理</strong>，它使用 <code>@Transactional</code> 注解指定哪些方法或类需要事务支持，不需要在业务代码中显式地编写事务处理逻辑。</p><p>切面</p><p>Spring 框架定义了一个 <strong>事务切面</strong>（Transaction Aspect），用来拦截被 <code>@Transactional</code> 标记的方法。这个切面是在方法调用前后执行相应的事务操作。</p><p>切入点</p><p>@Transactional</p><p>通知</p><p>通知逻辑</p><p>在方法执行前，事务切面拦截器会开启一个事务。</p><p>如果方法正常执行完成，则事务切面拦截器会提交事务。</p><p>如果方法执行过程中抛出了异常，事务切面拦截器会根据配置决定是回滚事务还是提交事务。</p><h6 id="1-事务入门-例子"><a href="#1-事务入门-例子" class="headerlink" title="1.事务入门 -例子"></a>1.事务入门 -例子</h6><p>假设我们有一个简单的用户管理系统，其中包括一个服务类 <code>UserService</code>，负责创建用户。我们希望在执行用户</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserRepository</span> userRepository;<br><br>    <span class="hljs-comment">// 被 @Transactional 注解的方法将由 Spring AOP 管理</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> username</span>) &#123;<br>        <span class="hljs-comment">// 保存用户</span><br>        userRepository.<span class="hljs-title function_">save</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(username));<br><br>        <span class="hljs-comment">// 模拟一个异常情况，测试事务回滚</span><br>        <span class="hljs-keyword">if</span> (username == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Username cannot be null&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br>----------<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);<br>        <span class="hljs-title class_">UserService</span> userService = context.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">UserService</span>.<span class="hljs-property">class</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.<span class="hljs-title function_">createUser</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 将会导致事务回滚</span><br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Exception caught: &quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-事务管理员-事务协调员"><a href="#2-事务管理员-事务协调员" class="headerlink" title="2.事务管理员 事务协调员"></a>2.事务管理员 事务协调员</h6><p>例子事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/342dd9a76057ac1992637973417a63c8.png" alt="342dd9a76057ac1992637973417a63c8"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9b888313da273ab68bfb514f19274a0b.png" alt="9b888313da273ab68bfb514f19274a0b"></p><h6 id="3-事务配置"><a href="#3-事务配置" class="headerlink" title="3.事务配置"></a>3.事务配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f65b886518d3736b235a310f1a6754.png" alt="b6f65b886518d3736b235a310f1a6754"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/59d7f8499d23c0a2bcfdb780f1e00ea3.png" alt="59d7f8499d23c0a2bcfdb780f1e00ea3"></p><h5 id="4-事务加入-规则"><a href="#4-事务加入-规则" class="headerlink" title="4.事务加入-规则"></a>4.事务加入-规则</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/03f05df2aa222c9fb3abd3efb44ef699.png" alt="03f05df2aa222c9fb3abd3efb44ef699"></p><p>例子</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5dde408db43ac7d09f859c76ed257c91.png" alt="5dde408db43ac7d09f859c76ed257c91"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fba20ae7cf0e8f32ff7aa3de0fb42e42.png" alt="fba20ae7cf0e8f32ff7aa3de0fb42e42"></p><p>如图-都加入同一事务-一旦有异常-日志也会回滚</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9972f6f167883d144abc515733c62536.png" alt="9972f6f167883d144abc515733c62536"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5f99a409d1ff453639c1d9cc7aa2fcf2.png" alt="5f99a409d1ff453639c1d9cc7aa2fcf2"></p><p>解决</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf8e05d7e9f071a8464d78b45eab2ae5.png" alt="cf8e05d7e9f071a8464d78b45eab2ae5"></p><h6 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fa818038f3cf6f80cf14608cec80c598.png" alt="fa818038f3cf6f80cf14608cec80c598"></p><h4 id="0-1-Spring-整合mybatis"><a href="#0-1-Spring-整合mybatis" class="headerlink" title="0.1 Spring 整合mybatis"></a>0.1 Spring 整合mybatis</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/11abe4ba3472982e3b1b217edb94c96e.png" alt="11abe4ba3472982e3b1b217edb94c96e"></p><p>-&gt;将该注册为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e038210f851e6d054f2de5a40605d29c.png" alt="e038210f851e6d054f2de5a40605d29c"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb16bf7c1655375464b67dcd0194534b.png" alt="eb16bf7c1655375464b67dcd0194534b"></p><p>如图–以上配置全部进行修改</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/241a0676f37e4b12a5eef8cdc8e7fe35.png" alt="241a0676f37e4b12a5eef8cdc8e7fe35"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79a9256b4115e3f74adcb4dfc1db5f30.png" alt="79a9256b4115e3f74adcb4dfc1db5f30"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ba320445dccb955e30224a3bbee6193.png" alt="3ba320445dccb955e30224a3bbee6193"></p><p>收纳</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7ff11a9112a3615d298943a68b54e9d6.png" alt="7ff11a9112a3615d298943a68b54e9d6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55cab2a9fb9c8def31581e7f33474ad0.png" alt="55cab2a9fb9c8def31581e7f33474ad0"></p><h4 id="0-2-Spring整合测试"><a href="#0-2-Spring整合测试" class="headerlink" title="0.2 Spring整合测试"></a>0.2 Spring整合测试</h4><p>设定类运行器</p><p>整合spring运行器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6981732edb98c9b849ff758c5c4053c1.png" alt="6981732edb98c9b849ff758c5c4053c1"></p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>maven笔记</title>
    <link href="/2024/09/10/maven%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/10/maven%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="maven笔记"><a href="#maven笔记" class="headerlink" title="maven笔记"></a>maven笔记</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Maven.png" alt="Maven"></p><h4 id="1-Maven入门"><a href="#1-Maven入门" class="headerlink" title="1.Maven入门"></a>1.Maven入门</h4><h6 id="1-maven是什么"><a href="#1-maven是什么" class="headerlink" title="1.maven是什么"></a>1.maven是什么</h6><p>maven是一个统一构建工具-帮助我们快速的导入jar包-同时通过pom对jar进行统一管理–maen还统一了目录结构</p><p>项目构建–依赖管理-统一开发结构</p><h6 id="2-maven仓库"><a href="#2-maven仓库" class="headerlink" title="2.maven仓库"></a>2.maven仓库</h6><p>云端存储jar包—同时本地-私服</p><h6 id="3-坐标"><a href="#3-坐标" class="headerlink" title="3.坐标"></a>3.坐标</h6><p>groupld-定义maven项目组织名称</p><p>artifactld–定义当前maven项目名称</p><p>version-定义当前版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>坐标作用-使用唯一表示-定位资源位置</p><h6 id="4-手动创建maven工程"><a href="#4-手动创建maven工程" class="headerlink" title="4.手动创建maven工程"></a>4.手动创建maven工程</h6><p>–省-就是用命令来创建</p><h4 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2.依赖管理"></a>2.依赖管理</h4><h6 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1.依赖配置"></a>1.依赖配置</h6><dependencies></dependency><dependency></dependencies><h6 id="2-依赖传递"><a href="#2-依赖传递" class="headerlink" title="2.依赖传递"></a>2.依赖传递</h6><p>直接依赖–再当前项目内直接通过pom建立依赖关系</p><p>间接依赖-一个依赖依赖于其他依赖–当前项目会都导入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88a5b650615c05bdb3b51bb6518a3044.png" alt="88a5b650615c05bdb3b51bb6518a3044"></p><h6 id="3-可选依赖"><a href="#3-可选依赖" class="headerlink" title="3.可选依赖"></a>3.可选依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69b032579ca283056eb5f2d056059bf4.png" alt="69b032579ca283056eb5f2d056059bf4"></p><h6 id="4-排查依赖"><a href="#4-排查依赖" class="headerlink" title="4.排查依赖"></a>4.排查依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e2be3508cc74b63a6c7f32972fa4017e.png" alt="e2be3508cc74b63a6c7f32972fa4017e"></p><h6 id="5-依赖范围"><a href="#5-依赖范围" class="headerlink" title="5.依赖范围"></a>5.依赖范围</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eaf5484e109c98583c4af32c8cc48353.png" alt="eaf5484e109c98583c4af32c8cc48353"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e74890abdf3d3cbdd37154251a5c005.png" alt="9e74890abdf3d3cbdd37154251a5c005"></p><h4 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h4><p>快速生命周期-compile-test-compile-test-package-install</p><p>生命周期介绍</p><p>clean-清理工作</p><p>default0核心工作-如编译-测试打包-部署</p><p>site-产生报告-发布站点</p><hr><p>Clean生命周期</p><p>pre-clean-执行一些需要再clean之前完成的工作</p><p>clean-移除上一次构建生成的文件</p><p>post-clean-执行一些需要再clean之后立刻完成的工作</p><hr><p>default构建生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1c6053fbcc84183fbc8f1a7789cee3fb.png" alt="1c6053fbcc84183fbc8f1a7789cee3fb"></p><hr><p>site生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7037669c99ca8e172d0144f4de087264.png" alt="7037669c99ca8e172d0144f4de087264"></p><hr><p>default 介绍</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69d200277cfe62e6d98340f0269f0bfe.png" alt="69d200277cfe62e6d98340f0269f0bfe"></p><p>又分为三大周期</p><h4 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/455befffa49ca7d0354264bf3db7dd62.png" alt="455befffa49ca7d0354264bf3db7dd62"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d32a812fe29eddabf67bcda3cfbcae8b.png" alt="d32a812fe29eddabf67bcda3cfbcae8b"></p><h1 id="Maven-高级"><a href="#Maven-高级" class="headerlink" title="Maven-高级"></a>Maven-高级</h1><h4 id="1-分模块开发与设计"><a href="#1-分模块开发与设计" class="headerlink" title="1.分模块开发与设计"></a>1.分模块开发与设计</h4><p>将一个大型项目拆分为多个独立模块的开发方式。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f0de39a2aea7bbe668e3574cef96944.png" alt="8f0de39a2aea7bbe668e3574cef96944"></p><p>如图 分模块开发就是将模块-导成架包–</p><p>例如-公司 -pojo包-导给你，你只需要导入pom即可使用</p><h4 id="2-聚合"><a href="#2-聚合" class="headerlink" title="2.聚合"></a>2.聚合</h4><p>将模块-聚合再一起构建</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/14b16e3b8bff7a90e90f6f6d42086115.png" alt="14b16e3b8bff7a90e90f6f6d42086115"></p><h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f4069f69f02e626eba8d6941cd4394.png" alt="b6f4069f69f02e626eba8d6941cd4394"></p><p>继承依赖使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62d9f5c074c0336ef3fcb5d36fd6546d.png" alt="62d9f5c074c0336ef3fcb5d36fd6546d"></p><p>继承资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3225c0c79867bfb1e4f2abe6cf748d9.png" alt="f3225c0c79867bfb1e4f2abe6cf748d9"></p><p>继承聚合区别</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240414120838551.png" alt="image-20240414120838551"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br>xml<br><span class="hljs-comment">&lt;!-- 子模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-属性"><a href="#4-属性" class="headerlink" title="4.属性"></a>4.属性</h4><p>属性最大的作用-配置-和版本管理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c4f542e3165840110e15b9913de9dc.png" alt="b4c4f542e3165840110e15b9913de9dc"></p><p>1.自定义属性管理</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/90eb8af64c4b02ba15ed77e0ac33fd16.png" alt="90eb8af64c4b02ba15ed77e0ac33fd16" style="zoom:75%;" /><h4 id="5-工厂版本"><a href="#5-工厂版本" class="headerlink" title="5.工厂版本"></a>5.工厂版本</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e1232256a286acb832c2975ad59ea8a1.png" alt="e1232256a286acb832c2975ad59ea8a1"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7d129e90eaca59df9ae2b62f7ab6ca55.png" alt="7d129e90eaca59df9ae2b62f7ab6ca55"></p><h4 id="6-资源配置"><a href="#6-资源配置" class="headerlink" title="6.资源配置"></a>6.资源配置</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9de34d5dbae1ebc7a72669952069638a.png" alt="9de34d5dbae1ebc7a72669952069638a"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5fc90c8dd4f839707b20624bdf4242c6.png" alt="5fc90c8dd4f839707b20624bdf4242c6"></p><h4 id="7-多环境开发配置"><a href="#7-多环境开发配置" class="headerlink" title="7.多环境开发配置"></a>7.多环境开发配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9c38f1922d021ec7c78c0c8ffbb0c0d5.png" alt="9c38f1922d021ec7c78c0c8ffbb0c0d5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2eccbb8497a79d12ba5b7337f7a9d98f.png" alt="2eccbb8497a79d12ba5b7337f7a9d98f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8c84b9496ecb0a2922bc874f8019530.png" alt="e8c84b9496ecb0a2922bc874f8019530"></p><h4 id="8-跳过测试"><a href="#8-跳过测试" class="headerlink" title="8.跳过测试"></a>8.跳过测试</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d039b87b2aa7539c3a17519c5e509652.png" alt="d039b87b2aa7539c3a17519c5e509652"></p><h4 id="9-私服"><a href="#9-私服" class="headerlink" title="9.私服"></a>9.私服</h4><p>省</p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础题目</title>
    <link href="/2024/09/10/nk/"/>
    <url>/2024/09/10/nk/</url>
    
    <content type="html"><![CDATA[<h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h6 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">JAVA2 简单运算<br>题目<br>题解(<span class="hljs-number">32</span>)<br>讨论(<span class="hljs-number">49</span>)<br>排行<br>入门  通过率：<span class="hljs-number">38.22%</span>  时间限制：<span class="hljs-number">1</span>秒  空间限制：<span class="hljs-number">256</span>M<br>warning 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。<br>描述<br>输入两个正整数<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>，输出这两个正整数的和，差，积，商，模（若<span class="hljs-selector-tag">a</span>&gt;<span class="hljs-selector-tag">b</span>则输出<span class="hljs-selector-tag">a</span>-<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>%<span class="hljs-selector-tag">b</span>的值反之输出<span class="hljs-selector-tag">b</span>-<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>/<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>%<span class="hljs-selector-tag">a</span>的值，不考虑小数，请使用int类型）<br>输入描述：<br>两个正整数<br>输出描述：<br>它们的和，差，积，商，模。每个值之间用空格隔开<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">10</span> <span class="hljs-number">5</span><br>复制<br>输出：<br><span class="hljs-number">15</span> <span class="hljs-number">5</span> <span class="hljs-number">50</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> a = scanner.<span class="hljs-built_in">nextInt</span>();<br>        <span class="hljs-type">int</span> b = scanner.<span class="hljs-built_in">nextInt</span>();<br>        scanner.<span class="hljs-built_in">close</span>();<br><br>        <span class="hljs-keyword">if</span>(a&gt;b)<br>        &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<br><br><br>        <span class="hljs-comment">//write your code here......</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt; <span class="hljs-comment">//堆区开辟对象 将它的引用压入操作数栈</span><br> <span class="hljs-number">3</span> dup <span class="hljs-comment">//复制了该对象引用，并再次将其压入操作数栈。</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt; <br> <span class="hljs-comment">///获取 System.in，即标准输入流，并将其压入操作数栈。</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">///调用 Scanner 的构造方法，使用 System.in 作为输入流参数来初始化 Scanner 对象。</span><br><span class="hljs-number">10</span> astore_1<br>将操作数栈顶的引用类型Scanner（对象引用）存储到局部变量表的索引 <span class="hljs-number">1</span> 位置 并弹出<br><span class="hljs-number">11</span> aload_1<br><span class="hljs-comment">//从局部变量表中加载索引为 1 的引用类型（对象引用）到操作数栈。</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextInt 方法，读取输入的下一个整数，并将其结果（一个 int）压入操作数栈。</span><br><span class="hljs-number">15</span> istore_2<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">2</span>）。并弹出<br><span class="hljs-number">16</span> aload_1<br>加载 Scanner 对象引用。<br><span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-number">20</span> istore_3<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">3</span>）。并弹出<br><span class="hljs-number">21</span> aload_1<br>加载 Scanner 对象引用<br><span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.close : ()V&gt;<br>调用 Scanner 的 close 方法，关闭输入流。<br>--------- <br>       <br>       Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> a = scanner.nextInt();<br>        <span class="hljs-keyword">int</span> b = scanner.nextInt();<br>        scanner.close();<br>------------<br><span class="hljs-number">25</span> iload_2<br><span class="hljs-number">26</span> iload_3<br>将 <span class="hljs-number">2</span> <span class="hljs-number">3</span> 索引值存储到操作数栈<br><br><span class="hljs-number">27</span> if_icmple <span class="hljs-number">55</span> (+<span class="hljs-number">28</span>)  <span class="hljs-keyword">if</span>(a&gt;b)<br>-&gt;比较大小<br>  System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><br><span class="hljs-number">30</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-comment">//获取标准输出流 System.out。-到操作数栈</span><br><span class="hljs-number">33</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-comment">//将格式化字符串 &quot;%d&quot; 压入操作数栈。</span><br><span class="hljs-number">35</span> iconst_1<br>将常量整数 <span class="hljs-number">1</span> 压入操作数栈，表示需要一个参数进行格式化。<br><span class="hljs-comment">///</span><br><br><span class="hljs-number">36</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br>创建一个 Object 类型的新数组，大小为 <span class="hljs-number">1</span>。<br><span class="hljs-number">39</span> dup<br>复制新建的数组引用。 压入操作数栈<br><span class="hljs-number">40</span> iconst_0<br>将整数 <span class="hljs-number">0</span> 压入操作数栈，表示数组的索引位置。<br><span class="hljs-number">41</span> iload_2<br><span class="hljs-number">42</span> iload_3<br><span class="hljs-number">43</span> iadd<br><span class="hljs-comment">//将 23 索引数据存储到操作数栈-并且相加</span><br><span class="hljs-number">44</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br>调用 Integer.valueOf 方法，将和转换为 Integer 对象。<br><span class="hljs-number">47</span> aastore<br>将 Integer 对象存储到数组的第一个位置。<br><span class="hljs-number">48</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br>调用 printf 方法输出结果。<br><span class="hljs-number">51</span> <span class="hljs-keyword">pop</span><br>弹出 PrintStream 对象的引用，清理操作数栈。<br><span class="hljs-number">52</span> goto <span class="hljs-number">77</span> (+<span class="hljs-number">25</span>)<br><span class="hljs-number">77</span><br><br>代码跳处 <br> System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><span class="hljs-number">55</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">58</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-number">60</span> iconst_1<br><span class="hljs-number">61</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br><span class="hljs-number">64</span> dup<br><span class="hljs-number">65</span> iconst_0<br><span class="hljs-number">66</span> iload_2<br><span class="hljs-number">67</span> iload_3<br><span class="hljs-number">68</span> iadd<br><span class="hljs-number">69</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br><span class="hljs-number">72</span> aastore<br><span class="hljs-number">73</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">76</span> <span class="hljs-keyword">pop</span><br><span class="hljs-number">77</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h6><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">描述<br>定义一个<span class="hljs-built_in">int</span>类型变量i,i为由浮点数变量d四舍五入后的整数类型，请将转换后的i进行输出<br>输入描述：<br>用户随机输入的浮点数<br>输出描述：<br>四舍五入之后的整数（小数点后一位&gt;=<span class="hljs-number">5</span>则进一，否则舍去）<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">14.99</span><br>复制<br>输出：<br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">double</span> d= scanner.<span class="hljs-built_in">nextDouble</span>();<br><br>        <span class="hljs-comment">//write your code here......</span><br>        <span class="hljs-type">double</span> v = d + <span class="hljs-number">0.5</span>;<br>        <span class="hljs-type">int</span> i= (<span class="hljs-type">int</span>) v;<br>        System.out.<span class="hljs-built_in">println</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码分析</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt;<br> <span class="hljs-comment">//创建scanner引用 压入到操作数栈 1</span><br> <span class="hljs-number">3</span> dup<br> <span class="hljs-comment">//复制操作数栈顶的Scanner对象引用 并将该引用再次压入操作数栈。2</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt;<br> <span class="hljs-comment">//获取输入流 压入到操作数栈 3</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">//调用构造方法 System.in 作为参数</span><br><br><span class="hljs-number">10</span> astore_1 -弹出 <span class="hljs-number">1</span><br><span class="hljs-number">11</span> aload_1  <span class="hljs-number">2</span><br><span class="hljs-comment">//int *1=&amp;input;</span><br><span class="hljs-comment">//int **1=&amp;1;--存到操作数栈</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextDouble : ()D&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextDouble 方法，读取输入的 double 类型的数值，将其压入操作数栈。 3</span><br><span class="hljs-number">15</span> dstore_2 弹出-数据存储到索引 <span class="hljs-number">2</span><br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>      <br>       <span class="hljs-keyword">double</span> d= scanner.nextDouble();<br>       <br>       <br><span class="hljs-number">16</span> dload_2<br>压入操作数栈- <span class="hljs-number">3</span><br><span class="hljs-number">17</span> ldc2_w #<span class="hljs-number">6</span> &lt;<span class="hljs-number">0.5</span>&gt;<br>将常量池中 #<span class="hljs-number">6</span> 位置的 <span class="hljs-keyword">double</span> 类型常量 <span class="hljs-number">0.5</span> 压入操作数栈。 <span class="hljs-number">4</span><br><span class="hljs-number">20</span> dadd<br>相加<br><span class="hljs-number">21</span> dstore <span class="hljs-number">4</span> <span class="hljs-number">3</span><br>弹出 最新的相加值 存储到槽<span class="hljs-number">4</span><br><span class="hljs-number">23</span> dload <span class="hljs-number">4</span> <span class="hljs-number">4</span><br>再压入操作数栈<br><span class="hljs-number">25</span> d2i<br>将栈顶的 <span class="hljs-keyword">double</span> 类型数值转换为 <span class="hljs-keyword">int</span> 类型（取整）。<br><span class="hljs-number">26</span> istore <span class="hljs-number">6</span> <span class="hljs-number">3</span><br>弹出 存储到 <span class="hljs-number">6</span><br><span class="hljs-number">28</span> getstatic #<span class="hljs-number">8</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">31</span> iload <span class="hljs-number">6</span>  <span class="hljs-number">4</span> 弹出 存储槽<span class="hljs-number">6</span> <br><span class="hljs-number">33</span> invokevirtual #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.<span class="hljs-keyword">println</span> : (I)V&gt; 打印<br><span class="hljs-number">36</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h6><p>不使用第三方变量交换值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>        <span class="hljs-comment">//write your code here.......</span><br>        a=a+b;<br>        b=a-b;<br>        a=a-b;<br><br>        System.out.println(a+<span class="hljs-string">&quot; &quot;</span>+b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2048实现秒过关</title>
    <link href="/2024/09/06/2048/"/>
    <url>/2024/09/06/2048/</url>
    
    <content type="html"><![CDATA[<h1 id="so分析"><a href="#so分析" class="headerlink" title="so分析"></a>so分析</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/041e24788116aad3e5b9d66d153c0597.png" alt="041e24788116aad3e5b9d66d153c0597"></p><p>hook其参数-得知</p><p>修改.</p><p>text:000A1CE8 01 32                         ADDS    R2, #1</p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5997fd65e2f23df2dedd500f805418d1.png" alt="5997fd65e2f23df2dedd500f805418d1"></p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0c2eab99470f976c0cc393352fa1b15.png" alt="b0c2eab99470f976c0cc393352fa1b15"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240908230448204.png" alt="`image-20240908230448204`"></p><p>修改盒子初始值达到快速过关</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三级缓存解决循环依赖</title>
    <link href="/2024/09/06/huanchun/"/>
    <url>/2024/09/06/huanchun/</url>
    
    <content type="html"><![CDATA[<h1 id="循环依赖解决"><a href="#循环依赖解决" class="headerlink" title="循环依赖解决"></a>循环依赖解决</h1><h6 id="1-了解循环依赖问题"><a href="#1-了解循环依赖问题" class="headerlink" title="1.了解循环依赖问题"></a>1.了解循环依赖问题</h6><p>在 Spring 中，如果一个 bean 尝试将自身引用注入到自身中，通常会引发循环依赖。</p><p>首先搞清楚什么是循环依赖：</p><p>两个Bean，A依赖B，B依赖A就构成了循环依赖，如下图：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240606225332349.png" alt="image-20240606225332349"></p><p>同样的道理，如果在A中注入A表示A依赖A，也就构成了循环依赖。</p><p>创建A实例–》初始化A–》注入B–》创建B实例–》初始化B–》注入A</p><p>A-初始化-需要初始化完成bean-&gt;初始化B-&gt;b也要初始化其中的bean-》A-初始化-</p><p>卡入死循环</p><h6 id="2-避免循环依赖流程"><a href="#2-避免循环依赖流程" class="headerlink" title="2.避免循环依赖流程"></a>2.避免循环依赖流程</h6><p>针对循环依赖的问题Spring会上边的过程调整为下边的流程：</p><p>创建A实例– -》创建B实例–》在B中注入A—*<code>B的成员保存A的内存地址</code>*》B初始化—成员赋值了》在A中注入B–》A初始化。</p><p><strong>实例-内存地址</strong>       </p><p>A -&gt;注入B-&gt;初始化</p><p>B-&gt;A(地址)–{最后存储的就是A}-&gt;初始化</p><p>延迟了A的初始化只保留了地址</p><h6 id="3-三级缓存解决循环依赖"><a href="#3-三级缓存解决循环依赖" class="headerlink" title="3.三级缓存解决循环依赖"></a>3.三级缓存解决循环依赖</h6><p>Spring是如何做到呢？</p><p>Spring会延迟初始化，B需要注入A,此时Spring会先实例化A，把一个半成品A注入给B，延迟A的初始化。</p><p>具体的底层原理是Spring通过三级缓存实现：</p><blockquote><p>1）<strong>singletonObjects缓存</strong>：这是 Spring 容器<strong>用来缓存完全初始化好的****单例</strong> <strong>bean 实例的缓存</strong>。当一个 bean 初始化完成后，它会被放入singletonObjects缓存中。这个缓存是单例 bean 的最终缓存，也是 BeanFactory 中保存 bean 的主要缓存。</p><p>2）<strong>earlySingletonObjects缓存</strong>：这个缓存是<strong>用来保存被实例化但还未完全初始化的 bean 的引用</strong>。当一个 bean 已经被实例化（但还未初始化）时，它会被放入earlySingletonObjects缓存中。</p><p>给空间了-但是类数据没有放入</p><p>3）<strong>singletonFactories缓存</strong>：这个缓存保存的是用于创建 bean 实例的 ObjectFactory，用于支持循环依赖的延迟初始化。当一个 bean 被实例化，但尚未完全初始化时，Spring 会在singletonFactories缓存中查找该 bean 的ObjectFactory。这个ObjectFactory会在需要时被调用来完成 bean 的初始化。</p></blockquote><p>类工厂</p><p>Spring 通过这三级缓存的组合，来确保在循环依赖情况下，能够正常初始化 bean。当两个或多个 bean 之间存在循环依赖时，Spring  使用 singletonFactories 缓存来存储 bean 的提供者（ObjectFactory）。当一个 bean  在初始化过程中需要依赖另一个还未初始化的 bean 时，Spring 会调用相应的 ObjectFactory 来获取对应的 bean  实例，这样就实现了循环依赖的延迟初始化。一旦 bean 初始化完成，它就会被移动到singletonObjects缓存中。</p><p>举例：</p><p>创建A实例–》创建B实例–》在B中注入A–》B初始化—》在A中注入B–》A初始化。</p><p>创建A实例（半成品），在earlySingletonObjects放入A半成品。</p><p>创建B实例（半成品），在earlySingletonObjects放入B半成品。</p><p>在B中注入A，通过singletonFactories拿到A的对象工厂，通过对象工厂拿到A的半成品注入到B中。</p><p>B初始化完成，将B从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>在A中注入B-，通过singletonFactories拿到B的对象工厂，通过对象工厂拿到B的成品注入到A中。</p><p>A初始化完成，将A从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>A是一片空间-当初始化完成后-地址就有数据了</p><p>说来说去 就是个内存地址的问题</p><p>**构造参数注入</p><h6 id="4-构造循环依赖解决"><a href="#4-构造循环依赖解决" class="headerlink" title="4.构造循环依赖解决"></a>4.构造循环依赖解决</h6><p>虽然Spring可以解决上边通过成员变量注入引发的循环依赖问题，但是<strong>通过构造参数注入引发的循环依赖问题是会报错。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e9464064bc6f0632ead497e183ca6d3a-1717687581273-4.png" alt="e9464064bc6f0632ead497e183ca6d3a"></p><p>因为创建C需要调用构造方法，而构造方法需要依赖D，此时C是无法实例化的</p><p>上边分析Spring解决循环依赖是通过延迟初始化，当出现循环依赖问题可以注入一个半成品</p><p><strong>但是如上半成品也无法生成</strong></p><p>如何解决这种通过构造参数注入导致的循环依赖问题呢？</p><p>可以在C或D的任意一方注入另一方的代理对象而不是注入原始对象，如下：</p><p>假设在C的构造方法中注入D的代理对象可以写为：</p><p>在构造参数前加@Lazy注解，表示注入D的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-meta">@Lazy</span> D d)</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏逆向思路cpp</title>
    <link href="/2024/09/06/test2/"/>
    <url>/2024/09/06/test2/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏逆向思路cpp"><a href="#游戏逆向思路cpp" class="headerlink" title="游戏逆向思路cpp"></a>游戏逆向思路cpp</h1><p>游戏引擎 :cocos2dx<br>逆向思路</p><p>libcocos2dcpp.so  libgame.so     &#x2F;data&#x2F;app-lib&#x2F;包名<br>1.字符串信息查找关键函数<br>2.send函数进行定位<br>3.hook hook函数修改参数-返回值-或者多次调用-或者返回-根据情况</p><p><img src="https://s2.loli.net/2024/09/07/yZxfF9IcLlMbUzW.png" alt="2024-09-07 222659.png"></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础笔记目录</title>
    <link href="/2024/09/06/java/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/"/>
    <url>/2024/09/06/java/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础笔记目录"><a href="#java基础笔记目录" class="headerlink" title="java基础笔记目录"></a>java基础笔记目录</h1><p>ps:很遗憾，由于第一次的笔记很短暂。并不怎么深入<br>后续会更新String流处理 包括多线程 线程共享 线程安全 等<br>还有网络编程-各类心跳处理机制-多线程服务器-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Java.png" alt="Java">通过网盘分享的文件：java2笔记<br>链接: <a href="https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5">https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5</a> 提取码: vka5</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
