<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mybits框架</title>
    <link href="/2024/09/11/mybits/"/>
    <url>/2024/09/11/mybits/</url>
    
    <content type="html"><![CDATA[<h1 id="mybits框架"><a href="#mybits框架" class="headerlink" title="mybits框架"></a>mybits框架</h1><h1 id="Mybits"><a href="#Mybits" class="headerlink" title="Mybits"></a>Mybits</h1><h4 id="了解mybits"><a href="#了解mybits" class="headerlink" title="了解mybits"></a>了解mybits</h4><blockquote><p>“MyBatis” 是一个用于 Java 的持久层框架，它简化了数据库访问的过程。其主要作用包括：</p><ol><li><strong>简化数据库操作</strong>：MyBatis 可以通过 XML 或注解的方式，将 SQL 语句直接写在代码中，避免了使用传统 JDBC 时需要编写大量重复的代码，使得数据库操作更加简洁。</li><li><strong>灵活的 SQL 映射</strong>：MyBatis 允许开发人员编写自定义的 SQL 语句，然后将其与 Java 对象映射。这种方式提供了高度的灵活性，特别适用于复杂的查询操作。</li><li><strong>自动映射结果集</strong>：MyBatis 能够将 SQL 查询的结果集自动映射到 Java 对象中，这样开发者不需要手动解析 ResultSet，大大简化了开发过程。</li><li><strong>动态 SQL 支持</strong>：MyBatis 提供了一种动态 SQL 的能力，通过标签（如 <code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code> 等）来生成动态 SQL 语句，满足各种复杂的查询需求。</li></ol><p>MyBatis 可以进行数据库操作的原因是，它封装了 <strong>JDBC</strong> 操作，将 SQL 查询的执行与结果的处理自动化，并且与 Java 应用程序的对象模型无缝集成。这使得开发人员可以专注于业务逻辑，而不需要关心底层的数据库操作细节。</p></blockquote><h4 id="mybits原理"><a href="#mybits原理" class="headerlink" title="mybits原理"></a>mybits原理</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6daa7e673d972cdd3a904b3bc10d63ee.png" alt="6daa7e673d972cdd3a904b3bc10d63ee"></p><blockquote><p><strong>MyBatis 配置文件</strong>：</p><ul><li><code>SqlMapConfig.xml</code> 是 MyBatis 的全局配置文件，用于配置 MyBatis 的运行环境等信息。</li><li><code>mapper.xml</code> 是用于 SQL 语句和对象映射的文件，这些文件配置了操作数据库的 SQL 语句，需要在 <code>SqlMapConfig.xml</code> 中加载这些文件。</li></ul></blockquote><blockquote><p><strong>通过 MyBatis 环境配置创建 SqlSessionFactory（会话工厂）</strong>：</p><ul><li>通过 MyBatis 的环境配置信息构造一个 <code>SqlSessionFactory</code>，它用于创建会话（<code>SqlSession</code>）实例。</li></ul></blockquote><blockquote><p><strong>会话（SqlSession）的作用</strong>：</p><ul><li>由会话工厂创建的 <code>SqlSession</code> 用于执行数据库操作，开发者在代码中使用 <code>SqlSession</code> 对象来执行 SQL 语句。</li></ul></blockquote><blockquote><p><strong>Executor 执行器</strong>：</p><ul><li>MyBatis 底层定义了 <code>Executor</code> 执行器接口，负责接收并执行 SQL 语句，有两个实现：一个是批量执行器（Batch Executor），一个是缓存执行器（Caching Executor）。</li></ul></blockquote><blockquote><p><strong>Mapped Statement</strong>：-mapper</p><ul><li><code>Mapped Statement</code> 是 MyBatis 底层封装的对象，包含了 MyBatis 配置信息、SQL 映射信息等。</li><li>在 <code>mapper.xml</code> 文件中，每个 SQL 语句对应一个 <code>Mapped Statement</code> 对象，SQL 的 <code>id</code> 对应 Mapped Statement 的 <code>id</code>。</li></ul></blockquote><blockquote><p><strong>输入参数映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输入参数进行定义，包括 <code>HashMap</code>、基本类型、POJO（普通的 Java 对象）。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 前将输入的 Java 对象映射为 SQL 中的参数，类似于 JDBC 编程中 <code>PreparedStatement</code> 的设定参数的过程。</li></ul></blockquote><blockquote><p><strong>输出结果映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输出结果进行定义，包括 <code>HashMap</code>、基本类型、POJO。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 后将输出结果映射至 Java 对象，类似于 JDBC 编程中结果集（<code>ResultSet</code>）的解析处理过程。</li></ul></blockquote><h4 id="Mybits入门"><a href="#Mybits入门" class="headerlink" title="Mybits入门"></a>Mybits入门</h4><h6 id="1-mybits使用"><a href="#1-mybits使用" class="headerlink" title="1.mybits使用"></a>1.mybits使用</h6><p>1.创建工程<br>2.导入依赖<br>3.创建配置文件</p><p>以下是一个 MyBatis 使用案例，包括配置文件 <code>mybatis-config.xml</code>、映射文件 <code>UserMapper.xml</code>、实体类 <code>User</code>、映射接口 <code>UserMapper</code>，以及一个使用 MyBatis 的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;!DOCTYPE configuration<br>  PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br>  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;<br>&lt;configuration&gt;<br>  &lt;!-- 环境配置 --&gt;<br>  &lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>    &lt;environment id=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>      &lt;!-- 使用 JDBC 事务管理器 --&gt;<br>      &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span> /&gt;<br>      &lt;!-- 配置数据源 --&gt;<br>      &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb?useSSL=false&amp;serverTimezone=UTC&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;root&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;password&quot;</span> /&gt;<br>      &lt;/dataSource&gt;<br>    &lt;/environment&gt;<br>  &lt;/environments&gt;<br>  <br>  &lt;!-- 指定映射文件 --&gt;<br>  &lt;mappers&gt;<br>    &lt;mapper resource=<span class="hljs-string">&quot;com/example/mapper/UserMapper.xml&quot;</span> /&gt;<br>  &lt;/mappers&gt;<br>&lt;/configuration&gt;<br><br></code></pre></td></tr></table></figure><p> 映射文件 <code>UserMapper.xml</code></p><p>这个文件包含 SQL 语句和 Java 方法的映射。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="language-xml">  ///对应路径映射</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="language-xml">///</span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 插入用户 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="language-xml">    INSERT INTO user (name, age) VALUES (#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">, #</span><span class="hljs-template-variable">&#123;age&#125;</span><span class="language-xml">)</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>映射接口 <code>UserMapper</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//会生成代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserMapper</span> &#123;<br>    <span class="hljs-built_in">void</span> insertUser(User user);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程</p><p><strong>配置加载</strong>：读取 MyBatis 配置文件，初始化 <code>SqlSessionFactory</code>。</p><p><strong>会话创建</strong>：通过 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code>，作为数据库操作的会话</p><p><strong>Mapper 映射</strong>：获取映射接口（Mapper）的代理对象，映射接口方法与 SQL 语句对应。</p><blockquote><p>通过 <code>SqlSession</code> 实例的 <code>getMapper(UserMapper.class)</code> 方法，获取 <code>UserMapper</code> 映射接口的代理对象。</p><p>MyBatis 底层会根据 <code>UserMapper.xml</code> 映射文件中定义的 SQL 语句和 <code>UserMapper</code> 接口中的方法进行绑定。</p></blockquote><p><strong>执行 SQL</strong>：使用 <code>Executor</code> 执行映射 SQL 语句，对数据库进行 CRUD 操作。</p><p><strong>参数映射</strong>：在执行 SQL 前，将输入参数映射到 SQL 语句中；执行 SQL 后，将结果集映射为 Java 对象。</p><p><strong>事务控制</strong>：通过 <code>SqlSession</code> 的 <code>commit()</code> 和 <code>rollback()</code> 控制事务。</p><p><strong>会话关闭</strong>：操作完成后，关闭 <code>SqlSession</code>，释放资源。</p><h6 id="2-占位符"><a href="#2-占位符" class="headerlink" title="2.占位符"></a>2.占位符</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;insertUser&quot; parameterType=&quot;com.example.model.User&quot;&gt;    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (<span class="hljs-type">name</span>, age) <span class="hljs-keyword">VALUES</span> (#&#123;<span class="hljs-type">name</span>&#125;, #&#123;age&#125;)  &lt;/<span class="hljs-keyword">insert</span>&gt;<br></code></pre></td></tr></table></figure><p>#{} 实现向占位符添加值-自动进行java类型和jdbc类型转换-可以防止sql注入-可接收简单类型值和pojo属性值</p><p> ￥s{}拼接sql传&#x3D;不进行类型转换&#x3D;</p><h6 id="3-parameterType-resultType"><a href="#3-parameterType-resultType" class="headerlink" title="3.parameterType-resultType"></a>3.parameterType-resultType</h6><p>parameterType-传入的参数类型</p><p>resultType返回值类型</p><h6 id="4-selectOne和selectList"><a href="#4-selectOne和selectList" class="headerlink" title="4..selectOne和selectList"></a>4..selectOne和selectList</h6><p>selectOne查询一条记录</p><p>selectList查询多条记录</p><h6 id="5-mybits-主键"><a href="#5-mybits-主键" class="headerlink" title="5.mybits-主键"></a>5.mybits-主键</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f2a7da3c2707062c15cbbfc7c5f51f9.png" alt="3f2a7da3c2707062c15cbbfc7c5f51f9"></p><p>使用</p><p>SqlSession.insert(“test.insertUser”,user);</p><p>selectkey-&gt;select Last_INSERT_ID–用户添加后自动返回主键-</p><p>—返回主键 </p><p>uuid生成主键</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69eddd3b9e877d74e91d107aad7b6940.png" alt="69eddd3b9e877d74e91d107aad7b6940"></p><h6 id="6-mybits-删除"><a href="#6-mybits-删除" class="headerlink" title="6.mybits-删除"></a>6.mybits-删除</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f16033409c2f9eb00418ede68cffc228.png" alt="f16033409c2f9eb00418ede68cffc228"></p><p>sqlSession.delete(“test.deleteUser”,39);</p><h6 id="7-mybiits-更新用户"><a href="#7-mybiits-更新用户" class="headerlink" title="7.mybiits-&gt;更新用户"></a>7.mybiits-&gt;更新用户</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95864300169e8c1df1b79f4d0102505e.png" alt="95864300169e8c1df1b79f4d0102505e"></p><p>sqlSession.update(“test.updateUser”,user);</p><h4 id="mybits-Dao开发"><a href="#mybits-Dao开发" class="headerlink" title="mybits-Dao开发"></a>mybits-Dao开发</h4><h6 id="1-Dao开发配置入门"><a href="#1-Dao开发配置入门" class="headerlink" title="1.Dao开发配置入门"></a>1.Dao开发配置入门</h6><p>Impl层</p><p>前言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个请求 都会创建 SqlSessionFactory  SqlSessionFactoryBuilder-影响资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61928ee9fd81bc3528cdddda96a0d8be.png" alt="61928ee9fd81bc3528cdddda96a0d8be"></p><p><code>SqlSessionFactoryBuilder</code> 只是一个构建器，它的生命周期是短暂的，只需在创建 <code>SqlSessionFactory</code> 时使用一次。创建好 <code>SqlSessionFactory</code> 后，就不需要再保留 <code>SqlSessionFactoryBuilder</code> 实例。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a59f5c6efc930fdf24b4753e2d6c0165.png" alt="a59f5c6efc930fdf24b4753e2d6c0165"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8f73ed7437e15b3fd61ff570da0b265.png" alt="e8f73ed7437e15b3fd61ff570da0b265"></p><p>解决多次创建后代码–bean-单例bena实现 -如图还未bean 也就是简单的单例模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f89faf38a206b6547777bbea1aa5e14.png" alt="8f89faf38a206b6547777bbea1aa5e14"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d751486c93be306c26947fa45914c821.png" alt="d751486c93be306c26947fa45914c821"></p><p>dao层面-有非常多的重复代码-比如释放资源-拿取selSession-</p><h6 id="2-Mapper开发"><a href="#2-Mapper开发" class="headerlink" title="2.Mapper开发"></a>2.Mapper开发</h6><p>mapper代理方法（程序员只需要mapper接口）<br>程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a8d02d56bb89ffa8d43fd55385bb115a.png" alt="a8d02d56bb89ffa8d43fd55385bb115a"></p><p>需要一一对应进行映射</p><p>也就是mapper-函数映射到xml文件中–需要进行一一对应</p><h6 id="3-mapper代理"><a href="#3-mapper代理" class="headerlink" title="3.mapper代理"></a>3.mapper代理</h6><p>xml定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab74d1f694af3fb743e294f135a4041a.png" alt="ab74d1f694af3fb743e294f135a4041a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5eea9b8887ac8e1894fd8520adf4dcec.png" alt="5eea9b8887ac8e1894fd8520adf4dcec"></p><p>加载</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/922160ede6004b8fb5aea389641d68c2.png" alt="922160ede6004b8fb5aea389641d68c2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45e07e2b4ddd60cd021dcc2f31c066c8.png" alt="45e07e2b4ddd60cd021dcc2f31c066c8"></p><p>—如图–userMapper-来调用方法0由sqlSession-来生成代理对象</p><p>   代理对象内部调用selectOne或selectList<br>如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。<br>如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库</p><hr><p>mapper接口方法参数只能有一个，系统是否不利于扩展维护。</p><p>系统 框架中，dao层的代码是被业务层公用的。<br>即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。</p><p>注意：持久层方法的参数可以包装类型、map。。。，service方法中建议不要使用包装类型（不利于业务层的可扩展）。</p><h6 id="4-l配置"><a href="#4-l配置" class="headerlink" title="4.l配置"></a>4.l配置</h6><p>SqlMapConfig.xm</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a05192e83f10245208db8c09e74468f.png" alt="0a05192e83f10245208db8c09e74468f"></p><p> properties属性</p><p>将数据库连接参数只配置在db.properties中，原因：方便对参数进行统一管理，其它xml可以引用该db.properties</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5afb2ae748e665a0957970ae4a909e5d.png" alt="5afb2ae748e665a0957970ae4a909e5d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a29db16646c4c42d5d9896bd292741d.png" alt="2a29db16646c4c42d5d9896bd292741d"></p><p> settings全局参数配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0070c06383100dde987ddc21ea4a4b3a.png" alt="0070c06383100dde987ddc21ea4a4b3a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62169f009b19205c6220b75f7a4bcb5a.png" alt="62169f009b19205c6220b75f7a4bcb5a"></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><blockquote><p>类型别名（Type Alias）是为了简化和减少 XML 配置文件中的类全限定名而引入的一种便捷方式。通过定义类型别名，你可以使用更短的名称来引用 Java 类，从而使得 Mapper XML 文件更简洁和易读。</p></blockquote><blockquote><p><strong>定义类型别名</strong>：在 MyBatis 配置文件 (<code>mybatis-config.xml</code>) 中，可以为 Java 类指定一个别名。</p><p><strong>使用类型别名</strong>：在 Mapper XML 文件中使用别名来代替类的全限定名。</p></blockquote><h6 id="1-普通类型别名"><a href="#1-普通类型别名" class="headerlink" title="1.普通类型别名"></a>1.普通类型别名</h6><p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p><p>自定义别名-当我们参数的pojo大部分一致的时候 定义别名可以减少代码繁杂</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e1d9343cb1eb8b59a484042657ed0f6.png" alt="8e1d9343cb1eb8b59a484042657ed0f6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7ae2a441a846072ed1c64575f9fa045.png" alt="d7ae2a441a846072ed1c64575f9fa045"></p><p>批量别名-常用-扫描po文件 给所有pojo注册别名</p><h6 id="3-mybits-类型处理器"><a href="#3-mybits-类型处理器" class="headerlink" title="3.mybits 类型处理器"></a>3.mybits 类型处理器</h6><blockquote><p>在 MyBatis 中，<strong>类型处理器（Type Handlers）</strong> 用于处理 Java 类型与 JDBC 类型之间的转换。它们在 MyBatis 从数据库中读取数据（结果集映射）或将数据写入数据库（参数映射）时起着关键作用。<br>例子</p><p><strong>Java 类型到 JDBC 类型的转换</strong>：将 Java 对象类型转换为 SQL 参数，发送到数据库。例如，将 <code>Integer</code> 类型的 Java 对象转换为数据库的 <code>INTEGER</code> 类型。</p><p><strong>JDBC 类型到 Java 类型的转换</strong>：将从数据库查询的结果转换为 Java 对象。例如，将数据库查询结果中的 <code>INTEGER</code> 类型转换为 Java 的 <code>Integer</code> 或 <code>int</code>。</p></blockquote><h6 id="4-mappers-映射配置"><a href="#4-mappers-映射配置" class="headerlink" title="4.  mappers 映射配置"></a>4.  mappers 映射配置</h6><ol><li><p>通过resource加载单个映射文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/982f90b2b3ead1f97c7560fa9326b4fe.png" alt="982f90b2b3ead1f97c7560fa9326b4fe"></p></li><li><p>通过mapper接口加载单个mapper</p></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5c7c2136386dd9b06663cdf3631c412c.png" alt="5c7c2136386dd9b06663cdf3631c412c"></p><p>按照上边的规范，将mapper.java和mapper.xml放在一个目录 ，且同名</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de35b2cb9ffb9c7af48ac36f9586f000.png" alt="de35b2cb9ffb9c7af48ac36f9586f000"></p><p>3 .  批量加载mapper(推荐使用)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3cc05d3339e8ebae691aaac0073392fa.png" alt="3cc05d3339e8ebae691aaac0073392fa"></p><p>4.输入映射</p><p>通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/80e95beb88e2a055ee91e47d12c5bc6e.png" alt="80e95beb88e2a055ee91e47d12c5bc6e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/16e891a8f40288f28679241a5f4a6dd0.png" alt="16e891a8f40288f28679241a5f4a6dd0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eec86ff7c8c1cc0c909076d9d0827b36.png" alt="eec86ff7c8c1cc0c909076d9d0827b36"></p><h5 id="Mybits高级"><a href="#Mybits高级" class="headerlink" title="Mybits高级"></a>Mybits高级</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ec78fe0039ba4d7a0f0e93edde34ffd.png" alt="3ec78fe0039ba4d7a0f0e93edde34ffd"></p><h6 id="1-一对一查询"><a href="#1-一对一查询" class="headerlink" title="1.一对一查询"></a>1.一对一查询</h6><p>查询订单信息，关联查询创建订单的用户信息<br>sql语句<br>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS,USER WHRE ORDERS.USER_ID&#x3D;USER.ID;</p><p>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS JOIN USER ON ORDERS.USER_ID&#x3D;USER.ID;</p><p>实现该查询</p><p>1.创建pojo</p><p>2.mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;SELECT ID=<span class="hljs-string">&quot;FINDorderUser&quot;</span> resultType=<span class="hljs-string">&#x27;pojo&#x27;</span>&gt;<br>select orders.*,user.username,user.sexmuser.address from orders,user WHRE ORDERS.USER_ID=USER.ID;<br><br>&lt;/lelect&gt;<br></code></pre></td></tr></table></figure><p>3.mapper.java</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5efc0b312fab4d35aa879dd46fae93a0.png" alt="5efc0b312fab4d35aa879dd46fae93a0"></p><p>这个时候-只需要获取即可使用该sql语句<br>–    使用resultMap映射的思路<br>使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f8a7cbf8b3875476e103b0733ac7f7f5.png" alt="f8a7cbf8b3875476e103b0733ac7f7f5"></p><p>定义resultMap</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ee4c7227c01ec39fa1bfa811976628dc.png" alt="ee4c7227c01ec39fa1bfa811976628dc"></p><p>S定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e92a4eb35812042de17a350aa5405bc7.png" alt="e92a4eb35812042de17a350aa5405bc7"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55906bbde71b042c14daf40325e2734a.png" alt="55906bbde71b042c14daf40325e2734a"></p><h6 id="2-一对多查询"><a href="#2-一对多查询" class="headerlink" title="2.一对多查询"></a>2.一对多查询</h6><p>查询订单及订单明细的信息。<br>SELECT<br>  orders.*,<br>  USER.username,<br>  USER.sex,<br>  USER.address,<br>  orderdetail.id orderdetail_id,<br>  orderdetail.items_id,<br>  orderdetail.items_num,<br>  orderdetail.orders_id<br>from<br> orders,<br>  USER,<br>  orderdetail<br>whrer<br>orders.user_id &#x3D; user.id AND orderdetail.orders_id&#x3D;orders.id</p><hr><hr><hr><hr><p>使用resultType将上边的 查询结果映射到pojo中，订单信息的就是重复<br>要求：<br>对orders映射不能出现重复记录。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/affb5c09f23f5c042208c4323940698f.png" alt="affb5c09f23f5c042208c4323940698f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6c2accdfd7490aa05255bb2aaa6f9807.png" alt="6c2accdfd7490aa05255bb2aaa6f9807"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7c536bcee1988bbddfd784e6de1204ec.png" alt="7c536bcee1988bbddfd784e6de1204ec"></p><p>map-&gt;映射关系<br>将数据库字段-&gt;对象的字段中<br>同时会指定映射的属性和集合中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/44c0fb3e4d6de667636651db0026ad85.png" alt="44c0fb3e4d6de667636651db0026ad85"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e59fc4b2bdacf3621426fec322ad24c3.png" alt="e59fc4b2bdacf3621426fec322ad24c3"></p><h6 id="3-多对多查询案例"><a href="#3-多对多查询案例" class="headerlink" title="3.多对多查询案例"></a>3.多对多查询案例</h6><hr><p>查询主表是：用户表<br>关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：<br>orders、orderdetail、items</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5d503cb8e549dc16e9fb2f3d9f972be9.png" alt="5d503cb8e549dc16e9fb2f3d9f972be9"></p><p>映射</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c9ea555f307b956af31dbce8415170.png" alt="b4c9ea555f307b956af31dbce8415170"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb9ca63b64a989b5b020ebe231fb555d.png" alt="bb9ca63b64a989b5b020ebe231fb555d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/314f0ba042424242c4135b4302a65f13.png" alt="314f0ba042424242c4135b4302a65f13"></p><h4 id="resultmap总结"><a href="#resultmap总结" class="headerlink" title="resultmap总结"></a>resultmap总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/863ba0486e9be85c0c64ea7eccdead9a.png" alt="863ba0486e9be85c0c64ea7eccdead9a"></p><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>如果查询两张表-如果只需要查询一张表即可满足条件的情况下-那么就不需要查询下一章表<br>关联查询-&gt;单表查询<br>1.使用association实现延迟加载</p><p>查询订单并且关联查询用户信息</p><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf67701ceb62d4d73d31491daee4f282.png" alt="cf67701ceb62d4d73d31491daee4f282"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>resultMap type<span class="hljs-operator">=</span>&quot;orders&quot; id&quot;map&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--对订单信息进行映射配置  --&gt;</span><br>            <span class="hljs-operator">&lt;</span>id <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;id&quot; property<span class="hljs-operator">=</span>&quot;id&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot; property<span class="hljs-operator">=</span>&quot;userId&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;number&quot; property<span class="hljs-operator">=</span>&quot;number&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;createtime&quot; property<span class="hljs-operator">=</span>&quot;createtime&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;note&quot; property<span class="hljs-operator">=</span>&quot;note&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 实现对用户信息进行延迟加载</span><br>            <span class="hljs-keyword">select</span>：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）<br>            要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace<br>            <span class="hljs-keyword">column</span>：订单信息中关联用户信息查询的列，是user_id<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span>association property<span class="hljs-operator">=</span>&quot;user&quot; javaType<span class="hljs-operator">=</span>&quot;user&quot;<br>  <span class="hljs-keyword">select</span><span class="hljs-operator">=</span>&quot;cn.itcast.mybatis.mapper.UserMapper.findUserById&quot; <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>association<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>resultMap<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62a5de17ceb2efb1cb23ce43c27b6311.png" alt="62a5de17ceb2efb1cb23ce43c27b6311"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/83717cda1037366a4cc5b930afeefd1d.png" alt="83717cda1037366a4cc5b930afeefd1d"></p><p>也就是-我们编译器没有访问到user内容就不会去加载吗 2.延迟加载配置<br>mybits默认没有开启延迟加载-需要自己手动开启<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3055bee2e2c581a6d17f4c89b04fb4c.png" alt="img"><br>3.</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41591507899361a44254c502150f44f5.png" alt="img"></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h6 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h6><p>第一层查询-如果没有-从数据库查 再添加进缓存中<br>sqlSession去执行增删改-清空一级缓存<br>2次发起-&gt;缓存有直接返回</p><p>redis缓存思路</p><p>mybits默认支持一级缓存<br>Sqlsession sqlsession&#x3D;sqlsessionfactry.ioensession();<br>UserMapper userMapper&#x3D;sqlsession.getMapper(usermapper.class);<br>User user&#x3D;usermapper.finduserbyid(1);第一层查询-如果没有-从数据库查 再添加进缓存中</p><p>User user&#x3D;usermapper.finduserbyid(1); 2次发起-&gt;缓存有直接返回</p><p>usermapper.updateuser(user1);sqlSession去执行增删改-清空一级缓存</p><p>一级缓存应用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ada7a24f8aeae89ccbcdb1d4e103400.png" alt="2ada7a24f8aeae89ccbcdb1d4e103400"></p><h6 id="2-2级缓存"><a href="#2-2级缓存" class="headerlink" title="2.2级缓存"></a>2.2级缓存</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0e49bf45af19e07fa4ee06a0b7335180.png" alt="0e49bf45af19e07fa4ee06a0b7335180"></p><p>二级缓存范围大-多个sqlsession可以共享一个usermapper二级缓存区域<br>二级缓存区域是按照namespace分-其他不同的mapper也有自己的二级缓存区域</p><p>一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同 的二级缓存区域中。</p><p>开启二级缓存<br>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a1dafc8e5fd22b6cf93d8e8aae31c4e.png" alt="0a1dafc8e5fd22b6cf93d8e8aae31c4e"></p><h4 id="mybits整合ehcache"><a href="#mybits整合ehcache" class="headerlink" title="mybits整合ehcache"></a>mybits整合ehcache</h4><p>mybits整合ehcache<br>ehcache是一个分布式缓存框架<br>缓存的数据-进行集中管理-分布式集中访问 整合方法</p><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。<br>mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45eaa4a652048030f4b17712288fbc56.png" alt="img"><br>ehcache配置<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/687820640853663a040469325cfb6a5b.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68e729a0da44d9d806007bc8178478d5.png" alt="img"></p><h6 id="二级应用场景"><a href="#二级应用场景" class="headerlink" title="二级应用场景"></a>二级应用场景</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fcf22de20a326941945b31d902fd8608.png" alt="fcf22de20a326941945b31d902fd8608"></p><h4 id="Mybits整合Spring"><a href="#Mybits整合Spring" class="headerlink" title="Mybits整合Spring"></a>Mybits整合Spring</h4><h6 id="1-bean配置"><a href="#1-bean配置" class="headerlink" title="1.bean配置"></a>1.bean配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/af73e0779b8e3e14680320c06a1d3e29_720.jpg" alt="af73e0779b8e3e14680320c06a1d3e29_720"></p><p>bean的配置</p><p> user.xml</p><p>![b13f504c2f17c64e26097dff4834aed8](G:\360MoveData\Users\nixg\Documents\Tencent Files\2760045743\nt_qq\nt_data\Pic\2024-04\Ori\b13f504c2f17c64e26097dff4834aed8.jpg)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/92c073b510f63afca1597faf32e1d6be.jpg" alt="92c073b510f63afca1597faf32e1d6be"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68ba41b8d0cb810134cb064e6eed67c5.jpg" alt="68ba41b8d0cb810134cb064e6eed67c5"></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4b6944e971eb9c6af10fdffe3f6cd943.jpeg" alt="4b6944e971eb9c6af10fdffe3f6cd943"></strong></p><p>以上bean去读xml配置<br>然后mybits去注册 在接口实现类进行查询<br>之后注册为bean</p><p>后续直接使用</p><h6 id="2-mapper"><a href="#2-mapper" class="headerlink" title="2.mapper"></a>2.mapper</h6><p>还是要在同级目录以下 </p><p>注册为bean 扫描xml文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dad5b70ff70703d57a807c3d9a740926_720.jpg" alt="dad5b70ff70703d57a807c3d9a740926_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/38fcb7f3871e63a3686786685b0671b7.jpg" alt="38fcb7f3871e63a3686786685b0671b7"></p>]]></content>
    
    
    <categories>
      
      <category>mybits</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java字节码</title>
    <link href="/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <url>/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>1</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架</title>
    <link href="/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h1 id="Spring复习"><a href="#Spring复习" class="headerlink" title="Spring复习"></a>Spring复习</h1><h4 id="1-了解Spirng"><a href="#1-了解Spirng" class="headerlink" title="1.了解Spirng"></a>1.了解Spirng</h4><p>spirng-&gt;spring mvc -&gt;spring boot -&gt;spring cloud</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48b2da9ced4cd0074a9fdd4f7c0a4318.png" alt="48b2da9ced4cd0074a9fdd4f7c0a4318"></p><p>层层递进–</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3a684778fcbcadf529eaad2b4e9ca34d.png" alt="3a684778fcbcadf529eaad2b4e9ca34d"></p><h4 id="2-IOC-Di-了解"><a href="#2-IOC-Di-了解" class="headerlink" title="2.IOC -Di 了解"></a>2.IOC -Di 了解</h4><p>由分层解耦引出的依赖注入 以及依赖反转</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab5ce66c757c262b95bdbeb4ec1862ad.png" alt="ab5ce66c757c262b95bdbeb4ec1862ad"></p><p>如图 -&gt;当我们想更改对象 BookDaoImp12 名字时候-&gt;时 -&gt;所有业务代码都需要改动改动过大-&gt;</p><p>Ioc-&gt;控制反转<br>使用对象–由主动new-改为外部提供对象-&gt;对象控制器转移到外部</p><p>对此-spring提供容器-&gt;ioc容器 -&gt;提供了对象的创建和管理</p><p>依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1f0310fa78da12366d47e8d7844a002a.png" alt="1f0310fa78da12366d47e8d7844a002a"></p><p>IOC-&gt;容器管理Bean-&gt;容器管理bookdaoimpl</p><p>DI-&gt;将具有依赖关系的Bean进行关系绑定-&gt;例如上面的bookdao-&gt;与bookdaoimpl进行绑定  Spring利用依赖注入机制来处理这些Bean之间的依赖关系，从而实现对象之间的松耦合。</p><h4 id="3-加入IOC-容器"><a href="#3-加入IOC-容器" class="headerlink" title="3.加入IOC 容器"></a>3.加入IOC 容器<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed3173cdd0c9bc6ba6d44953a8c38e0a.png" alt="ed3173cdd0c9bc6ba6d44953a8c38e0a"></h4><h6 id="1-配置Bean"><a href="#1-配置Bean" class="headerlink" title="1.配置Bean"></a>1.配置Bean</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/19c1fd155ec41e2182592cffc5262d96.png" alt="19c1fd155ec41e2182592cffc5262d96"></p><p>2.获取Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/506c12b2db4dd7aca712594fa5e279fa.png" alt="506c12b2db4dd7aca712594fa5e279fa"></p><p>当我们配置bean的时候–容器内就保存了我们的对象地址-&gt;单例-&gt;谁需要就给予</p><h6 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/838a65e2572d2c5fafc8c03d3a3ffd44.png" alt="838a65e2572d2c5fafc8c03d3a3ffd44"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dace05b9aa02d6ab02fd488a060b202e.png" alt="dace05b9aa02d6ab02fd488a060b202e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eed54b5a29e21c9568ee7b195168d180.png" alt="eed54b5a29e21c9568ee7b195168d180"></p><p>set容器执行-&gt;最后还是容器将Bean给予了</p><p>spring-&gt;编译 –自动找set 依赖方法注入</p><h4 id="4-Bean配置"><a href="#4-Bean配置" class="headerlink" title="4.Bean配置"></a>4.Bean配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a1a6f9cec7eca02be1d7807228f64ae.png" alt="2a1a6f9cec7eca02be1d7807228f64ae"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/316948bfd792a80f844396040f862c94.png" alt="316948bfd792a80f844396040f862c94"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f41e07fcd21e2e60e49873e445f8656.png" alt="8f41e07fcd21e2e60e49873e445f8656"></p><p>spring-&gt;默认的Bean是单例的</p><p>如果需要多例 就需要修改配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20bd78b82f85ef5660348295b0f97bf6.png" alt="20bd78b82f85ef5660348295b0f97bf6"></p><p>为什么bean要单例–<br>开对象-&gt;耗费内存</p><p>由于是单例-&gt;需要改变的数据就不能加入spring管理-&gt;除非开多例</p><h4 id="5-Bean实例化"><a href="#5-Bean实例化" class="headerlink" title="5.Bean实例化"></a>5.Bean实例化</h4><h6 id="1-ioc过程"><a href="#1-ioc过程" class="headerlink" title="1.ioc过程"></a>1.ioc过程</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2509eb7c62e476183b724c53e7881f29.png" alt="2509eb7c62e476183b724c53e7881f29"></p><p>给接口内-&gt;一个构造-&gt;通过xml解析出 需要构造的对象-&gt;通过反射 -&gt;创建出对象返回-&gt;默认单例</p><p>通过类名动态加载类的方法</p><p>在使用 <code>Class.forName()</code> 方法时，情况会根据加载的类是否已存在而有所不同：</p><ol><li><strong>类已存在</strong>：<ul><li>如果使用 <code>Class.forName()</code> 加载的类在类路径中已经存在，则会返回对应的 Class 对象，而不会创建新的对象。这意味着它只是获取已加载类的引用，不会触发类的初始化和实例化。</li></ul></li><li><strong>类不存在</strong>：<ul><li>如果要加载的类在类路径中不存在，则会抛出 <code>ClassNotFoundException</code> 异常，而不会创建新的类对象。在这种情况下，不会创建新的类对象，因为类根本就没有被加载到内存中</li></ul></li></ol><h6 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h6><p>工厂模式 -&gt;由一个类中的静态方法-&gt;返回对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 静态工厂方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyService <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;通过静态工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createInstance()</code> 是静态工厂方法，负责返回 <code>MyService</code> 类型的对象。</p><p>在 Spring 配置文件中使用 <code>&lt;bean&gt;</code> 标签指定静态工厂方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span> <span class="hljs-attribute">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p> Java 注解配置静态工厂方法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-variable">@Bean</span><br>    public MyService myService() &#123;<br>        <span class="hljs-keyword">return</span> MyServiceFactory.createInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-实例工厂"><a href="#3-实例工厂" class="headerlink" title="3.实例工厂-"></a>3.实例工厂-</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 实例工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyService <span class="hljs-title">createInstance</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;通过实例工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Spring 配置文件（<code>applicationContext.xml</code>）中，通过 <code>&lt;bean&gt;</code> 标签配置实例工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-comment">&lt;!-- 配置工厂类的 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用工厂类的实例方法创建 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>获取bean</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br>MyService myService <span class="hljs-operator">=</span> (MyService) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>)<span class="hljs-comment">;</span><br>myService.doSomething()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Spring 容器首先会创建 <code>MyServiceFactory</code> 的实例，然后调用其 <code>createInstance</code> 方法来创建 <code>MyService</code> 实例。</p><p> Java 注解配置实例工厂方法</p><p>&#x2F;&#x2F;多了一步-先获取到实例工厂bean才能够注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyServiceFactory <span class="hljs-title function_">myServiceFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceFactory</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> myServiceFactory().createInstance();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h6><p>在 Spring 框架中，<code>FactoryBean</code> 是一个特殊的接口，用于自定义 Bean 的创建逻辑</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Object <span class="hljs-title">getObject</span>(): 返回要创建的 Bean 实例。这个方法用于定义实际的对象创建逻辑。</span><br><span class="hljs-function">Class&lt;?&gt; <span class="hljs-title">getObjectType</span>(): 返回创建的 Bean 的类型。</span><br><span class="hljs-function">boolean <span class="hljs-title">isSingleton</span>(): 指示这个 Bean 是否是单例模式。返回 <span class="hljs-literal">true</span> 表示单例，<span class="hljs-literal">false</span> 表示每次请求都会创建一个新的实例。</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd082cfbea4d7e4b13aa31843b6f35c3.jpeg" alt="dd082cfbea4d7e4b13aa31843b6f35c3"></p><p>指定类-扫描</p><p>Spring 容器会创建一个 <code>CarFactoryBean</code> 的实例，并调用它的 <code>getObject()</code> 方法来获取 <code>Car</code> 对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br><br>// 获取由 CarFactoryBean 创建的 UserDao 实例<br>UserDao car <span class="hljs-operator">=</span> (Car) context.getBean(<span class="hljs-string">&quot;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(car)<span class="hljs-comment">;</span><br><br>// 获取 CarFactoryBean 实例本身<br>CarFactoryBean factoryBean <span class="hljs-operator">=</span> (CarFactoryBean) context.getBean(<span class="hljs-string">&quot;&amp;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(factoryBean)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="6-Bean生命周期"><a href="#6-Bean生命周期" class="headerlink" title="6.Bean生命周期"></a>6.Bean生命周期</h4><h6 id="1-生命周期配置"><a href="#1-生命周期配置" class="headerlink" title="1.生命周期配置"></a>1.生命周期配置</h6><p>1.配置法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f411aabb27ce975d2121258bbe3d082.jpeg" alt="3f411aabb27ce975d2121258bbe3d082"></p><p>2.接口法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a1a7897db2e6c6a81a71ae18c1629103.jpg" alt="a1a7897db2e6c6a81a71ae18c1629103"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0b42710ae7bb291a8a7f65ac715b86bc.png" alt="0b42710ae7bb291a8a7f65ac715b86bc"></p><h6 id="2-bean销毁时间"><a href="#2-bean销毁时间" class="headerlink" title="2.bean销毁时间"></a>2.bean销毁时间</h6><p>为了体现生命周期-&gt;我们提前销毁bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/87ed0bfac3a4d77291ac594173873a77.jpeg" alt="87ed0bfac3a4d77291ac594173873a77"></p><h4 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7.依赖注入"></a>7.依赖注入</h4><h6 id="1-了解依赖注入"><a href="#1-了解依赖注入" class="headerlink" title="1.了解依赖注入"></a>1.了解依赖注入</h6><p>有Bean关系的类进行自动注入 —向类传递数据方式-set 传递 –构造传参</p><hr><p>参数–引用类型和简单类型</p><h6 id="2-引用注入"><a href="#2-引用注入" class="headerlink" title="2.引用注入"></a>2.引用注入</h6><p><strong>引用注入</strong> 是指将一个对象作为另一个对象的属性注入。例如，在一个类中注入另一个类的实例。在 XML 配置或基于注解的方式中，都可以实现引用注入。</p><p><strong>引用注入是指将一个 Bean 注入到另一个 Bean 中，这个 Bean 可以通过构造器、Setter 方法、或其他方式注入。引用注入强调的是一种</strong>引用关系**。</p><p><code>Person</code> 类需要 <code>Address</code> 类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String street;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">// 引用注入</span><br><span class="hljs-comment">// getters and setters</span><br><br><span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <span class="hljs-comment">//构造器</span><br>Person(Address address)<br>&#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Person</code> 类依赖于 <code>Address</code> 类，即 <code>Person</code> 拥有一个 <code>Address</code> 类型的属性。我们可以通过 Spring 配置文件来实现引用注入。</p><p>XML 配置引用注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;New York&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5th Avenue&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John Doe&quot;</span>/&gt;</span>//属性注入<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 引用注入 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>///ref 属性表示引用另一个 Bean。<br></code></pre></td></tr></table></figure><p>基于注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <br><span class="hljs-keyword">private</span> String name;    <br><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 注解方式引用注入    </span><br><span class="hljs-keyword">private</span> Address address;   <br>/<br>/ getters and setters    <span class="hljs-comment">//... &#125;</span><br></code></pre></td></tr></table></figure><h6 id="3-setter注入"><a href="#3-setter注入" class="headerlink" title="3.setter注入"></a>3.setter注入</h6><p><strong>Setter 注入</strong> 是一种通过提供 setter 方法来实现依赖注入的方式</p><p>Setter 注入通常用于将简单数据类型（如 <code>String</code>、<code>int</code>）或引用类型注入到 Bean 中。在 XML 配置中使用 <code>&lt;property&gt;</code> 标签来定义：</p><p><code>&lt;property&gt;</code> 标签的 <code>name</code> 属性表示要注入的属性名称，<code>value</code> 属性表示简单数据类型的值，<code>ref</code> 属性表示对其他 Bean 的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;Jane Doe&quot;</span>/&gt; &lt;!-- 简单类型 --&gt;<br>    &lt;property name=<span class="hljs-string">&quot;address&quot;</span> ref=<span class="hljs-string">&quot;address&quot;</span>/&gt; &lt;!-- 引用类型 --&gt;<br>&lt;/bean&gt;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Address</span> address;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Address</span> <span class="hljs-title function_">getAddress</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">Address</span> address</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="4-构造器注入"><a href="#4-构造器注入" class="headerlink" title="4.构造器注入"></a>4.构造器注入</h6><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ac8de3631e734a2817de72f0e21076e.jpeg" alt="2ac8de3631e734a2817de72f0e21076e"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/906d5345ed81c62f2ca79c2c87182043.jpeg" alt="906d5345ed81c62f2ca79c2c87182043"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/37aa8dfa1862573eb20ad4710135f7a0.jpeg" alt="37aa8dfa1862573eb20ad4710135f7a0"></strong></p><h6 id="4-依赖注入方式选择"><a href="#4-依赖注入方式选择" class="headerlink" title="4.依赖注入方式选择"></a>4.依赖注入方式选择</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7f4076b8a85df6389a465186386ba9f.jpeg" alt="d7f4076b8a85df6389a465186386ba9f"></p><h6 id="5-依赖自动装配"><a href="#5-依赖自动装配" class="headerlink" title="5.依赖自动装配"></a>5.依赖自动装配</h6><p>IOC容器根据bean所依赖的资源在容器中自动查找并注入到bena的过程称为自动装配</p><p>1.按类型</p><p>2.按名称</p><p>3.按构造方法</p><p>4.不启用自动装配</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d604dff0d944968b0f83ef5e0ed9148f.png" alt="d604dff0d944968b0f83ef5e0ed9148f"></strong></p><p>更改自动装配为按照类型</p><p>比如bookServcice依赖BookDao–我们不需要描述其关系 程序会自动根据名字找到对应类的bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入 不需要`&lt;property&gt;来描述引用关系</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">BookDao</span> bookDao</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">bookDao</span> = bookDao;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="8-集合注入"><a href="#8-集合注入" class="headerlink" title="8.集合注入"></a>8.集合注入</h4><h6 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6956e79faab9804acbd6a47b860b0245.png" alt="6956e79faab9804acbd6a47b860b0245"></p><h6 id="2-list"><a href="#2-list" class="headerlink" title="2.list"></a>2.list</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/43ed876a380305fa263d981c7a984c74.png" alt="43ed876a380305fa263d981c7a984c74"></p><h6 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;p&gt;</span><br><span class="hljs-section">&lt;set&gt;</span><br><br><span class="hljs-section">&lt;/set&gt;</span><br><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ca7bbcd65d882884d7297dd75609d006.png" alt="ca7bbcd65d882884d7297dd75609d006"></p><h6 id="5-Properties"><a href="#5-Properties" class="headerlink" title="5.Properties"></a>5.Properties</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2fac8b9f2d57b4c92547d6a8235169a4.png" alt="2fac8b9f2d57b4c92547d6a8235169a4"></p><h4 id="9-案例分析-bean注入"><a href="#9-案例分析-bean注入" class="headerlink" title="9.案例分析-bean注入"></a>9.案例分析-bean注入</h4><p>我们要拿到druid的连接</p><p>1.配置bean -注入参数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/00252469c47ede33f309cf222de6d27a.png" alt="00252469c47ede33f309cf222de6d27a"></p><p>我们就可以进行拿取</p><p>Set注入–进行注入传普通参数</p><h4 id="10-加载properties文件"><a href="#10-加载properties文件" class="headerlink" title="10.加载properties文件"></a>10.加载properties文件</h4><p><code>.properties</code> 文件的结构和格式</p><ul><li><strong>文件扩展名</strong>：<code>.properties</code></li><li><strong>基本格式</strong>：每行包含一个键值对，格式为 <code>key=value</code></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3259185201691e092710f1c19ad74f73.png" alt="3259185201691e092710f1c19ad74f73"></p><p>加载模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e482c7cd8837d44f0b1684ae235838c7.png" alt="e482c7cd8837d44f0b1684ae235838c7"></p><h4 id="11-容器"><a href="#11-容器" class="headerlink" title="11.容器"></a>11.容器</h4><p>创建过程包括多个关键步骤，从加载配置文件、解析 Bean 定义，到创建和初始化 Bean，再到处理 Bean 的生命周期和容器的启动与关闭。</p><h6 id="1-初始化容器"><a href="#1-初始化容器" class="headerlink" title="1.初始化容器"></a>1.初始化容器</h6><p><strong>加载配置</strong>：Spring 容器从配置文件或注解中加载应用程序的配置。这些配置文件可以是 XML 文件、Java 配置类（使用 <code>@Configuration</code> 注解）、或通过其他方式如 YAML 文件等</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88afb0e3109da0ceb049ce45b2ea81dd.png" alt="88afb0e3109da0ceb049ce45b2ea81dd"></p><p>创建 ApplicationContext 实例</p><p>ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p><h6 id="2-加载-Bean-定义"><a href="#2-加载-Bean-定义" class="headerlink" title="2.加载 Bean 定义"></a>2.加载 Bean 定义</h6><p>流程</p><p><strong>解析配置</strong>：Spring 容器解析配置文件中的 Bean 定义（包括 Bean 的类名、构造器参数、属性值等），或扫描标注有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类。</p><p><strong>注册 Bean 定义</strong>：将解析得到的 Bean 定义注册到容器中。这包括 Bean 的名称、类型、作用域（如单例或原型）、依赖关系等信息。</p><p><strong>创建 Bean 实例</strong>：根据 Bean 定义，Spring 容器创建 Bean 实例。Spring 使用反射机制调用 Bean 的构造函数（若是构造器注入）或默认构造函数。</p><p><strong>依赖注入</strong>：在 Bean 实例创建后，Spring 容器根据 Bean 定义的依赖关系注入所需的依赖。这包括构造器注入、Setter 注入、字段注入等方式。</p><p><strong>执行初始化方法</strong>：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6441e65ec06a343800d7d118ec915bf7.png" alt="6441e65ec06a343800d7d118ec915bf7"></p><p>处理 Bean 的生命周期</p><p><strong>Bean 销毁</strong>：在容器关闭时，Spring 会销毁 Bean。-&gt;bean生命周期方法</p><p> <strong>容器的启动和关闭</strong></p><p><strong>启动容器</strong>：Spring 容器在创建完成后会启动并准备好处理应用程序的请求和交互。此时，所有的 Bean 都已经被创建和初始化完毕，可以使用它们提供的功能。</p><p><strong>关闭容器</strong>：容器可以通过调用 <code>ApplicationContext</code> 的 <code>close</code> 方法来关闭。在关闭过程中，容器会执行 Bean 的销毁操作，释放资源，完成容器的清理工作。</p><h6 id="3-容器接口分析"><a href="#3-容器接口分析" class="headerlink" title="3.容器接口分析"></a>3.容器接口分析</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d310da378a35e1bc86067389adf5c3b.png" alt="8d310da378a35e1bc86067389adf5c3b"></p><h6 id="4-BeanFactory初始化"><a href="#4-BeanFactory初始化" class="headerlink" title="4.BeanFactory初始化"></a>4.BeanFactory初始化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ccb6cf9576f42e82a4190ea129f29b18.png" alt="ccb6cf9576f42e82a4190ea129f29b18"></p><h2 id="IOC-DI-Bean总结"><a href="#IOC-DI-Bean总结" class="headerlink" title="IOC DI Bean总结"></a>IOC DI Bean总结</h2><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aec185bb8dc978e09e302c6e168d677e.jpeg" alt="aec185bb8dc978e09e302c6e168d677e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/18abb534418dab1c205c287cd041975f.jpeg" alt="18abb534418dab1c205c287cd041975f"></p><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h4 id="12-注解"><a href="#12-注解" class="headerlink" title="12.注解"></a>12.注解</h4><h6 id="1-声明为Bean"><a href="#1-声明为Bean" class="headerlink" title="1.@声明为Bean"></a>1.@声明为Bean</h6><p>将一个类声明为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/86b345941eab120771d71166dbf2beb3.png" alt="86b345941eab120771d71166dbf2beb3"></p><p>为了适配MVC-&gt;故此还有 @Controller @Service @Repository</p><h6 id="2-纯注解配置"><a href="#2-纯注解配置" class="headerlink" title="2.纯注解配置"></a>2.纯注解配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/547c0427ec597688cc1c0ec42b75f8a2.png" alt="547c0427ec597688cc1c0ec42b75f8a2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e5159d69c7dd85c33f019d20ac3be99.png" alt="8e5159d69c7dd85c33f019d20ac3be99"></p><h6 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ede5cccd6b754d10bd7e5d2dfb4db131.png" alt="ede5cccd6b754d10bd7e5d2dfb4db131"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f4d394d6384f8e1211f0b8775862a884.png" alt="f4d394d6384f8e1211f0b8775862a884"></p><p>简单类型注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2cde566b050a6d34fbe85be5502e6c50.png" alt="2cde566b050a6d34fbe85be5502e6c50"></p><h6 id="4-加载properties文件"><a href="#4-加载properties文件" class="headerlink" title="4.加载properties文件"></a>4.加载properties文件</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/73301e328b26e40279005a10ac179d9b.png" alt="73301e328b26e40279005a10ac179d9b"></p><p>![22a1fbb70d0306860f7d4ce5107158b5](G:\360MoveData\Users\nixg\Documents\Tencent Files\819429207\nt_qq\nt_data\Pic\2024-03\Ori\22a1fbb70d0306860f7d4ce5107158b5.png)</p><h6 id="5-第三方bean管理例子"><a href="#5-第三方bean管理例子" class="headerlink" title="5.第三方bean管理例子"></a>5.第三方bean管理例子</h6><p>1.注册为bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b515a9216fdb4b0cf13229af949a5107.png" alt="b515a9216fdb4b0cf13229af949a5107"></p><p>2.加入管理-导入式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/26e0669596d4e65ef8badc876869a654.png" alt="26e0669596d4e65ef8badc876869a654"></p><p>扫描式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f1c3b59e56b859a8a04b94fa9cc65876.png" alt="f1c3b59e56b859a8a04b94fa9cc65876"></p><p>简单依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240330164305805.png" alt="image-20240330164305805"></p><p>—连接池配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f09511581cde24e3c7dfcb783c3dc4c.png" alt="2f09511581cde24e3c7dfcb783c3dc4c"></p><h4 id="XML与注解-配置区别"><a href="#XML与注解-配置区别" class="headerlink" title="XML与注解 配置区别"></a>XML与注解 配置区别</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4f6fbbd9134d7813d17dec19a77cd8c.jpeg" alt="b4f6fbbd9134d7813d17dec19a77cd8c"></p><h4 id="13-aop"><a href="#13-aop" class="headerlink" title="13.aop"></a>13.aop</h4><h5 id="1-Aop基础"><a href="#1-Aop基础" class="headerlink" title="1.Aop基础"></a>1.Aop基础</h5><h6 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h6><p>AOP的原理主要是通过使用代理对象来实现，在Spring中，AOP通过代理对象包装目标对象（被代理的对象），在代理对象中插入切面（aspect），实现对目标对象方法的增强。Spring AOP主要采用动态代理技术来实现AOP，其中包括JDK动态代理和CGLIB动态代理两种方式。</p><blockquote><p>只有那些被 Spring 容器管理的 Bean（例如使用 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, 或 <code>@Controller</code> 等注解的类，或者通过 XML 配置的 Bean），Spring 才能为它们创建代理对象。</p></blockquote><p>代理对象的工作原理</p><ol><li><p><strong>代理对象的生成</strong>：</p><ul><li>当容器启动并扫描到 <code>@EnableAspectJAutoProxy</code> 注解时，Spring AOP 框架会自动创建一个代理对象来包装原始的 <code>UserServiceImpl</code> 对象。</li><li>根据 <code>UserService</code> 接口类型，Spring 将使用 <strong>JDK 动态代理</strong> 创建代理对象。</li></ul></li><li><p><strong>切面拦截方法</strong>：</p><ul><li>代理对象接收到方法调用时，它会拦截调用并根据 AOP 配置执行相应的切面逻辑。</li><li>在这个例子中，代理对象会在方法执行前和执行后调用 <code>LoggingAspect</code> 中的切面方法 <code>logBeforeMethod()</code> 和 <code>logAfterMethod()</code>。</li></ul></li><li><p><strong>方法调用的委托</strong>：</p><ul><li><p>在执行完切面方法后，代理对象会将方法调用委托给实际的目标对象 (<code>UserServiceImpl</code>) 以完成核心业务逻辑4</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserService</span> <span class="hljs-title function_">userService</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-title function_">loggingAspect</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingAspect</span>();<br>    &#125;<br>&#125;<br>---------------------------------<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">&quot;execution(* com.example.service.UserService.*(..))&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">allUserServiceMethods</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logBeforeMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: Before method execution&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logAfterMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: After method execution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><p>再框架中添加了个拦截器-&gt;依据正则过滤</p><h6 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h6><ol><li><strong>日志记录</strong>：记录方法的调用、参数、返回值等信息。</li><li><strong>事务管理</strong>：管理事务的开始、提交、回滚等操作。</li><li><strong>安全性</strong>：实现权限控制、加密解密等安全相关功能。</li><li><strong>性能监控</strong>：统计方法的执行时间、次数等性能指标。</li></ol><h6 id="3-连接点-切面-切入点-通知"><a href="#3-连接点-切面-切入点-通知" class="headerlink" title="3.连接点 切面 切入点 通知"></a>3.连接点 切面 切入点 通知</h6><hr><p>切面 @Aspect</p><p>定义一个类为切面类 -通知和切入点</p><p>@Aspect注解标识一个类为切面类，Spring会在扫描到这个注解的类时，自动创建代理对象，并将切面逻辑织入到目标方法中。</p><hr><p>通知</p><p>通知（Advice）是指切面（Aspect）中定义的在程序执行过程中插入的代码片段，它们是在指定的连接点（Join Point）处执行的行为逻辑。通知的主要作用是定义在目标方法执行前后、异常抛出时等特定情况下，应该执行的动作或逻辑。</p><p>@Before和@After</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeMethod</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Before method execution&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>切入点</p><p>它用于定义通知（Advice）应用的具体位置（方法或类）。切入点决定了通知在哪些连接点（Join Point）上执行。切入点的主要作用是<strong>定义通知的应用范围</strong>，即通知应该在什么情况下、对哪些方法或类生效。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* Calculator.divide(..)</span></span>)<br><br></code></pre></td></tr></table></figure><p>-通知+切入点-哪个方法被aop进行管理-再什么时候运行</p><hr><p>连接点</p><p>连接点是代码执行过程中的具体位置，可以被切面（Aspect）拦截并注入相应的增强逻辑。</p><p>当切入点表达式匹配到一个被 AOP 管理的类的方法时，这些方法就被认为是 <strong>连接点（Join Points）</strong>。</p><hr><p>@Before(“execution(* Calculator.add(..))”)</p><p>通知+切入点</p><p>代表了 Calculator类的add方法上执行增强操作</p><p>案例代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-comment">//连接点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-comment">//切面</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* Calculator.add(..))&quot;)</span><br>    <span class="hljs-comment">///通知 切入点 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeAdd</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging before the add method is called&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;execution(* Calculator.divide(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterDivide</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging after the divide method is called&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">&lt;aop:aspectj-autoproxy/&gt;<br>&lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="2-Aop进阶"><a href="#2-Aop进阶" class="headerlink" title="2.Aop进阶"></a>2.Aop进阶</h5><h6 id="1-通知类型"><a href="#1-通知类型" class="headerlink" title="1.通知类型"></a>1.通知类型</h6><ol><li><p>前置通知（Before Advice）：在目标方法执行之前调用通知方法。</p><p>对应注解：<code>@Before</code></p></li><li><p>后置通知（After Returning Advice）：在目标方法成功执行之后调用通知方法。</p><p>对应注解：<code>@AfterReturning</code></p></li><li><p>后置异常通知（After Throwing Advice）：在目标方法抛出异常后调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@AfterThrowing</span><br></code></pre></td></tr></table></figure></li><li><p>后置通知（After (finally) Advice）：无论目标方法是否成功执行，都会调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@After</span><br></code></pre></td></tr></table></figure></li><li><p>环绕通知（Around Advice）：在目标方法之前和之后执行通知方法，可以控制目标方法的执行过程。</p><p>对应注解：<code>@Around</code></p></li><li><p>引入通知（Introduction Advice）：向现有的对象添加新的方法或属性。</p></li><li><p>织入通知（AspectJ Advice）：在AOP中指定切点和通知的组合。</p></li></ol><hr><p>案例</p><ol><li><p>前置通知（Before Advice）：在用户进行结账操作时，检查用户的权限，确保用户具有足够的权限进行结账操作。</p></li><li><p>后置通知（After Returning Advice）：在用户提交订单成功后，记录订单信息到日志中，或者发送确认邮件给用户。</p></li><li><p>后置异常通知（After Throwing Advice）：如果订单处理过程中出现异常，比如库存不足，就发送通知给相关人员进行处理。</p></li><li><p>后置最终通知（After (finally) Advice）：无论订单处理成功与否，都需要关闭数据库连接或释放其他资源。</p></li><li><p>环绕通知（Around Advice）：在处理订单之前和之后记录订单处理时间，以及性能监控等功能。</p></li><li><p>引入通知（Introduction Advice）：向订单类引入一个新的接口，比如可追踪变更历史的接口。</p></li><li><p>织入通知（AspectJ Advice）：定义一个切面，将上述的各种通知类型织入到订单处理的流程中。</p></li></ol><p>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.aspectj.lang.annotation.AfterReturning;<br>import org.aspectj.lang.annotation.AfterThrowing;<br>import org.aspectj.lang.annotation.After;<br>import org.aspectj.lang.annotation.Around;<br>import org.aspectj.lang.ProceedingJoinPoint;</p><p>@Aspect<br>public class LoggingAspect {</p><pre><code class="hljs">@Before(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void beforeProcessOrder() &#123;    System.out.println(&quot;Before processing order...&quot;);&#125;@AfterReturning(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, returning = &quot;result&quot;)public void afterProcessOrder(Object result) &#123;    System.out.println(&quot;After processing order. Result: &quot; + result);&#125;@AfterThrowing(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, throwing = &quot;exception&quot;)public void afterThrowingProcessOrder(Exception exception) &#123;    System.out.println(&quot;Exception thrown during order processing: &quot; + exception.getMessage());&#125;@After(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void afterProcessOrderCompletion() &#123;    System.out.println(&quot;After processing order completion...&quot;);&#125;@Around(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123;    long startTime = System.currentTimeMillis();    Object result = joinPoint.proceed();    long endTime = System.currentTimeMillis();    System.out.println(&quot;Order processing time: &quot; + (endTime - startTime) + &quot; milliseconds&quot;);    return result;&#125;</code></pre><h6 id="2-通知顺序"><a href="#2-通知顺序" class="headerlink" title="2.通知顺序"></a>2.通知顺序</h6><p>当多个切面匹配到同一个类时，可以按照切入点所在类的字母顺序来决定通知方法的执行顺序</p><p>1.类字母</p><p>按照匹配到的切入点的类字母决定先后顺讯</p><p>1.前置-字母排名靠前的先执行</p><p>2.后置-字母排名靠前的后执行</p><p>2.@Order</p><p>可以使用<code>@Order</code>注解来控制多个通知方法的执行顺序。通过<code>@Order</code>注解可以指定通知方法的执行顺序，数值越小的通知方法优先执行。</p><p>具体步骤如下：</p><ol><li>在定义通知方法的类上添加<code>@Component</code>或其他相关注解，使其成为Spring容器中的Bean。</li><li>在通知方法上添加<code>@Order</code>注解，并指定执行顺序的数值，数值越小优先级越高。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(1)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 前置通知的实现</span><br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 后置通知的实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标前-数字小的先执行</p><p>目标后-数字小的后执行</p><h6 id="3-切入点"><a href="#3-切入点" class="headerlink" title="3.切入点"></a>3.切入点</h6><p>1.execution</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0484d9f1bbe10d4207d84882472bf29.png" alt="b0484d9f1bbe10d4207d84882472bf29"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e0a84ff1d8ccee34eb3876e12a63ef97.png" alt="e0a84ff1d8ccee34eb3876e12a63ef97"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ce5a2480e7eaf7f880d1624f4013487.png" alt="3ce5a2480e7eaf7f880d1624f4013487"></p><h4 id="2-注解aop开发"><a href="#2-注解aop开发" class="headerlink" title="2.注解aop开发"></a>2.注解aop开发</h4><p>代码案例</p><p>首先，定义一个自定义注解<code>CustomAnnotation</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-comment">//@Target(ElementType.METHOD)：表示该注解可以用于方法上。这意味着CustomAnnotation只能用于方法的声明中，而不能用于其他地方，比如类、字段等。</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-comment">///@Retention(RetentionPolicy.RUNTIME)：表示该注解在运行时可以被反射读取。这意味着在运行时，我们可以通过Java的反射机制来获取并处理带有CustomAnnotation注解的方法。</span><br>public <span class="hljs-variable">@interface</span> CustomAnnotation &#123;<br>    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">value</span>();<br>&#125;<br>这两个元数据的设定确保了<span class="hljs-selector-tag">CustomAnnotation</span>注解的使用方式和其在程序运行期间的可见性，使其可以被<span class="hljs-selector-tag">AOP</span>或其他机制所识别并进行相应的处理。<br></code></pre></td></tr></table></figure><p>接着，在一个服务类中使用<code>CustomAnnotation</code>注解：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Service</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;<br><br>    <span class="hljs-variable">@CustomAnnotation</span>(<span class="hljs-string">&quot;Custom Annotation Example&quot;</span>)<br>    public void myMethod() &#123;<br>        <span class="hljs-regexp">//</span> 方法实现<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>@CustomAnnotation(&quot;Custom Annotation Example&quot;)</code>这个注解中，双引号里面的参数是注解的属性值。在定义自定义注解时，可以为注解定义属性，并在使用注解时为这些属性赋值。</p><p>在这个示例中，自定义注解<code>CustomAnnotation</code>定义了一个名为<code>value</code>的属性，因此在使用这个注解时，需要为<code>value</code>属性赋值。双引号中的内容 <code>&quot;Custom Annotation Example&quot;</code> 就是为<code>value</code>属性赋的具体数值。</p><p>当在切面类中通过反射获取带有<code>CustomAnnotation</code>注解的方法时，可以通过访问注解的属性值来获取这里传入的参数值，从而实现根据不同的属性值执行不同的逻辑处理。</p><hr><p>然后，在切面类中使用<code>@annotation</code>注解匹配带有<code>CustomAnnotation</code>注解的方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Aspect</span><br>public class MyAspect &#123;<br><br>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;@annotation(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">annotatedMethod</span>(CustomAnnotation customAnnotation) &#123;&#125;<br><br>    <span class="hljs-variable">@Before</span>(<span class="hljs-string">&quot;annotatedMethod(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">beforeAnnotatedMethod</span>(CustomAnnotation customAnnotation) &#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Before advice for method with custom annotation: &quot;</span> + customAnnotation.<span class="hljs-built_in">value</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个切入点表达式 <code>@annotation(customAnnotation)</code> 的作用是匹配所有被 <code>@CustomAnnotation</code> 注解标记的方法。</p><p><code>@annotation(customAnnotation)</code> 是 AspectJ 提供的一个语法，用来匹配方法级别的注解。这里，<code>customAnnotation</code> 是一个参数，它表示目标方法上使用的 <code>@CustomAnnotation</code>。</p><p>同时<code>annotatedMethod</code> f方法的主要用处是可以在通知（Advice）方法中使用一个更清晰、易读的命名标识来引用切入点。</p><hr><p><code>@Before(&quot;annotatedMethod(customAnnotation)&quot;)</code> 表示在所有匹配 <code>@annotation(customAnnotation)</code> 切入点的方法执行之前，执行 <code>beforeAnnotatedMethod</code> 这个方法。</p><p><code>beforeAnnotatedMethod</code> 方法将会在任何被 <code>@CustomAnnotation</code> 标记的方法执行之前运行。它可以访问这个自定义注解实例 <code>customAnnotation</code>，并获取该注解中的属性（例如 <code>value()</code> 方法）。</p><h6 id="4-连接点"><a href="#4-连接点" class="headerlink" title="4.连接点"></a>4.连接点</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9a1881e71612ce58b920331bae4d304.png" alt="c9a1881e71612ce58b920331bae4d304"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6ecb0785b0a6a59af4c08f919aeb6b9e.png" alt="6ecb0785b0a6a59af4c08f919aeb6b9e"></p><h4 id="14-事务"><a href="#14-事务" class="headerlink" title="14.事务"></a>14.事务</h4><h6 id="0-事务的声明式管理"><a href="#0-事务的声明式管理" class="headerlink" title="0.事务的声明式管理"></a>0.事务的声明式管理</h6><p><strong>Spring 事务管理</strong> 依赖于 <strong>AOP 的思想和机制</strong> 来实现声明式事务管理。</p><p>在 Spring 中，当你使用 <code>@Transactional</code> 注解声明一个方法或类需要事务管理时，Spring AOP 会在运行时为这些方法或类创建一个代理对象（Proxy）。代理对象负责在方法调用之前开始事务，在方法调用之后提交或回滚事务。</p><p>Spring 使用 AOP 机制来织入事务管理代码。<code>@Transactional</code> 注解背后是通过 AOP 来实现的。在方法执行的前后，AOP 拦截器会自动进行事务管理操作（如事务开启、提交和回滚），而这些操作对业务代码是透明的。</p><p>这种方式被称为 <strong>声明式事务管理</strong>，它使用 <code>@Transactional</code> 注解指定哪些方法或类需要事务支持，不需要在业务代码中显式地编写事务处理逻辑。</p><p>切面</p><p>Spring 框架定义了一个 <strong>事务切面</strong>（Transaction Aspect），用来拦截被 <code>@Transactional</code> 标记的方法。这个切面是在方法调用前后执行相应的事务操作。</p><p>切入点</p><p>@Transactional</p><p>通知</p><p>通知逻辑</p><p>在方法执行前，事务切面拦截器会开启一个事务。</p><p>如果方法正常执行完成，则事务切面拦截器会提交事务。</p><p>如果方法执行过程中抛出了异常，事务切面拦截器会根据配置决定是回滚事务还是提交事务。</p><h6 id="1-事务入门-例子"><a href="#1-事务入门-例子" class="headerlink" title="1.事务入门 -例子"></a>1.事务入门 -例子</h6><p>假设我们有一个简单的用户管理系统，其中包括一个服务类 <code>UserService</code>，负责创建用户。我们希望在执行用户</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserRepository</span> userRepository;<br><br>    <span class="hljs-comment">// 被 @Transactional 注解的方法将由 Spring AOP 管理</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> username</span>) &#123;<br>        <span class="hljs-comment">// 保存用户</span><br>        userRepository.<span class="hljs-title function_">save</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(username));<br><br>        <span class="hljs-comment">// 模拟一个异常情况，测试事务回滚</span><br>        <span class="hljs-keyword">if</span> (username == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Username cannot be null&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br>----------<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);<br>        <span class="hljs-title class_">UserService</span> userService = context.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">UserService</span>.<span class="hljs-property">class</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.<span class="hljs-title function_">createUser</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 将会导致事务回滚</span><br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Exception caught: &quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-事务管理员-事务协调员"><a href="#2-事务管理员-事务协调员" class="headerlink" title="2.事务管理员 事务协调员"></a>2.事务管理员 事务协调员</h6><p>例子事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/342dd9a76057ac1992637973417a63c8.png" alt="342dd9a76057ac1992637973417a63c8"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9b888313da273ab68bfb514f19274a0b.png" alt="9b888313da273ab68bfb514f19274a0b"></p><h6 id="3-事务配置"><a href="#3-事务配置" class="headerlink" title="3.事务配置"></a>3.事务配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f65b886518d3736b235a310f1a6754.png" alt="b6f65b886518d3736b235a310f1a6754"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/59d7f8499d23c0a2bcfdb780f1e00ea3.png" alt="59d7f8499d23c0a2bcfdb780f1e00ea3"></p><h5 id="4-事务加入-规则"><a href="#4-事务加入-规则" class="headerlink" title="4.事务加入-规则"></a>4.事务加入-规则</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/03f05df2aa222c9fb3abd3efb44ef699.png" alt="03f05df2aa222c9fb3abd3efb44ef699"></p><p>例子</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5dde408db43ac7d09f859c76ed257c91.png" alt="5dde408db43ac7d09f859c76ed257c91"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fba20ae7cf0e8f32ff7aa3de0fb42e42.png" alt="fba20ae7cf0e8f32ff7aa3de0fb42e42"></p><p>如图-都加入同一事务-一旦有异常-日志也会回滚</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9972f6f167883d144abc515733c62536.png" alt="9972f6f167883d144abc515733c62536"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5f99a409d1ff453639c1d9cc7aa2fcf2.png" alt="5f99a409d1ff453639c1d9cc7aa2fcf2"></p><p>解决</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf8e05d7e9f071a8464d78b45eab2ae5.png" alt="cf8e05d7e9f071a8464d78b45eab2ae5"></p><h6 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fa818038f3cf6f80cf14608cec80c598.png" alt="fa818038f3cf6f80cf14608cec80c598"></p><h4 id="0-1-Spring-整合mybatis"><a href="#0-1-Spring-整合mybatis" class="headerlink" title="0.1 Spring 整合mybatis"></a>0.1 Spring 整合mybatis</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/11abe4ba3472982e3b1b217edb94c96e.png" alt="11abe4ba3472982e3b1b217edb94c96e"></p><p>-&gt;将该注册为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e038210f851e6d054f2de5a40605d29c.png" alt="e038210f851e6d054f2de5a40605d29c"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb16bf7c1655375464b67dcd0194534b.png" alt="eb16bf7c1655375464b67dcd0194534b"></p><p>如图–以上配置全部进行修改</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/241a0676f37e4b12a5eef8cdc8e7fe35.png" alt="241a0676f37e4b12a5eef8cdc8e7fe35"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79a9256b4115e3f74adcb4dfc1db5f30.png" alt="79a9256b4115e3f74adcb4dfc1db5f30"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ba320445dccb955e30224a3bbee6193.png" alt="3ba320445dccb955e30224a3bbee6193"></p><p>收纳</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7ff11a9112a3615d298943a68b54e9d6.png" alt="7ff11a9112a3615d298943a68b54e9d6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55cab2a9fb9c8def31581e7f33474ad0.png" alt="55cab2a9fb9c8def31581e7f33474ad0"></p><h4 id="0-2-Spring整合测试"><a href="#0-2-Spring整合测试" class="headerlink" title="0.2 Spring整合测试"></a>0.2 Spring整合测试</h4><p>设定类运行器</p><p>整合spring运行器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6981732edb98c9b849ff758c5c4053c1.png" alt="6981732edb98c9b849ff758c5c4053c1"></p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>maven笔记</title>
    <link href="/2024/09/10/maven%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/10/maven%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="maven笔记"><a href="#maven笔记" class="headerlink" title="maven笔记"></a>maven笔记</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Maven.png" alt="Maven"></p><h4 id="1-Maven入门"><a href="#1-Maven入门" class="headerlink" title="1.Maven入门"></a>1.Maven入门</h4><h6 id="1-maven是什么"><a href="#1-maven是什么" class="headerlink" title="1.maven是什么"></a>1.maven是什么</h6><p>maven是一个统一构建工具-帮助我们快速的导入jar包-同时通过pom对jar进行统一管理–maen还统一了目录结构</p><p>项目构建–依赖管理-统一开发结构</p><h6 id="2-maven仓库"><a href="#2-maven仓库" class="headerlink" title="2.maven仓库"></a>2.maven仓库</h6><p>云端存储jar包—同时本地-私服</p><h6 id="3-坐标"><a href="#3-坐标" class="headerlink" title="3.坐标"></a>3.坐标</h6><p>groupld-定义maven项目组织名称</p><p>artifactld–定义当前maven项目名称</p><p>version-定义当前版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>坐标作用-使用唯一表示-定位资源位置</p><h6 id="4-手动创建maven工程"><a href="#4-手动创建maven工程" class="headerlink" title="4.手动创建maven工程"></a>4.手动创建maven工程</h6><p>–省-就是用命令来创建</p><h4 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2.依赖管理"></a>2.依赖管理</h4><h6 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1.依赖配置"></a>1.依赖配置</h6><dependencies></dependency><dependency></dependencies><h6 id="2-依赖传递"><a href="#2-依赖传递" class="headerlink" title="2.依赖传递"></a>2.依赖传递</h6><p>直接依赖–再当前项目内直接通过pom建立依赖关系</p><p>间接依赖-一个依赖依赖于其他依赖–当前项目会都导入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88a5b650615c05bdb3b51bb6518a3044.png" alt="88a5b650615c05bdb3b51bb6518a3044"></p><h6 id="3-可选依赖"><a href="#3-可选依赖" class="headerlink" title="3.可选依赖"></a>3.可选依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69b032579ca283056eb5f2d056059bf4.png" alt="69b032579ca283056eb5f2d056059bf4"></p><h6 id="4-排查依赖"><a href="#4-排查依赖" class="headerlink" title="4.排查依赖"></a>4.排查依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e2be3508cc74b63a6c7f32972fa4017e.png" alt="e2be3508cc74b63a6c7f32972fa4017e"></p><h6 id="5-依赖范围"><a href="#5-依赖范围" class="headerlink" title="5.依赖范围"></a>5.依赖范围</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eaf5484e109c98583c4af32c8cc48353.png" alt="eaf5484e109c98583c4af32c8cc48353"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e74890abdf3d3cbdd37154251a5c005.png" alt="9e74890abdf3d3cbdd37154251a5c005"></p><h4 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h4><p>快速生命周期-compile-test-compile-test-package-install</p><p>生命周期介绍</p><p>clean-清理工作</p><p>default0核心工作-如编译-测试打包-部署</p><p>site-产生报告-发布站点</p><hr><p>Clean生命周期</p><p>pre-clean-执行一些需要再clean之前完成的工作</p><p>clean-移除上一次构建生成的文件</p><p>post-clean-执行一些需要再clean之后立刻完成的工作</p><hr><p>default构建生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1c6053fbcc84183fbc8f1a7789cee3fb.png" alt="1c6053fbcc84183fbc8f1a7789cee3fb"></p><hr><p>site生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7037669c99ca8e172d0144f4de087264.png" alt="7037669c99ca8e172d0144f4de087264"></p><hr><p>default 介绍</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69d200277cfe62e6d98340f0269f0bfe.png" alt="69d200277cfe62e6d98340f0269f0bfe"></p><p>又分为三大周期</p><h4 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/455befffa49ca7d0354264bf3db7dd62.png" alt="455befffa49ca7d0354264bf3db7dd62"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d32a812fe29eddabf67bcda3cfbcae8b.png" alt="d32a812fe29eddabf67bcda3cfbcae8b"></p><h1 id="Maven-高级"><a href="#Maven-高级" class="headerlink" title="Maven-高级"></a>Maven-高级</h1><h4 id="1-分模块开发与设计"><a href="#1-分模块开发与设计" class="headerlink" title="1.分模块开发与设计"></a>1.分模块开发与设计</h4><p>将一个大型项目拆分为多个独立模块的开发方式。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f0de39a2aea7bbe668e3574cef96944.png" alt="8f0de39a2aea7bbe668e3574cef96944"></p><p>如图 分模块开发就是将模块-导成架包–</p><p>例如-公司 -pojo包-导给你，你只需要导入pom即可使用</p><h4 id="2-聚合"><a href="#2-聚合" class="headerlink" title="2.聚合"></a>2.聚合</h4><p>将模块-聚合再一起构建</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/14b16e3b8bff7a90e90f6f6d42086115.png" alt="14b16e3b8bff7a90e90f6f6d42086115"></p><h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f4069f69f02e626eba8d6941cd4394.png" alt="b6f4069f69f02e626eba8d6941cd4394"></p><p>继承依赖使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62d9f5c074c0336ef3fcb5d36fd6546d.png" alt="62d9f5c074c0336ef3fcb5d36fd6546d"></p><p>继承资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3225c0c79867bfb1e4f2abe6cf748d9.png" alt="f3225c0c79867bfb1e4f2abe6cf748d9"></p><p>继承聚合区别</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240414120838551.png" alt="image-20240414120838551"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br>xml<br><span class="hljs-comment">&lt;!-- 子模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-属性"><a href="#4-属性" class="headerlink" title="4.属性"></a>4.属性</h4><p>属性最大的作用-配置-和版本管理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c4f542e3165840110e15b9913de9dc.png" alt="b4c4f542e3165840110e15b9913de9dc"></p><p>1.自定义属性管理</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/90eb8af64c4b02ba15ed77e0ac33fd16.png" alt="90eb8af64c4b02ba15ed77e0ac33fd16" style="zoom:75%;" /><h4 id="5-工厂版本"><a href="#5-工厂版本" class="headerlink" title="5.工厂版本"></a>5.工厂版本</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e1232256a286acb832c2975ad59ea8a1.png" alt="e1232256a286acb832c2975ad59ea8a1"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7d129e90eaca59df9ae2b62f7ab6ca55.png" alt="7d129e90eaca59df9ae2b62f7ab6ca55"></p><h4 id="6-资源配置"><a href="#6-资源配置" class="headerlink" title="6.资源配置"></a>6.资源配置</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9de34d5dbae1ebc7a72669952069638a.png" alt="9de34d5dbae1ebc7a72669952069638a"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5fc90c8dd4f839707b20624bdf4242c6.png" alt="5fc90c8dd4f839707b20624bdf4242c6"></p><h4 id="7-多环境开发配置"><a href="#7-多环境开发配置" class="headerlink" title="7.多环境开发配置"></a>7.多环境开发配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9c38f1922d021ec7c78c0c8ffbb0c0d5.png" alt="9c38f1922d021ec7c78c0c8ffbb0c0d5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2eccbb8497a79d12ba5b7337f7a9d98f.png" alt="2eccbb8497a79d12ba5b7337f7a9d98f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8c84b9496ecb0a2922bc874f8019530.png" alt="e8c84b9496ecb0a2922bc874f8019530"></p><h4 id="8-跳过测试"><a href="#8-跳过测试" class="headerlink" title="8.跳过测试"></a>8.跳过测试</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d039b87b2aa7539c3a17519c5e509652.png" alt="d039b87b2aa7539c3a17519c5e509652"></p><h4 id="9-私服"><a href="#9-私服" class="headerlink" title="9.私服"></a>9.私服</h4><p>省</p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础题目</title>
    <link href="/2024/09/10/nk/"/>
    <url>/2024/09/10/nk/</url>
    
    <content type="html"><![CDATA[<h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h6 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">JAVA2 简单运算<br>题目<br>题解(<span class="hljs-number">32</span>)<br>讨论(<span class="hljs-number">49</span>)<br>排行<br>入门  通过率：<span class="hljs-number">38.22%</span>  时间限制：<span class="hljs-number">1</span>秒  空间限制：<span class="hljs-number">256</span>M<br>warning 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。<br>描述<br>输入两个正整数<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>，输出这两个正整数的和，差，积，商，模（若<span class="hljs-selector-tag">a</span>&gt;<span class="hljs-selector-tag">b</span>则输出<span class="hljs-selector-tag">a</span>-<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>%<span class="hljs-selector-tag">b</span>的值反之输出<span class="hljs-selector-tag">b</span>-<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>/<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>%<span class="hljs-selector-tag">a</span>的值，不考虑小数，请使用int类型）<br>输入描述：<br>两个正整数<br>输出描述：<br>它们的和，差，积，商，模。每个值之间用空格隔开<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">10</span> <span class="hljs-number">5</span><br>复制<br>输出：<br><span class="hljs-number">15</span> <span class="hljs-number">5</span> <span class="hljs-number">50</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> a = scanner.<span class="hljs-built_in">nextInt</span>();<br>        <span class="hljs-type">int</span> b = scanner.<span class="hljs-built_in">nextInt</span>();<br>        scanner.<span class="hljs-built_in">close</span>();<br><br>        <span class="hljs-keyword">if</span>(a&gt;b)<br>        &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<br><br><br>        <span class="hljs-comment">//write your code here......</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt; <span class="hljs-comment">//堆区开辟对象 将它的引用压入操作数栈</span><br> <span class="hljs-number">3</span> dup <span class="hljs-comment">//复制了该对象引用，并再次将其压入操作数栈。</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt; <br> <span class="hljs-comment">///获取 System.in，即标准输入流，并将其压入操作数栈。</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">///调用 Scanner 的构造方法，使用 System.in 作为输入流参数来初始化 Scanner 对象。</span><br><span class="hljs-number">10</span> astore_1<br>将操作数栈顶的引用类型Scanner（对象引用）存储到局部变量表的索引 <span class="hljs-number">1</span> 位置 并弹出<br><span class="hljs-number">11</span> aload_1<br><span class="hljs-comment">//从局部变量表中加载索引为 1 的引用类型（对象引用）到操作数栈。</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextInt 方法，读取输入的下一个整数，并将其结果（一个 int）压入操作数栈。</span><br><span class="hljs-number">15</span> istore_2<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">2</span>）。并弹出<br><span class="hljs-number">16</span> aload_1<br>加载 Scanner 对象引用。<br><span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-number">20</span> istore_3<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">3</span>）。并弹出<br><span class="hljs-number">21</span> aload_1<br>加载 Scanner 对象引用<br><span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.close : ()V&gt;<br>调用 Scanner 的 close 方法，关闭输入流。<br>--------- <br>       <br>       Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> a = scanner.nextInt();<br>        <span class="hljs-keyword">int</span> b = scanner.nextInt();<br>        scanner.close();<br>------------<br><span class="hljs-number">25</span> iload_2<br><span class="hljs-number">26</span> iload_3<br>将 <span class="hljs-number">2</span> <span class="hljs-number">3</span> 索引值存储到操作数栈<br><br><span class="hljs-number">27</span> if_icmple <span class="hljs-number">55</span> (+<span class="hljs-number">28</span>)  <span class="hljs-keyword">if</span>(a&gt;b)<br>-&gt;比较大小<br>  System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><br><span class="hljs-number">30</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-comment">//获取标准输出流 System.out。-到操作数栈</span><br><span class="hljs-number">33</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-comment">//将格式化字符串 &quot;%d&quot; 压入操作数栈。</span><br><span class="hljs-number">35</span> iconst_1<br>将常量整数 <span class="hljs-number">1</span> 压入操作数栈，表示需要一个参数进行格式化。<br><span class="hljs-comment">///</span><br><br><span class="hljs-number">36</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br>创建一个 Object 类型的新数组，大小为 <span class="hljs-number">1</span>。<br><span class="hljs-number">39</span> dup<br>复制新建的数组引用。 压入操作数栈<br><span class="hljs-number">40</span> iconst_0<br>将整数 <span class="hljs-number">0</span> 压入操作数栈，表示数组的索引位置。<br><span class="hljs-number">41</span> iload_2<br><span class="hljs-number">42</span> iload_3<br><span class="hljs-number">43</span> iadd<br><span class="hljs-comment">//将 23 索引数据存储到操作数栈-并且相加</span><br><span class="hljs-number">44</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br>调用 Integer.valueOf 方法，将和转换为 Integer 对象。<br><span class="hljs-number">47</span> aastore<br>将 Integer 对象存储到数组的第一个位置。<br><span class="hljs-number">48</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br>调用 printf 方法输出结果。<br><span class="hljs-number">51</span> <span class="hljs-keyword">pop</span><br>弹出 PrintStream 对象的引用，清理操作数栈。<br><span class="hljs-number">52</span> goto <span class="hljs-number">77</span> (+<span class="hljs-number">25</span>)<br><span class="hljs-number">77</span><br><br>代码跳处 <br> System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><span class="hljs-number">55</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">58</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-number">60</span> iconst_1<br><span class="hljs-number">61</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br><span class="hljs-number">64</span> dup<br><span class="hljs-number">65</span> iconst_0<br><span class="hljs-number">66</span> iload_2<br><span class="hljs-number">67</span> iload_3<br><span class="hljs-number">68</span> iadd<br><span class="hljs-number">69</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br><span class="hljs-number">72</span> aastore<br><span class="hljs-number">73</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">76</span> <span class="hljs-keyword">pop</span><br><span class="hljs-number">77</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h6><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">描述<br>定义一个<span class="hljs-built_in">int</span>类型变量i,i为由浮点数变量d四舍五入后的整数类型，请将转换后的i进行输出<br>输入描述：<br>用户随机输入的浮点数<br>输出描述：<br>四舍五入之后的整数（小数点后一位&gt;=<span class="hljs-number">5</span>则进一，否则舍去）<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">14.99</span><br>复制<br>输出：<br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">double</span> d= scanner.<span class="hljs-built_in">nextDouble</span>();<br><br>        <span class="hljs-comment">//write your code here......</span><br>        <span class="hljs-type">double</span> v = d + <span class="hljs-number">0.5</span>;<br>        <span class="hljs-type">int</span> i= (<span class="hljs-type">int</span>) v;<br>        System.out.<span class="hljs-built_in">println</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码分析</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt;<br> <span class="hljs-comment">//创建scanner引用 压入到操作数栈 1</span><br> <span class="hljs-number">3</span> dup<br> <span class="hljs-comment">//复制操作数栈顶的Scanner对象引用 并将该引用再次压入操作数栈。2</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt;<br> <span class="hljs-comment">//获取输入流 压入到操作数栈 3</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">//调用构造方法 System.in 作为参数</span><br><br><span class="hljs-number">10</span> astore_1 -弹出 <span class="hljs-number">1</span><br><span class="hljs-number">11</span> aload_1  <span class="hljs-number">2</span><br><span class="hljs-comment">//int *1=&amp;input;</span><br><span class="hljs-comment">//int **1=&amp;1;--存到操作数栈</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextDouble : ()D&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextDouble 方法，读取输入的 double 类型的数值，将其压入操作数栈。 3</span><br><span class="hljs-number">15</span> dstore_2 弹出-数据存储到索引 <span class="hljs-number">2</span><br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>      <br>       <span class="hljs-keyword">double</span> d= scanner.nextDouble();<br>       <br>       <br><span class="hljs-number">16</span> dload_2<br>压入操作数栈- <span class="hljs-number">3</span><br><span class="hljs-number">17</span> ldc2_w #<span class="hljs-number">6</span> &lt;<span class="hljs-number">0.5</span>&gt;<br>将常量池中 #<span class="hljs-number">6</span> 位置的 <span class="hljs-keyword">double</span> 类型常量 <span class="hljs-number">0.5</span> 压入操作数栈。 <span class="hljs-number">4</span><br><span class="hljs-number">20</span> dadd<br>相加<br><span class="hljs-number">21</span> dstore <span class="hljs-number">4</span> <span class="hljs-number">3</span><br>弹出 最新的相加值 存储到槽<span class="hljs-number">4</span><br><span class="hljs-number">23</span> dload <span class="hljs-number">4</span> <span class="hljs-number">4</span><br>再压入操作数栈<br><span class="hljs-number">25</span> d2i<br>将栈顶的 <span class="hljs-keyword">double</span> 类型数值转换为 <span class="hljs-keyword">int</span> 类型（取整）。<br><span class="hljs-number">26</span> istore <span class="hljs-number">6</span> <span class="hljs-number">3</span><br>弹出 存储到 <span class="hljs-number">6</span><br><span class="hljs-number">28</span> getstatic #<span class="hljs-number">8</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">31</span> iload <span class="hljs-number">6</span>  <span class="hljs-number">4</span> 弹出 存储槽<span class="hljs-number">6</span> <br><span class="hljs-number">33</span> invokevirtual #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.<span class="hljs-keyword">println</span> : (I)V&gt; 打印<br><span class="hljs-number">36</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h6><p>不使用第三方变量交换值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>        <span class="hljs-comment">//write your code here.......</span><br>        a=a+b;<br>        b=a-b;<br>        a=a-b;<br><br>        System.out.println(a+<span class="hljs-string">&quot; &quot;</span>+b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2048实现秒过关</title>
    <link href="/2024/09/06/2048/"/>
    <url>/2024/09/06/2048/</url>
    
    <content type="html"><![CDATA[<h1 id="so分析"><a href="#so分析" class="headerlink" title="so分析"></a>so分析</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/041e24788116aad3e5b9d66d153c0597.png" alt="041e24788116aad3e5b9d66d153c0597"></p><p>hook其参数-得知</p><p>修改.</p><p>text:000A1CE8 01 32                         ADDS    R2, #1</p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5997fd65e2f23df2dedd500f805418d1.png" alt="5997fd65e2f23df2dedd500f805418d1"></p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0c2eab99470f976c0cc393352fa1b15.png" alt="b0c2eab99470f976c0cc393352fa1b15"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240908230448204.png" alt="`image-20240908230448204`"></p><p>修改盒子初始值达到快速过关</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础笔记</title>
    <link href="/2024/09/06/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/"/>
    <url>/2024/09/06/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础笔记"><a href="#java基础笔记" class="headerlink" title="java基础笔记"></a>java基础笔记</h1><p>ps:很遗憾，由于第一次的笔记很短暂。并不怎么深入<br>后续会更新String流处理 包括多线程 线程共享 线程安全 等<br>还有网络编程-各类心跳处理机制-多线程服务器-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Java.png" alt="Java">通过网盘分享的文件：java2笔记<br>链接: <a href="https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5">https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5</a> 提取码: vka5</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三级缓存解决循环依赖</title>
    <link href="/2024/09/06/huanchun/"/>
    <url>/2024/09/06/huanchun/</url>
    
    <content type="html"><![CDATA[<h1 id="循环依赖解决"><a href="#循环依赖解决" class="headerlink" title="循环依赖解决"></a>循环依赖解决</h1><h6 id="1-了解循环依赖问题"><a href="#1-了解循环依赖问题" class="headerlink" title="1.了解循环依赖问题"></a>1.了解循环依赖问题</h6><p>在 Spring 中，如果一个 bean 尝试将自身引用注入到自身中，通常会引发循环依赖。</p><p>首先搞清楚什么是循环依赖：</p><p>两个Bean，A依赖B，B依赖A就构成了循环依赖，如下图：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240606225332349.png" alt="image-20240606225332349"></p><p>同样的道理，如果在A中注入A表示A依赖A，也就构成了循环依赖。</p><p>创建A实例–》初始化A–》注入B–》创建B实例–》初始化B–》注入A</p><p>A-初始化-需要初始化完成bean-&gt;初始化B-&gt;b也要初始化其中的bean-》A-初始化-</p><p>卡入死循环</p><h6 id="2-避免循环依赖流程"><a href="#2-避免循环依赖流程" class="headerlink" title="2.避免循环依赖流程"></a>2.避免循环依赖流程</h6><p>针对循环依赖的问题Spring会上边的过程调整为下边的流程：</p><p>创建A实例– -》创建B实例–》在B中注入A—*<code>B的成员保存A的内存地址</code>*》B初始化—成员赋值了》在A中注入B–》A初始化。</p><p><strong>实例-内存地址</strong>       </p><p>A -&gt;注入B-&gt;初始化</p><p>B-&gt;A(地址)–{最后存储的就是A}-&gt;初始化</p><p>延迟了A的初始化只保留了地址</p><h6 id="3-三级缓存解决循环依赖"><a href="#3-三级缓存解决循环依赖" class="headerlink" title="3.三级缓存解决循环依赖"></a>3.三级缓存解决循环依赖</h6><p>Spring是如何做到呢？</p><p>Spring会延迟初始化，B需要注入A,此时Spring会先实例化A，把一个半成品A注入给B，延迟A的初始化。</p><p>具体的底层原理是Spring通过三级缓存实现：</p><blockquote><p>1）<strong>singletonObjects缓存</strong>：这是 Spring 容器<strong>用来缓存完全初始化好的****单例</strong> <strong>bean 实例的缓存</strong>。当一个 bean 初始化完成后，它会被放入singletonObjects缓存中。这个缓存是单例 bean 的最终缓存，也是 BeanFactory 中保存 bean 的主要缓存。</p><p>2）<strong>earlySingletonObjects缓存</strong>：这个缓存是<strong>用来保存被实例化但还未完全初始化的 bean 的引用</strong>。当一个 bean 已经被实例化（但还未初始化）时，它会被放入earlySingletonObjects缓存中。</p><p>给空间了-但是类数据没有放入</p><p>3）<strong>singletonFactories缓存</strong>：这个缓存保存的是用于创建 bean 实例的 ObjectFactory，用于支持循环依赖的延迟初始化。当一个 bean 被实例化，但尚未完全初始化时，Spring 会在singletonFactories缓存中查找该 bean 的ObjectFactory。这个ObjectFactory会在需要时被调用来完成 bean 的初始化。</p></blockquote><p>类工厂</p><p>Spring 通过这三级缓存的组合，来确保在循环依赖情况下，能够正常初始化 bean。当两个或多个 bean 之间存在循环依赖时，Spring  使用 singletonFactories 缓存来存储 bean 的提供者（ObjectFactory）。当一个 bean  在初始化过程中需要依赖另一个还未初始化的 bean 时，Spring 会调用相应的 ObjectFactory 来获取对应的 bean  实例，这样就实现了循环依赖的延迟初始化。一旦 bean 初始化完成，它就会被移动到singletonObjects缓存中。</p><p>举例：</p><p>创建A实例–》创建B实例–》在B中注入A–》B初始化—》在A中注入B–》A初始化。</p><p>创建A实例（半成品），在earlySingletonObjects放入A半成品。</p><p>创建B实例（半成品），在earlySingletonObjects放入B半成品。</p><p>在B中注入A，通过singletonFactories拿到A的对象工厂，通过对象工厂拿到A的半成品注入到B中。</p><p>B初始化完成，将B从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>在A中注入B-，通过singletonFactories拿到B的对象工厂，通过对象工厂拿到B的成品注入到A中。</p><p>A初始化完成，将A从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>A是一片空间-当初始化完成后-地址就有数据了</p><p>说来说去 就是个内存地址的问题</p><p>**构造参数注入</p><h6 id="4-构造循环依赖解决"><a href="#4-构造循环依赖解决" class="headerlink" title="4.构造循环依赖解决"></a>4.构造循环依赖解决</h6><p>虽然Spring可以解决上边通过成员变量注入引发的循环依赖问题，但是<strong>通过构造参数注入引发的循环依赖问题是会报错。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e9464064bc6f0632ead497e183ca6d3a-1717687581273-4.png" alt="e9464064bc6f0632ead497e183ca6d3a"></p><p>因为创建C需要调用构造方法，而构造方法需要依赖D，此时C是无法实例化的</p><p>上边分析Spring解决循环依赖是通过延迟初始化，当出现循环依赖问题可以注入一个半成品</p><p><strong>但是如上半成品也无法生成</strong></p><p>如何解决这种通过构造参数注入导致的循环依赖问题呢？</p><p>可以在C或D的任意一方注入另一方的代理对象而不是注入原始对象，如下：</p><p>假设在C的构造方法中注入D的代理对象可以写为：</p><p>在构造参数前加@Lazy注解，表示注入D的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-meta">@Lazy</span> D d)</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云岚到家1-4技术栈</title>
    <link href="/2024/09/06/yunlan/"/>
    <url>/2024/09/06/yunlan/</url>
    
    <content type="html"><![CDATA[<h1 id="云岚到家-1-4"><a href="#云岚到家-1-4" class="headerlink" title="云岚到家 1-4"></a>云岚到家 1-4</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6.png" alt="云岚到家"></p><p>技术栈-</p><p>微信小程序登录流程</p><p>用户定位接口</p><p>SpringCache</p><p>Redis  </p><p>缓存穿透 缓存击穿 缓存雪崩 缓存不一致 -</p><p>门户优化</p><p>XXL-JOB使用 </p><p>具体这些框架原理后续我会剖析</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏逆向思路cpp</title>
    <link href="/2024/09/06/test2/"/>
    <url>/2024/09/06/test2/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏逆向思路cpp"><a href="#游戏逆向思路cpp" class="headerlink" title="游戏逆向思路cpp"></a>游戏逆向思路cpp</h1><p>游戏引擎 :cocos2dx<br>逆向思路</p><p>libcocos2dcpp.so  libgame.so     &#x2F;data&#x2F;app-lib&#x2F;包名<br>1.字符串信息查找关键函数<br>2.send函数进行定位<br>3.hook hook函数修改参数-返回值-或者多次调用-或者返回-根据情况</p><p><img src="https://s2.loli.net/2024/09/07/yZxfF9IcLlMbUzW.png" alt="2024-09-07 222659.png"></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
