<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最近的笔记方向</title>
    <link href="/2024/11/19/%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/11/19/%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>java项目场景题目(完成各类中间件的学习+java进阶学习</strong>)</p><p><strong>数据结构(考试)-&gt;考试完-&gt;学习完</strong></p><p><strong>mysql 刷题</strong></p>]]></content>
    
    
    <categories>
      
      <category>杂言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云岚到家思维导图</title>
    <link href="/2024/10/09/yunlan/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2024/10/09/yunlan/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="云岚到家思维导图"><a href="#云岚到家思维导图" class="headerlink" title="云岚到家思维导图"></a>云岚到家思维导图</h1><h6 id="1-4"><a href="#1-4" class="headerlink" title="1-4"></a>1-4</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6.png" alt="云岚到家"></p><p>2.27-5.24具体笔记所在</p><h6 id="5-支付"><a href="#5-支付" class="headerlink" title="5 支付"></a>5 支付</h6><blockquote><ul><li><pre><code class="hljs"> 下单预约 1.预约下单状态设计 2.订单表设计思路 3.下单思路 4.OpenFeign 5.微服务雪崩问题探究 5.sentinel 熔断降级- @Component  public class CustomerClient&#123;  @Resource   private Api Api;  @SentinelResource(value = &quot;getAddressBookDetail&quot;, fallback = &quot;detailFallback&quot;, blockHandler = &quot;detailBlockHandler&quot;)    public AddressBookResDTO getDetail(Long id)   &#123;       return Api.api(id);   &#125;   public  AddressBookResDTO detailFallback(Long id, Throwable throwable)   &#123;       log.error(&quot;异常抛出&quot;);       return null;   &#125;   public  AddressBookResDTO detailBlockHandler(Long id, Throwable throwable)   &#123;       log.error(&quot;熔断&quot;);       return null;   &#125;    &#125;<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>  <br><br></code></pre></td></tr></table></figure></code></pre></li></ul><p> 6.订单号生成规则</p><p> 7.事务优化</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br><br></code></pre></td></tr></table></figure><p>@Transactional(rollbackFor &#x3D; Exception.class)<br>public void save()<br>{<br>&#x2F;&#x2F;远程调用<br>api.selectid();&#x2F;&#x2F;提高事务时长-锁数据库时间增加-造成雪崩</p><p>&#x2F;&#x2F;本地添加 -抽离save<br>this.save();<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>public void save()<br>{<br>&#x2F;&#x2F;远程调用<br>api.selectid();&#x2F;&#x2F;提高事务时长-锁数据库时间增加-造成雪崩<br>this.saveqq();&#x2F;&#x2F;事务失效–Spring进行事务控制是通过代理对象进行的，在调用add方法之前开启事务，方法执行结束提交事务。</p><p>}<br>@Transactional(rollbackFor &#x3D; Exception.class)<br>public void saveqq()<br>{<br>&#x2F;&#x2F;本地添加 -<br>this.save();<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>public class qq{<br>@Resource<br> private qq MM;<br>public void save()<br>{<br>&#x2F;&#x2F;远程调用<br>api.selectid();&#x2F;&#x2F;提高事务时长-锁数据库时间增加-造成雪崩<br>MM.saveqq();&#x2F;&#x2F;–Spring进行事务控制是通过代理对象进行的，在调用add方法之前开启事务，方法执行结束提交事务。</p><p>}<br>@Transactional(rollbackFor &#x3D; Exception.class)<br>public void saveqq()<br>{<br>&#x2F;&#x2F;本地添加 -<br>this.save();<br>}<br>}</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p> 8.循环依赖</p><p>抽出来当博客</p><p> 微信小程序支付流程</p><p> 1.开通流程</p><p> 2.小程序支付接口</p><p> 3.支付业务流程</p><p> 4.小程序下单</p><p> 5.小程序调起支付</p><p> 6.小程序支付通知</p><p> 7.订单号查询订单</p><p> Native使用</p><p> 2.流程</p><p> SDK</p><p> 1.导入微信支付sdk</p><p> 2.名词认识</p><p>.3.WechatPayHttpClientBuilder构建请求</p><p> 请求构建</p><p> jsapi下单</p><p> 查单 </p><p> 退单</p><pre><code class="hljs">6.6-6.9内容</code></pre></blockquote><h6 id="6-支付"><a href="#6-支付" class="headerlink" title="6 支付"></a>6 支付</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.png" alt="img"></p><h6 id="7-退款"><a href="#7-退款" class="headerlink" title="7 退款"></a>7 退款</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E9%80%80%E6%AC%BE.png" alt="img"></p><p>6.11</p><h6 id="8-状态机退款"><a href="#8-状态机退款" class="headerlink" title="8 状态机退款"></a>8 状态机退款</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%94%AF%E4%BB%98%E7%AB%A0%E8%8A%82.png" alt="支付章节"></p><p>6.12</p><h6 id="9-订单优化-分库分表-索引"><a href="#9-订单优化-分库分表-索引" class="headerlink" title="9  订单优化 分库分表 索引"></a>9  订单优化 分库分表 索引</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E8%AE%A2%E5%8D%95%E4%BC%98%E5%8C%96.png" alt="img"></p><p>6.22-6.24</p><h6 id="10-秒杀抢购"><a href="#10-秒杀抢购" class="headerlink" title="10 秒杀抢购"></a>10 秒杀抢购</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1%E7%A7%92%E6%9D%80%E6%8A%A2%E8%B4%AD.png" alt="1秒杀抢购"></p><p>7.3-7.8</p><h6 id="11-抢卷结果同步"><a href="#11-抢卷结果同步" class="headerlink" title="11 抢卷结果同步"></a>11 抢卷结果同步</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%8A%A2%E5%8D%B7%E7%BB%93%E6%9E%9C%E5%90%8C%E6%AD%A5.png" alt="img"></p><p>7.9</p><h6 id="12-核销抢单取消"><a href="#12-核销抢单取消" class="headerlink" title="12  核销抢单取消"></a>12  核销抢单取消</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%A0%B8%E9%94%80%E6%8A%A2%E5%8D%95%E5%8F%96%E6%B6%88.png" alt="img"></p><p>7.9*-7.11</p><h6 id="13订单各类优化"><a href="#13订单各类优化" class="headerlink" title="13订单各类优化"></a>13订单各类优化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E8%AE%A2%E5%8D%95.png" alt="img"></p><p>7.16-7.17</p><h6 id="14-派单"><a href="#14-派单" class="headerlink" title="14 派单"></a>14 派单</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E6%B4%BE%E5%8D%95%E7%AD%96%E7%95%A5.png" alt="img"></p><p>7.17</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>项目已经复习了一次-写完是花了28天时间-技术面非常广泛</p><h6 id="业务部分"><a href="#业务部分" class="headerlink" title="业务部分"></a>业务部分</h6><p>思维导图来自官方</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9024291640ec41ca7aa09bec44326e9b.png" alt="9024291640ec41ca7aa09bec44326e9b"></p><h6 id="技术部分"><a href="#技术部分" class="headerlink" title="技术部分"></a>技术部分</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241003160553910.png" alt="image-20241003160553883"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241003160607274.png" alt="image-20241003160607274"></p><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>通过网盘分享的文件：云岚到家 -新<br>链接: <a href="https://pan.baidu.com/s/1KeGLcvCHReneF278uG4REw?pwd=c9si">https://pan.baidu.com/s/1KeGLcvCHReneF278uG4REw?pwd=c9si</a> 提取码: c9si</p>]]></content>
    
    
    <categories>
      
      <category>云岚到家</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jwtcookieseiion探究</title>
    <link href="/2024/10/04/skill/Jwtcookieseiion%20/"/>
    <url>/2024/10/04/skill/Jwtcookieseiion%20/</url>
    
    <content type="html"><![CDATA[<h1 id="jwt-cookie-seiion探究"><a href="#jwt-cookie-seiion探究" class="headerlink" title="jwt cookie seiion探究"></a>jwt cookie seiion探究</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2db9fbc3e04de8bcf5bbd95f05261d8c.png" alt="2db9fbc3e04de8bcf5bbd95f05261d8c"></p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p><strong>定义</strong>：Session 是服务器端用于保存用户会话状态的数据结构。在用户登录时，服务器为其创建一个 Session，并生成一个唯一的 Session ID 来标识该会话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>            session.setAttribute(<span class="hljs-string">&quot;session_account&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>服务器<br></code></pre></td></tr></table></figure><p>客户端拿到的是一段令牌-后续传递到服务端-服务端会解密-</p><p><strong>存储位置</strong>：<strong>服务器端</strong>。服务器保存每个用户的 Session 数据，客户端通过 <strong>Session ID</strong> 与服务器通信。</p><p><strong>特点</strong>：</p><ul><li><strong>有状态</strong>：服务器必须存储 Session 数据，因此这种方式需要服务器管理用户的会话信息。</li><li><strong>Session ID 传递</strong>：<strong>服务器在用户登录时生成 Session ID 并发送给客户端，客户端通常通过 Cookie 来存储 Session ID，并在每次请求时自动发送给服务器。</strong></li><li><strong>安全性</strong>：由于 Session ID 存储在 Cookie 中，结合 Cookie 的安全设置（如 <code>HttpOnly</code>、<code>Secure</code>）可以提升安全性，但 Session 本身依赖服务器存储和管理。</li><li><strong>应用场景</strong>：传统 Web 应用中会话管理最常用的方式，尤其适合需要维护状态的应用。</li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><strong>定义</strong>：Cookie 是存储在客户端的小型数据文件，通常由服务器生成，用于在客户端和服务器之间传递信息，最常用于保存会话信息、用户偏好等。</p><p><strong>存储位置</strong>：客户端（浏览器）中，客户端每次发起请求时会自动将与请求域相关的 Cookie 发送给服务器。</p><p><strong>会话管理</strong>：Cookie 可以存储用户的 Session ID 等信息，用于维持用户的会话状态。</p><p><strong>大小限制</strong>：单个 Cookie 的大小通常限制为 4KB。</p><p><strong>安全性</strong>：Cookie 可以设置 <code>HttpOnly</code>（防止客户端 JavaScript 访问）、<code>Secure</code>（仅通过 HTTPS 传输）等安全属性。</p><p><strong>自动发送</strong>：浏览器会在每次请求时自动携带 Cookie，无需客户端手动干预。</p><p><strong>应用场景</strong>：主要用于会话管理和状态维护，常用于 Web 应用的用户登录状态保持。</p><h4 id="session再探究"><a href="#session再探究" class="headerlink" title="session再探究"></a>session再探究</h4><p><strong>工作流程</strong></p><p>当用户登录应用时，服务器为该用户创建一个 Session 并生成一个唯一的 <strong>Session ID</strong>。</p><p><strong>Session ID</strong> 通常是一个随机生成的字符串，用于唯一标识该用户的会话。</p><p>服务器将 <strong>Session ID</strong> 和会话数据（如用户信息、权限等）存储在服务器的内存或数据库中。</p><p>服务器通过 HTTP 响应将 <strong>Session ID</strong> 发送给客户端，客户端通常会将这个 <strong>Session ID</strong> 保存在 <strong>Cookie</strong> 中。</p><p>在随后的每个请求中，客户端会将 <strong>Session ID</strong> 通过 Cookie 自动发送给服务器。</p><p>服务器接收到请求时，通过查询存储的 Session ID 来获取对应的会话数据，从而确定用户的身份。</p><p><strong>session数据查找</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241004234535358.png" alt="image-20241004234535358"></p><p><strong>接收请求</strong>：客户端通过 Cookie 发送 <strong>Session ID</strong> 给服务器。</p><p><strong>查询服务器存储</strong>：服务器在内部的 Session 存储中查找该 <strong>Session ID</strong> 是否存在。</p><p><strong>获取会话数据</strong>：如果找到匹配的 Session ID，服务器会返回对应的会话数据（如用户身份、权限等）。</p><p><strong>处理请求</strong>：服务器根据会话数据执行相应的操作。</p><p>会话劫持问题</p><p><strong>如果另一个人获得了有效的 Session ID</strong>，他确实可以伪装成该用户登录到系统。因为 Session ID 本质上是唯一标识用户会话的凭证，获得 Session ID 的人可以在没有输入用户名和密码的情况下发送请求，服务器会认为他们是合法的用户。这种攻击通常被称为 <strong>Session Hijacking（会话劫持）</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图</title>
    <link href="/2024/10/04/data%20structure/%E5%9B%BE/"/>
    <url>/2024/10/04/data%20structure/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h4 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/19214be3c45d09940407b8c6322f29e1.png" alt="19214be3c45d09940407b8c6322f29e1"></p><p>a b c d e f组成顶点集<br>边集-链接顶点的边组成</p><p>图的规则-图的每个边必须有顶点</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b7a8db0b939dd4da7949904e9effd2ab.png" alt="b7a8db0b939dd4da7949904e9effd2ab" style="zoom: 50%;" /><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/540e70ba6ea8f4383bae1be2ab0253d1.png" alt="540e70ba6ea8f4383bae1be2ab0253d1"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aea691c9c97d85a4569c92a3e01d3caa.png" alt="aea691c9c97d85a4569c92a3e01d3caa"></p><p>图-的边集可以是空</p><h4 id="图的逻辑结果应用"><a href="#图的逻辑结果应用" class="headerlink" title="图的逻辑结果应用"></a>图的逻辑结果应用</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e768e87564a1f0ffaf46241def8f8d16.png" alt="e768e87564a1f0ffaf46241def8f8d16"></p><h4 id="图的性质"><a href="#图的性质" class="headerlink" title="图的性质"></a>图的性质</h4><h5 id="无向图和有向图"><a href="#无向图和有向图" class="headerlink" title="无向图和有向图"></a>无向图和有向图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/558e406be0fb79e8913871d97c993196.png" alt="558e406be0fb79e8913871d97c993196"></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/620e418d6d60ef2a8ebcd7e928bb085a.png" alt="620e418d6d60ef2a8ebcd7e928bb085a" style="zoom:50%;" /></strong></p><p>有向图</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ff73d6e358747263936168f878ca4d8.png" alt="0ff73d6e358747263936168f878ca4d8"></p><p>尾 -&gt;没有箭头<br>头-&gt;有箭头</p><p>A-&gt;c  A弧尾  C弧头</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/af418af68cb716958a4790c6c147e495.png" alt="af418af68cb716958a4790c6c147e495" style="zoom:50%;" /><h5 id="简单图多重图"><a href="#简单图多重图" class="headerlink" title="简单图多重图"></a>简单图多重图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4c63b0b865be3241750e2c81432d88ce.png" alt="4c63b0b865be3241750e2c81432d88ce"></p><p>只探讨简单图</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3aa2a0d6462a243daa747c659b6d0288.png" alt="3aa2a0d6462a243daa747c659b6d0288" style="zoom:33%;" /><p>多重 不许自己加自己好友-不许重复加好友</p><h5 id="顶点的度-入度-出度"><a href="#顶点的度-入度-出度" class="headerlink" title="顶点的度 入度 出度"></a>顶点的度 入度 出度</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/90ec4308e2c4d454e66104654a2112e9.png" alt="90ec4308e2c4d454e66104654a2112e9"></p><p>有向图计算 顶点度的计算</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb3c96e46ff13c39547c95fd3b39e191.png" alt="eb3c96e46ff13c39547c95fd3b39e191"></p><h5 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述 ***"></a>顶点-顶点的关系描述 ***</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bc517c509e931b20b768753113386775.png" alt="bc517c509e931b20b768753113386775"></p><hr><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/419915ab238d666e8193aa36ebe5a5bc.png" alt="419915ab238d666e8193aa36ebe5a5bc"></p><p>不是简单路径情况-a b a b d  ab都重复出现了</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55a99d194510bcdc954d45b3e11e0e4e.png" alt="55a99d194510bcdc954d45b3e11e0e4e"></p><p>例如 无向图 F A-无穷   A-B 就是最短路径</p><hr><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241004150018957.png" alt="image-20241004150018957"></p><h5 id="连通图-强连通图"><a href="#连通图-强连通图" class="headerlink" title="连通图 强连通图"></a>连通图 强连通图</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/75c56e5e5386e8aaa102ff6c307e59bb.png" alt="75c56e5e5386e8aaa102ff6c307e59bb"></p><h6 id="考点"><a href="#考点" class="headerlink" title="考点**"></a>考点**</h6><p>连通图考点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/687bc9622ce00d325b200fa7b814477b.png" alt="687bc9622ce00d325b200fa7b814477b"></p><p>n-1性质</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241004150427522.png" alt="image-20241004150427499" style="zoom:33%;" /><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c8afcc69e98643f7293b908edadaaabe.svg" alt="img"></p><p>感叹号表示阶乘</p><p>5!&#x3D;5×4×3×2×1&#x3D;120</p><p>4&#x3D;24</p><p>4</p><p>6边</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>knife4i</title>
    <link href="/2024/10/04/Middleware/knife4i/knife4i/"/>
    <url>/2024/10/04/Middleware/knife4i/knife4i/</url>
    
    <content type="html"><![CDATA[<h1 id="knife4i"><a href="#knife4i" class="headerlink" title="knife4i"></a>knife4i</h1><h4 id="1-依赖导入-认识knife4i"><a href="#1-依赖导入-认识knife4i" class="headerlink" title="1.依赖导入 认识knife4i"></a>1.依赖导入 认识knife4i</h4><blockquote><p>knife4i 是一个针对 Spring Boot 和 Spring Cloud 的增强型文档生成工具，主要用于生成和管理 RESTful API 文档。它是对 Swagger 的增强版，提供了更多功能和更好的用户体验。下面详细介绍 knife4i 的主要功能和如何在 Spring Boot 项目中使用它。</p></blockquote><blockquote><p>主要功能<br>API 文档生成：自动生成 RESTful API 文档。<br>UI 增强：提供更加友好的 UI 界面，方便查看和调试 API。<br>接口测试：直接在浏览器中测试接口。<br>代码生成：支持多种语言的客户端 SDK 代码生成。<br>接口管理：方便管理和维护 API 文档。</p></blockquote><p>官方配置文档</p><p><strong><a href="https://doc.xiaominfo.com/docs/quick-start">https://doc.xiaominfo.com/docs/quick-start</a></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml">parent&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.13.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-配置启动类"><a href="#2-配置启动类" class="headerlink" title="2.配置启动类"></a>2.配置启动类</h4><p>swagg</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><br><span class="hljs-variable">@EnableOpenApi</span>   <span class="hljs-comment">// 开启Swagger自定义接口文档</span><br><span class="hljs-variable">@Configuration</span>   <span class="hljs-comment">// 相当于Spring配置中的&lt;beans&gt;</span><br>public class SwaggerConfig &#123;<br>    <span class="hljs-comment">// 读取yaml中的配置</span><br>    <span class="hljs-variable">@Value</span>(<span class="hljs-string">&quot;$&#123;swagger.enable&#125;&quot;</span>)<br>    private Boolean enable;<br><br>    <span class="hljs-variable">@Bean</span>   <span class="hljs-comment">// 相当于Spring 配置中的&lt;bean&gt;</span><br>    public Docket <span class="hljs-built_in">createRestApi</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Docket</span>(DocumentationType.OAS_30)<br>                <span class="hljs-comment">// 配置swagger是否生效</span><br>                <span class="hljs-selector-class">.enable</span>(enable)<br>                <span class="hljs-selector-class">.apiInfo</span>(<span class="hljs-built_in">apiInfo</span>())<br>                <span class="hljs-selector-class">.select</span>()<br>                <span class="hljs-selector-class">.apis</span>(RequestHandlerSelectors.<span class="hljs-built_in">withMethodAnnotation</span>(ApiOperation.class))<br>                <span class="hljs-selector-class">.apis</span>(RequestHandlerSelectors.<span class="hljs-built_in">basePackage</span>(<span class="hljs-string">&quot;com.anli1.controller&quot;</span>)) <span class="hljs-comment">// 替换为你的controller包路径</span><br>                <span class="hljs-selector-class">.paths</span>(PathSelectors.<span class="hljs-built_in">any</span>())<br>                <span class="hljs-selector-class">.build</span>();<br>    &#125;<br>    <span class="hljs-comment">// API基础信息定义（就是更新Swagger默认页面上的信息）</span><br>    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">ApiInfo</span> <span class="hljs-selector-tag">apiInfo</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ApiInfoBuilder</span>()<br>                <span class="hljs-selector-class">.title</span>(<span class="hljs-string">&quot;Swagger3接口文档测试&quot;</span>)<br>                <span class="hljs-selector-class">.description</span>(<span class="hljs-string">&quot;这里是文档描述&quot;</span>)<br>                <span class="hljs-selector-class">.contact</span>(new <span class="hljs-built_in">Contact</span>(<span class="hljs-string">&quot;小盛&quot;</span>, <span class="hljs-string">&quot;网址&quot;</span>, <span class="hljs-string">&quot;邮箱&quot;</span>))<br>                <span class="hljs-selector-class">.version</span>(<span class="hljs-string">&quot;v1.0&quot;</span>)<br>                <span class="hljs-selector-class">.build</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Knife4j</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2WebMvc</span> <span class="hljs-comment">// 貌似被弃用，可以替换为@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife4jConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;swagger.enable&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Boolean</span> enable;<br><br>    <span class="hljs-meta">@Bean(value = <span class="hljs-string">&quot;defaultApi2&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> Docket defaultApi2() &#123;<br>        Docket docket=new Docket(DocumentationType.SWAGGER_2)<br>                .enable(enable)<br>                .apiInfo(<br>                        new ApiInfoBuilder()<br>                                <span class="hljs-comment">//.title(&quot;swagger-bootstrap-ui-demo RESTful APIs&quot;)</span><br>                                .description(<span class="hljs-string">&quot;# swagger-bootstrap-ui-demo RESTful APIs&quot;</span>)<br>                                .termsOfServiceUrl(<span class="hljs-string">&quot;http://www.xx.com/&quot;</span>)<br>                                .contact(new Contact(<span class="hljs-string">&quot;小盛&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;504040410@qq.com&quot;</span>))<br>                                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                                .build()<br>                )<br>                <span class="hljs-comment">//分组名称</span><br>                .groupName(<span class="hljs-string">&quot;2.X版本&quot;</span>)<br>                .select()<br>                <span class="hljs-comment">//这里指定你自己的Controller扫描包路径</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.anli1.controller&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></p><p> 访问文档地址</p><h4 id="3-注解认识"><a href="#3-注解认识" class="headerlink" title="3.注解认识"></a>3.注解认识</h4><h6 id="api"><a href="#api" class="headerlink" title="@api"></a>@api</h6><p>用于标记接口类或接口类的方法，描述接口的作用。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Api</span>(value = <span class="hljs-string">&quot;用户管理&quot;</span>, description = <span class="hljs-string">&quot;用户相关的API&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    // ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a>@ApiOperation</h6><p>作用：用于标记接口类的方法，描述具体操作的作用。<br>示例：</p><pre><code class="hljs"> @ApiOperation(value = &quot;获取用户列表&quot;, notes = &quot;返回所有用户的列表&quot;) @GetMapping(&quot;/users&quot;) public List&lt;User&gt; getUsers() &#123;     // ... &#125;</code></pre><h6 id="ApiModel"><a href="#ApiModel" class="headerlink" title="@ApiModel"></a>@ApiModel</h6><p>作用：用于描述模型对象，通常用于实体类</p><pre><code class="hljs"> @ApiModel(description = &quot;用户信息&quot;) public class User &#123;     @ApiModelProperty(value = &quot;用户ID&quot;)     private Long id;     @ApiModelProperty(value = &quot;用户名&quot;)     private String name;     // 其他字段和方法 &#125;</code></pre><h6 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="@ApiModelProperty"></a>@ApiModelProperty</h6><p>作用：用于描述模型对象中的属性。</p><pre><code class="hljs"> @ApiModelProperty(value = &quot;用户ID&quot;, required = true) private Long id;</code></pre><h6 id="ApiParam"><a href="#ApiParam" class="headerlink" title="@ApiParam"></a>@ApiParam</h6><p>作用：用于描述参数。</p><pre><code class="hljs"> @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User getUser(@ApiParam(value = &quot;用户ID&quot;, required = true) @PathVariable Long id) &#123;     // ... &#125;</code></pre><h6 id="ApiResponses"><a href="#ApiResponses" class="headerlink" title="@ApiResponses"></a>@ApiResponses</h6><p>作用：用于描述方法的响应结果。<br>示例：</p><pre><code class="hljs"> @ApiOperation(value = &quot;获取用户列表&quot;) @ApiResponses(&#123;     @ApiResponse(code = 200, message = &quot;成功&quot;),     @ApiResponse(code = 404, message = &quot;未找到&quot;) &#125;) @GetMapping(&quot;/users&quot;) public List&lt;User&gt; getUsers() &#123;     // ... &#125;</code></pre><h6 id="ApiResponse"><a href="#ApiResponse" class="headerlink" title="@ApiResponse"></a>@ApiResponse</h6><p>作用：用于描述单个响应结果。<br>示例：</p><pre><code class="hljs"> @ApiResponse(code = 200, message = &quot;成功&quot;, response = User.class)</code></pre><h6 id="ApiImplicitParams"><a href="#ApiImplicitParams" class="headerlink" title="@ApiImplicitParams"></a>@ApiImplicitParams</h6><pre><code class="hljs"> @ApiOperation(value = &quot;获取用户列表&quot;) @ApiImplicitParams(&#123;     @ApiImplicitParam(name = &quot;page&quot;, value = &quot;页码&quot;, paramType = &quot;query&quot;, dataType = &quot;int&quot;),     @ApiImplicitParam(name = &quot;size&quot;, value = &quot;每页数量&quot;, paramType = &quot;query&quot;, dataType = &quot;int&quot;) &#125;) @GetMapping(&quot;/users&quot;) public List&lt;User&gt; getUsers(@RequestParam int page, @RequestParam int size) &#123;     // ... &#125;</code></pre><h6 id="ApiImplicitParam"><a href="#ApiImplicitParam" class="headerlink" title="@ApiImplicitParam"></a>@ApiImplicitParam</h6><p>作用：用于描述单个隐式参数。<br>示例：</p><pre><code class="hljs"> @ApiImplicitParam(name = &quot;page&quot;, value = &quot;页码&quot;, paramType = &quot;query&quot;, dataType = &quot;int&quot;)</code></pre><h6 id="ApiIgnore"><a href="#ApiIgnore" class="headerlink" title="@ApiIgnore"></a>@ApiIgnore</h6><p>作用：用于忽略某个类或方法，使其不被文档化。<br>示例：</p><pre><code class="hljs">  @ApiIgnore  @GetMapping(&quot;/health&quot;)  public String healthCheck() &#123;      return &quot;OK&quot;;  &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实战 登录注册</title>
    <link href="/2024/10/03/case/%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B/"/>
    <url>/2024/10/03/case/%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>ps</p><p>01案例，不想想太多，简简单单上个手</p><p>设计思路-</p><p>数据库 id 账号 密码</p><p>逻辑 -判断账号密码-给与seioon-拦截器进行判断</p><p>技术方案-</p><p>redis+&#x2F;&#x2F; SpringCache下一个项目再使用</p><p>MQ+Canal-同步数据库 </p><p>xxl-job预热缓存&#x2F;&#x2F;</p><p>cookie 加密登录逻辑 </p><p>调优方案</p><p>jvm-</p><p>查看堆-gc时间-查看高并发下运行时间</p><p>ps:</p><p>01案例-只需要搭建起查看时间，不需要进行各类jvm调优</p><h6 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h6><p>太久没搭建环境了</p><p>创建的maven项目-导入的各类依赖</p><h6 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h6><p>三个字段</p><p>主键 id (雪花算法) 用户名String –去重  密码String </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(id <span class="hljs-type">BigInt</span> <span class="hljs-keyword">Primary key</span>,account <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, <span class="hljs-keyword">password</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><h6 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2.配置环境"></a>2.配置环境</h6><p>1.配置maven 导入spring起步依赖 导入redis-导入knif34i 导入工具类</p><p>2.编写启动类-编写knif4i配置</p><p>3.导入mybutsplus-代码生成</p><p>4.自动生成mvc三层架构模式</p><p>5.插入数据库数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into user(id,account,password) values(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>6.修改用户账号索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> account_unique <span class="hljs-keyword">Unique</span>(account);<br></code></pre></td></tr></table></figure><h6 id="3-登录逻辑"><a href="#3-登录逻辑" class="headerlink" title="3.登录逻辑"></a>3.登录逻辑</h6><h6 id="1-controller"><a href="#1-controller" class="headerlink" title="1.controller"></a>1.controller</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleController</span> &#123;<br><span class="hljs-meta">@Autowired</span><br>    IUserService iUserService;<br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;登录&quot;)</span><br><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(value = &quot;用户ID&quot;, required = true)</span>String account, <span class="hljs-meta">@ApiParam(value = &quot;用户密码&quot;, required = true)</span> String password , HttpServletRequest req)</span> &#123;<br>        R r=iUserService.login(account,password);<br>        <span class="hljs-keyword">if</span>(Objects.nonNull(r.getData()))<br>        &#123;<br>            <span class="hljs-comment">//登录成功了的</span><br>            <span class="hljs-type">SessionwebUserDto</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (SessionwebUserDto) r.getData();<br>            <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>            session.setAttribute(<span class="hljs-string">&quot;session_account&quot;</span>,data);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-service"><a href="#2-service" class="headerlink" title="2.service"></a>2.service</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><span class="hljs-meta">@Autowired</span><br>    RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">login</span><span class="hljs-params">(String account, String password)</span> &#123;<br>        <span class="hljs-comment">//查询redis缓存</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(account);<br>        <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">null</span>)<br>       &#123;<br>            <span class="hljs-comment">//弹出验证码-或者其他策略 查mysql</span><br>            <span class="hljs-comment">//mysql也为空</span><br>            LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            lambdaQueryWrapper.eq(User::getAccount, account); <span class="hljs-comment">// 使用 Lambda 表达式引用字段 lambdaQueryWrapper.ge(User::getAge, 18);</span><br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.baseMapper.selectOne(lambdaQueryWrapper);<br>            o=user;<br>            <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;账号或密码错误&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//插入user缓存到redis</span><br>           redisTemplate.opsForValue().set(account,user);<br><br>        &#125;<br>        <span class="hljs-comment">//账号对了</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) o;<br>        <span class="hljs-keyword">if</span>(!user.getPassword().equals(password))<br>        &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;账号或密码错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//登录成功给sessio</span><br>        <span class="hljs-type">SessionwebUserDto</span> <span class="hljs-variable">sessionwebUserDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionwebUserDto</span>();<br>        sessionwebUserDto.setAccountId(user.getAccount());<br><br>        <span class="hljs-keyword">return</span> R.success(sessionwebUserDto);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>demo 登录注册 <strong>抢单-核销</strong> lua-redis原子性</p><p>主要是的redis进行操作-看看<strong>redis的延迟任务</strong>能不能加入进来</p><h6 id="加密token编写"><a href="#加密token编写" class="headerlink" title="加密token编写"></a><em><strong>加密token编写</strong></em></h6><p>对明文seiion转json后加密</p><p>非对称和对称</p><p>加密解密都在服务器-选择对称加密</p><blockquote><p>采用base64编码，</p><p>需要手动解析data-赋值给对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenEncryption</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;token.encryption.key&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String key;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;token.encryption.iv&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String iv;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;token.encryption.algorithm&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String algorithm;<br><br><br>    <span class="hljs-keyword">private</span> SecretKeySpec AES;<br><br>    <span class="hljs-keyword">private</span>  IvParameterSpec ivSpec;<br>    <span class="hljs-keyword">private</span>  Cipher cipher;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIv</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> iv;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAlgorithm</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> algorithm;<br>    &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTokenEncryption</span><span class="hljs-params">(String data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//用于包装密钥 --包装向量</span><br>       extracted();<br>       <span class="hljs-comment">//指定加密</span><br>        <span class="hljs-comment">//加密</span><br>        cipher.init(Cipher.ENCRYPT_MODE, AES, ivSpec);<br>        <span class="hljs-type">byte</span>[] encrypted = cipher.doFinal(data.getBytes());<br>       <span class="hljs-type">String</span> <span class="hljs-variable">encryptedBase64</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(encrypted);<br><br><br>       <span class="hljs-keyword">return</span> encryptedBase64;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extracted</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(AES==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[] rawKey = adjustKeyLength(key, <span class="hljs-number">16</span>); <span class="hljs-comment">// 16字节=128位</span><br>            AES=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(rawKey,algorithm);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ivSpec==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[] ivBytes = adjustKeyLength(iv, <span class="hljs-number">16</span>);<br>            ivSpec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(ivBytes);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cipher == <span class="hljs-literal">null</span>)<br>        &#123;<br>             cipher = Cipher.getInstance(<span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>);<br>        &#125;<br>    &#125;<br><br> <span class="hljs-keyword">private</span>    SecretKeySpec secretKey;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">retToken</span><span class="hljs-params">(String data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(secretKey==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[]  rawKey = adjustKeyLength(key, <span class="hljs-number">16</span>); <span class="hljs-comment">// 16字节=128位</span><br>            secretKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(rawKey, algorithm);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(ivSpec==<span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-type">byte</span>[] ivBytes = adjustKeyLength(iv, <span class="hljs-number">16</span>);<br>            ivSpec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(ivBytes);<br>        &#125;<br>        <span class="hljs-comment">// 指定解密算法和模式</span><br>        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>);<br><br>        <span class="hljs-comment">// 初始化解密器</span><br>        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);<br><br>        <span class="hljs-comment">// 解密Base64编码的加密数据</span><br>        <span class="hljs-type">byte</span>[] decodedEncryptedData = Base64.getDecoder().decode(data);<br>        <span class="hljs-type">byte</span>[] decryptedData = cipher.doFinal(decodedEncryptedData);<br><br>        <span class="hljs-comment">// 返回解密后的原始字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decryptedData, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] adjustKeyLength(String key, <span class="hljs-type">int</span> length) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] keyBytes = key.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-keyword">if</span> (keyBytes.length == length) &#123;<br>            <span class="hljs-keyword">return</span> keyBytes;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyBytes.length &lt; length) &#123;<br>            <span class="hljs-comment">// 如果长度不足，使用0填充</span><br>            <span class="hljs-type">byte</span>[] paddedKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>            System.arraycopy(keyBytes, <span class="hljs-number">0</span>, paddedKey, <span class="hljs-number">0</span>, keyBytes.length);<br>            <span class="hljs-keyword">return</span> paddedKey;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果长度超出，截取前面的部分</span><br>            <span class="hljs-type">byte</span>[] shortenedKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>            System.arraycopy(keyBytes, <span class="hljs-number">0</span>, shortenedKey, <span class="hljs-number">0</span>, length);<br>            <span class="hljs-keyword">return</span> shortenedKey;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>脑子一抽就写出来了，本来准备套JWT的。。</p><p>我脑子抽了-</p><p>然后-关于过期就加入时间搓效验-我没有加-后续能人再加把-嘻嘻</p></blockquote><h4 id="拦截器编写"><a href="#拦截器编写" class="headerlink" title="拦截器编写"></a>拦截器编写</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>)&#123;<br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截所有请求</span><br>                .<span class="hljs-title function_">excludePathPatterns</span>(<span class="hljs-string">&quot;/api/login&quot;</span>, <span class="hljs-string">&quot;/error&quot;</span>); <span class="hljs-comment">// 排除某些路径不拦截</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>  <span class="hljs-meta">@Autowired</span><br>    TokenEncryption tokenEncryption;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">/*  HttpSession session = request.getSession();</span><br><span class="hljs-comment">        String token= (String) session.getAttribute(&quot;session_account&quot;);*/</span><br>        <span class="hljs-keyword">if</span>(tokenEncryption==<span class="hljs-literal">null</span>)<br>        &#123;<br>            tokenEncryption=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenEncryption</span>();<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                key: &quot;w7HqL+Jz3Kt0J3u6fYT3Ow==&quot;</span><br><span class="hljs-comment">    iv: &quot;77b07a672d57d64c&quot;</span><br><span class="hljs-comment">    algorithm: AES</span><br><span class="hljs-comment">             */</span><br>            tokenEncryption.setKey(<span class="hljs-string">&quot;w7HqL+Jz3Kt0J3u6fYT3Ow==&quot;</span>);<br>            tokenEncryption.setIv(<span class="hljs-string">&quot;77b07a672d57d64c&quot;</span>);<br>            tokenEncryption.setAlgorithm(<span class="hljs-string">&quot;AES&quot;</span>);<br>        &#125;<br><br>        Cookie[] cookies = request.getCookies();<br>        <span class="hljs-keyword">if</span> (cookies == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;用户错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;username&quot;</span>.equals(cookie.getName())) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> cookie.getValue();<br>              <span class="hljs-type">String</span> <span class="hljs-variable">userid</span>  <span class="hljs-operator">=</span>tokenEncryption.retToken(username);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;用户错误&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="全局异常编写"><a href="#全局异常编写" class="headerlink" title="全局异常编写"></a>全局异常编写</h4><p>我redis忘记启动了，报错信息直接给我出了-redis地址-笑死我了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandler</span> &#123;<br>    <span class="hljs-meta">@org</span>.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ExceptionHandler(value = Exception.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-keyword">public</span> R handleException(Exception e)<br>    &#123;<br>        e.getMessage();<br>        <span class="hljs-keyword">return</span>  R.error(<span class="hljs-string">&quot;对不起,操作失败,请联系管理员&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@org</span>.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ExceptionHandler(value = BusinessException.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-keyword">public</span> R handleException(BusinessException e)<br>    &#123;<br>       <br>        <span class="hljs-keyword">return</span>  R.error( e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BusinessException</span> <span class="hljs-title">extends</span> <span class="hljs-title">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">private</span> ResponseCodeEnum codeEnum;<br><br>    <span class="hljs-keyword">private</span> Integer code;<br><br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">public</span> BusinessException(String message, Throwable e) &#123;<br>        <span class="hljs-keyword">super</span>(message, e);<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(String message) &#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(Throwable e) &#123;<br>        <span class="hljs-keyword">super</span>(e);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(ResponseCodeEnum codeEnum) &#123;<br>        <span class="hljs-keyword">super</span>(codeEnum.getMsg());<br>        <span class="hljs-keyword">this</span>.codeEnum = codeEnum;<br>        <span class="hljs-keyword">this</span>.code = codeEnum.getCode();<br>        <span class="hljs-keyword">this</span>.message = codeEnum.getMsg();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BusinessException(Integer code, String message) &#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ResponseCodeEnum getCodeEnum() &#123;<br>        <span class="hljs-keyword">return</span> codeEnum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer getCode() &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String getMessage() &#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写fillInStackTrace 业务异常不需要堆栈信息，提高效率.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Throwable fillInStackTrace() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>10&#x2F;4号代码</p>]]></content>
    
    
    <categories>
      
      <category>后端实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql Er模型</title>
    <link href="/2024/10/01/mysql/Er%E6%A8%A1%E5%9E%8B/Er%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/10/01/mysql/Er%E6%A8%A1%E5%9E%8B/Er%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-Er模型"><a href="#Mysql-Er模型" class="headerlink" title="Mysql Er模型"></a>Mysql Er模型</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3d798c7ab8d7dfd55a274fcc0edaa1ae.png" alt="在这里插入图片描述"></p><p>ps:未了解</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 管理</title>
    <link href="/2024/10/01/mysql/mysql%E7%AE%A1%E7%90%86/mysql%E7%AE%A1%E7%90%86/"/>
    <url>/2024/10/01/mysql/mysql%E7%AE%A1%E7%90%86/mysql%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql管理"><a href="#Mysql管理" class="headerlink" title="Mysql管理"></a>Mysql管理</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/50e52325f000ebef03b8c0a9d406bd67.png" alt="在这里插入图片描述"></p><p>ps:不过脑子看了一遍。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 执行计划</title>
    <link href="/2024/10/01/mysql/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2024/10/01/mysql/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-执行计划"><a href="#Mysql-执行计划" class="headerlink" title="Mysql 执行计划"></a>Mysql 执行计划</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5a7aa3b0d5fc4375a0ed7edf3fa7391b.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>explain<br><span class="hljs-keyword">SELECT</span> id<br><span class="hljs-keyword">FROM</span> orders_0<br><span class="hljs-keyword">WHERE</span> (orders_status <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1716346406098296832</span> <span class="hljs-keyword">AND</span> display <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sort_by<span class="hljs-operator">&lt;</span><span class="hljs-number">1698924600022</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sort_by <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">10</span><br><br><br><br><br><br>[<br>  &#123;<br>    &quot;id&quot;: <span class="hljs-number">1</span>,  每个查询步骤的唯一标识符<br>    &quot;select_type&quot;: &quot;SIMPLE&quot;,  查询的类型，例如 SIMPLE（简单查询）或 <span class="hljs-keyword">PRIMARY</span>（主查询，嵌套子查询的最外层查询）。<br>    &quot;table&quot;: &quot;orders_0&quot;,查询涉及的表。<br>    &quot;partitions&quot;: <span class="hljs-keyword">null</span>, 使用的分区（如果有分区表的话）<br>    &quot;type&quot;: &quot;range&quot;,查询使用的连接类型，例如 <span class="hljs-keyword">ALL</span>（全表扫描）或 index（索引扫描）。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>数据扫描类型<br>    &quot;possible_keys&quot;: &quot;query_index_0,query_index_1&quot;,可能用于此查询的键列表。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>用到的索引<br>    &quot;key&quot;: &quot;query_index_0&quot;,实际用于此查询的键。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>实际索引<br>    &quot;key_len&quot;: &quot;26&quot;,实际用于此查询的键。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>索引字节数<br>    &quot;ref&quot;: <span class="hljs-keyword">null</span>,显示索引的哪一列被用于查询。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>查找值用到的索引<span class="hljs-operator">-</span>名字<br>    &quot;rows&quot;: <span class="hljs-number">1</span>,MySQL 估计将需要读取的行数。<span class="hljs-operator">/</span><span class="hljs-operator">/</span>预计扫描行数<br>    &quot;filtered&quot;: <span class="hljs-number">100</span>,在表中的行数的百分比，表示查询的条件有多少行满足。<span class="hljs-operator">/</span>越大越好<br>    &quot;Extra&quot;: &quot;Using where; Using index&quot; 其他的额外信息，例如使用了哪些索引、是否使用了文件排序等。<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql范式</title>
    <link href="/2024/10/01/mysql/%E8%8C%83%E5%BC%8F/%E8%8C%83%E5%BC%8F/"/>
    <url>/2024/10/01/mysql/%E8%8C%83%E5%BC%8F/%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql范式"><a href="#mysql范式" class="headerlink" title="mysql范式"></a>mysql范式</h1><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式</strong>，英文名称为<code>Normal Form</code>，简称<code>NF</code>。可以理解为，<strong>一张数据表的设计结构需要满足的某种设计标准的级别</strong>。要想设计一个结构合理的关系型数据库，必须满足一定的范式</p><p>目前关系型数据库有六种常见范式，按照范式级别，从<strong>低到高</strong>分别是：<strong>第一范式</strong>（<code>1NF</code>）、<strong>第二范式</strong> （<code>2NF</code>）、<strong>第三范式</strong>（<code>3NF</code>）、<strong>巴斯-科德范式</strong>（<code>BCNF</code>）、<strong>第四范式</strong>(<code>4NF</code>）和<strong>第五范式</strong>（<code>5NF</code>，又称完美范式）。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/66b5891b241d191286f6db87f4c593df.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7b20dde77ec3710676394c37916274d.png" alt="在这里插入图片描述"></p><p>ps:类似于架构师了解-能提升项目的运行速度-对表字段处理，工作很难处理</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-锁</title>
    <link href="/2024/09/30/mysql/%E9%94%81/%E9%94%81/"/>
    <url>/2024/09/30/mysql/%E9%94%81/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/54d52160d5508c502fc7aca831290dd9.png" alt="在这里插入图片描述"></p><h5 id="1-全局锁演示"><a href="#1-全局锁演示" class="headerlink" title="1.全局锁演示"></a>1.全局锁演示</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/85e7f9ae75ed8aef4a4e2e92ac1046fa.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61d33f96df7baf15aaf47b04001d699d.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61d33f96df7baf15aaf47b04001d699d.png" alt="在这里插入图片描述"></p><p>全局锁缺点</p><ul><li>如果在<strong>主库</strong>上备份，那么在<strong>备份期间都不能执行更新，在此期间非查询业务无法正常执行</strong>。</li><li>如果在<strong>从库</strong>上备份，那么在<strong>备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</strong>。</li></ul><h5 id="2-表锁演示"><a href="#2-表锁演示" class="headerlink" title="2.表锁演示"></a>2.表锁演示</h5><p>共享锁</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/caa3aa202b4f3908e58b6632c3988f32.png" alt="在这里插入图片描述"></p><p>独占锁</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c827ade0130b2199aeb482565b390017.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d08c155cfb954f9537ec88427e45564b.png" alt="d08c155cfb954f9537ec88427e45564b"></p><h5 id="3-元数据锁"><a href="#3-元数据锁" class="headerlink" title="3.元数据锁"></a>3.元数据锁</h5><p>元数据锁（meta data lock），简写<code>MDL</code>。其加锁过程是<strong>系统自动控制的，无需显式调用，在访问一张表的时候会自动加上</strong>。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。</p><p>事务-不允许写</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240930102913710.png" alt="image-20240930102913710"></strong></p><h5 id="4-意向锁的具体作用"><a href="#4-意向锁的具体作用" class="headerlink" title="4.意向锁的具体作用"></a>4.意向锁的具体作用</h5><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5635460a65d87661a7d75c78d116ec9f.png" alt="在这里插入图片描述"></p><ul><li>首先客户端一，开启一个事务，然后根据索引执行DML操作，会对涉及到的行加行锁。当客户端二，想对这张表加表锁时，会逐行检查当前表是否有对应的行锁，如果没有，则添加表锁，由于会从第一行数据，检查到最后一行数据，效率较低。</li></ul><p>有了意向锁之后 :</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f88a67eafdc1659450b443811b9856c3.png" alt="在这里插入图片描述"></p><ul><li>客户端一，在执行DML操作时，在加行锁的同时也会对该表加上意向锁。此时其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了 ，极大的提高了效率。</li></ul><h6 id="意向锁分类"><a href="#意向锁分类" class="headerlink" title="意向锁分类"></a>意向锁分类</h6><p>意向锁又分为：</p><p><strong>意向共享锁(IS)</strong>: 由语句select … lock in share mode添加 。与 表<strong>锁共享锁 (read)兼容，与表锁独占锁(write)互斥。</strong></p><p><strong>意向排他锁(IX)</strong>: 由insert、update、delete、select…for update添加 。<strong>与表锁共享锁(read)及独占锁(write)都互斥，意向锁之间不会互</strong>斥。<br>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><p>意向共享锁与表读锁是兼容的：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1920b5dc0b0e0e6a50453b4f4bc41a38.png" alt="在这里插入图片描述"></p><p>意向排他锁与表读锁、写锁都是互斥的：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b3a52fb8af7672ba10977dc2a84b34e4.png" alt="在这里插入图片描述"></p><h5 id="5-行锁"><a href="#5-行锁" class="headerlink" title="5.行锁"></a>5.行锁</h5><p><strong>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</strong>，也就是说<strong>根据索引字段操作数据</strong>行才生效，否则行锁会升级为表锁。</p><h6 id="1-行锁"><a href="#1-行锁" class="headerlink" title="1.行锁"></a>1.行锁</h6><ul><li><strong>行锁</strong>（Record Lock）：<strong>锁定单个行记录的锁</strong>，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f93b1f4f1efae4c1ab3b52297d14b9cb.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/56bbc8d75de1ba5fd52386c30f710917.png" alt="56bbc8d75de1ba5fd52386c30f710917"></p><h6 id="2-间隙锁"><a href="#2-间隙锁" class="headerlink" title="2.间隙锁"></a>2.间隙锁</h6><ul><li><strong>间隙锁</strong>（Gap Lock）：<strong>锁定索引记录间隙</strong>（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240930105157928.png" alt="image-20240930105157928"></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7234d2e32be56fdd45839c6067e3e652.png" alt="在这里插入图片描述"></p><h6 id="3-临间锁"><a href="#3-临间锁" class="headerlink" title="3.临间锁"></a>3.临间锁</h6><p>行锁和间隙锁组合，<strong>同时锁住数据以及数据前面的间隙Gap</strong>。 在RR隔离级别下支持</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6eb7a7d58e33e3a19d9cd5ce49620b28.png" alt="在这里插入图片描述"></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用临键 (next-key) 锁进行搜索和索引扫描，以防止幻读。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 触发器</title>
    <link href="/2024/09/29/mysql/%E8%A7%A6%E5%8F%91%E5%99%A8/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2024/09/29/mysql/%E8%A7%A6%E5%8F%91%E5%99%A8/%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/435040c5d3ab07529ec0571e4230e04e.png" alt="在这里插入图片描述"></p><h5 id="1-执行器作用"><a href="#1-执行器作用" class="headerlink" title="1.执行器作用"></a>1.执行器作用</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bf6d4998e717364090e0b0f5abb38402.png" alt="在这里插入图片描述"></p><h5 id="2-相关语法"><a href="#2-相关语法" class="headerlink" title="2.相关语法"></a>2.相关语法</h5><h6 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1d2b49b223780af1529a2f070a97a3fa.png" alt="在这里插入图片描述"></p><p>触发器中的SQL语句不能出现 SELECT * FROM TABLE 形式的查询 ，因为其会返回一个结果集 ，使用时会抛出错误Not allowed to return a result set from a trigger，可以使用SELECT INTO 为变量设置值。</p><p><strong>在使用插入&#x2F;更新触发器时，由于MySQL的写锁，无法在触发器内再次定义对当前表的更新或插入SQL语句。</strong></p><h6 id="2-查看"><a href="#2-查看" class="headerlink" title="2.查看"></a>2.查看</h6><h6 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h6><h5 id="日志记录添加"><a href="#日志记录添加" class="headerlink" title="日志记录添加"></a>日志记录添加</h5><p>使用触发器可以快捷的记录表数据变更日志。接下来我们通过触发器记录 user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除，学习三种触发器的使用。</p><p>使用方法</p><h6 id="1-创建表-日志记录表"><a href="#1-创建表-日志记录表" class="headerlink" title="1.创建表+日志记录表"></a>1.创建表+日志记录表</h6><h6 id="2-创建insert触发器"><a href="#2-创建insert触发器" class="headerlink" title="2.创建insert触发器"></a>2.创建insert触发器</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> user_insert_trigger<br><span class="hljs-comment">-- 每次在user表执行完插入操作之后触发</span><br>after <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-comment">-- 在日志表插入操作日志</span><br><span class="hljs-comment">-- 通过 new 可以获得新插入的数据行记录</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="hljs-string">&#x27;插入的数据内容为: id=&#x27;</span>,new.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,new.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>,NEW.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, NEW.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, NEW.profession));<br><span class="hljs-keyword">end</span>;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0614efb1acbf4eae7fc2e356225ad288.png" alt="在这里插入图片描述"></p><h6 id="3-update"><a href="#3-update" class="headerlink" title="3.update"></a>3.update</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> user_update_trigger<br><span class="hljs-comment">-- 每次在user表执行完更新操作之后触发</span><br><span class="hljs-keyword">after</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <br><span class="hljs-keyword">VALUES</span><br><span class="hljs-comment">-- 在日志表插入操作日志</span><br><span class="hljs-comment">-- 通过 new 可以获得修改之后的数据行记录</span><br><span class="hljs-comment">-- 通过 old 可以获得修改之前的数据行记录</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;update&#x27;</span>, now(), <span class="hljs-built_in">new</span>.id,concat(<span class="hljs-string">&#x27;更新之前的数据: id=&#x27;</span>,<span class="hljs-built_in">old</span>.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,<span class="hljs-built_in">old</span>.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>, <br><span class="hljs-built_in">old</span>.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, <span class="hljs-built_in">old</span>.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, <span class="hljs-built_in">old</span>.profession,<span class="hljs-string">&#x27; | 更新之后的数据: id=&#x27;</span>,<span class="hljs-built_in">new</span>.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,<span class="hljs-built_in">new</span>.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>, <span class="hljs-built_in">NEW</span>.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, <span class="hljs-built_in">NEW</span>.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, <span class="hljs-built_in">NEW</span>.profession));<br><span class="hljs-keyword">end</span>;<br><br></code></pre></td></tr></table></figure><h6 id="4-delete型触发器"><a href="#4-delete型触发器" class="headerlink" title="4.delete型触发器"></a>4.delete型触发器</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> user_delete_trigger<br><span class="hljs-comment">-- 每次在user表执行完删除操作之后触发</span><br><span class="hljs-keyword">after</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <br><span class="hljs-keyword">VALUES</span><br><span class="hljs-comment">-- 在日志表插入操作日志</span><br><span class="hljs-comment">-- 通过 old 可以获得已经删除的数据行记录</span><br>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;delete&#x27;</span>, now(), <span class="hljs-built_in">old</span>.id,concat(<span class="hljs-string">&#x27;删除之前的数据: id=&#x27;</span>,<span class="hljs-built_in">old</span>.id,<span class="hljs-string">&#x27;,name=&#x27;</span>,<span class="hljs-built_in">old</span>.name, <span class="hljs-string">&#x27;, phone=&#x27;</span>, <span class="hljs-built_in">old</span>.phone, <span class="hljs-string">&#x27;, email=&#x27;</span>, <span class="hljs-built_in">old</span>.email, <span class="hljs-string">&#x27;, profession=&#x27;</span>, <span class="hljs-built_in">old</span>.profession));<br> <span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d339d141f23a9fe9c3f35a0364ad19e3.png" alt="在这里插入图片描述"></p><p>作用:自带一个快照记录-不需要spring我们写框架</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-树和二叉树</title>
    <link href="/2024/09/28/data%20structure/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/09/28/data%20structure/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h4 id="6-1-1-树的定义"><a href="#6-1-1-树的定义" class="headerlink" title="6.1.1 树的定义"></a>6.1.1 树的定义</h4><h5 id="6-1-1-1树的概念"><a href="#6-1-1-1树的概念" class="headerlink" title="6.1.1.1树的概念"></a>6.1.1.1树的概念</h5><p>树是一种非线性结构,它由节点和边组成。节点之间通过边连接.<br>由n(n&gt;&#x3D;o)个节点的有限集。n&#x3D;0表示空树</p><p> n&gt;1时满足:<br><strong>1.有且只有一个根结点并在最顶层</strong></p><p><strong>2.其余结点分成互不相交的 M 个子集,每个子集又是一颗树。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/01ae4e3f3ab40d0d6ee722cca213d94f.png" alt="01ae4e3f3ab40d0d6ee722cca213d94f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925214411226.png" alt="image-20240925214411226"></p><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c7899e91cf258a2e5aeb58cf6a8abf39.png" alt="c7899e91cf258a2e5aeb58cf6a8abf39"></p><h5 id="6-1-2-树的逻辑结构表示"><a href="#6-1-2-树的逻辑结构表示" class="headerlink" title="6.1.2 树的逻辑结构表示"></a>6.1.2 树的逻辑结构表示</h5><h5 id="6-1-3-树的基本术语"><a href="#6-1-3-树的基本术语" class="headerlink" title="6.1.3  树的基本术语"></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925214728851.png" alt="image-20240925214728851">6.1.3  树的基本术语</h5><p>6.2</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925215050252.png" alt="image-20240925215050252"></p><p>1234 探讨的是节点的度</p><p>节点位置探讨  5 6-&gt;对套 </p><p>抽象节点 7 -&gt;包括孩子和孙子</p><p>8 _&gt;H E C A 只要能找到对应父节点就继续</p><p>9  父节点下   同分支下-兄弟节点(节点层次相同 )</p><p>10 树的高度</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6283648c2434efb19dab8c70ed2347bb.png" alt="6283648c2434efb19dab8c70ed2347bb"></p><p>11 </p><h6 id="6-1-4-树的性质"><a href="#6-1-4-树的性质" class="headerlink" title="6.1.4  树的性质"></a>6.1.4  树的性质</h6><h6 id="1-树的节点数"><a href="#1-树的节点数" class="headerlink" title="1.树的节点数"></a>1.树的节点数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7b0b909debd7b65958998b710e0b4bc2.png" alt="7b0b909debd7b65958998b710e0b4bc2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b81c4239fcc6a1bd1ce83c3f1844d5be.png" alt="b81c4239fcc6a1bd1ce83c3f1844d5be"></p><p>节点数&#x3D;总度数(数线或者自己遍历)+1</p><p>例如 A的度数 2 B  C1 G 1省  3+2+1+1+2+3&#x3D;12-再加上A-就是总度数</p><h6 id="2-度为m的数第i层至多节点"><a href="#2-度为m的数第i层至多节点" class="headerlink" title="2.度为m的数第i层至多节点"></a>2.度为m的数第i层至多节点</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925221552376.png" alt="image-20240925221552376"></p><p>看不懂</p><h6 id="3-高度为h-m次树至多有多少个节点"><a href="#3-高度为h-m次树至多有多少个节点" class="headerlink" title="3.高度为h  m次树至多有多少个节点"></a>3.高度为h  m次树至多有多少个节点</h6><p>例如高度4    -3次书</p><p>“m 次树”指的是 <strong>每个节点的度最多为 m 的树</strong>，即每个节点最多可以有 m 个子节点。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925221953903.png" alt="image-20240925221953903"></p><p>3<em>3</em>3*3&#x3D;81-1&#x3D;80&#x2F;2&#x3D;40</p><p>手算</p><p>A(3)  9 -              9*3&#x3D;27 -27+9+1&#x3D;37+BCD &#x3D;40手算也能对上</p><h5 id="6-1-5-树的基本运算"><a href="#6-1-5-树的基本运算" class="headerlink" title="6.1.5 树的基本运算"></a>6.1.5 树的基本运算</h5><h6 id="1-树的运算"><a href="#1-树的运算" class="headerlink" title="1.树的运算"></a>1.树的运算</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925222425649.png" alt="image-20240925222425649"></p><h6 id="2-树的遍历"><a href="#2-树的遍历" class="headerlink" title="2.树的遍历"></a>2.树的遍历</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a8c012d28887d403fce53fd6b0d2eb9.png" alt="2a8c012d28887d403fce53fd6b0d2eb9"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925215050252.png" alt="image-20240925215050252"></p><h5 id="6-1-6树的存储结构"><a href="#6-1-6树的存储结构" class="headerlink" title="6.1.6树的存储结构"></a>6.1.6树的存储结构</h5><p>计算机中-树存储着节点的值-还有节点与节点间的关系</p><h6 id="1-双亲存储结构"><a href="#1-双亲存储结构" class="headerlink" title="1.双亲存储结构"></a>1.双亲存储结构</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e0d9cb587ce9a54d3ffe777dfb242eb5.png" alt="e0d9cb587ce9a54d3ffe777dfb242eb5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/302b2416bd1ef27490005e7e122998bd.png" alt="302b2416bd1ef27490005e7e122998bd"></p><h6 id="2-孩子链表存储结构"><a href="#2-孩子链表存储结构" class="headerlink" title="2.孩子链表存储结构"></a>2.孩子链表存储结构</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e99ab18983dc7dabb1b8967997daed09.png" alt="e99ab18983dc7dabb1b8967997daed09"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0d79d9d1aac810a3ec7802fe69b5fb16.png" alt="0d79d9d1aac810a3ec7802fe69b5fb16"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0db38af72b0e41685ea731c78216f257.png" alt="0db38af72b0e41685ea731c78216f257"></p><p>用空间换来部分算法遍历</p><h6 id="3-孩子兄弟表示法"><a href="#3-孩子兄弟表示法" class="headerlink" title="3.孩子兄弟表示法"></a>3.孩子兄弟表示法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e4784c0f99fccd18533be7f3af34cde5.png" alt="e4784c0f99fccd18533be7f3af34cde5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925224029517.png" alt="image-20240925224029517"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240925224041108.png" alt="image-20240925224041108"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树的每个节点最多只有2个后继节点，度最大为2</p><h4 id="6-2-1二叉树的定义"><a href="#6-2-1二叉树的定义" class="headerlink" title="6.2.1二叉树的定义"></a>6.2.1二叉树的定义</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a95b854c64b1ee12a514fef8416e13a4.png" alt="a95b854c64b1ee12a514fef8416e13a4"></p><p><strong>逻辑表示</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/662d28dac95d48fce16b08859f1f7f6c.png" alt="662d28dac95d48fce16b08859f1f7f6c"></p><p>例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/25e4ad07ef50280efe9411bd04d624d5.png" alt="25e4ad07ef50280efe9411bd04d624d5"></p><h4 id="6-2-2-二叉树的性质"><a href="#6-2-2-二叉树的性质" class="headerlink" title="6.2.2 二叉树的性质"></a>6.2.2 二叉树的性质</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b10626d48c710df1a3750b31a7677610.png" alt="b10626d48c710df1a3750b31a7677610"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b3c33e0f0c0ff70793de170f1c269be.png" alt="1b3c33e0f0c0ff70793de170f1c269be"></p><p>n 0-&gt;叶子节点个数–</p><p>n2-是度&#x3D;2的节点个数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bab76beffd19b333ecde671999c88014.png" alt="bab76beffd19b333ecde671999c88014"></p><p>C</p><h5 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a><strong>特殊二叉树</strong></h5><h6 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1.斜树"></a>1.斜树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240927084532399.png" alt="image-20240927084532399"></p><h6 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2.满二叉树"></a>2.满二叉树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4474f58dbbba4b0fdbd67039efabe3d.png" alt="c4474f58dbbba4b0fdbd67039efabe3d"></p><p>高度为h–2h次方-1  -节点最多的情况</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fdcde068645aa8213c505f9cb0530bb4.png" alt="fdcde068645aa8213c505f9cb0530bb4"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240927095359810.png" alt="image-20240927095359810"></p><p>计算节点最多情况-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0456a0c483c46ebb194c776bbaadd82e.png" alt="0456a0c483c46ebb194c776bbaadd82e"></p><h6 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3.完全二叉树"></a>3.完全二叉树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/da5cec1b77459a3e828b2787860b6332.png" alt="da5cec1b77459a3e828b2787860b6332"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240927085503364.png" alt="image-20240927085503364"></p><p>完全二叉树特性 </p><p>完全二叉树实际上-对应的是满二叉树删除叶节点最右边若干个节点得到的</p><p>二叉树中至多只有最下边两层节点的读书小于2 ，并且二叉树中任意一个节点的右子树高度为h.则左子树的高度只能是h或h+1，因此高度为h的完全二叉树若按层次从上到下，从左到右自然数编号，它与高度为h的满二叉树中节点的编号一一对应</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a6c977d73728864a0eab7b144691e7c2.png" alt="a6c977d73728864a0eab7b144691e7c2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de3e93b1a8cad0f48552d2c5ec2897b2.png" alt="de3e93b1a8cad0f48552d2c5ec2897b2"></p><p>n 1是度为1</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/58572e8e7507955a5d1a96368b707eb6.png" alt="58572e8e7507955a5d1a96368b707eb6"></p><h4 id="6-2-3-二叉树的存储结构"><a href="#6-2-3-二叉树的存储结构" class="headerlink" title="6.2.3 二叉树的存储结构"></a>6.2.3 二叉树的存储结构</h4><h5 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5485d6355af906601e5a9fd3e33a3b53.png" alt="5485d6355af906601e5a9fd3e33a3b53"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b491c0176ee7c01a6a65ddeb325698ce.png" alt="b491c0176ee7c01a6a65ddeb325698ce"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0cc795511b49146f1acf2603434e87b8.png" alt="0cc795511b49146f1acf2603434e87b8"></p><p>具有空间浪费<br>特点总结</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5b6b2e941ef139a1373de2bbfdf162aa.png" alt="5b6b2e941ef139a1373de2bbfdf162aa"></p><h5 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ad0feb90a20cbdbbf7e34fd211d3bc93.png" alt="ad0feb90a20cbdbbf7e34fd211d3bc93"></p><p>叶子节点特点-左右都为空<br>左 数据 右</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b02ee522a627db1efaf6e5de7e2f30c5.png" alt="b02ee522a627db1efaf6e5de7e2f30c5"></p><p>二叉树特点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c0f72288f4f5a88f2e2f3841557eeab6.png" alt="c0f72288f4f5a88f2e2f3841557eeab6"></p><p>—找双亲不方便 可以写三链式表</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20f493db431b79d51749bc0800751a2c.png" alt="20f493db431b79d51749bc0800751a2c"></p><p> 存储双亲链</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69e06d709b1f95592ac17e6c71cb337a.png" alt="69e06d709b1f95592ac17e6c71cb337a"></p><h4 id="6-2-4-递归算法设计"><a href="#6-2-4-递归算法设计" class="headerlink" title="6.2.4 递归算法设计"></a>6.2.4 递归算法设计</h4><h5 id="1-递归算法了解"><a href="#1-递归算法了解" class="headerlink" title="1.递归算法了解"></a>1.递归算法了解</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240928170946087.png" alt="image-20240928170946087"></p><p>递归模型 递归出口-递归的终止条件 递归体 递归求解的递推关系</p><h5 id="2-二叉树的递归算法设计"><a href="#2-二叉树的递归算法设计" class="headerlink" title="2.二叉树的递归算法设计"></a>2.二叉树的递归算法设计</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240928171809445.png" alt="image-20240928171809445"></p><blockquote><p>整个递归过程的关键在于，从树的最底层（叶节点）开始计算，每次计算当前节点的值并将结果返回给上一层，最终返回根节点的总和。图中箭头所示就是递归函数从叶节点向上返回的过程。</p><p>这个递归实现了树的后序遍历（左子树 -&gt; 右子树 -&gt; 根节点），每个节点都只被访问一次，因此时间复杂度为 O(n)，其中 n 是树中节点的总数。</p></blockquote><h4 id="6-4二叉树的基本运算"><a href="#6-4二叉树的基本运算" class="headerlink" title="6.4二叉树的基本运算"></a>6.4二叉树的基本运算</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3a084bee096c8c290d381bafe81ad77e.png" alt="3a084bee096c8c290d381bafe81ad77e"></p><h6 id="1-二叉树初始化"><a href="#1-二叉树初始化" class="headerlink" title="1.二叉树初始化"></a>1.二叉树初始化</h6><p>通过字符来规范树的结构-读取字符进行处理二叉树</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929091845554.png" alt="image-20240929091845554"></p><h6 id="2-销毁二叉树"><a href="#2-销毁二叉树" class="headerlink" title="2.销毁二叉树"></a>2.销毁二叉树</h6><p>递归算法-结束条件结束bt&#x3D;&#x3D;null</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de46920865c40f0027f69978f5cf953d.png" alt="de46920865c40f0027f69978f5cf953d">jhs</p><h6 id="3-高度计算"><a href="#3-高度计算" class="headerlink" title="3.高度计算"></a>3.高度计算</h6><p>f(bt)&#x3D;0; bt&#x3D;null </p><p>max(f(bt-&gt;lchild),f(bt-&gt;rchild))+1;&#x2F;&#x2F;遍历左右子树-谁高就是谁大</p><p>递归代码</p><p>递归结束-左右子树都为空</p><p>int BThight(BtNode *&amp;bt)</p><p>{</p><p>int lchildddep,rchildddep;</p><p>if(bt &#x3D;null) return 0;</p><p>else</p><p>{</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929093243686.png" alt="image-20240929093243686"></p><p>}</p><p>}</p><p>从根节点的左右子树遍历下去-嵌套很深</p><h6 id="4-求二叉树个数"><a href="#4-求二叉树个数" class="headerlink" title="4.求二叉树个数"></a>4.求二叉树个数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dba716586b9766fa6609c8ae656009f9.png" alt="dba716586b9766fa6609c8ae656009f9"></p><h6 id="5-求二叉树叶子节点个数"><a href="#5-求二叉树叶子节点个数" class="headerlink" title="5.求二叉树叶子节点个数"></a>5.求二叉树叶子节点个数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929094209725.png" alt="image-20240929094209725"></p><h6 id="6-输出二叉树"><a href="#6-输出二叉树" class="headerlink" title="6.输出二叉树"></a>6.输出二叉树</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929094316839.png" alt="image-20240929094316839"></p><h4 id="6-5二叉树的遍历"><a href="#6-5二叉树的遍历" class="headerlink" title="6.5二叉树的遍历"></a>6.5二叉树的遍历</h4><h6 id="1-前序"><a href="#1-前序" class="headerlink" title="1.前序"></a>1.前序</h6><p>若二叉树不为空 -<strong>根-&gt;左右</strong></p><p>递归算法</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">void pRi(BtNode*ps)<br>&#123;<br><span class="hljs-comment">//打印</span><br><span class="hljs-function"><span class="hljs-title">pRi</span>（ps-&gt;</span>lchid);<br><span class="hljs-function"><span class="hljs-title">pRi</span>（ps-&gt;</span>light);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f138432e6f5e955d55bd5d98e141654.png" alt="2f138432e6f5e955d55bd5d98e141654"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929095621970.png" alt="image-20240929095621970"></p><h6 id="2-中序"><a href="#2-中序" class="headerlink" title="2.中序"></a>2.中序</h6><p>左根右</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240929152947372.png" alt="image-20240929152947372"></p><p>D  </p><h6 id="3-后序"><a href="#3-后序" class="headerlink" title="3.后序"></a>3.后序</h6><p>左右根</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41fbf8580631e99424e120e5ca9a77aa.png" alt="41fbf8580631e99424e120e5ca9a77aa"></p><h6 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4.层次遍历"></a>4.层次遍历</h6><p>根节点开始-从上向下-同一层从左到右访问节点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241002113334235.png" alt="image-20241002113334235"></p><p>算法剖析</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/895fb13aedccbf010940ab93b8087956.png" alt="895fb13aedccbf010940ab93b8087956"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>遍历代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">void</span> <span class="hljs-keyword">function</span><span class="hljs-params">(bt )</span><br><br>&#123;<br><span class="hljs-keyword">if</span>(bt !=<span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-comment">//左子树递归</span><br><br><span class="hljs-comment">//右子树递归</span><br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>前序-中序-后续-的打印结束根据名字来定-考场如果立马思考还是需要时间的</p><p>其实依照打印顺序递归也是好想的</p><p>序名字-就是根的位置 根左右 左根右  左右 根</p><h4 id="6-6二叉树与树的转换"><a href="#6-6二叉树与树的转换" class="headerlink" title="6.6二叉树与树的转换"></a>6.6二叉树与树的转换</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7d9e0739061552757808aec6378120f.png" alt="e7d9e0739061552757808aec6378120f"></p><h5 id="树转换二叉树"><a href="#树转换二叉树" class="headerlink" title="树转换二叉树"></a>树转换二叉树</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/622b4d4f245461d8be3ca14d6e3b15dd.png" alt="622b4d4f245461d8be3ca14d6e3b15dd"></p><p>完整步骤-下面是取巧方法</p><p>二叉树-孩子兄弟表示法来表示</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/801021d1130c2d06689ee6fd40df4363.png" alt="801021d1130c2d06689ee6fd40df4363"></p><p>串糖葫芦就是右指针串</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c3b15ecc621f90209999ae47cc50ff1e.png" alt="c3b15ecc621f90209999ae47cc50ff1e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/32fabb4a65cd7c2321c855138a7fd4a5.png" alt="32fabb4a65cd7c2321c855138a7fd4a5"></p><h5 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h5><p>ps:基本不变-就是根节点线串完后-依次遍历每个节点下的数据</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0f7ad89c2a69e255c33462ca40776a1.png" alt="b0f7ad89c2a69e255c33462ca40776a1"></p><h6 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h6><p>1.过程转换</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/807d51501d1fe2e9a0df54469e5c575b.png" alt="807d51501d1fe2e9a0df54469e5c575b"></p><p>A-&gt;B右节点有节点-把整个右节点拆下来-同级</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e1b66ba68902f52be920db26447511ba.png" alt="e1b66ba68902f52be920db26447511ba"></p><p>层次顺序恢复</p><h6 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41d4761d60810b7afa9adc41a32d04d2.png" alt="41d4761d60810b7afa9adc41a32d04d2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fa16db114f3f3a7b83aa5fcff23d87c3.png" alt="fa16db114f3f3a7b83aa5fcff23d87c3"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/14c21c3116f7006f21055379645b964a.png" alt="14c21c3116f7006f21055379645b964a"></p><p>注意-简化二叉树下-什么是树-什么是森林</p><h4 id="6-7-哈夫曼树"><a href="#6-7-哈夫曼树" class="headerlink" title="6.7 哈夫曼树"></a>6.7 哈夫曼树</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/883c38cc630cab12b5a3220fd7a6e13f.png" alt="883c38cc630cab12b5a3220fd7a6e13f"></p><h5 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/84dfcde5443298f385743c0a30c4b59b.png" alt="84dfcde5443298f385743c0a30c4b59b"></p><p>树的带权路径长度</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ba23ebc2fc457072454df04454a73599.png" alt="ba23ebc2fc457072454df04454a73599"></p><p>叶子节点的权值-*根节点到达叶子经过的边数-之和</p><h5 id="哈夫曼树的定义-构造"><a href="#哈夫曼树的定义-构造" class="headerlink" title="哈夫曼树的定义-构造"></a>哈夫曼树的定义-构造</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c230d613341cbbe8987c5d8c24c0c64f.png" alt="c230d613341cbbe8987c5d8c24c0c64f"></p><p>哈夫曼树的构造</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79037578c43a7b2a4214a3b77a73db78.png" alt="79037578c43a7b2a4214a3b77a73db78"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/232fd0bc9072a29e517862fa4728481f.png" alt="232fd0bc9072a29e517862fa4728481f"></p><p>将最小和的叶子节点结合-会生成新的节点-其中-必须是叶子节点</p><h5 id="哈夫曼树的编码"><a href="#哈夫曼树的编码" class="headerlink" title="哈夫曼树的编码"></a>哈夫曼树的编码</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd09b925000470bf88be7e398862b5ed.png" alt="dd09b925000470bf88be7e398862b5ed"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1807433cf1f909098a45132e719e9dc9.png" alt="1807433cf1f909098a45132e719e9dc9"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a54437e61b3c0679bfc274267c4ce02.png" alt="0a54437e61b3c0679bfc274267c4ce02"></p><p>2.重新规范ABCD编码</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/23e2f727ac1a7378b3e3eb6f7913b2f8.png" alt="23e2f727ac1a7378b3e3eb6f7913b2f8"></p><p>前缀编码</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd74ab00537f2ddbf29be1294321dd55.png" alt="dd74ab00537f2ddbf29be1294321dd55"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/35ed23fa61ff32a789b564424a8a7fbc.png" alt="35ed23fa61ff32a789b564424a8a7fbc"></p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ff3d2e49788f93e7b2171b2b6cffdfdf.png" alt="ff3d2e49788f93e7b2171b2b6cffdfdf"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql SQL优化</title>
    <link href="/2024/09/27/mysql/sql%E4%BC%98%E5%8C%96/sql%E4%BC%98%E5%8C%96/"/>
    <url>/2024/09/27/mysql/sql%E4%BC%98%E5%8C%96/sql%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/56525dee22310c3f2e41b9350df824be.png" alt="在这里插入图片描述"></p><h4 id="1-插入优化"><a href="#1-插入优化" class="headerlink" title="1.插入优化"></a>1.插入优化</h4><h6 id="1-3-小规模"><a href="#1-3-小规模" class="headerlink" title="1-3 小规模"></a>1-3 小规模</h6><p>1.批量插入数据</p><p>由于每次<code>insert</code>都需要<strong>与数据库建立连接，进行网络传输导致一定的性能损失</strong>，我们可以选择一次性插入多条数据，代替一条一条插入。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">Insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure><p>2.手动控制事务</p><p>mysql-事务是默认开启的-我们避免多次开启事务</p><p>– 多条插入手动控制事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span>  transaction;   <span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span>  tb_test  <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;    <span class="hljs-comment">-- 提交事务</span><br></code></pre></td></tr></table></figure><p>3.主键顺序插入</p><p>由于主键索引的存在，每次插入数据都可能会重新组织索引结构，因此，主键顺序插入，性能要高于乱序插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-- 主键乱序插入 : <span class="hljs-number">8</span>  <span class="hljs-number">1</span>  <span class="hljs-number">9</span>  <span class="hljs-number">21</span>  <span class="hljs-number">88</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span>  <span class="hljs-number">15</span>  <span class="hljs-number">89</span>  <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">3</span>  <br>-- 主键顺序插入 : <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">15</span>  <span class="hljs-number">21</span>  <span class="hljs-number">88</span>  <span class="hljs-number">89</span><br>insert  into  tb_test  <span class="hljs-title function_">values</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>)</span>,(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);  -- 顺序插入<br>insert  into  tb_test  <span class="hljs-title function_">values</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>)</span>,(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);  -- 乱序插入<br><br></code></pre></td></tr></table></figure><h6 id="4大规模"><a href="#4大规模" class="headerlink" title="4大规模"></a>4大规模</h6><p>如果<strong>一次性需要插入大批量数</strong>据(比如: <strong>几百万</strong>的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的<code>load</code>指令进行插入。通过<code>load</code>指令我们可以一次性将本地文件当中的数据全部加载进数据库表结构中。<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/060eb4a390baed91d42dbafbb67d4bb1.png" alt="在这里插入图片描述"></p><p>教程分析</p><ul><li>（1）客户端连接服务端时，加上参数 <code>-–local-infile</code></li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">mysql –-<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span> -<span class="hljs-keyword">u</span> root -p <br>-- -–<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span> 表示需要加载本地文件<br><br></code></pre></td></tr></table></figure><p>2）设置全局参数local_infile为1，<strong>开启从本地加载文件导入数据的开关</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">set  global  local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>3.执行load指令将准备好的数据，加载到表结构中</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">load  data  local  <span class="hljs-keyword">infile</span>  <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span>  <span class="hljs-keyword">into</span>  <span class="hljs-keyword">table</span>  tb_user  fields  <br>terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;,&#x27;</span>  lines  terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;\n&#x27;</span> ; <br><br>--  local  <span class="hljs-keyword">infile</span>  <span class="hljs-string">&#x27;需要加载的文件路径&#x27;</span><br>--  <span class="hljs-keyword">into</span>  <span class="hljs-keyword">table</span>  需要插入到哪张表<br>--  fields terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;字段分隔符&#x27;</span><br>--  lines  terminated  <span class="hljs-keyword">by</span>  <span class="hljs-string">&#x27;行分隔符&#x27;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ba34c5bb916b2d4568056afa7d1b1cd6.png" alt="在这里插入图片描述"></p><h4 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2.主键优化"></a>2.主键优化</h4><h6 id="1-长度优化、"><a href="#1-长度优化、" class="headerlink" title="1.长度优化、"></a>1.长度优化、</h6><p>对于一张表来说主键索引只有一个，但是二级索引可能会有很多个，在二级索引的叶子节点当中挂的就是数据的主键，因此，如果主键长度比较长且二级索引比较多，将会占用大量的磁盘空间。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed56d90914fcb7eb74b1dc528bedeca6.png" alt="在这里插入图片描述"></p><h6 id="2-顺序插入"><a href="#2-顺序插入" class="headerlink" title="2.顺序插入"></a>2.顺序插入</h6><p>在条件允许的情况下，使用<strong>AUTO_INCREMENT自增主键</strong>，顺序插入数据。</p><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，行数据都是存储在聚集索引的叶子节点上的。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/78ac6641a01aff35e1268d9bdda418a5.png" alt="在这里插入图片描述"></p><p>而数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2d46cccf85f29f6d184fb8869c2c448f.png" alt="在这里插入图片描述"></p><ul><li><strong>主键顺序插入效果</strong></li></ul><ol><li>从磁盘中申请页， 主键顺序插入</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/89aa4fd10beb58a5081e20dca93b12f5.png" alt="在这里插入图片描述"></p><ol><li>第一个页没有满，继续往第一页插入</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e09795c3279a42fa57d81077fc7897bf.png" alt="在这里插入图片描述"></p><ol><li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c5a5c659e3037fe313c6da8e2c798830.png" alt="在这里插入图片描述"></p><ol><li>当第二页写满了，再往第三页写入</li></ol><p>如此往复，没有任何额外损耗性能的情况。</p><hr><hr><hr><hr><hr><ul><li><strong>主键乱序插入效果</strong></li></ul><ol><li>假如1#,2#页都已经写满了</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/beecb78b62f4c4293c3941f4d6f7fc22.png" alt="在这里插入图片描述"></p><p>2.此时再插入id为50的记录</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8a37f6367be753c2b7dd632226de9120.png" alt="在这里插入图片描述"></p><ol><li>按照顺序，应该存储在47之后</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e726302bba2b570bdeb97b6794941f8a.png" alt="在这里插入图片描述"></p><ol><li>此时会开辟一个新的页 3#</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41561e3d67fb81472f003e4ccf361db5.png" alt="在这里插入图片描述"></p><ol><li>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/627ae2a4f6ea16c39adfd4883dbe4a3e.png" alt="在这里插入图片描述"></p><ol><li>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针</li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e613d530c9b354fd6eadc23f39ea0955.png" alt="在这里插入图片描述"></p><p>上述的这种现象，称之为 “<strong>页分裂</strong>”，是<strong>比较耗费性能的操作</strong>。</p><p>页分裂指的是：页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列</p><h6 id="3-避免修改主键"><a href="#3-避免修改主键" class="headerlink" title="3.避免修改主键"></a>3.避免修改主键</h6><p><strong>尽量不要使用有意义的值作为主键</strong>，如<strong>身份证号</strong>，避免在进行业务操作对主键产生修改操作。这是因为插入修改删除操作都会导致数据库重新组织索引结构。</p><h4 id="3-order-by"><a href="#3-order-by" class="headerlink" title="3..order by"></a>3..order by</h4><blockquote><p>MySQL的排序，有两种方式：</p><p>​       Using filesort : 通过表的索引或全表扫描，<strong>读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作</strong>，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。<br>​        Using index : <strong>通过有序索引顺序扫描直接返回有序数据</strong>，这种情况即为 using index，不需要 额外排序，操作效率高。<br>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序 操作时，尽量要优化为 Using index。</p></blockquote><ul><li>排序字段值没有索引，Using filesort</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bfbf5cb573a5f802a0feef7e5ddb0906.png" alt="在这里插入图片描述"></p><ul><li>为排序字段值创建索引后，Using index</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/040a4e4a9299a80247c2c3ccc211559a.png" alt="在这里插入图片描述"></p><hr><hr><hr><hr><hr><p>由于我们在MySQL中创建的索引，默认的叶子节点是<strong>从小到大</strong>排序的。如果我们在查询的时候，order by是从大到小即降序<strong>desc</strong>，那么除了出现 Using index， 也会出现了 <strong>Backward index scan，这个代表反向扫描索引。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/75d20fb4e48a34314567063cede4a652.png" alt="在这里插入图片描述"></p><p>– 语法<br>create index 索引名 on 表名(字段名 desc);</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1e51703ed292cf163b7d3fe6aa1aefea.png" alt="在这里插入图片描述"></p><hr><hr><hr><p>排序时,也需要满足最左前缀法则（与where条件不同的是，此时必须按照创建索引时的顺序进行排序）,否则也会出现 filesort。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c772524ca094db96a0cbb22e69097bee.png" alt="在这里插入图片描述"></p><p>因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort</p><hr><hr><hr><p>在条件允许的情况下，<strong>尽量使用覆盖索引代替</strong>*，否则由于回表查询依旧会出现Using filesort</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8c181657e433713b3bfe012a4c1dbfb0.png" alt="在这里插入图片描述"></p><h4 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4.group by优化"></a>4.group by优化</h4><p>与order by类似，分组就相当于大范围的排序。我们同样可以通过<strong>使用索引字段进行分组</strong>来提高效率。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ba73b7370f8289b90a0a0c156b0b110b.png" alt="img"></p><p>此外，对于分组操作，在使用联合索引时，也是符合最左前缀法则的。例如下面：我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f7fc0dc1171a2e7ed4a22b72e0e253f2.png" alt="在这里插入图片描述"></p><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f7fc0dc1171a2e7ed4a22b72e0e253f2.png" alt="在这里插入图片描述"></p><h4 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5..limit优化"></a>5..limit优化</h4><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。这是因为当在进行分页查询时，例如执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记 录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c133b1f99bc94db83f1d20357b16b3e0.png" alt="在这里插入图片描述"></p><p>通过测试我们会看到，分页越往后，查询效率越低。</p><ul><li>一般在进行分页查询时，我们可以通过 <strong>+ 子查询 使用覆盖索引 拿出id-进行筛选id</strong> 的形式进行优化以提高性能。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--  select  *  from  tb_sku limit 9000000,10;</span><br><span class="hljs-comment">-- 例如对于上述测试示例 9000000,10 我们可以进行如下优化</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>,<span class="hljs-number">10</span>) a <span class="hljs-keyword">where</span> t.id  <span class="hljs-operator">=</span>  a.id;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6677c2725704abac6ce8b7dda786329f.png" alt="在这里插入图片描述"></p><p>测试我们可以看到，耗费时间缩短了了近7秒，但是同时也增加了SQL语句复杂度，需要我们根据自身业务情况选择使用~</p><h4 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6..count优化"></a>6..count优化</h4><blockquote><p>在数据量很大的情况下，执行 <code>COUNT</code> 操作通常比较耗时。以下是针对不同存储引擎和优化方案的简化总结：</p><h3 id="MyISAM-与-InnoDB-的-COUNT-对比："><a href="#MyISAM-与-InnoDB-的-COUNT-对比：" class="headerlink" title="MyISAM 与 InnoDB 的 COUNT(*) 对比："></a>MyISAM 与 InnoDB 的 <code>COUNT(*)</code> 对比：</h3><ul><li><strong>MyISAM</strong>：表的总行数存储在磁盘上，执行 <code>COUNT(*)</code> 时可以直接返回结果，因此效率很高。</li><li><strong>InnoDB</strong>：需要逐行读取数据进行计数，因此 <code>COUNT(*)</code> 操作会较慢。</li></ul><h3 id="提升-InnoDB-表的-COUNT-效率："><a href="#提升-InnoDB-表的-COUNT-效率：" class="headerlink" title="提升 InnoDB 表的 COUNT(*) 效率："></a>提升 InnoDB 表的 <code>COUNT(*)</code> 效率：</h3><ol><li><strong>自定义计数</strong>：可以使用 Redis 等外部缓存数据库来存储计数。在插入&#x2F;删除数据时，分别进行加减操作，保持实时计数。</li><li><strong>优化 <code>COUNT</code> 的用法</strong>：<code>COUNT</code> 是聚合函数，计算时会逐行判断。如果参数不是 <code>NULL</code>，则进行累加。不同写法的效率不同。</li></ol><h3 id="COUNT-的不同用法："><a href="#COUNT-的不同用法：" class="headerlink" title="COUNT 的不同用法："></a><code>COUNT</code> 的不同用法：</h3><ul><li><p><code>COUNT(主键)</code>：遍历表，取出每一行的主键值并进行计数（主键不可能为 <code>NULL</code>）。</p></li><li><pre><code class="hljs">COUNT(字段)<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  ：<br><br>  - **无 `NOT NULL` 约束**：遍历表，取出每一行字段值，服务层判断是否为 `NULL`，不为 `NULL` 则累加。<br>  - **有 `NOT NULL` 约束**：直接累加。<br><br>- `COUNT(<span class="hljs-number">1</span>)`：遍历表，但不取值。服务层对每一行放入数字 “<span class="hljs-number">1</span>”，直接累加。<br><br>- `COUNT(*)`：引擎不取字段，直接逐行累加，效率较高。<br><br>### 效率排序：<br><br>- `COUNT(字段)` &lt; `COUNT(主键)` &lt; `COUNT(<span class="hljs-number">1</span>)` ≈ `COUNT(*)`，因此建议优先使用 `COUNT(*)`。<br><br>#### <span class="hljs-number">7</span>..update优化<br><br>InnoDB默认事务级别使用的是行锁，**但是行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁** 。也就是说在开启事务时：<br><br>- 我们能同时根据带有主**键索引的不同id字段修改行记录**-行锁<br><br></code></pre></td></tr></table></figure>update  course  set  name = &#39;javaEE&#39; where id  =  1 ;update  course  set  name = &#39;Vue&#39; where id  =  4 ;</code></pre></li></ul></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>但是无法同时根据不带索引的name字段修改行记录，因为此时行锁会升级为表锁，无法操作。<br><br></code></pre></td></tr></table></figure><p>update course set name &#x3D; ‘SpringBoot’ where name &#x3D; ‘PHP’ ;<br>update update course set name &#x3D; ‘SpringBoot’ where name &#x3D; ‘JS’ ;</p><pre><code class="hljs">**也就是说为了避免行锁升级为表锁影响执行效率，我们应当根据索引字段来进行更新操作。**</code></pre>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 存储过程</title>
    <link href="/2024/09/27/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/09/27/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5fc934f5c3f21ae0bf0e11fa1da2997.png" alt="在这里插入图片描述"></p><h4 id="存储过程的基本操作-1-2"><a href="#存储过程的基本操作-1-2" class="headerlink" title="存储过程的基本操作 (1-2)"></a>存储过程的基本操作 (1-2)</h4><h6 id="1-了解存储过程"><a href="#1-了解存储过程" class="headerlink" title="1.了解存储过程"></a>1.了解存储过程</h6><p>存储过程是<strong>事先经过编译并存储在数据库中的一段 SQL 语句的集合</strong>，调用存储过程可以简化应用开发人员的工作，<strong>可以减少数据在数据库和应用服务器之间的传输</strong>，提高数据处理的效率。 存储过程相当于数据库 SQL 语言层面的代码封装与重用。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/81a4dc8fae84dad88df4b91f4819f541.png" alt="在这里插入图片描述"></p><blockquote><p>可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。<br>类似于其他语言的函数(方法)，在使用存储过程中，可以传递参数，也可以接收返回值。<br>减少客户端与数据库的网络交互，提高执行效率，如果涉及到多条SQL执行，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p></blockquote><h6 id="2-存储过程创建注意事项"><a href="#2-存储过程创建注意事项" class="headerlink" title="2.存储过程创建注意事项"></a>2.存储过程创建注意事项</h6><p>分号错误</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e9a127dff3080aec7ceae81b655ef24f.png" alt="在这里插入图片描述"></p><p>通过关键字 <code>delimiter</code><strong>重新指定SQL语句的结束符</strong>,</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62d1ca8ad004f80a5f8f8347a08c7d33.png" alt="在这里插入图片描述"></p><h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><h5 id="1-变量探究"><a href="#1-变量探究" class="headerlink" title="1.变量探究"></a>1.变量探究</h5><p>系统变量</p><p>系统变量 是MySQL服务器提供，属于服务器层面，其中又分为全局变量、会话变量</p><ul><li>全局变量(<code>GLOBAL</code>): 设置后针对于所有的会话生效</li><li>会话变量(<code>SESSION</code>): 只对当前会话生效，在另外一个会话窗口就不生效了</li><li>mysql服务<strong>重新启动之后，所设置的全局参数会失效</strong>，要想不失效，可以在 <code>/etc/my.cnf</code> 中配置</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/98ceb5f33e3cfe4c02c460f5596a89bf.png" alt="在这里插入图片描述"></li></ul><p>用户自定义变量</p><p>用户根据需要自己定义的变量，可以不提前声明直接使用（返回null），在用的时候直接用 “<code>@变量名</code>” 就可以。其作用域为当前连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 赋值时，可以使用 = ，也可以使用 := </span><br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var_name</span> <span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var_name</span> <span class="hljs-operator">=</span> expr] ... ; <br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr] ... ;<br><br><span class="hljs-comment">-- ===使用示例===</span><br><span class="hljs-keyword">set</span> <span class="hljs-variable">@test1</span> :<span class="hljs-operator">=</span> <span class="hljs-number">111</span>  <span class="hljs-comment">-- 可为单个变量声明赋值</span><br><span class="hljs-keyword">set</span> <span class="hljs-variable">@test2</span> :<span class="hljs-operator">=</span> <span class="hljs-number">222</span>,<span class="hljs-variable">@test3</span><span class="hljs-operator">=</span><span class="hljs-number">333</span>  <span class="hljs-comment">-- 可为多个变量声明赋值</span><br><br></code></pre></td></tr></table></figure><ul><li>方式二</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr  [, <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr] ... <br><br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@var_name</span> <span class="hljs-keyword">FROM</span> 表名;<br><br><span class="hljs-comment">-- ===使用示例===</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@test4</span> :<span class="hljs-operator">=</span> <span class="hljs-number">444</span><br><span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@test5</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">-- 需确保结果为一个</span><br><br></code></pre></td></tr></table></figure><p>局部变量</p><p>定义在局部生效的变量，访问之前，需要先使用<code>DECLARE</code>声明。<strong>可用作存储过程内的局部变量和输入参数</strong>，局部变量的<strong>范围是在其内声明的</strong><code>BEGIN ... END</code>块。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> 存储过程名称 ([ 参数列表 ])<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> 变量名 变量类型 [<span class="hljs-keyword">DEFAULT</span> ... ];<br>    <span class="hljs-comment">-- ....</span><br>    <span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">end</span>;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-- 方式一</span><br><span class="hljs-comment">SET 变量名 = 值 ;</span><br><span class="hljs-comment">-- 方式二</span><br><span class="hljs-comment">SET 变量名 := 值 ;</span><br><span class="hljs-comment">-- 方式三</span><br><span class="hljs-comment">SELECT 字段名 INTO 变量名  FROM  表名 ... ;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/96b316f5e54279aa36ec0ad964538a76.png" alt="在这里插入图片描述"></p><h5 id="2-if判断"><a href="#2-if判断" class="headerlink" title="2.if判断"></a>2.if判断</h5><p>根据定义的分数score变量，判定当前分数对应的分数等级。 score &gt;&#x3D; 85分，等级为优秀。 score &gt;&#x3D; 60分 且 score &lt; 85分，等级为及格。 score &lt; 60分，等级为不及格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建存储过程</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p3()<br> <span class="hljs-keyword">begin</span><br> <span class="hljs-comment">-- 定义变量</span><br>    <span class="hljs-keyword">declare</span> score <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">58</span>;<br>    <span class="hljs-keyword">declare</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">-- if判断</span><br>    if score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;优秀&#x27;</span>;<br>    elseif score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;及格&#x27;</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;不及格&#x27;</span>;<br>    <span class="hljs-keyword">end</span> if;<br>    <span class="hljs-comment">-- 查看参数值</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">result</span>;<br> <span class="hljs-keyword">end</span>;<br> <span class="hljs-comment">-- 调用存储过程</span><br> <span class="hljs-keyword">call</span> p3();<br><br></code></pre></td></tr></table></figure><h5 id="3-参数"><a href="#3-参数" class="headerlink" title="3.参数"></a>3.参数</h5><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>IN</code></td><td>表示输入参数，也就是调用时需要传入值</td></tr><tr><td><code>OUT</code></td><td>表示输出参数，也就是该参数可以作为返回值</td></tr><tr><td><code>INOUT</code></td><td>既可以作为输入参数，也可以作为输出参数</td></tr></tbody></table><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">-- 创建存储过程<br>-- <span class="hljs-keyword">in</span> score int 表示需要传入一个整数型的参数<br>-- <span class="hljs-keyword">out</span> <span class="hljs-keyword">result</span> varchar(<span class="hljs-number">10</span>) 表示返回一个varchar(<span class="hljs-number">10</span>)的字符串参数<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> <span class="hljs-title function_">p4</span><span class="hljs-params">(<span class="hljs-keyword">in</span> score int, <span class="hljs-keyword">out</span> <span class="hljs-keyword">result</span> varchar(10)</span>)<br> <span class="hljs-title function_">begin</span><br>    <span class="hljs-title function_">if</span> <span class="hljs-title function_">score</span> &gt;= 85 <span class="hljs-title function_">then</span><br>        <span class="hljs-title function_">set</span> <span class="hljs-title function_">result</span> := <span class="hljs-string">&#x27;优秀&#x27;</span><span class="hljs-punctuation">;</span><br>    elseif score &gt;= <span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br> <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> := <span class="hljs-string">&#x27;及格&#x27;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> := <span class="hljs-string">&#x27;不及格&#x27;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><span class="hljs-punctuation">;</span><br> <span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br> <br>-- 定义用户变量 @<span class="hljs-keyword">result</span>来接收返回的数据, 用户变量可以不用声明<br>-- 调用存储过程 <br>call p4(<span class="hljs-number">18</span>, @<span class="hljs-keyword">result</span>)<span class="hljs-punctuation">;</span><br>-- 查看变量值<br><span class="hljs-keyword">select</span> @<span class="hljs-keyword">result</span><span class="hljs-punctuation">;</span><br><br></code></pre></td></tr></table></figure><h5 id="4-case-流程控制"><a href="#4-case-流程控制" class="headerlink" title="4.case 流程控制"></a>4.case 流程控制</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5d5d48d883f0e8825d02b19912dd7e1.png" alt="在这里插入图片描述"></p><h5 id="5-循环"><a href="#5-循环" class="headerlink" title="5. 循环"></a>5. 循环</h5><h6 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fdc98bb98a69ca12802b8b0190543fff.png" alt="在这里插入图片描述"></p><h6 id="2-repeat"><a href="#2-repeat" class="headerlink" title="2.repeat"></a>2.repeat</h6><p>与while类似，repeat也是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><p><code>先执行一次</code>逻辑，然后判定<strong>UNTIL</strong>条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/161abeed68a1f50b90748a3a4309ba00.png" alt="在这里插入图片描述"></p><h6 id="3-loop"><a href="#3-loop" class="headerlink" title="3.loop"></a>3.loop</h6><p>LOOP 也可以用来实现循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。 LOOP可以配合一下两个语句使用：</p><ul><li><code>LEAVE</code> ：配合循环使用，退出循环。</li><li><code>ITERATE</code>：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/11400f1726eebe19759860b613c2b24d.png" alt="在这里插入图片描述"></p><table><thead><tr><th>名称</th><th>区别</th></tr></thead><tbody><tr><td><code>while</code></td><td><strong>先判定条件</strong>，如果条件为true，则执行逻辑，否则不执行逻辑。</td></tr><tr><td><code>repeat</code></td><td><strong>先执行一次逻辑</strong>，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</td></tr><tr><td><code>loop</code></td><td>可以配合两个语句实现：死循环，退出循环，跳过剩余语句执行下一轮循环</td></tr></tbody></table><h6 id="4-游标"><a href="#4-游标" class="headerlink" title="4.游标"></a>4.游标</h6><p>我们的变量只能存储单个查询结果<strong>，而游标（CURSOR）是用来存储查询结果集的数据类型</strong> , 在存储过程和函数中可以使用游标对结果集进行循环的处理。</p><ul><li>声明游标</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> 游标名称 <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> 查询语句;<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>打开游标</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">OPEN</span> 游标名称;<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>获取游标记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FETCH</span> 游标名称 <span class="hljs-keyword">INTO</span> 变量 [,变量 ];<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>关闭游标</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CLOSE</span> 游标名称;<br></code></pre></td></tr></table></figure><p>使用示例：根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4ed019020ad2479cbafa0a9df7c7ed93.png" alt="在这里插入图片描述"></p><p>在我们调用上述存储过程的过程中，由于while循环中并没有退出条件，当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。但是此时，user_pro表结构及其数据都已经插入成功了。 要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决</p><h6 id="5-条件处理程序"><a href="#5-条件处理程序" class="headerlink" title="5. 条件处理程序"></a>5. 条件处理程序</h6><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><p>语法<br>DECLARE handler_action HANDLER FOR condition_value [,condition_value] …   statement;<br>1<br>handler_action 的取值：</p><p>CONTINUE: 继续执行当前程序<br>EXIT: 终止执行当前程序<br>condition_value 的取值：</p><p>SQLSTATE sqlstate_value: 状态码，如 02000<br>SQLWARNING: 所有以01开头的SQLSTATE代码的简写<br>NOT FOUND: 所有以02开头的SQLSTATE代码的简写<br>SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写<br>我们来处理完善一下上一个案例所遇到的问题~</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6ead8aebc1af0bee4df72f6d0230fd86.png" alt="在这里插入图片描述"></p><h4 id="6-存储函数"><a href="#6-存储函数" class="headerlink" title="6.存储函数"></a>6.存储函数</h4><p>存储函数<strong>是有返回值的存储过程</strong>，存储函数的参数只能是<code>in</code>类型的。具体语法如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">CREATE  <span class="hljs-keyword">FUNCTION</span>   <span class="hljs-title">存储函数名称</span> ([ 参数列表 ])<br>RETURNS  type  [characteristic ...]<br>BEGIN<br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">RETURN</span> <span class="hljs-type">...</span>;<br><span class="hljs-keyword">END</span> ;<br><br></code></pre></td></tr></table></figure><ul><li><code>DETERMINISTIC</code>：相同类型的输入参数总是产生相同类型的结果</li><li><code>NO SQL</code> ：不包含 SQL 语句。</li><li><code>READS SQL DATA</code>：包含读取数据的语句，但不包含写入数据的语句。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/368d80234ab3ce11f8a7d64050292c65.png" alt="在这里插入图片描述"></p><p>注意：在mysql8.0版本中<code>binlog</code>默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql执行耗时</title>
    <link href="/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/sql%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6/"/>
    <url>/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/sql%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql执行耗时"><a href="#mysql执行耗时" class="headerlink" title="mysql执行耗时"></a>mysql执行耗时</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7f70e187ad24476e662c28723f3a81a9.png" alt="img"></p><h6 id="1-sql执行频率"><a href="#1-sql执行频率" class="headerlink" title="1.sql执行频率"></a>1.sql执行频率</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/34df6fc2b1e7174a47b7b0621aa03d48.png" alt="在这里插入图片描述"></p><blockquote><p>模糊匹配</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8648d68ee5e264a8765eab167ee255bc.png" alt="在这里插入图片描述"></p></blockquote><hr><p><strong>，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 <strong>如果是以查询为主，那么就要考虑对数据库的索引进行优化了</strong>。</strong></p><h6 id="2-慢日志开启"><a href="#2-慢日志开启" class="headerlink" title="2.慢日志开启"></a>2.慢日志开启</h6><blockquote><p>慢查询日志记录了<strong>执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志</strong>。 MySQL的慢查询日志<strong>默认没有开启</strong>，需要我们手动的开启，我们可以查看一下系统变量 <code>slow_query_log</code>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62f5b157978b1dc56bee39972d036af4.png" alt="在这里插入图片描述"></p><blockquote><p>如果要开启慢查询日志，需要在MySQL的配置文件（<code>/etc/my.cnf</code>）中配置如下信息：</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 1.开启MySQL慢日志查询开关</span><br>slow_query_log = <span class="hljs-number">1</span><br><br><span class="hljs-comment">-- 2.设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br>long_query_time = <span class="hljs-number">2</span><br><br><span class="hljs-comment">-- 3.配置完毕之后，重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 </span><br>systemctl <span class="hljs-keyword">restart</span> mysqld<br><br>g<span class="hljs-comment">-- 4. 随后我们可以在/var/lib/mysql/localhost-slow.log中</span><br><span class="hljs-comment">-- 查看慢日志文件中记录的信息</span><br>cat /var/lib/mysql/localhost-slow.lo<br></code></pre></td></tr></table></figure><blockquote><p>-<br>  – 查看慢日志文件中记录的信息<br>  cat &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.lo</p><ul><li>我们可以执行一条比较耗时的SQL语句（耗时超过指定的2s），然后看慢查询日志是否记录了相关信息。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/52fb5f6fedd2d5d96c0d6ccc21b8605b.png" alt="在这里插入图片描述"></p><h6 id="3-执行计划"><a href="#3-执行计划" class="headerlink" title="3.执行计划"></a>3.执行计划</h6><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">explain<br>SELECT id,user_id,serve_item_name<br>FROM <span class="hljs-keyword">orders_0</span><br><span class="hljs-keyword"></span>WHERE (<span class="hljs-keyword">orders_status </span>= <span class="hljs-number">0</span> <span class="hljs-keyword">AND </span>user_id = <span class="hljs-number">1716346406098296832</span> <span class="hljs-keyword">AND </span><span class="hljs-keyword">display </span>= <span class="hljs-number">1</span> <span class="hljs-keyword">and </span>sort_by&lt;<span class="hljs-number">1698924600022</span>)<br><span class="hljs-keyword">ORDER </span><span class="hljs-keyword">BY </span>sort_by DESC<br>LIMIT <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<br>  &#123;<br>    &quot;id&quot;: <span class="hljs-number">1</span>,  每个查询步骤的唯一标识符<br>    &quot;select_type&quot;: &quot;SIMPLE&quot;,  查询的类型，例如 SIMPLE（简单查询）或 <span class="hljs-keyword">PRIMARY</span>（主查询，嵌套子查询的最外层查询）。<br>    &quot;table&quot;: &quot;orders_0&quot;,查询涉及的表。<br>    &quot;partitions&quot;: <span class="hljs-keyword">null</span>, 使用的分区（如果有分区表的话）<br>    &quot;type&quot;: &quot;range&quot;,查询使用的连接类型，例如 <span class="hljs-keyword">ALL</span>（全表扫描）或 <span class="hljs-keyword">index</span>（索引扫描）。<br>    &quot;possible_keys&quot;: &quot;query_index_0,query_index_1&quot;,可能用于此查询的键列表。<br>    &quot;key&quot;: &quot;query_index_0&quot;,实际用于此查询的键。<br>    &quot;key_len&quot;: &quot;26&quot;,实际用于此查询的键。<br>    &quot;ref&quot;: <span class="hljs-keyword">null</span>,显示索引的哪一列被用于查询。<br>    &quot;rows&quot;: <span class="hljs-number">1</span>,MySQL 估计将需要读取的行数。<br>    &quot;filtered&quot;: <span class="hljs-number">100</span>,在表中的行数的百分比，表示查询的条件有多少行满足。<br>    &quot;Extra&quot;: &quot;Using where; Using index&quot; 其他的额外信息，例如使用了哪些索引、是否使用了文件排序等。<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 存储引擎</title>
    <link href="/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2d0e1a405212168834553b0697afe31a.png" alt="img"></p><p><code>MyISAM</code>是MySQL早期的默认存储引擎。它不支持事务，不支持外键，不支持行锁，但是它支持表锁，而且<strong>访问速度很快</strong>。</p><h6 id="1-体系结构"><a href="#1-体系结构" class="headerlink" title="1.体系结构"></a>1.体系结构</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5a3eb5c08370e63227fbfcdb8c84e7a1.png" alt="在这里插入图片描述"></p><blockquote><p>连接层：负责处理客户端连接请求，包括本地sock通信和基于TCP&#x2F;IP的客户端&#x2F;服务端通信，支持线程池和SSL安全连接。该层负责认证、授权及安全性检查。</p><p>服务层：执行SQL接口、查询缓存、SQL解析与优化，处理跨存储引擎功能，如函数、过程等，负责查询解析与优化。</p><p>存储引擎层：负责数据的存储与提取，通过API与服务器通信，支持多种存储引擎，索引结构随引擎不同。</p><p>数据存储层：将数据（如日志、索引）存储到文件系统，管理与存储引擎的交互。</p><p>MySQL的架构灵活，插件式存储引擎适应多种业务场景。————————————————</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 索引</title>
    <link href="/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/09/26/mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B4%A2%E5%BC%95sql%E4%BC%98%E5%8C%96/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197b41c9ff3284f61e102fa83bbaa0f.png"></p><h6 id="0-引用"><a href="#0-引用" class="headerlink" title="0.引用"></a>0.引用</h6><p><strong>数据库除了存储数据之外，还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 当我们在查找数据的时候，就可以在这些数据结构上实现高级查找算法，快速查找到我们想要的数据，这种数据结构就是索引</strong>。</p><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td><strong>提高数据检索的效率</strong>，降低数据库的IO成本</td><td>索引列也是要<strong>占用空间</strong>的</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，<strong>降低CPU的消耗</strong>。</td><td>索引大大提高了查询效率，同时却也<strong>降低更新表的速度</strong>， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dedb0bef3ead1be337fbb8c545872435.png" alt="在这里插入图片描述"></p><p>针对于这张表的age字段建立了索引，假设索引的数据结构就是二叉树（实际并不是，而是一种比二叉树更高效的数据结构），那么也就意味着，会对age这个字段建立一个二叉树的索引结构。此时我们在进行查询时，<strong>只需要扫描三次</strong>就可以找到数据了，极大的提高的查询的效率。</p><h6 id="2-索引结构"><a href="#2-索引结构" class="headerlink" title="2.索引结构"></a>2.索引结构</h6><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p><strong>特别说明</strong>：MySQL索引数据结构对经典的B+Tree进行了优化。<strong>在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree</strong>，提高区间访问的性能，利于排序。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aa4fb1c8e79c9e5a49a98b19eb5587e2.png" alt="在这里插入图片描述"></p><h4 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h4><p><strong>在MySQL数据库中</strong>，将索引的具体类型主要分为以下几类：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td><strong>主键</strong>索引</td><td><strong>针对于表中主键</strong>创建的索引</td><td>默认自动创建, <strong>只能有一个</strong></td><td><code>PRIMARY</code></td></tr><tr><td><strong>唯一</strong>索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有<strong>多个</strong></td><td><code>UNIQUE</code></td></tr><tr><td><strong>常规</strong>索引</td><td>快速定位特定数据</td><td>可以有<strong>多个</strong></td><td></td></tr><tr><td><strong>全文</strong>索引</td><td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td><td>可以有<strong>多个</strong></td><td><code>FULLTEXT</code></td></tr></tbody></table><p>而<strong>在InnoDB存储引擎中</strong>，<strong>根据索引的存储形式</strong>，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><strong>聚集</strong>索引(<code>Clustered Index</code>)</td><td>将<strong>数据存储与索引放到了一块</strong>，索引结构的<strong>叶子节点保存了行数据</strong></td><td><strong>必须有</strong>,而且<strong>只有一个</strong></td></tr><tr><td><strong>二级</strong>（非聚集）索引(<code>Secondary Index</code>)</td><td>将<strong>数据与索引分开存储</strong>，索引结构的<strong>叶子节点关联的是对应的主键</strong></td><td><strong>可以存在多个</strong></td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/18faad393942fd691df45c49946a2189.png" alt="在这里插入图片描述"></p><ul><li><strong>聚集索引</strong>的叶子节点下<strong>挂的是这一行的数据</strong> 。</li><li><strong>二级（非聚集）索引</strong>的叶子节点下挂的是<strong>该字段值对应的主键值</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/745eaf5e00b49b4f5eca1cf7a3564648.png" alt="在这里插入图片描述"></p><p>当我们执行上述的SQL语句：</p><p><strong>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</strong><br><strong>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</strong><br>最终拿到这一行的数据，直接返回即可。<br>这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为<strong>回表查询</strong>。</p><p>由于存在回表查询，我们通过聚集索引查询值的方式要比通过二级索引查询值的方式快很多。因为走聚集索引，可以直接返回数据。 而走二级索引，需要先获取id值，然后再查询聚集索引获取值要慢许多。<br>————————————————</p><h4 id="4-创建索引"><a href="#4-创建索引" class="headerlink" title="4.创建索引"></a>4.创建索引</h4><p>索引创建要遵从最左前缀法则</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">UNIQUE</span> | FULLTEXT ] <span class="hljs-keyword">INDEX</span> 索引名 <span class="hljs-keyword">ON</span> table_name (字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>,... );<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 为用户表的姓名name字段创建名为idx_user_name的唯一索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_user_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(name);<br><br><span class="hljs-comment">-- 为用户表的手机号phone字段创建名为idx_user_phone的普通索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_user_phone <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(phone);<br><br><span class="hljs-comment">-- 为用户表的profession,age,status字段创建名为idx_user_pro_age_stae的联合索引-不回表查询</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_user_pro_age_sta <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(profession,age,status);<br><br></code></pre></td></tr></table></figure><p>最左原则例子</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> <br>query_index_0 <br><span class="hljs-keyword">on</span> <br>jzo2o-orders<span class="hljs-number">-1.</span>orders_0<br>(orders_status <span class="hljs-keyword">asc</span>, user_id <span class="hljs-keyword">asc</span>, display <span class="hljs-keyword">asc</span>, sort_by <span class="hljs-keyword">desc</span>); <br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">explain<br>SELECT id<br>FROM <span class="hljs-keyword">orders_0</span><br><span class="hljs-keyword"></span>WHERE (<span class="hljs-keyword">orders_status </span>= <span class="hljs-number">0</span> <span class="hljs-keyword">AND </span>user_id = <span class="hljs-number">1716346406098296832</span> <span class="hljs-keyword">AND </span><span class="hljs-keyword">display </span>= <span class="hljs-number">1</span> <span class="hljs-keyword">and </span>sort_by&lt;<span class="hljs-number">1698924600022</span>)<br><span class="hljs-keyword">ORDER </span><span class="hljs-keyword">BY </span>sort_by DESC<br>LIMIT <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="5-索引失效情况"><a href="#5-索引失效情况" class="headerlink" title="5.索引失效情况"></a>5.索引失效情况</h4><h6 id="1-最左前缀法则"><a href="#1-最左前缀法则" class="headerlink" title="1.最左前缀法则"></a>1.最左前缀法则</h6><p>1.<strong>如果索引了多列（联合索引），要遵守最左前缀法则</strong>。</p><p>注：在where条件中索引最左列存在即可，在order by多字段排序中索引最左列必须为排序条件最左列。</p><h6 id="2-范围查询"><a href="#2-范围查询" class="headerlink" title="2.范围查询"></a>2.范围查询</h6><p>联合索引中，出现范围查询<code>(&gt;,&lt;</code>)，<strong>范围查询右侧的列索引失效</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age &gt; <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> status = <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p>根据长度<code>key_len</code>我们可以知道：联合索引生效了，但是只有profession与age的索引生效了，status字段的索引没有生效。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb22fd01b4f7dc7d021a8025b3f2a61f.png" alt="在这里插入图片描述"></p><p><strong>值得注意的是</strong>：当范围查询使用<code>&gt;=</code> 或 <code>&lt;=</code> 时，则不会产生影响。 因此，在业务允许的情况下，进行范围查询时，为了避免索引失效，我们可以使用类似于 <code>&gt;=</code> 或 <code>&lt;=</code> 这类的范围查询，代替使用<code>&gt;</code> 或 <code>&lt;</code>。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9044380259b86c0ee14b88b788f79d28.png" alt="在这里插入图片描述"></p><h6 id="3-索引列运算"><a href="#3-索引列运算" class="headerlink" title="3.索引列运算"></a>3.索引列运算</h6><p>当我们在索引列上进行运算操作， 索引也将失效。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span>  <span class="hljs-keyword">select</span>  *  <span class="hljs-keyword">from</span>  <span class="hljs-keyword">user</span>  <span class="hljs-keyword">where</span>  substring(phone,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) = <span class="hljs-string">&#x27;15&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e77f250521e08c856951053745eedd5d.png" alt="在这里插入图片描述"></p><h6 id="4-字符串不加引号"><a href="#4-字符串不加引号" class="headerlink" title="4.字符串不加引号"></a>4.<strong>字符串不加引号</strong></h6><p>当我们对添加索引的字符串类型字段进行操作时，如果<strong>字符串不加引号</strong>，对于查询结果，没什么影响，但是数据库存在隐式类型转换，<strong>索引将失效</strong>。</p><ul><li>例如 phone 为 varchar类型字段</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/70cfc75173512170e116448195027897.png" alt="在这里插入图片描述"></p><h6 id="5-模糊查询"><a href="#5-模糊查询" class="headerlink" title="5.模糊查询"></a>5.模糊查询</h6><p>如果仅仅是<strong>尾部模糊匹配，索引不会失效</strong>。如果是<strong>头部模糊匹配，索引失效</strong></p><ul><li>我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/be218c2cb18370a2148ac42f5ecaf63f.png" alt="在这里插入图片描述"></p><h6 id="6-or连接条件"><a href="#6-or连接条件" class="headerlink" title="6.or连接条件"></a>6.or连接条件</h6><p>用or分割开的条件， <strong>如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</strong></p><ul><li>例如我们先删除age字段上的联合索引，再进行or连接查询</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3dc203f7379ec6635da67947b7ba8725.png" alt="在这里插入图片描述"></p><p>我们发现当or连接的条件，左右两侧字段都有索引时，索引才会生效~</p><h6 id="7-数据分布影响-索引使用情况"><a href="#7-数据分布影响-索引使用情况" class="headerlink" title="7.数据分布影响-索引使用情况"></a>7.数据分布影响-索引使用情况</h6><p>如果MySQL评估使用索引比全表扫描更慢，则不使用索引。</p><ul><li>例如，下面使用相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/918d8a2e9104654ba4d293844176d958.png" alt="在这里插入图片描述"></p><p>这是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p><h4 id="6-索引使用优化"><a href="#6-索引使用优化" class="headerlink" title="6.索引使用优化"></a>6.索引使用优化</h4><h6 id="1-SQL提示"><a href="#1-SQL提示" class="headerlink" title="1.SQL提示"></a>1.SQL提示</h6><blockquote><p>当我们的字段存在多个索引时，MySQL会进行评估自动选择一个索引进行使用。我们也可以<strong>借助于SQL提示指定MySQL使用哪个索引</strong>。</p></blockquote><ul><li><code>use index</code> ：建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估，即或许不会遵从建议）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 use index(索引名) <span class="hljs-keyword">where</span> 查询条件....;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e499ff8da49c252b9207ccdda6f446e.png" alt="在这里插入图片描述"></p><ul><li><p><code>force index</code> ： 强制使用索引</p></li><li><p><code>ignore index</code> ：忽略指定的索引</p></li></ul><h6 id="2-覆盖索引-聚集索引-介绍"><a href="#2-覆盖索引-聚集索引-介绍" class="headerlink" title="2.覆盖索引 聚集索引 介绍"></a>2.覆盖索引 聚集索引 介绍</h6><p>在需求允许的情况下，尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少<code>select *</code>的使用。</p><p>创建索引-防止回表查询  执行器返回</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>聚集索引查询</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/775bba4e48859a02efba1dbba92e33fa.png" alt="在这里插入图片描述"></p><p>覆盖索引</p><ul><li>根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索 引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9ada929f8b5ffa035c8ad17445bdaa2.png" alt="在这里插入图片描述"></p><p>回表查询</p><p>多查询一个gender字段，由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相 对较差一点。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/49f94fe8830483f549d0192ecf46dde1.png" alt="在这里插入图片描述"></p><h6 id="3-前缀索引"><a href="#3-前缀索引" class="headerlink" title="3.前缀索引"></a>3.前缀索引</h6><p>当字段类型为字符串（varchar，text，longtext等）时，有时候这些字段值会非常大（例如一段很长的文本），如果直接对此建立索引，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>create index 索引名 on 表名(字段名(索引长度)) ;</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/85353abee403daebd3eb39c1e601a2c5.png" alt="在这里插入图片描述"></p><p>有时候我们难以确定应该创建多长的索引，这时可以根据索引的选择性来决定。选择性是指<strong>不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高</strong>， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">-- 可以直接计算比值<br><span class="hljs-keyword">select</span>  count(<span class="hljs-keyword">distinct</span> 字段名) / count<span class="hljs-comment">(*) from 表名;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-- 也可以使用函数截取部分数据进行计算</span><br><span class="hljs-comment"> select  count(distinct substring(字段名,开始位置,结束位置)) / count(*)</span> <span class="hljs-keyword">from</span> 表名<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cde495c86ccb9f2660001f19f45970e2.png" alt="在这里插入图片描述"></p><p>前缀索引的查询流程</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4e4ff3db963e37c8fbdb9220903ac42c.png" alt="在这里插入图片描述"></p><ul><li>对于类似身份证号、微信小程序openId这些，其长度比较长，但是其前几位区分度并不大，很显然不能直接创建前缀索引，于此，我们可以在数据库中对其倒序存储，再计算索引选择性创建合适长度的索引</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> openId <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> openId=reverse(<span class="hljs-string">&#x27;xxxxxx&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="7-索引设计原则"><a href="#7-索引设计原则" class="headerlink" title="7.索引设计原则"></a>7.索引设计原则</h4><p>针对于数据量较大，且查询比较频繁的表建立索引</p><p>。<br>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>在复合业务场景的情况下，尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</p><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p><p>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-视图详解</title>
    <link href="/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/"/>
    <url>/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e38cef8b1142a5e6cdecd852b8e0e64.png" alt="img"></p><h6 id="1-视图创建"><a href="#1-视图创建" class="headerlink" title="1.视图创建"></a>1.视图创建</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4adba23c36c21d29f7333ed1ca00b7b3.png" alt="在这里插入图片描述"></p><h6 id="2-操作数据"><a href="#2-操作数据" class="headerlink" title="2.操作数据"></a>2.操作数据</h6><p>视图也是一张表，我们可以像操作正常表一样操作视图。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/411a3256cd81babd17c4ab734204a1c8.png" alt="在这里插入图片描述"></p><h6 id="3-修改视图"><a href="#3-修改视图" class="headerlink" title="3. 修改视图"></a>3. 修改视图</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1ca8bd5536cdcd2976a90d59018ebeb5.png" alt="在这里插入图片描述"></p><ul><li>方式二</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9ad91dcd17d274ee645377d602307cc4.png" alt="在这里插入图片描述"></p><h4 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h4><p>由于视图是虚拟存在的表，<strong>我们对视图的操作都会反应到基表当中</strong>，</p><p>假设我们对视图表插入<strong>不符合视图where条件的数据</strong>，那么这条数据只会存在于基表当中，而<strong>我们在视图表无法获悉</strong>，这岂不是插入了一条无效数据？</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/859a6bc41a2feb3335f82e2140f0460b.png" alt="在这里插入图片描述"></p><h6 id="1-CASCADED级联"><a href="#1-CASCADED级联" class="headerlink" title="1 CASCADED级联"></a>1 CASCADED级联</h6><p>假设v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 <code>cascaded</code>，v1视图 创建时未指定检查选项（如果指定了则继续检查上一级，以此往复）。 则在对v2进行操作执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1，如果不满足条件则无法进行相关操作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ccfaf862ac5d565e8a314d7e3d9b929.png" alt="在这里插入图片描述"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d8c8e73ecf50f96a59d1b336079c38f3.png" alt="在这里插入图片描述"></p><ul><li><code>u2</code>插入成功</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ee38d82249fb9ec346bbe6c3759d4922.png" alt="img"></p><ul><li><code>u1</code>插入情况</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cd39677ac7b14f045bc036a0340d2fd7.png" alt="在这里插入图片描述"></li></ul><h6 id="2-LOCAL本地"><a href="#2-LOCAL本地" class="headerlink" title="2. LOCAL本地"></a>2. LOCAL本地</h6><h4 id="4-视图更新"><a href="#4-视图更新" class="headerlink" title="4.视图更新"></a>4.视图更新</h4><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p><p>聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）<br>DISTINCT<br>GROUP BY<br>HAVING<br>UNION 或者 UNION ALL<br>例如我们创建视图时使用了聚合函数，破坏了一对一关系</p><p>create view stu_v_count as select count(*) from student;<br>1<br>如果我们对这个视图进行更新或插入的，将会报错。</p><p>insert into stu_v_count values(10);<br>1</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-限性表-栈-队列</title>
    <link href="/2024/09/24/data%20structure/%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A0%88%E9%98%9F%E5%88%97/"/>
    <url>/2024/09/24/data%20structure/%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A0%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h4 id="3-1栈"><a href="#3-1栈" class="headerlink" title="3.1栈"></a>3.1栈</h4><h5 id="3-1-1栈的基本概念"><a href="#3-1-1栈的基本概念" class="headerlink" title="3.1.1栈的基本概念"></a>3.1.1栈的基本概念</h5><p>栈（Stack）是一种<strong>后进先出</strong>（LIFO, Last In First Out）的数据结构。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/31223128ec51be79cbbaab3a516fbd79.png" alt="在这里插入图片描述"></p><p>栈的存储方式</p><ul><li>线性存储(顺序)</li><li>链接存储（链表）</li></ul><p><strong>栈的相关概念</strong></p><ul><li>栈顶和栈底：允许元素插入与删除的一段称为栈顶，另一端栈底</li><li>压栈：栈的插入操作，叫做进栈，也称压栈、入栈</li><li>弹栈：栈的删除操作，也叫作出栈</li></ul><h5 id="3-3-2栈的基本运算"><a href="#3-3-2栈的基本运算" class="headerlink" title="3.3.2栈的基本运算"></a>3.3.2栈的基本运算</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4a863233041de63d236d25cef8aa9bc8.png" alt="4a863233041de63d236d25cef8aa9bc8"></p><h4 id="3-1-2栈的顺序存储结构"><a href="#3-1-2栈的顺序存储结构" class="headerlink" title="3.1.2栈的顺序存储结构"></a>3.1.2栈的顺序存储结构</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cbb54aaeb6631dfefabaa6f13be1af80.png" alt="cbb54aaeb6631dfefabaa6f13be1af80"></p><h5 id="3-3-3栈的运算算法"><a href="#3-3-3栈的运算算法" class="headerlink" title="3.3.3栈的运算算法"></a>3.3.3栈的运算算法</h5><h6 id="1-初始化栈"><a href="#1-初始化栈" class="headerlink" title="1.初始化栈"></a>1.初始化栈</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2721032b154a905ca4d7d363ac5ca8b7.png" alt="2721032b154a905ca4d7d363ac5ca8b7"></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h6 id="2-销毁栈"><a href="#2-销毁栈" class="headerlink" title="2.销毁栈"></a>2.销毁栈</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fd1ccae8d6ebc042c2846cf1f9bf70d3.png" alt="fd1ccae8d6ebc042c2846cf1f9bf70d3"></p><h6 id="3-push进栈算法"><a href="#3-push进栈算法" class="headerlink" title="3.push进栈算法"></a>3.push进栈算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924122500463.png" alt="image-20240924122500463"></p><h6 id="4-pop出栈算法"><a href="#4-pop出栈算法" class="headerlink" title="4.pop出栈算法"></a>4.pop出栈算法</h6><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">int pop(sQsTACK &amp; <span class="hljs-keyword">ST</span>,ElemType x)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">st</span>.top==maxSizx-1)<br>&#123;<br><span class="hljs-keyword">return</span> 0;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>x=<span class="hljs-keyword">st</span>.data[<span class="hljs-keyword">st</span>.topp];<br><span class="hljs-keyword">st</span>.top--;<br><span class="hljs-keyword">return</span> 1;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-取栈顶元素"><a href="#5-取栈顶元素" class="headerlink" title="5.取栈顶元素"></a>5.取栈顶元素</h6><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata">int Getpop(sQsTACK &amp; <span class="hljs-keyword">ST</span>,ElemType x)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">st</span>.top==maxSizx-1)<br>&#123;<br><span class="hljs-keyword">return</span> 0;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>x=<span class="hljs-keyword">st</span>.data[<span class="hljs-keyword">st</span>.topp];<br><span class="hljs-keyword">return</span> 1;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="6-判断栈空运算算法"><a href="#6-判断栈空运算算法" class="headerlink" title="6.判断栈空运算算法"></a>6.判断栈空运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924122925102.png" alt="image-20240924122925102"></p><h4 id="3-1-3栈的链式存储结构"><a href="#3-1-3栈的链式存储结构" class="headerlink" title="3.1.3栈的链式存储结构"></a>3.1.3栈的链式存储结构</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/709b2460b69b0dbbca4f45040fd652f8.png" alt="709b2460b69b0dbbca4f45040fd652f8"></p><h5 id="3-1-4栈链的运算算法"><a href="#3-1-4栈链的运算算法" class="headerlink" title="3.1.4栈链的运算算法"></a>3.1.4栈链的运算算法</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79210cbcd65acdf5dabb14d8c5dc2b5e.png" alt="79210cbcd65acdf5dabb14d8c5dc2b5e"></p><h6 id="1-初始化栈算法"><a href="#1-初始化栈算法" class="headerlink" title="1.初始化栈算法"></a>1.初始化栈算法</h6><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack * &amp;ls)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>ls=<span class="hljs-keyword">null</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-销毁栈运算算法"><a href="#2-销毁栈运算算法" class="headerlink" title="2.销毁栈运算算法"></a>2.销毁栈运算算法</h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> DestroyStack(LinkStack * &amp;ls)<br><br>&#123;<br>LinkStack *pre=ls,*P;<br><span class="hljs-keyword">if</span>(pre==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//空栈</span><br>p=pre-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//指向栈顶</span><br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)<br>&#123;<br>free(pre)<br>pre=p;p=p-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br>free(pre);<br><br><br>&#125;<br>pre-代表的是栈-》p下一个栈<br></code></pre></td></tr></table></figure><h6 id="3-进栈运算算法（头插"><a href="#3-进栈运算算法（头插" class="headerlink" title="3.进栈运算算法（头插)"></a>3.进栈运算算法（头插)</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924124055740.png" alt="image-20240924124055740"></p><h6 id="4-出栈运算算法"><a href="#4-出栈运算算法" class="headerlink" title="4.出栈运算算法"></a>4.出栈运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5dd683269143f8f2d81a4d989b50eede.png" alt="5dd683269143f8f2d81a4d989b50eede"></p><h6 id="5-取栈顶元素运算算法"><a href="#5-取栈顶元素运算算法" class="headerlink" title="5.取栈顶元素运算算法"></a>5.取栈顶元素运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c340118ccfa67d3548153fec1942a337.png" alt="c340118ccfa67d3548153fec1942a337"></p><h6 id="6-判断栈空"><a href="#6-判断栈空" class="headerlink" title="6.判断栈空"></a>6.判断栈空</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0983520a7bf7899f352c74142fb0144a.png" alt="0983520a7bf7899f352c74142fb0144a"></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h4 id="3-2-1队列的基本概念"><a href="#3-2-1队列的基本概念" class="headerlink" title="3.2.1队列的基本概念"></a>3.2.1队列的基本概念</h4><p>队列（Queue）是一种<strong>先进先出</strong>（FIFO, First In First Out）的数据结构。其基本概念是：</p><ol><li><strong>先进先出（FIFO）</strong>：在队列中，第一个被添加的元素最先被移除。这类似于排队买票，最先进入队列的人最先得到服务。</li><li><strong>队列的操作</strong>：<ul><li><strong>入队（Enqueue）</strong>：将一个元素添加到队列的末尾。</li><li><strong>出队（Dequeue）</strong>：移除并返回队列的第一个元素。</li><li><strong>查看队头元素（Front&#x2F;Peek）</strong>：查看队列的第一个元素，但不移除它。</li></ul></li><li><strong>队列的类型</strong>：<ul><li><strong>普通队列</strong>：遵循标准的先进先出规则。</li><li><strong>双端队列（Deque）</strong>：允许在队列的两端进行入队和出队操作。</li><li><strong>循环队列</strong>：队列中的元素循环使用，队尾连接到队头。</li></ul></li><li><strong>用途</strong>：队列常用于广度优先搜索（BFS）、任务调度、缓冲区管理等场景。例如，操作系统中的任务排队、打印队列，或消息处理系统中的任务管理等。</li></ol><blockquote><p>队列的实现方式</p><p>在计算机科学中，队列通常使用数组或链表来实现。下面分别介绍这两种实现方式：</p><ol><li>数组实现</li></ol><p>使用数组实现的队列被称为<strong>顺序队列</strong>。</p><ol start="2"><li>链表实现</li></ol><p>使用链表实现的队列被称为<strong>链式队列</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8ee352aa77223d088608ab7c8cf3a29f.png" alt="栈示意图"></p><h4 id="3-2-2队列的基本运算"><a href="#3-2-2队列的基本运算" class="headerlink" title="3.2.2队列的基本运算"></a>3.2.2队列的基本运算</h4><p>**初始化队列 InitQueue(Qu)**：建立一个空队列 Qu。</p><p>**销毁队列 DestroyQueue(Qu)**：释放队列 Qu 占用的内存空间。</p><p>**进队列 EnQueue(Qu, z)**：将元素 z 插入到队列 Qu 的队尾。</p><p>**出队列 DeQueue(Qu, z)**：将队列 Qu 的队头元素出队并赋给 z。</p><p>**取队头元素 GetHead(Qu, z)**：取出队列 Qu 的队头元素并赋给 z，但该元素不出队。</p><p>**判断队空 QueueEmpty(Qu)**：判断队列 Qu 是否为空。</p><h4 id="3-2-3队列的顺序存储结构"><a href="#3-2-3队列的顺序存储结构" class="headerlink" title="3.2.3队列的顺序存储结构"></a>3.2.3队列的顺序存储结构</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aca8a15b20ba388f1102fec36f1b904e.png" alt="aca8a15b20ba388f1102fec36f1b904e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/54139a5b87ff159eac498b9e4fe2e7d4.png" alt="54139a5b87ff159eac498b9e4fe2e7d4"></p><p>先出的是front 队头指针</p><h5 id="3-2-3-4循环队列"><a href="#3-2-3-4循环队列" class="headerlink" title="3.2.3.4循环队列"></a>3.2.3.4循环队列</h5><p>偷个懒 看视频学习</p><h6 id="1-循环队列要素"><a href="#1-循环队列要素" class="headerlink" title="1.循环队列要素"></a>1.循环队列要素</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125151135.png" alt="image-20240924125151135"></p><h5 id="2-循环队列基本算法"><a href="#2-循环队列基本算法" class="headerlink" title="2.循环队列基本算法"></a>2.循环队列基本算法</h5><h6 id="1-初始化队列运算算法"><a href="#1-初始化队列运算算法" class="headerlink" title="1.初始化队列运算算法"></a>1.初始化队列运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125226253.png" alt="image-20240924125226253"></p><h6 id="2-销毁队列算法"><a href="#2-销毁队列算法" class="headerlink" title="2.销毁队列算法"></a>2.销毁队列算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125244039.png" alt="image-20240924125244039"></p><h6 id="3-进队运算算法"><a href="#3-进队运算算法" class="headerlink" title="3.进队运算算法"></a>3.进队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125307304.png" alt="image-20240924125307304"></p><h4 id="3-2-4队列的链式存储"><a href="#3-2-4队列的链式存储" class="headerlink" title="3.2.4队列的链式存储"></a>3.2.4队列的链式存储</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924125417315.png" alt="image-20240924125417315"></p><h5 id="链式存储算法运算"><a href="#链式存储算法运算" class="headerlink" title="链式存储算法运算"></a>链式存储算法运算</h5><h6 id="1-初始化队列算法"><a href="#1-初始化队列算法" class="headerlink" title="1.初始化队列算法"></a>1.初始化队列算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3034d08132b1dc6fcd62d6a3bf7b4c8d.png" alt="3034d08132b1dc6fcd62d6a3bf7b4c8d"></p><h6 id="2-销毁队列算法-1"><a href="#2-销毁队列算法-1" class="headerlink" title="2.销毁队列算法"></a>2.销毁队列算法</h6><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DestroyQueue(LinkQueue *&amp;lq)<br>&#123;<br>Q<span class="hljs-function"><span class="hljs-title">type</span> *pre=lq-&gt;</span>front,*P;<span class="hljs-comment">///指向头数据</span><br><span class="hljs-keyword">if</span>(pre!=null)<span class="hljs-comment">//不为空</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span>(pre==lq-&gt;</span>rear)<span class="hljs-comment">//只有一个节点情况</span><br>&#123; free(pre);&#125;<span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">p</span>=pre-&gt;</span>next;<span class="hljs-comment">//下一个节点</span><br><span class="hljs-keyword">while</span>(p!=null)<span class="hljs-comment">//不为空</span><br><br>&#123;<br>free(pre)<span class="hljs-comment">//节点数据</span><br>pre=p;<span class="hljs-comment">//下节点赋值</span><br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<span class="hljs-comment">//指向下一个节点</span><br><br>&#125;<br>free(pre);<span class="hljs-comment">//最好节点释放</span><br><br><br>&#125;<br><br>&#125;<br>free(lq);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-进队运算算法-1"><a href="#3-进队运算算法-1" class="headerlink" title="3.进队运算算法"></a>3.进队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924130041703.png" alt="image-20240924130041703"></p><h6 id="4-出队运算算法"><a href="#4-出队运算算法" class="headerlink" title="4.出队运算算法"></a>4.出队运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f2bbe46cd00c440b2507086fdad63213.png" alt="f2bbe46cd00c440b2507086fdad63213"></p><h6 id="5-取队头元素运算算法"><a href="#5-取队头元素运算算法" class="headerlink" title="5.取队头元素运算算法"></a>5.取队头元素运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924130214173.png" alt="image-20240924130214173"></p><h6 id="6-判断队空运算算法"><a href="#6-判断队空运算算法" class="headerlink" title="6.判断队空运算算法"></a>6.判断队空运算算法</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240924130241344.png" alt="image-20240924130241344"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql-事务详解</title>
    <link href="/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/09/24/mysql/%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6e6181b34accccf653ace905a69d8652.png" alt="在这里插入图片描述"></p><h4 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h4><p>MySQL 事务的实现主要依赖于以下几个核心组件和机制：</p><ol><li><strong>InnoDB存储引擎</strong>：MySQL事务通常是由InnoDB存储引擎支持的。InnoDB提供了事务的核心功能，如ACID（原子性、一致性、隔离性、持久性）属性。</li></ol><p>​    2.<strong>Redo Log（重做日志）</strong>：为了确保事务的<strong>持久性</strong>（Durability），InnoDB使用了Redo Log。在事务提交时，MySQL会将事务的修改记录写入Redo Log，即使系统崩溃，也可以通过Redo Log进行数据恢复</p><p>​      3.<strong>Undo Log（回滚日志）</strong>：为了支持<strong>原子性</strong>（Atomicity）和<strong>一致性</strong>（Consistency），MySQL会在事务开始之前记录数据的原始状态，即Undo Log。这样，如果事务失败或者被回滚，MySQL可以通过Undo Log恢复到修改前的状态。。 AT模式</p><p>​     4.锁机制</p><ul><li><strong>行锁</strong>：InnoDB支持行级锁，以确保多事务并发执行时的数据一致性。</li><li><strong>表锁</strong>：MySQL也支持表级锁，但InnoDB引擎通常使用行锁来提高并发性。</li></ul><p>锁的机制确保了事务的<strong>隔离性</strong>（Isolation），使得事务在并发操作时不会互相干扰。</p><p>​          5.<strong>隔离级别</strong>：MySQL支持多种事务隔离级别，如读未提交、读已提交、可重复读、串行化。通过这些隔离级别，MySQL可以控制事务并发时的读写行为，以减少并发带来的数据一致性问题。</p><p>​      6.<strong>两阶段提交</strong>：为了保证数据的一致性，MySQL采用了两阶段提交机制（2PC），在事务提交时，首先会将事务的变更写入Redo Log，确保日志写入成功后，再将实际数据写入磁盘。这可以保证事务的原子性，即事务要么全部提交成功，要么回滚。</p><p>​     7.<strong>MVCC</strong>（多版本并发控制）**：MySQL通过MVCC来实现事务的隔离性，特别是在可重复读（Repeatable Read）隔离级别下，使用MVCC可以让事务在读取数据时看到的是某个固定的快照，而不会被其他事务的并发修改所影响。</p><h4 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h4><p>锁学后补充</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当前读和快照读<br></code></pre></td></tr></table></figure><blockquote><p>，<strong>MVCC</strong>（多版本并发控制，<strong>Multi-Version Concurrency Control</strong>）是一种常用的机制，可以帮助数据库系统实现事务的<strong>隔离性</strong>。MVCC 通过为每个事务提供数据库中数据的不同版本来实现隔离，从而避免了事务之间的直接冲突。</p></blockquote><p>隔离性</p><h4 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h4><h6 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1.脏读"></a>1.脏读</h6><p>不同事务读取</p><p><strong>定义</strong>：脏读是指一个事务可以读取到另一个事务尚未提交的修改。如果后续事务回滚，读取的数据就会变成无效的，从而导致数据不一致。</p><p><strong>场景</strong>：事务A修改了某条记录，但未提交，事务B读取了该记录的修改内容。如果事务A回滚，事务B读取的数据就是无效的。</p><p><strong>SQL示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span>复制代码<span class="hljs-comment">-- 假设表 `accounts` 有一行数据：id = 1, balance = 1000</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">900</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 修改余额为900，但未提交</span><br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> balance <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 读到了事务A未提交的余额900</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">ROLLBACK</span>;  <span class="hljs-comment">-- 事务A回滚，balance恢复为1000</span><br><br><span class="hljs-comment">-- 事务B现在读到的余额是900，但实际上余额已经恢复为1000，这是脏读</span><br></code></pre></td></tr></table></figure><p><strong>解决方法</strong>：设置隔离级别为<strong>读已提交</strong>（Read Committed）或更高，防止脏读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;<br></code></pre></td></tr></table></figure><h6 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2.不可重复读"></a>2.不可重复读</h6><p>不可重复读发生在<strong>事务多次读取同一条记录</strong>时，由于另一个事务提交了修改，导致读取结果不同。</p><p><strong>定义</strong>：不可重复读是指在一个事务中对同一条记录的多次读取结果不一致，因为另一事务在两次读取之间修改了该记录并提交了修改。</p><p><strong>场景</strong>：事务A第一次读取某条记录的数据，事务B修改并提交了这条记录，事务A再次读取该记录时，读取到了不同的结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设表 `accounts` 有一行数据：id = 1, balance = 1000</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> balance <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 第一次读取，余额为1000</span><br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">800</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 修改余额为800</span><br><span class="hljs-keyword">COMMIT</span>;  <span class="hljs-comment">-- 提交事务B</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">SELECT</span> balance <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 第二次读取，余额变为800</span><br><br><span class="hljs-comment">-- 事务A第一次读取到的是1000，第二次读取到的是800，发生了不可重复读</span><br></code></pre></td></tr></table></figure><p><strong>解决方法</strong>：设置隔离级别为<strong>可重复读</strong>（Repeatable Read）或更高，防止不可重复读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><h6 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3.幻读"></a>3.幻读</h6><p><strong>定义</strong>：幻读是指一个事务在读取某范围内的记录时，另一事务插入了新的记录。由于新的记录符合第一次查询的条件，因此再次读取时，前后结果不同。</p><p><strong>场景</strong>：事务A在查询某个条件范围内的记录，事务B插入了一条符合条件的新记录，导致事务A的再次查询结果中出现“幻影”记录。</p><p>幻读发生在事务读取<strong>一个数据范围</strong>时，另一个事务在该范围内<strong>插入、删除</strong>了数据，导致读取到的记录集不同</p><p><strong>SQL示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span>复制代码<span class="hljs-comment">-- 假设表 `orders` 有两行数据：id = 1, 2，对应的金额为500, 800</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">300</span>;  <span class="hljs-comment">-- 查询金额大于300的订单，返回两条记录：id = 1, 2</span><br><br><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (id, amount) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-number">700</span>);  <span class="hljs-comment">-- 插入新订单，金额为700</span><br><span class="hljs-keyword">COMMIT</span>;  <span class="hljs-comment">-- 提交事务B</span><br><br><span class="hljs-comment">-- 事务A</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">300</span>;  <span class="hljs-comment">-- 再次查询，发现多了一条新记录：id = 3</span><br><br><span class="hljs-comment">-- 事务A第一次查询结果中没有id为3的记录，第二次却出现了，这是幻读</span><br></code></pre></td></tr></table></figure><p><strong>解决方法</strong>：设置隔离级别为<strong>串行化</strong>（Serializable）或通过InnoDB的<strong>间隙锁</strong>（Gap Lock）防止幻读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br></code></pre></td></tr></table></figure><p><strong>脏读</strong>：<strong>读取了其他事务尚未提交的修改</strong>，解决方法是使用<code>READ COMMITTED</code>或更高的隔离级别。</p><p><strong>不可重复读</strong>：<strong>同一事务中多次读取同一数据得到不同的结果</strong>，解决方法是使用<code>REPEATABLE READ</code>。</p><p><strong>幻读</strong>：<strong>事务中读取的范围内的记录集在后续读取时发生变化</strong>，解决方法是使用<code>SERIALIZABLE</code>或Gap Lock。</p><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/30c55ef7b7688240c3ef12043d093524.png" alt="30c55ef7b7688240c3ef12043d093524"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c5f1b25ebb4c14d48080d1f0f5c2701b.png" alt="img"></p><h6 id="1-Read-Uncommitted（读未提交）"><a href="#1-Read-Uncommitted（读未提交）" class="headerlink" title="1.. Read Uncommitted（读未提交）"></a>1.. <strong>Read Uncommitted（读未提交）</strong></h6><blockquote><ul><li><strong>脏读（Dirty Read）</strong>：会出现，事务可以读取未提交的数据。</li><li><strong>不可重复读（Non-repeatable Read）</strong>：会出现，由于数据可以被修改并提交，导致多次读取不一致。</li><li><strong>幻读（Phantom Read）</strong>：会出现，由于插入或删除操作可以影响读取范围内的数据集。</li></ul><p>在该隔离级别下，没有有效的并发控制，允许读取未提交的数据，因此可能出现所有并发问题。这种隔离级别通常不用于生产环境，因为数据一致性无法得到保障。</p></blockquote><h6 id="2-Read-Committed（读已提交）"><a href="#2-Read-Committed（读已提交）" class="headerlink" title="2.Read Committed（读已提交）"></a>2.<strong>Read Committed（读已提交）</strong></h6><blockquote><ul><li><strong>脏读</strong>：× 不会出现，事务只能读取已经提交的数据，避免了读取未提交的数据。</li><li><strong>不可重复读</strong>：√ 仍然会出现，因为在一个事务中多次读取同一条记录时，其他事务可以修改并提交该记录，导致前后读取结果不同。</li><li><strong>幻读</strong>：√ 仍然会出现，因为其他事务可以插入或删除符合查询条件的新记录，导致数据集的变化。</li><li>在 RC 级别下，事务每次读取数据时都会获取当前最新的已提交数据的快照。也就是说，当事务在执行两次相同的查询时，如果在这两次查询之间有其他事务提交了新的数据变更，查询结果可能不同。</li></ul><p><strong>如何解决脏读</strong>：通过<strong>只允许读取已提交的数据</strong>，避免了脏读问题。换句话说，事务只能看到其他事务已经提交的结果，而不是中途修改的未提交数据。</p></blockquote><h6 id="3-Repeatable-Read（可重复读，MySQL默认隔离级别）"><a href="#3-Repeatable-Read（可重复读，MySQL默认隔离级别）" class="headerlink" title="3. Repeatable Read（可重复读，MySQL默认隔离级别）"></a>3. <strong>Repeatable Read（可重复读，MySQL默认隔离级别）</strong></h6><blockquote><ul><li><strong>脏读</strong>：× 不会出现，事务只能看到已经提交的修改。</li><li><strong>不可重复读</strong>：× 不会出现，事务在其生命周期内使用一致性视图（Snapshot），即使其他事务修改并提交了数据，本事务多次读取同一条记录时，仍然会看到初始读取时的数据。—在 RR 级别下，事务在第一次读取数据时，会生成一个一致性读快照（快照的时间点是事务开始时或第一次读取时）。<ul><li><strong><strong><strong>一致性视图（Snapshot）：当事务在 <code>Repeatable Read</code> 隔离级别下启动时，MySQL 会创建一个快照（Snapshot）。事务中所有的 <code>SELECT</code> 语句都会从这个快照中读取数据，而不会受到其他事务在该事务执行过程中对数据库所做的更改影响。</strong></strong></strong></li></ul></li><li><strong>幻读</strong>：√ 仍然可能出现，因为其他事务可以在查询范围内插入或删除新记录，影响结果集。</li></ul><blockquote><p>**  ********* 一致性视图**只能保护已有的数据的一致性，但它并不能防止新的数据插入 **********</p></blockquote><p><strong>如何解决脏读和不可重复读</strong>：</p><ul><li><strong>脏读</strong>通过只读取已提交的数据解决。</li><li><strong>不可重复读</strong>通过<strong>一致性视图（MVCC）</strong>解决。事务在开始时获取一个快照，后续查询将基于这个快照，即使其他事务修改了记录，本事务始终读取同一版本的数据，避免了多次读取时数据不一致。</li></ul><p><strong>如何解决幻读（MySQL特性）</strong>：</p><ul><li>InnoDB通过引入<strong>间隙锁（Gap Lock）</strong>来部分解决幻读问题。间隙锁不仅锁住查询到的记录，还锁定记录之间的“间隙”，防止其他事务在这些间隙内插入新记录。虽然这在一定程度上解决了幻读问题，但并不是完全解决，特别是在复杂的查询场景中。</li></ul></blockquote><h6 id="4-Serializable（串行化）"><a href="#4-Serializable（串行化）" class="headerlink" title="4. Serializable（串行化）"></a>4. <strong>Serializable（串行化）</strong></h6><blockquote><ul><li><strong>脏读</strong>：× 不会出现。</li><li><strong>不可重复读</strong>：× 不会出现。</li><li><strong>幻读</strong>：× 不会出现。</li></ul><p><strong>如何解决所有问题</strong>：</p><ul><li>在串行化隔离级别下，事务是<strong>串行执行</strong>的，仿佛事务是一个接一个顺序完成的，不存在并发问题。MySQL通过<strong>加锁机制</strong> <strong>元数据锁（meta data lock）</strong>保证这一点。每次读取数据时都会加锁，任何其他事务在该事务执行过程中都无法对相关数据进行修改或插入，确保了没有数据的并发修改或插入，从根本上防止了脏读、不可重复读和幻读。</li></ul><p><strong>代价</strong>：由于串行化隔离级别会对所有相关数据加锁，因此并发性能大大降低，所有事务必须一个接一个地执行，无法同时进行并发操作。因此，这种隔离级别通常只在对数据一致性要求极高的场景中使用，且性能开销较大。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>和平转区半火封包</title>
    <link href="/2024/09/22/%E5%92%8C%E5%B9%B3ios%E8%BD%AC%E5%8C%BA%E5%8D%8A%E7%81%AB/"/>
    <url>/2024/09/22/%E5%92%8C%E5%B9%B3ios%E8%BD%AC%E5%8C%BA%E5%8D%8A%E7%81%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="和平ios转区"><a href="#和平ios转区" class="headerlink" title="和平ios转区"></a>和平ios转区</h1><h6 id="1-kit安装"><a href="#1-kit安装" class="headerlink" title="1.kit安装"></a>1.kit安装</h6><p>自行百度</p><h6 id="2-规则集配置"><a href="#2-规则集配置" class="headerlink" title="2.规则集配置"></a>2.规则集配置</h6><p>半火</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[RuleSet(id=<span class="hljs-number">1</span>, remark=转ios区半火防封规则<span class="hljs-number">1.2</span>[支持的辅助以验证页面为准], content=[RoutingRule]<br># 全火规则<span class="hljs-number">2403192</span><br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,t3yan,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,downloadfiler,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,spark,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,down.pandora,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,down.qq,REJECT<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,nj.cschannel.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,mbgame,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,down,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,meizu,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,dlie,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,anticheatexpert,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,gamesafe,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cschannel,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,wsdvs,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,chnc,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cloudcsp,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,payba,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com.chnc.cloudcsp.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,jiazhang,DIRECT<br><span class="hljs-keyword">DOMAIN</span>,api.m.taobao.com,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,eydata,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,qlogo,REJECT<br><span class="hljs-keyword">DOMAIN</span>,api.paojiaoyun.com,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,t3data,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.ssl.msdk.qq.com,DIRECT<br><span class="hljs-keyword">DOMAIN</span>,cloud.tgpa.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cdn.wetest.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,android.crashsight.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,game.weixin.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.mobi,REJECT<br><span class="hljs-keyword">DOMAIN</span>,android.bugly.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cloudctrl.gcloud.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,h.trace.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.tpns.sh.tencent.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,gatherer.m.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,snowflake.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cgi.<span class="hljs-keyword">connect</span>.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,cfg.imtt.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,tbs.imtt.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,api.unipay.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,szmg.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,<span class="hljs-keyword">log</span>.tbs.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,flow.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,idcconfig.gcloudsdk.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,mazu.m.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.tga.qq.com,REJECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">182.254</span><span class="hljs-number">.116</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">223.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">123.187</span><span class="hljs-number">.28</span><span class="hljs-number">.125</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.144</span><span class="hljs-number">.82</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.150</span><span class="hljs-number">.14</span><span class="hljs-number">.112</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">150.138</span><span class="hljs-number">.104</span><span class="hljs-number">.242</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.182</span><span class="hljs-number">.23</span><span class="hljs-number">.64</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.44</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">222.132</span><span class="hljs-number">.143</span><span class="hljs-number">.107</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.162</span><span class="hljs-number">.101</span><span class="hljs-number">.24</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.99</span><span class="hljs-number">.140</span><span class="hljs-number">.58</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.140</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">117.157</span><span class="hljs-number">.238</span><span class="hljs-number">.251</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.141</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">163.171</span><span class="hljs-number">.198</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.163</span><span class="hljs-number">.161</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.81</span><span class="hljs-number">.238</span><span class="hljs-number">.132</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">118.112</span><span class="hljs-number">.241</span><span class="hljs-number">.91</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.156</span><span class="hljs-number">.77</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">103.254</span><span class="hljs-number">.188</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">113.125</span><span class="hljs-number">.206</span><span class="hljs-number">.16</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.31</span><span class="hljs-number">.16</span><span class="hljs-number">.74</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.240</span><span class="hljs-number">.60</span><span class="hljs-number">.41</span>/<span class="hljs-number">32</span>,PROXY<br>PORT,<span class="hljs-number">80</span>,REJECT<br>PORT,<span class="hljs-number">442</span><span class="hljs-number">-444</span>,REJECT<br>PORT,<span class="hljs-number">843</span>,PROXY<br>PORT,<span class="hljs-number">666</span>,PROXY<br>PORT,<span class="hljs-number">1024</span>,PROXY<br>PORT,<span class="hljs-number">5692</span>,REJECT<br>PORT,<span class="hljs-number">14000</span>,REJECT<br>PORT,<span class="hljs-number">15692</span>,REJECT<br>PORT,<span class="hljs-number">10011</span><span class="hljs-number">-10013</span>,PROXY<br>PORT,<span class="hljs-number">17501</span>,PROXY<br>PORT,<span class="hljs-number">17005</span>,PROXY<br>PORT,<span class="hljs-number">7889</span>,REJECT<br>PORT,<span class="hljs-number">8085</span>,PROXY<br>PORT,<span class="hljs-number">8081</span>,REJECT<br>PORT,<span class="hljs-number">20000</span>,PROXY<br>PORT,<span class="hljs-number">31003</span>,PROXY<br>PORT,<span class="hljs-number">50000</span>,PROXY<br>PORT,<span class="hljs-number">3861</span>,REJECT<br>PORT,<span class="hljs-number">13861</span>,REJECT<br>PORT,<span class="hljs-number">23861</span>,REJECT<br>PORT,<span class="hljs-number">33861</span>,REJECT<br>PORT,<span class="hljs-number">43861</span>,REJECT<br>PORT,<span class="hljs-number">53861</span>,REJECT<br>PORT,<span class="hljs-number">63861</span>,PROXY<br>PORT,<span class="hljs-number">4863</span>,REJECT<br>PORT,<span class="hljs-number">14863</span>,REJECT<br>PORT,<span class="hljs-number">24863</span>,REJECT<br>PORT,<span class="hljs-number">34863</span>,REJECT<br>PORT,<span class="hljs-number">44863</span>,REJECT<br>PORT,<span class="hljs-number">54863</span>,REJECT<br>PORT,<span class="hljs-number">64863</span>,PROXY<br>PORT,<span class="hljs-number">1762</span>,REJECT<br>PORT,<span class="hljs-number">11762</span>,REJECT<br>PORT,<span class="hljs-number">21762</span>,REJECT<br>PORT,<span class="hljs-number">31762</span>,REJECT<br>PORT,<span class="hljs-number">41762</span>,REJECT<br>PORT,<span class="hljs-number">51762</span>,REJECT<br>PORT,<span class="hljs-number">61762</span>,PROXY<br>PORT,<span class="hljs-number">17500</span>,PROXY<br>FINAL,DIRECT<br><br>[RoutingDomainStrategy]<br>AsIs<br><br>[FreedomDomainStrategy]<br>AsIs<br><br>[LocalPolicy]<br>bufferSize = <span class="hljs-number">4096</span><br>connIdle = <span class="hljs-number">600</span><br>downlinkOnly = <span class="hljs-number">0</span><br>handshake = <span class="hljs-number">64</span><br>uplinkOnly = <span class="hljs-number">0</span><br><br>[DnsServer]<br><br>[DnsRule]<br><br>[DnsHost]<br><br>[DnsClientIp]<br><br>[<span class="hljs-keyword">Log</span>]<br>loglevel = <span class="hljs-keyword">none</span><br><br>[PerAppVpn]<br><br>[PerAppMode]<br><br>[PerAppAllow]<br><br>[PerAppDisallow], url=<span class="hljs-keyword">null</span>, lastUpdate=<span class="hljs-keyword">null</span>), RuleSet(id=<span class="hljs-number">2</span>, remark=仅供[扫码/更新游戏/地图/扫脸/异地],不可防封使用;扫设备脸需分代理勾选qqvx,否则人脸环境异常<span class="hljs-number">1.0</span>, content=[RoutingRule]<br># 扫码规则<span class="hljs-number">0710</span><br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,.tpns.sh.tencent.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,snowflake.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,<span class="hljs-keyword">log</span>.tbs.qq.com,REJECT<br><span class="hljs-keyword">DOMAIN</span>,idcconfig.gcloudsdk.com,REJECT<br><br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,nj.cschannel.anticheatexpert.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,meizu,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,anticheatexpert,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,gamesafe,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,wsdvs,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,chnc,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cloudcsp,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>,down.anticheatexpert.com.wsdvs.com.chnc.cloudcsp.com,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,qlogo,REJECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,dlie,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,mbgame,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,cschannel,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,anticheatexpert,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,payba,PROXY<br><span class="hljs-keyword">DOMAIN</span>,ry643.top,PROXY<br><span class="hljs-keyword">DOMAIN</span>,w.eydata.net,PROXY<br><span class="hljs-keyword">DOMAIN</span>,w5.eydata.net,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,lanzou,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,jiazhang,PROXY<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,<span class="hljs-keyword">open</span>,DIRECT<br><span class="hljs-keyword">DOMAIN</span>-KEYWORD,google,DIRECT<br><span class="hljs-keyword">DOMAIN</span>,intldlgs.qq.com,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">182.254</span><span class="hljs-number">.116</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">223.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span>/<span class="hljs-number">32</span>,DIRECT<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.136</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.217</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.93</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.116</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.179</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.52</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.151</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.119</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.228</span><span class="hljs-number">.118</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.18</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.99</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.171</span><span class="hljs-number">.23</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.73</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.249</span><span class="hljs-number">.82</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.251</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.206</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.211</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.100</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.204</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">117.89</span><span class="hljs-number">.177</span><span class="hljs-number">.167</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">222.94</span><span class="hljs-number">.109</span><span class="hljs-number">.22</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.186</span><span class="hljs-number">.200</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">182.50</span><span class="hljs-number">.10</span><span class="hljs-number">.74</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">59.83</span><span class="hljs-number">.207</span><span class="hljs-number">.176</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.251</span><span class="hljs-number">.15</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">109.244</span><span class="hljs-number">.228</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.137</span><span class="hljs-number">.190</span><span class="hljs-number">.80</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.119</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.137</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.18</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.85</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.8</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.135</span><span class="hljs-number">.105</span><span class="hljs-number">.28</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.204</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.192</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.246</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.140</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.164</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.93</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.185</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.230</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.102</span><span class="hljs-number">.111</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">129.226</span><span class="hljs-number">.103</span><span class="hljs-number">.182</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.249</span><span class="hljs-number">.33</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.228</span><span class="hljs-number">.242</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.22</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.202</span><span class="hljs-number">.43</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.171</span><span class="hljs-number">.46</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.171</span><span class="hljs-number">.203</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.253</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.46</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.249</span><span class="hljs-number">.84</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.102</span><span class="hljs-number">.211</span><span class="hljs-number">.32</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.250</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.222</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">122.96</span><span class="hljs-number">.96</span><span class="hljs-number">.152</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.228</span><span class="hljs-number">.234</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.73</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.95</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.185</span><span class="hljs-number">.128</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.76</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.190</span><span class="hljs-number">.53</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.67</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.177</span><span class="hljs-number">.246</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.185</span><span class="hljs-number">.85</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">49.51</span><span class="hljs-number">.67</span><span class="hljs-number">.163</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">220.194</span><span class="hljs-number">.120</span><span class="hljs-number">.73</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.192</span><span class="hljs-number">.160</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">60.28</span><span class="hljs-number">.172</span><span class="hljs-number">.70</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">220.194</span><span class="hljs-number">.120</span><span class="hljs-number">.90</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">60.29</span><span class="hljs-number">.239</span><span class="hljs-number">.218</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.192</span><span class="hljs-number">.202</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.179</span><span class="hljs-number">.246</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.184</span><span class="hljs-number">.84</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.78</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.171</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.186</span><span class="hljs-number">.37</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.185</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">183.2</span><span class="hljs-number">.143</span><span class="hljs-number">.21</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">14.22</span><span class="hljs-number">.9</span><span class="hljs-number">.124</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">14.22</span><span class="hljs-number">.9</span><span class="hljs-number">.210</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.112</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.178</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.209</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.231</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.169</span><span class="hljs-number">.81</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.114</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.203</span><span class="hljs-number">.167</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">175.27</span><span class="hljs-number">.204</span><span class="hljs-number">.240</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.169</span><span class="hljs-number">.110</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.28</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.19</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">14.22</span><span class="hljs-number">.9</span><span class="hljs-number">.201</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.168</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.94</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.60</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.127</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.110</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.203</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.58</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.87</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.150</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.215</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.172</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.32</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.225</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.107</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.126</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.189</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.69</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.153</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.90</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.125</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.23</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">139.186</span><span class="hljs-number">.105</span><span class="hljs-number">.5</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.65</span><span class="hljs-number">.237</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.27</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.27</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.27</span><span class="hljs-number">.62</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">43.159</span><span class="hljs-number">.233</span><span class="hljs-number">.6</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.35</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.37</span><span class="hljs-number">.101</span><span class="hljs-number">.66</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.105</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.249</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.47</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.94</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.19</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.229</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.60</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.57</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.53</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.37</span><span class="hljs-number">.101</span><span class="hljs-number">.56</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.84</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.214</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.152</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.208</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.177</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.33</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.35</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">114.221</span><span class="hljs-number">.149</span><span class="hljs-number">.235</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.50</span><span class="hljs-number">.11</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.94</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.149</span><span class="hljs-number">.19</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">180.109</span><span class="hljs-number">.156</span><span class="hljs-number">.93</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.80</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.150</span><span class="hljs-number">.78</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.143</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.240</span><span class="hljs-number">.199</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.155</span><span class="hljs-number">.245</span><span class="hljs-number">.161</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.37</span><span class="hljs-number">.101</span><span class="hljs-number">.103</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.102</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">153.3</span><span class="hljs-number">.150</span><span class="hljs-number">.213</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.22</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.68</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.203</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.68</span><span class="hljs-number">.31</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.70</span><span class="hljs-number">.196</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">119.45</span><span class="hljs-number">.69</span><span class="hljs-number">.27</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.238</span><span class="hljs-number">.41</span><span class="hljs-number">.116</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.70</span><span class="hljs-number">.219</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.70</span><span class="hljs-number">.162</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.238</span><span class="hljs-number">.41</span><span class="hljs-number">.103</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.70</span><span class="hljs-number">.252</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.198</span><span class="hljs-number">.69</span><span class="hljs-number">.12</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.228</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.238</span><span class="hljs-number">.41</span><span class="hljs-number">.36</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.170</span><span class="hljs-number">.35</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.183</span><span class="hljs-number">.51</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.179</span><span class="hljs-number">.205</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.30</span><span class="hljs-number">.183</span><span class="hljs-number">.164</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.219</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.194</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.53</span><span class="hljs-number">.1</span><span class="hljs-number">.152</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">123.187</span><span class="hljs-number">.28</span><span class="hljs-number">.125</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.81</span><span class="hljs-number">.144</span><span class="hljs-number">.82</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.150</span><span class="hljs-number">.14</span><span class="hljs-number">.112</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">150.138</span><span class="hljs-number">.104</span><span class="hljs-number">.242</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">221.182</span><span class="hljs-number">.23</span><span class="hljs-number">.64</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.44</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">222.132</span><span class="hljs-number">.143</span><span class="hljs-number">.107</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.162</span><span class="hljs-number">.101</span><span class="hljs-number">.24</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">42.99</span><span class="hljs-number">.140</span><span class="hljs-number">.58</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.140</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">120.232</span><span class="hljs-number">.97</span><span class="hljs-number">.92</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">117.157</span><span class="hljs-number">.238</span><span class="hljs-number">.251</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">58.220</span><span class="hljs-number">.74</span><span class="hljs-number">.141</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">163.171</span><span class="hljs-number">.198</span><span class="hljs-number">.117</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">61.163</span><span class="hljs-number">.161</span><span class="hljs-number">.42</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.81</span><span class="hljs-number">.238</span><span class="hljs-number">.132</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">118.112</span><span class="hljs-number">.241</span><span class="hljs-number">.91</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">36.156</span><span class="hljs-number">.77</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">103.254</span><span class="hljs-number">.188</span><span class="hljs-number">.49</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">113.125</span><span class="hljs-number">.206</span><span class="hljs-number">.16</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">111.31</span><span class="hljs-number">.16</span><span class="hljs-number">.74</span>/<span class="hljs-number">32</span>,PROXY<br>IP-<span class="hljs-type">CIDR</span>,<span class="hljs-number">112.240</span><span class="hljs-number">.60</span><span class="hljs-number">.41</span>/<span class="hljs-number">32</span>,PROXY<br>PORT,<span class="hljs-number">666</span>,PROXY<br>PORT,<span class="hljs-number">1024</span>,PROXY<br>PORT,<span class="hljs-number">10012</span>,PROXY<br>PORT,<span class="hljs-number">8085</span>,PROXY<br>PORT,<span class="hljs-number">20000</span>,PROXY<br>PORT,<span class="hljs-number">31003</span>,PROXY<br>PORT,<span class="hljs-number">50000</span>,PROXY<br>PORT,<span class="hljs-number">8081</span>,REJECT<br>PORT,<span class="hljs-number">7889</span>,PROXY<br>PORT,<span class="hljs-number">17500</span>,PROXY<br>PORT,<span class="hljs-number">843</span>,PROXY<br>PORT,<span class="hljs-number">5692</span>,REJECT<br>PORT,<span class="hljs-number">14000</span>,REJECT<br>PORT,<span class="hljs-number">15692</span>,REJECT<br>PORT,<span class="hljs-number">17501</span>,PROXY<br>PORT,<span class="hljs-number">17005</span>,PROXY<br>FINAL,DIRECT<br><br>[RoutingDomainStrategy]<br>AsIs<br><br>[FreedomDomainStrategy]<br>AsIs<br><br>[LocalPolicy]<br>bufferSize = <span class="hljs-number">4096</span><br>connIdle = <span class="hljs-number">600</span><br>downlinkOnly = <span class="hljs-number">0</span><br>handshake = <span class="hljs-number">64</span><br>uplinkOnly = <span class="hljs-number">0</span><br><br>[DnsServer]<br><br>[DnsRule]<br><br>[DnsHost]<br><br>[DnsClientIp]<br><br>[<span class="hljs-keyword">Log</span>]<br>loglevel = <span class="hljs-keyword">none</span><br><br>[PerAppVpn]<br><br>[PerAppMode]<br><br>[PerAppAllow]<br><br>[PerAppDisallow], url=<span class="hljs-keyword">null</span>, lastUpdate=<span class="hljs-keyword">null</span>)]<br></code></pre></td></tr></table></figure><h6 id="3-down映射-封包"><a href="#3-down映射-封包" class="headerlink" title="3.down映射  封包"></a>3.down映射  封包</h6><p>下载地址</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">假￥<span class="hljs-number">0</span>￥假￥<span class="hljs-number">0</span>￥假￥￥假￥<span class="hljs-number">0</span>￥<span class="hljs-number">0</span>￥真￥假￥假￥<span class="hljs-number">1</span>￥ 过滤器 <span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥<span class="hljs-number">1</span>￥假￥真￥假￥真￥<span class="hljs-number">0</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0</span><span class="hljs-symbol">$</span>￥<span class="hljs-number">0</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0</span><span class="hljs-symbol">$</span>￥<span class="hljs-number">1</span><span class="hljs-symbol">$</span><span class="hljs-number">1000000065</span><span class="hljs-symbol">$</span><span class="hljs-number">5</span><span class="hljs-symbol">$</span>￥<span class="hljs-number">5</span><span class="hljs-symbol">$</span><span class="hljs-number">66</span><span class="hljs-symbol">$</span><span class="hljs-number">1</span><span class="hljs-symbol">$</span>￥假￥<span class="hljs-number">0</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>￥￥<span class="hljs-number">1</span>￥<br></code></pre></td></tr></table></figure><p>过滤器 1勾选</p>]]></content>
    
    
    <categories>
      
      <category>杂言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sql  函数 约束 多表查询 新手02</title>
    <link href="/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(2)/"/>
    <url>/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql常见函数使用-二"><a href="#Mysql常见函数使用-二" class="headerlink" title="Mysql常见函数使用(二)"></a>Mysql常见函数使用(二)</h1><h4 id="1-思维导图"><a href="#1-思维导图" class="headerlink" title="1.思维导图"></a>1.思维导图</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f83095441457603846914321ac6d2732.png" alt="在这里插入图片描述"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="Mysql常见约束使用-三"><a href="#Mysql常见约束使用-三" class="headerlink" title="Mysql常见约束使用(三)"></a>Mysql常见约束使用(三)</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c8dc24ae2c02733b1e814ea10aa8f2e.png" alt="在这里插入图片描述"></p><h6 id="1-普通约束探究"><a href="#1-普通约束探究" class="headerlink" title="1.普通约束探究"></a>1.普通约束探究</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>(<br>    id <span class="hljs-type">int</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;ID唯一标识&#x27;</span>,<br>    <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;姓名&#x27;</span> ,<br>    age <span class="hljs-type">int</span> <span class="hljs-keyword">check</span> (age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt;= <span class="hljs-number">120</span>)  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;年龄&#x27;</span> ,<br>    status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span>  <span class="hljs-string">&#x27;1&#x27;</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;状态&#x27;</span>,<br>    test <span class="hljs-type">int</span>  <span class="hljs-keyword">COMMENT</span>  <span class="hljs-string">&#x27;无约束对比测试字段&#x27;</span><br> );<br><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br></code></pre></td></tr></table></figure><h6 id="2-外键约束探究"><a href="#2-外键约束探究" class="headerlink" title="2.外键约束探究"></a>2.外键约束探究</h6><p>逻辑探究</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20c13f39af895a49334d1a1de9de0cbe.png" alt="在这里插入图片描述"></p><p>它们只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联。也就说emp表中的dept_id值可以为任意数值，即是dept表中不存在。而dept表中字段被emp使用了也可以随意删除。 因此无法保证数据的一致性和完整性的。这时候就需要我们严格的进行手动维护或者<strong>使用外键约束</strong>。</p><p>父子关系探究</p><p><strong>父表</strong>（也称为<strong>主表</strong>）是提供主键（或唯一键）的表</p><p><strong>数据依赖</strong>：父表中的主键数据必须先存在，子表中的外键才能引用这些数据。这意味着父表不依赖子表，而子表依赖父表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 必须先创建需要关联的父表 (dept)<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br> id  <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br> name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br> age  <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br> job <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br> salary <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br> entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br> managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导ID&#x27;</span>,<br> dept_id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span>,<br> <span class="hljs-keyword">CONSTRAINT</span> fk_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> dept(id)<br> )comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h1 id="Mysql常见多表查询-四"><a href="#Mysql常见多表查询-四" class="headerlink" title="Mysql常见多表查询(四)"></a>Mysql常见多表查询(四)</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eea4e831fb9433b06cdfb829a6f17155.png" alt="在这里插入图片描述"></p><h6 id="1-多表查询探究"><a href="#1-多表查询探究" class="headerlink" title="1.多表查询探究"></a>1.多表查询探究</h6><p>多表查询就是指一次性从多张表中查询数据。</p><p>原来我们查询单表数据，执行的SQL形式为：select 字段列表 from 表名;</p><p>现在我们想要执行多表查询，就只需要使用逗号分隔多张表即可，如： select 字段列表 from 表名1, 表名2;</p><p>但是我们这样使用却发现存在问题：的确同时查到了多张表的数据，但是数据形式和我们想要的并不一样,它排列组合了两张表中的所有数据项！</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3e30ec1139034dfb8e32d6a5074b5896.png" alt="img"></p><p>例如我们查询员工、部门表，本来我们预期是每个员工对应其所在的部门，但事实确实，每个员工都对应了所有部门。这种现象也称之为 <strong>笛卡尔积</strong> 。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c032561ec0a9cb631757c5c82194ed98.png" alt="在这里插入图片描述"></p><p>因此，在多表查询中，我们需要根据业务情况进行连接查询，消除无效的笛卡尔积，只保留两张表关联部分的有效数据。</p><p>例如在上述示例，我们通过<code>表名.字段名</code>指定员工表的外键等于部门表的主键即可获得预期数据~</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/74724d85cff811c118e2327a50b23133.png" alt="在这里插入图片描述"></p><h6 id="2-内链接探究"><a href="#2-内链接探究" class="headerlink" title="2.内链接探究"></a>2.内链接探究</h6><p>内连接查询的是两张表交集部分的数据(也就是绿色部分的数据)。语法分为两种: 隐式内连接、显式内连接。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a368439562c0c96ffd6e306c72615448.png" alt="在这里插入图片描述"></p><p><strong>隐式内连接</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询每一个员工的姓名 , 及关联的部门的名称 <br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name,d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span>,dept d <span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><p>显式外连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询每一个员工的姓名 , 及关联的部门的名称 <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.name, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br><br></code></pre></td></tr></table></figure><h6 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3.外链接"></a>3.外链接</h6><p>外连接分为：左外连接 和 右外连接。左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4692bf13bf155811a9d1a0d8d6ba3eef.png" alt="在这里插入图片描述"></p><p>左外</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询emp表的所有数据, 和对应的部门信息<br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ef678e5b47e14a2c2e795cfe33c277d5.png" alt="在这里插入图片描述"></p><p>先出左表数据-右表数据拼接</p><p>右外链接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 查询emp表的所有数据, 和对应的部门信息 <br><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/49775a0ba7918f7e351015e047c8fa26.png" alt="在这里插入图片描述"></p><p>数据在右边-然后链接左表-包括null-没对应上的也会显示这就是查询范围</p><h6 id="4-内外区别探究"><a href="#4-内外区别探究" class="headerlink" title="4.内外区别探究"></a>4.内外区别探究</h6><p>在MySQL中，多表查询常常使用<strong>内连接（INNER JOIN）</strong>和<strong>外连接（OUTER JOIN）</strong>来实现。两者的区别在于查询结果集中是否包含没有匹配记录的行。以下是它们的区别及例子说明：</p><p>1.<strong>内连接</strong>只返回两个表中满足条件的记录。如果某一行在其中一个表中没有对应的匹配行，则该行不会出现在结果集中。</p><p>2.<strong>左外连接（LEFT JOIN）：</strong> 返回左表中的所有记录，即使在右表中没有匹配的记录，右表中没有匹配的地方会显示NULL。</p><p><strong>3.右外连接（RIGHT JOIN）：</strong> 返回右表中的所有记录，即使在左表中没有匹配的记录，左表中没有匹配的地方会显示NULL。</p><h6 id="5-自链接"><a href="#5-自链接" class="headerlink" title="5.自链接"></a>5.自链接</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 查询员工 及其 所属领导的名字,如果员工没有领导, 也需要查询出来<br><span class="hljs-keyword">select</span> a.name <span class="hljs-string">&#x27;员工&#x27;</span>, b.name <span class="hljs-string">&#x27;领导&#x27;</span> <span class="hljs-keyword">from</span> emp a <span class="hljs-keyword">left join</span> emp b <span class="hljs-keyword">on</span> a.managerid = <br>b.id;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d2a7ee93e7a0a2f9dbfc4b10ba44721a.png" alt="在这里插入图片描述"></p><p>6.联合查询</p><ul><li>注意事项<ul><li>对于联合查询的多张表的<strong>字段列表必须保持一致</strong>，<strong>字段类型也需要保持一致</strong>，如果不一致将会报错。</li><li><code>union all</code> 会将<strong>全部的数据直接合并</strong>在一起，<code>union</code> 会对合并之后的<strong>数据去重</strong>。</li></ul></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary &lt; <span class="hljs-number">5000</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age &gt; <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/acf531e80357c6afe3043efacc9b3b4c.png" alt="在这里插入图片描述"></p><p><code>union all</code>查询出来的结果，仅仅只对数据集进行简单的合并，查询结果中可能会存在重复数据项，使用<code>union</code>即可去除重复数据项。</p><h4 id="6-子查询"><a href="#6-子查询" class="headerlink" title="6.子查询"></a>6.子查询</h4><h6 id="1-标量子查询"><a href="#1-标量子查询" class="headerlink" title="1.标量子查询"></a>1.标量子查询</h6><ul><li>使用示例：查询 “销售部” 的所有员工信息</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 拆分<span class="hljs-number">1</span>： 查询 &quot;销售部&quot; 部门ID，返回单个id值<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span>;<br><br># 拆分<span class="hljs-number">2</span>：根据部门ID, 查询员工信息<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = xxx;<br><br># 完整版<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id = (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h6 id="2-列子查询"><a href="#2-列子查询" class="headerlink" title="2.列子查询"></a>2.列子查询</h6><p>子查询返回的结果是<strong>一列</strong>（可以是多行）。常用的操作符：<code>IN 、NOT IN 、 ANY 、SOME 、 ALL</code></p><ul><li>使用示例：查询比 财务部 所有人工资都高的员工信息</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 拆分<span class="hljs-number">1</span>: 查询财务部id<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;财务部&#x27;</span>;<br><br># 拆分<span class="hljs-number">2</span>： 查询财务部员工工资<br><span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id = 拆分<span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id = (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;财务部&#x27;</span>);<br><br>#  拆分<span class="hljs-number">3</span> ： 比 财务部 所有人工资都高的员工信息<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary &gt; <span class="hljs-keyword">all</span> (拆分<span class="hljs-number">2</span>);<br><br># 合并<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary &gt; <span class="hljs-keyword">all</span> ( <span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id = <br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;财务部&#x27;</span>) );<br><br></code></pre></td></tr></table></figure><h6 id="3-行子查询"><a href="#3-行子查询" class="headerlink" title="3.行子查询"></a>3.行子查询</h6><ul><li>使用示例：查询与 “张无忌” 的薪资及<strong>直属领导</strong>相同的员工信息 ;</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 拆分<span class="hljs-number">1</span>：查询 &quot;张无忌&quot; 的薪资及直属领导<br><span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张无忌&#x27;</span>;<br><br># 拆分<span class="hljs-number">2</span>：查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary,managerid) = (xx,xx);<br><br># 合并<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary,managerid) = (<span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp <br><span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张无忌&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h6 id="4-表子查询"><a href="#4-表子查询" class="headerlink" title="4. 表子查询"></a>4. 表子查询</h6><ul><li>使用示例：查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 拆分<span class="hljs-number">1</span>：查询 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资<br><br><span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;鹿杖客&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;宋远桥&#x27;</span>;<br><br># 拆分<span class="hljs-number">2</span>：查询与 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资相同的员工信息<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (job,salary) <span class="hljs-keyword">in</span> ( xxx );<br><br> # 合并<br><br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (job,salary) <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;鹿杖客&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;宋远桥&#x27;</span>);<br></code></pre></td></tr></table></figure><p>多表查询业务能实现相关需求的SQL往往会很多, 写法也多种多样，总之，能满足我们的需求，查询出符合条件的记录即可~</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sql新手入门 ddl-dml-dql-dcl 01</title>
    <link href="/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <url>/2024/09/22/mysql/%E5%9F%BA%E7%A1%80/SQL%E5%85%A5%E9%97%A8(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Sql新手入门-01"><a href="#Sql新手入门-01" class="headerlink" title="Sql新手入门 01"></a>Sql新手入门 01</h1><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本篇大部分内容来自csdn </p><p><a href="https://blog.csdn.net/m0_66570338/article/details/131730913">https://blog.csdn.net/m0_66570338/article/details/131730913</a></p><p>我对此进行修改-</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a5f4ea63bd6983a1d180f567908b5daa.png" alt="a5f4ea63bd6983a1d180f567908b5daa" style="zoom:80%;" /><h4 id="0-Sql分类"><a href="#0-Sql分类" class="headerlink" title="0.Sql分类"></a>0.Sql分类</h4><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><p>分类全称说明<br>DDLData Definition Language数据定义语言，用来定义数据库对象(数据库，表， 字段)<br>DMLData Manipulation Language数据操作语言，用来对数据库表中的数据进行增删改<br>DQLData Query Language数据查询语言，用来查询数据库中表的记录<br>DCLData Control Language数据控制语言，用来创建数据库用户、控制数据库的访问权限</p><p>书写规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span>语句可以单行或多行书写，以分号结尾。<br>MySQL数据库的<span class="hljs-keyword">SQL</span>语句不区分大小写，关键字建议使用大写。<br>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。<br>如果删除一个不存在的数据库，将会报错。<br>注释：<br>单行注释：<span class="hljs-comment">-- 注释内容 或 # 注释内容</span><br>多行注释：<span class="hljs-comment">/* 注释内容 */</span><br>————————————————<br><br></code></pre></td></tr></table></figure><h4 id="1-DDl语句"><a href="#1-DDl语句" class="headerlink" title="1.DDl语句"></a>1.DDl语句</h4><blockquote><p>Data Definition Language，数据定义语言，用来<strong>定义数据库对象(数据库，表，字段)</strong></p></blockquote><h6 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/85f114d7164ea6b8d14c8753f559e498.png" alt="在这里插入图片描述"></p><h6 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2.表操作"></a>2.表操作</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e4c611c8e61b11089a9668c45a904d00.png" alt="在这里插入图片描述"></p><h4 id="2-表字段类型"><a href="#2-表字段类型" class="headerlink" title="2.表字段类型"></a>2.表字段类型</h4><p><strong>数值类型</strong>、<strong>字符串类型</strong>、<strong>日期时间类型</strong>。</p><h6 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1.数值类型"></a>1.数值类型</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922162704845.png" alt="image-20240922162704845"></p><h6 id="2-日期和时间"><a href="#2-日期和时间" class="headerlink" title="2.日期和时间"></a>2.日期和时间</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922162753672.png" alt="image-20240922162753672"></p><h6 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3.字符串类型"></a>3.字符串类型</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922162817233.png" alt="image-20240922162817233"></p><h4 id="3-Dml"><a href="#3-Dml" class="headerlink" title="3.Dml"></a>3.Dml</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4fd1e47a99b734dc110abb78ade371fc.png" alt="img"></p><h4 id="4-Dql"><a href="#4-Dql" class="headerlink" title="4.Dql"></a>4.Dql</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/677d64d1d94c9eb05de365a77a53c84f.png" alt="在这里插入图片描述"></p><h6 id="0-条件查询"><a href="#0-条件查询" class="headerlink" title="0.条件查询"></a>0.条件查询</h6><blockquote></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922163541712.png" alt="image-20240922163541712"></p><h6 id="1-聚合函数查询"><a href="#1-聚合函数查询" class="headerlink" title="1.聚合函数查询"></a>1.聚合函数查询</h6><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>count</code></td><td>统计数量</td></tr><tr><td><code>max</code></td><td>最大值</td></tr><tr><td><code>min</code></td><td>最小值</td></tr><tr><td><code>avg</code></td><td>平均值</td></tr><tr><td><code>sum</code></td><td>求和</td></tr></tbody></table><h6 id="2-分组查询"><a href="#2-分组查询" class="headerlink" title="2.分组查询"></a>2.分组查询</h6><p>注意事项：</p><p>where与having区别<br>执行时机不同：where是分组之前进行过滤；<strong>having是分组之后对结果进行过滤。</strong><br>判断条件不同：<strong>where不能对聚合函数进行判断，而having可以</strong>。执行顺序: where &gt; 聚合函数 &gt; having。<br>支持多字段分组, 具体语法为 : group by 分组字段名1,分组字段名2</p><ul><li><strong>查询年龄小于45的员工</strong> , <strong>并根据工作地址分组</strong> , <strong>获取员工数量大于等于3的工作地址</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) address_count <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <br>workaddress <span class="hljs-keyword">having</span> address_count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a1f80af3ea4aa35c7f0ec97c1a9692ec.png" alt="img"></p><h6 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h6><p>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式,字段2 排序方式;</p><ul><li><p>排序方式类别</p><ul><li>ASC：升序(默认值)</li><li>DESC: 降序</li></ul></li><li><p>注意事项</p><ul><li>如果是升序, 可以不指定排序方式ASC ;</li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</li></ul></li><li><p>根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序</p></li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> , entrydate <span class="hljs-keyword">desc</span>;<br><br></code></pre></td></tr></table></figure><h6 id="4-分页查询"><a href="#4-分页查询" class="headerlink" title="4.分页查询"></a>4.分页查询</h6><p>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</p><ul><li><p>起始索引从0开始，计算规则为：（查询页码 - 1）* 每页显示记录数。</p></li><li><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p></li><li><p>查询第1页员工数据, 每页展示5条记录</p></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">limit</span> <span class="hljs-number">5</span>;<br><br></code></pre></td></tr></table></figure><ul><li>查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">limit</span> <span class="hljs-number">5</span>,<span class="hljs-number">5</span>;<br><br></code></pre></td></tr></table></figure><p>疑问 分页插件做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><span class="hljs-comment">/// 1 页 =多少大小 --2页多少大小</span><br>    <span class="hljs-comment">//转换为 limit x,x</span><br>    <span class="hljs-keyword">public</span> Page&lt;User&gt; <span class="hljs-title function_">getUsersByPage</span><span class="hljs-params">(<span class="hljs-type">int</span> currentPage, <span class="hljs-type">int</span> pageSize)</span> &#123;<br>        <span class="hljs-comment">// 创建 Page 对象</span><br>        Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(currentPage, pageSize);<br><br>        <span class="hljs-comment">// 创建 QueryWrapper 对象</span><br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        queryWrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 按照 id 降序排列</span><br><br>        <span class="hljs-comment">// 执行分页查询</span><br>        <span class="hljs-keyword">return</span> userMapper.selectPage(page, queryWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-复合使用"><a href="#5-复合使用" class="headerlink" title="5.复合使用"></a>5.复合使用</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cd2609707cb2bcce03cd4394e72495c2.png" alt="在这里插入图片描述"></p><ul><li>DQL语句复合使用系统执行顺序为： <code>from ... where ... group by ... having ... select ... order by ... limit ...</code></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">关于<span class="hljs-keyword">having</span>、<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>以及聚合函数的执行顺序问题，整个执行顺序可以这么理解：<br><br>先执行<span class="hljs-keyword">from</span>语句（表之间的笛卡尔积、交并差等），获得一个虚拟表<br>如果<span class="hljs-keyword">where</span>语句存在，从虚拟表中筛出符合<span class="hljs-keyword">where</span>条件的数据，不满足的被剔除<br>如果<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>语句存在，则目前存活的数据分组；如果不存在<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>，则将这些数据视为一个组<br>如果存在<span class="hljs-keyword">having</span>语句，则将满足<span class="hljs-keyword">having</span>条件的组留下，不满足的组被剔除<br>执行<span class="hljs-keyword">select</span>语句：对存活下来的每个组分别执行聚合函数，形成查询结果<br>执行<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 语句：对剩下的数据进行排序<br>执行<span class="hljs-keyword">limit</span> 语句：限制返回的数据条数<br>————————————————<br></code></pre></td></tr></table></figure><ul><li>查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序， 年龄相同按入职时间升序排序。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span> <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> ,entrydate <span class="hljs-keyword">asc</span> <br>limit <span class="hljs-number">5</span> ;<br></code></pre></td></tr></table></figure><h4 id="6-Dcl"><a href="#6-Dcl" class="headerlink" title="6.Dcl"></a>6.Dcl</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3eee03a3e74c60d2abf1179f360f5080.png" alt="在这里插入图片描述"></p><h6 id="0-权限控制列表"><a href="#0-权限控制列表" class="headerlink" title="0.权限控制列表"></a>0.权限控制列表</h6><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>ALL, ALL PRIVILEGES</code></td><td>所有权限</td></tr><tr><td><code>SELECT</code></td><td>查询数据</td></tr><tr><td><code>INSERT</code></td><td>插入数据</td></tr><tr><td><code>UPDATE</code></td><td>修改数据</td></tr><tr><td><code>DELETE</code></td><td>删除数据</td></tr><tr><td><code>ALTER</code></td><td>修改表</td></tr><tr><td><code>DROP</code></td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td><code>CREATE</code></td><td>创建数据库&#x2F;表</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dr自动踢人</title>
    <link href="/2024/09/21/Dr%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%BF%87%E6%BB%A4%E8%B8%A2%E5%87%BA/"/>
    <url>/2024/09/21/Dr%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%BF%87%E6%BB%A4%E8%B8%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/454.png" alt="454"></p><p>ps:由于校园网经常有人用，对此写了个白名单踢人爬虫。外加循环登录，和一个加密参数v</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务Spring Cloude</title>
    <link href="/2024/09/20/%E5%BE%AE%E6%9C%8D%E5%8A%A101/"/>
    <url>/2024/09/20/%E5%BE%AE%E6%9C%8D%E5%8A%A101/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务01"><a href="#微服务01" class="headerlink" title="微服务01"></a>微服务01</h1><blockquote><p>2024 10 1 更新 微服务事务的场景 cap-   ca   cp原则      Seata的模式</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1.png" alt="1"></p><p>总结-<br>微服务01</p><p>远程调用 RestTemplate-&gt;nacos-&gt;OpenFeign-&gt;</p><p>微服务02  GetWay网关-&gt;nacos进阶</p><p>微服务3 微服务保护-&gt;Sentinel-&gt;微服务事务</p><h4 id="微服务了解"><a href="#微服务了解" class="headerlink" title="微服务了解"></a>微服务了解</h4><h6 id="1-微服务和单体服务区别"><a href="#1-微服务和单体服务区别" class="headerlink" title="1.微服务和单体服务区别"></a>1.微服务和单体服务区别</h6><p>单体架构-项目的文件都在同一个工程中开发-项目部署简单<br>但是<br>团队协作不好分工<br>系统发布效率低<br>系统可用性差-无分布式效果-导致功能之间相互影响大</p><hr><p>微服务原则<br>单一职责-一个微服务辅助一部分业务功能-核心数据不依赖其他模块<br>团队自治-每个微服务都有独立的开发测试人员<br>服务自治-每个微服务独立部署</p><hr><ul><li>团队协作成本高？</li><li>系统发布效率低？</li><li>系统可用性差？</li></ul><h6 id="2-SpringCloude"><a href="#2-SpringCloude" class="headerlink" title="2.SpringCloude"></a>2.SpringCloude</h6><p>SpringCloud框架是Java领域的微服务组件的集合。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/da4945c334b905363d17af697d049ab0.png" alt="da4945c334b905363d17af697d049ab0"></p><p>SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本</p><p>Spring Cloud 是在 Spring Boot 之上构建的一组工具和框架，主要用于解决分布式系统中的常见问题，如服务注册与发现、负载均衡、配置管理、断路器等。它提供了一整套微服务架构下的解决方案。</p><h6 id="3-微服务拆分原则"><a href="#3-微服务拆分原则" class="headerlink" title="3.微服务拆分原则"></a>3.微服务拆分原则</h6><ul><li><p>什么时候拆？</p></li><li><p>如何拆？<br>大多数小型项目来说，一般是先采用单体架构，随着用户规模扩大、业务复杂后再逐渐拆分为微服务架构。</p></li><li><p>高内聚：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</p></li><li><p>低耦合：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</p></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/44368b18c4a6590fc1de4c06feb8ffd0.png" alt="44368b18c4a6590fc1de4c06feb8ffd0"></p><ul><li>纵向拆分<br>就是按照项目的功能模块来拆分。<br>例如黑马商城中，就有用户管理功能、订单管理功能、。按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</li><li>横向拆分<br>各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。<br>例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。</li></ul><h6 id="4-微服务拆分"><a href="#4-微服务拆分" class="headerlink" title="4.微服务拆分"></a>4.微服务拆分</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a901f2f7901587696846615aaf0ef1eb.png" alt="a901f2f7901587696846615aaf0ef1eb"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/894106143910c2cbb7708074f9256b47.png" alt="894106143910c2cbb7708074f9256b47"></p><h4 id="springcloude技术栈"><a href="#springcloude技术栈" class="headerlink" title="springcloude技术栈"></a>springcloude技术栈</h4><h4 id="1-远程调用"><a href="#1-远程调用" class="headerlink" title="1.远程调用"></a>1.远程调用</h4><h6 id="0-场景"><a href="#0-场景" class="headerlink" title="0.场景"></a>0.场景</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8ef363e77fbcac43b74e31bea4ea42e4.png" alt="8ef363e77fbcac43b74e31bea4ea42e4"></p><p>itmservice.chaxun(id);-&gt;改为远程调用</p><h6 id="1-RestTemplate"><a href="#1-RestTemplate" class="headerlink" title="1.RestTemplate"></a>1.RestTemplate</h6><p>同步客户端执行HTTP请求</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e7c61f69d70066c2f618e3b78b5ab0ea.png" alt="e7c61f69d70066c2f618e3b78b5ab0ea"></p><p>使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/354729fe5f6622042462ec267dae5a42.png" alt="354729fe5f6622042462ec267dae5a42"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/38aa2eb16283ccac08085d7a12d3a698.png" alt="38aa2eb16283ccac08085d7a12d3a698"></p><p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p><ul><li><p>① 请求方式</p></li><li><p>② 请求路径</p></li><li><p>③ 请求参数<br>返回值类型</p></li></ul><p>缺点<br><strong>负载均衡麻烦-无法指定请求路径</strong><br><strong>-我们就需要一个注册中心-帮我们收集实例-当访问对应就给与一个</strong></p><hr><h4 id="Nacos-注册中心"><a href="#Nacos-注册中心" class="headerlink" title="Nacos-注册中心"></a>Nacos-注册中心</h4><h6 id="0-了解nacos"><a href="#0-了解nacos" class="headerlink" title="0.了解nacos"></a>0.了解nacos</h6><p><strong>Nacos</strong> 是阿里巴巴开源的一款用于动态服务发现、配置管理和服务管理的工具，主要用于微服务架构中的服务治理。它的核心目标是简化分布式系统中的服务注册、服务发现和配置管理，并提供一站式解决方案。</p><p>Nacos 是一个面向微服务架构的服务治理平台，它的主要作用包括：</p><ul><li><strong>动态服务注册与发现</strong>，帮助微服务自动化发现其他服务。</li><li><strong>配置管理</strong>，提供了强大的配置存储、版本控制、动态刷新功能，提升了微服务架构下的配置灵活性。</li><li><strong>健康检查</strong>，保障服务的高可用性和故障隔离能力。</li></ul><h5 id="1-注册中心入门"><a href="#1-注册中心入门" class="headerlink" title="1.注册中心入门"></a>1.注册中心入门</h5><ul><li><p>服务提供者：提供接口供其它微服务访问，比如item-service</p></li><li><p>服务消费者：调用其它微服务提供的接口，比如cart-service</p></li></ul><p>为了管理这些服务·务消费者三者间关系如下：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/905b852bbe9e52b6c85f8ef4b220e33e.png" alt="905b852bbe9e52b6c85f8ef4b220e33e"></p><h6 id="2-注册中心配置-Docker"><a href="#2-注册中心配置-Docker" class="headerlink" title="2.注册中心配置-Docker"></a>2.注册中心配置-Docker</h6><p>1.导入nacos表</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2382bee1bde9f36e4701b2bf0c9986dd.png" alt="2382bee1bde9f36e4701b2bf0c9986dd"></p><p>2.修改配置文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4c2ae85d3e2a4b4c39a8d840d28d3016.png" alt="4c2ae85d3e2a4b4c39a8d840d28d3016"></p><p>3.<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5287cf7a27091d5968a3b9b76965f182.png" alt="5287cf7a27091d5968a3b9b76965f182"></p><h6 id="2-注册中心配置-spring-cloude"><a href="#2-注册中心配置-spring-cloude" class="headerlink" title="2.注册中心配置-spring cloude"></a>2.注册中心配置-spring cloude</h6><p>服务注册</p><p>1.引入依赖<br>2.配置nacos地址<br>3.重启</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/152860dce440d1d9e73f5ef0c6818808.png" alt="152860dce440d1d9e73f5ef0c6818808"></p><p>在nacos的服务列表中即可看到</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1ab667da96d404a3693f73e8f3e61dbd.png" alt="1ab667da96d404a3693f73e8f3e61dbd"></p><p>服务发现<br>1.引入依赖</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95c8c6bd4312301e08eb279ca19c6f72.png" alt="95c8c6bd4312301e08eb279ca19c6f72"></p><p>2.配置nacos</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b00650836cc74d97154f0c19e0885e3b.png" alt="b00650836cc74d97154f0c19e0885e3b"></p><p>3.发现调用服务<br>负载均衡调用服务选择<br>随机-轮训-ip的hash-最少访问</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cc0c30e1121009042204d4d6e490b1a0.png" alt="cc0c30e1121009042204d4d6e490b1a0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8199919e0d3bd8725cdbd299ff19a5db.png" alt="8199919e0d3bd8725cdbd299ff19a5db"></p><p>但是代码还是非常嘈杂以及难看-</p><h4 id="OpenFeign-远程调用"><a href="#OpenFeign-远程调用" class="headerlink" title="OpenFeign-远程调用"></a>OpenFeign-远程调用</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a7daefd898024466d28967eea99da8c.png" alt="0a7daefd898024466d28967eea99da8c"></p><h6 id="1-快速入门案例"><a href="#1-快速入门案例" class="headerlink" title="1.快速入门案例"></a>1.快速入门案例</h6><p>1.导入案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png" alt="e73d3e068484e2e31915ba7653f1003c"></p><p>2.启动注解</p><p>快速入门案例 1.导入案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e73d3e068484e2e31915ba7653f1003c.png" alt="img"><br>2.启动注解</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ed643292f8dcdbb4ff4d6e96ce00153.png" alt="img"><br>3.代码编写</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8241cb4042ea1e687948cd9b6c752e4b.png" alt="8241cb4042ea1e687948cd9b6c752e4b"></p><p>private final ItemClient itemclient;<br>List&lt;&gt;items&#x3D;itemclient.query();</p><p>如上feign帮我们进行了 <strong>服务拉取 负载均衡 -请发送的所有工作</strong></p><h6 id="2-OpenFeign连接池"><a href="#2-OpenFeign连接池" class="headerlink" title="2.OpenFeign连接池"></a>2.OpenFeign连接池</h6><p>我们发起请求的话-需要建立连接-再销毁-但连接池可以减少这个过程产生的消耗<br>使用ok-http连接池<br>1.导入依赖<br>2.配置启用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d0853161a442680c814a26edfd25d44b.png" alt="d0853161a442680c814a26edfd25d44b"></p><p>OkHttp连接池的操作如下：</p><pre><code class="hljs">连接的创建和管理: OkHttp连接池会在应用程序启动时创建一组HTTP连接，并在需要时将其保持在连接池中。这些连接可以被多个线程共享和重用，而不是每次请求都重新创建连接。连接的重用: 当一个线程需要执行一个HTTP请求时，它可以从连接池中获取一个可用的连接，而不必等待新连接的创建。如果连接池中没有可用的连接，线程可能会被阻塞，直到有连接可用为止。连接的释放: 当一个线程完成了对某个HTTP服务的请求，它会将连接放回连接池，而不是关闭连接。这样可以避免频繁地打开和关闭连接，提高了连接的重用率。</code></pre><p>OkHttp连接池可以加快效率的原因包括：</p><pre><code class="hljs">减少连接的创建和销毁开销：通过重用连接，可以避免频繁地创建和销毁连接，从而减少了系统资源的消耗和网络延迟。提高并发性能：连接池可以确保连接的有效重用，从而使多个线程能够并发地共享同一个连接，提高了系统的并发处理能力。降低网络延迟：通过重用连接和减少连接的创建次数，可以减少网络请求的等待时间，从而降低了网络延迟，提高了系统的响应速度。</code></pre><p>总的来说，OkHttp连接池的有效管理和重用HTTP连接可以显著提高应用程序的性能和效率，特别是在需要频繁进行HTTP通信的场景下。</p><p>这里的请求-是固定的 故此可以保存</p><h6 id="3-api抽取"><a href="#3-api抽取" class="headerlink" title="3.api抽取"></a>3.api抽取</h6><p>方案1 结构层次低-耦合度高<br>方案2 结构层次复杂-哦合度低<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f85cd781db72ba5994a9b7341f64c2f.png" alt="2f85cd781db72ba5994a9b7341f64c2f"></p><h6 id="包扫描问题"><a href="#包扫描问题" class="headerlink" title="包扫描问题"></a>包扫描问题</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/76f1f3f63bb3b8d05dc723f7f12117a2.png" alt="76f1f3f63bb3b8d05dc723f7f12117a2"></p><p>也是注册为bean-但我忘记常量注入了</p><h6 id="fegin日志配置"><a href="#fegin日志配置" class="headerlink" title="fegin日志配置"></a>fegin日志配置</h6><p>![2e098ace474e1339c04dd1aa450c100b](G:\360MoveData\Users\nixg\Documents\Tencent Files\2760045743\nt_qq\nt_data\Pic\2024-05\Ori\2e098ace474e1339c04dd1aa450c100b.png)</p><p>修改日志</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/670ebe6e23b9c09af17b4f1e53a3f249.png" alt="670ebe6e23b9c09af17b4f1e53a3f249"></p><h1 id="微服务02"><a href="#微服务02" class="headerlink" title="微服务02"></a>微服务02</h1><p>网关过滤器-全局-和指定-&gt;网关登录鉴权-&gt;</p><p>微服务到微服务-&gt;Feing拦截器</p><p>naocs-&gt;配置共享 -配置热更新-动态路由</p><h2 id="Getway网关"><a href="#Getway网关" class="headerlink" title="Getway网关"></a>Getway网关</h2><h6 id="1-网关了解"><a href="#1-网关了解" class="headerlink" title="1.网关了解"></a>1.网关了解</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/814cd85a1c02b2c0d6fcb82731791e49.png" alt="814cd85a1c02b2c0d6fcb82731791e49"></p><h6 id="2-SpringGetWay网关"><a href="#2-SpringGetWay网关" class="headerlink" title="2.SpringGetWay网关"></a>2.SpringGetWay网关</h6><p>1.创建网关微服务<br>2.引入依赖<br>3.编写启动类<br>4.配置网关路由</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/33c9a08d518a78765fcfda164468e9ed.png" alt="33c9a08d518a78765fcfda164468e9ed"></p><p>配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e602e00dfea1425d97903200ab20744d.png" alt="img"></p><p>规则合集</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/906530d2a10b4728e2e15ef674b795ab.png" alt="906530d2a10b4728e2e15ef674b795ab"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eba4edc2810d7f0f0c3a6af446baf9c6.png" alt="eba4edc2810d7f0f0c3a6af446baf9c6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a10173c12662023f3b425ef0fa1cf022.png" alt="a10173c12662023f3b425ef0fa1cf022"></p><h6 id="3-网关登录鉴权"><a href="#3-网关登录鉴权" class="headerlink" title="3.网关登录鉴权"></a>3.网关登录鉴权</h6><p>登录思路-很多敏感思路都需要鉴权-我们又不可能重复写鉴权代码<br>故此网关思路即可<br>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li><li></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7f0640d795ce3dfac74f1cd2921f308.png" alt="d7f0640d795ce3dfac74f1cd2921f308"></p><p>1.网关传递用户信息-加信息头<br>2.服务直接传递信息-&gt;加信息头</p><h3 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h3><h6 id="1-过滤器了解"><a href="#1-过滤器了解" class="headerlink" title="1.过滤器了解"></a>1.过滤器了解</h6><p>网关的请求转发-由于getway实现<br>具体实现</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8462748af036d85d5789334d705224cc.png" alt="8462748af036d85d5789334d705224cc"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c715d9286b13c80bef8c74b434f3eabc.png" alt="c715d9286b13c80bef8c74b434f3eabc"></p><p>定义一个网关过滤器<br>进行登录逻辑判断-&gt;再Nett….之前</p><p>网关过滤器<br>1.路由过滤器 GatewayFilter指定规则<br>2.全局过滤器 GlobalFilter 全局规则</p><p>过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。</p><p>FilteringWebHandeler处理会将全局-装饰为路由-放到同一过滤器链中<br>依次执行</p><p>spring cloude<br>指定的 路由过滤器<br><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories</a></p><h6 id="2-内置过滤器"><a href="#2-内置过滤器" class="headerlink" title="2.内置过滤器"></a>2.内置过滤器</h6><p>gateway内置的GatewayFilter过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个Route下，就作用于哪个Route.</p><p>AddRequestHeaderGatewayFilterFacotry<br>使用配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88ec0600e28b2a9d0ca37d52cefc3d1f.png" alt="88ec0600e28b2a9d0ca37d52cefc3d1f"></p><h6 id="3-网关路由器-GatewayFilter"><a href="#3-网关路由器-GatewayFilter" class="headerlink" title="3.网关路由器 GatewayFilter"></a>3.网关路由器 GatewayFilter</h6><p>自定义GatewayFilter不是直接实现GatewayFilter，而是实现AbstractGatewayFilterFactory</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1f41d6a93c5a68ed3df317daf479a836.png" alt="1f41d6a93c5a68ed3df317daf479a836"></p><p>该类的名称一定要以GatewayFilterFactory为后缀！</p><p>spring:<br>  cloud:<br>    gateway:<br>      default-filters:<br>            - PrintAny # 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</p><h6 id="4-动态配置参数-GatewayFilter"><a href="#4-动态配置参数-GatewayFilter" class="headerlink" title="4.动态配置参数 GatewayFilter"></a>4.动态配置参数 GatewayFilter</h6><p>过滤器动态配置参数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7fe049b96c1496d2914d63fb65f8a192.png" alt="7fe049b96c1496d2914d63fb65f8a192"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a4e216499c59db0b068a2d2adcfb6344.png" alt="a4e216499c59db0b068a2d2adcfb6344"></p><h6 id="5-全局过滤器-GlobalFilter"><a href="#5-全局过滤器-GlobalFilter" class="headerlink" title="5.全局过滤器 GlobalFilter"></a>5.全局过滤器 GlobalFilter</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b8745f34d893608b923694068caa317a.png" alt="b8745f34d893608b923694068caa317a"></p><h4 id="案例-网关登录鉴权"><a href="#案例-网关登录鉴权" class="headerlink" title="案例 -网关登录鉴权"></a>案例 -网关登录鉴权</h4><p>登录效验编写-<br>思路<br>全局过滤器中-对jwt进行解析-同时解析完毕将信息构造请求头中-以待微服务拿取-<br>如果解析失败-就直接返回</p><h6 id="1-网关拦截-转user-传递到请求头中"><a href="#1-网关拦截-转user-传递到请求头中" class="headerlink" title="1.网关拦截-转user-&gt;传递到请求头中"></a>1.网关拦截-转user-&gt;传递到请求头中</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d9d50e713326b10f6cbc455e35ac9982.png" alt="d9d50e713326b10f6cbc455e35ac9982"></p><h6 id="2-网关到微服务"><a href="#2-网关到微服务" class="headerlink" title="2.网关到微服务"></a>2.网关到微服务</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/21423572850708f447c70112b71b58fe.png" alt="21423572850708f447c70112b71b58fe"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4715d2573fb1cca2b0ad7ffd60d4cf77.png" alt="4715d2573fb1cca2b0ad7ffd60d4cf77"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/036abaa6e3c3efa4258a1ebb6a9a3f74.png" alt="036abaa6e3c3efa4258a1ebb6a9a3f74"></p><h6 id="3-微服务到微服务的传递"><a href="#3-微服务到微服务的传递" class="headerlink" title="3.微服务到微服务的传递"></a>3.微服务到微服务的传递</h6><p>OpenFeign传递<br>OpenFeign-提供了一个拦截器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5e22d64051c12080b52e137b3f2df8d1.png" alt="5e22d64051c12080b52e137b3f2df8d1"></p><h3 id="nacos配置管理"><a href="#nacos配置管理" class="headerlink" title="nacos配置管理"></a>nacos配置管理</h3><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c302ab029433076c8f27b8b744e77da4.png" alt="c302ab029433076c8f27b8b744e77da4"></p><p>解决配置写死-以及重复配置等问题</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/788621b778db5d0475a1459c7f47f2ef.png" alt="788621b778db5d0475a1459c7f47f2ef"></p><h6 id="1-配置共享"><a href="#1-配置共享" class="headerlink" title="1.配置共享"></a>1.配置共享</h6><p>1.naocs<strong>添加配置</strong></p><p>password : ${hm.db.password:}</p><ul><li>数据库database：可以通过${hm.db.database:test}来设定，默认值test</li></ul><p>2.微服务拉取配置</p><p>将共享配置与本地的application.yaml配置合并</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/34f7f37b9b9c8cd0cf8312e5f077eeb4.png" alt="34f7f37b9b9c8cd0cf8312e5f077eeb4"></p><p>依赖</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c7b8cd24915878d194e94777d1dc125c.png" alt="c7b8cd24915878d194e94777d1dc125c"></p><p>bootstart.yaml</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d9ab61eb239f97e8060fb49f7e71f0e1.png" alt="d9ab61eb239f97e8060fb49f7e71f0e1"></p><p>hm.db.database:test<br>hm:<br>  db:<br>      database:hm</p><p>-&gt;指定参数</p><h6 id="2-配置热更新"><a href="#2-配置热更新" class="headerlink" title="2.配置热更新"></a>2.配置热更新</h6><p>例–如我们的购物车上线是10–我们想要通过配置管理-<br>这里也可以用数据库的方法进行控制-但是配置方法更节约资源<br>1.nacos添加配置<br>2.微服务读取配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb27fd15744a4ce0dbbebcec3c82fded.png" alt="bb27fd15744a4ce0dbbebcec3c82fded"></p><p>指定配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7bd5b3ef60ef4f21a05d38e55b3c9c97.png" alt="7bd5b3ef60ef4f21a05d38e55b3c9c97"></p><p>get读取即可</p><p>类似心跳检测机制一样的更新</p><h6 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3.动态路由"></a>3.动态路由</h6><p>动态路由</p><p>网关的路由配置全部是在项目启动时由org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，我们无法利用上节课学习的配置热更新来实现路由更新。</p><p>因此，我们必须<strong>监听Nacos的配置变更</strong>，然后手动把最新的路由更新到路由表中。</p><p>1.nacos配置实时更新</p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/247218cd325db9d0990af715191c506f.png"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">serverAddr:</span> Nacos 服务器的地址，用户需要将 &#123;serverAddr&#125; 替换为实际的 Nacos 服务地址。<br><span class="hljs-symbol">dataId:</span> 配置项的唯一标识符，Nacos 通过 dataId 来标记不同的配置文件。<br><span class="hljs-symbol">group:</span> 配置的组名，Nacos 允许将配置划分为不同的组以便管理，默认为 <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>。<br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">这里通过 <span class="hljs-built_in">Properties</span> 对象来存储 <span class="hljs-variable">Nacos</span> 的配置信息。特别是 <span class="hljs-variable">Nacos</span> 服务器地址 <span class="hljs-variable">serverAddr</span>。<br>通过 <span class="hljs-variable">NacosFactory</span><span class="hljs-operator">.</span><span class="hljs-variable">createConfigService</span><span class="hljs-punctuation">(</span><span class="hljs-variable">properties</span><span class="hljs-punctuation">)</span> 创建了一个 <span class="hljs-variable">ConfigService</span> 对象，用于与 <span class="hljs-variable">Nacos</span> 配置中心进行交互。<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">通过 addListener 方法为指定的 dataId 和 <span class="hljs-keyword">group</span> <span class="hljs-title">添加一个监听器，当该配置有变化时，Nacos</span> 会通知客户端。<br>receiveConfig<span class="hljs-literal">Inf</span>o 方法是监听器的回调函数，当配置发生变化时，该方法会接收到变化的配置信息，并打印出来。<br>getExecutor 方法允许用户自定义线程池执行监听回调任务，返回 null 表示使用 Nacos 内部的默认线程池。<br><br><br>getConfig 方法用于同步获取当前 dataId 和 <span class="hljs-keyword">group</span> <span class="hljs-title">对应的配置内容。</span><br><span class="hljs-title">其中 5000</span> 是超时时间，表示如果在 <span class="hljs-number">5</span> 秒内没有获取到配置内容则会超时。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0fccbe790ea662f50e4dc78e637dfeb9.png"></p><p>路由更新接口<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb2704aaff009260682661686d43a863.png" alt="eb2704aaff009260682661686d43a863"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3834ba9c13d5c8765637fa028b2d2540.png" alt="3834ba9c13d5c8765637fa028b2d2540"></p><p>如上-网关路由的检测-和网关路由的更改已经完毕-接下来就是实例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1be7a5e7b5ff63918edfb6a98a4df1e8.png" alt="1be7a5e7b5ff63918edfb6a98a4df1e8"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/21dbf7eb235492bb336c2ee5a9b1d495.png" alt="21dbf7eb235492bb336c2ee5a9b1d495"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9283c00f8a1b26caba5a8ea4a7d47102.png" alt="9283c00f8a1b26caba5a8ea4a7d47102"># 微服务02</p><p>网关过滤器-全局-和指定-&gt;网关登录鉴权-&gt;</p><p>微服务到微服务-&gt;Feing拦截器</p><p>naocs-&gt;配置共享 -配置热更新-动态路由</p><h2 id="微服务03"><a href="#微服务03" class="headerlink" title="微服务03"></a>微服务03</h2><h4 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h4><p><strong>服务保护方案</strong></p><ul><li><p>请求限流</p></li><li><p>隔离和熔断</p></li><li><p>分布式事务</p><ul><li><p>初识分布式事务</p></li><li><p>Seata</p></li><li><p>知道雪崩问题产生原因及常见解决方案</p></li><li><p>能使用Sentinel实现服务保护</p></li><li><p>理解分布式事务产生的原因</p></li><li><p>能使用Seata解决分布式事务问题</p></li><li><p>理解AT模式基本原理</p></li></ul></li></ul><h6 id="1-微服务问题"><a href="#1-微服务问题" class="headerlink" title="1.微服务问题"></a>1.微服务问题</h6><p>级联问题-雪崩问题</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5adedac41a06aa9d5d23e1c048f9aefc.jpg" alt="5adedac41a06aa9d5d23e1c048f9aefc"></strong></p><p>请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度</p><p>都是属于降级处理</p><h6 id="2-请求限流"><a href="#2-请求限流" class="headerlink" title="2.请求限流"></a>2.请求限流</h6><p>限制或控制接口访问的并发流量<strong>，避免服务因流量激增而出现故障。</strong></p><p>请求限有一个限流器，并发请求，经过限流器就变的平均。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aa552325c073f6eb535f3dbda6adf3c2.jpg" alt="aa552325c073f6eb535f3dbda6adf3c2"></p><h6 id="3-线程隔离"><a href="#3-线程隔离" class="headerlink" title="3.线程隔离"></a>3.线程隔离</h6><p><strong>当一个业务接口响应时间长，而且并发高时，我们可以控制该线程的数量。</strong><br>即便该微服务出现问题。浪费的也只是20线程的资源～这里的20是我们设置的线程数量</p><h6 id="4-服务熔断"><a href="#4-服务熔断" class="headerlink" title="4.服务熔断"></a>4.服务熔断</h6><p><strong>线程熔断虽然避免了雪崩问题。但是依然无法解决。浪费资源问题</strong></p><ul><li>编写服务降级逻辑：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li>异常统计和熔断：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><p>熔断后写一个心跳机制-如果不超时或者异常 </p><p> 让他恢复</p><h4 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h4><h6 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h6><p>微服务保护技术</p><p>Sentinel是阿里巴巴开源的一款服务保护框架</p><p>Sentinel 的使用可以分为两个部分:</p><ul><li><p>核心库（Jar包）：不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</p></li><li><p>控制台（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</p><p>控制台整合</p></li></ul><p><a href="https://sentinelguard.io/zh-cn/docs/dashboard.html">https://sentinelguard.io/zh-cn/docs/dashboard.html</a></p><p>微服务整合Sentinel</p><!--sentinel--><dependency>    <groupId>com.alibaba.cloud</groupId>     <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId></dependency><hr><p>spring:<br>  cloud:<br>    sentinel:<br>      transport:<br>        dashboard: localhost：8090</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3ec0f2747e58af51ff00c89fad2f637.jpg" alt="f3ec0f2747e58af51ff00c89fad2f637"></p><h6 id="2-簇点链路"><a href="#2-簇点链路" class="headerlink" title="2.簇点链路"></a>2.簇点链路</h6><p> <strong>簇点链路</strong>，指的是在一次请求中经过的各个资源点，例如一个 SpringMVC 的接口 <code>/carts</code>，这是一个被 Sentinel 监控的资源。在默认情况下，Sentinel 会将请求路径（如 <code>/carts</code>）作为唯一标识来识别和监控资源。但在 RESTful 风格的 API 中，同一路径可能会根据 HTTP 方法执行不同的操作，如查询、删除或修改。例如：</p><ul><li><code>GET /carts</code> 用于查询购物车</li><li><code>POST /carts</code> 用于添加购物车</li><li><code>DELETE /carts</code> 用于删除购物车</li></ul><p>由于默认情况下 Sentinel 不区分 HTTP 方法，这会导致多个不同功能的接口被 Sentinel 认为是同一个资源。如果某个操作发生限流、熔断，其他操作也会受到影响，显然是不合理的。</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把请求方式 + 请求路径作为簇点资源名：</p><p>spring:<br>  cloud:<br>    sentinel:<br>      transport:<br>        dashboard: localhost:8090<br>      http-method-specify: true # 开启请求方式前缀</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd6ad74e5a523414c5fa94e71ce26b44.png" alt="dd6ad74e5a523414c5fa94e71ce26b44"></p><h6 id="3-请求限流"><a href="#3-请求限流" class="headerlink" title="3.请求限流"></a>3.请求限流</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/513f93a0c1b54d9cf48340131857d35b.png" alt="513f93a0c1b54d9cf48340131857d35b"></p><p>QPS &#x3D; 总请求数 &#x2F; 时间（秒）<br>6&#x3D;6&#x2F;1</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8bea4b790cd4908a3b2c157b54a82324.png" alt="8bea4b790cd4908a3b2c157b54a82324"></p><h6 id="4-线程隔离"><a href="#4-线程隔离" class="headerlink" title="4.线程隔离"></a>4.线程隔离</h6><p>限流-一旦雪崩还是没能解决<br>对查询商品的FeignClient接口做线程隔离</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd258ef0eff928db8ad60a51fa901e21.png" alt="dd258ef0eff928db8ad60a51fa901e21"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/96bf2d1721a6ad24b4c4c57a0420950e.png" alt="96bf2d1721a6ad24b4c4c57a0420950e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61c54a305d589adf29b99e9e783df0d8_720.png" alt="61c54a305d589adf29b99e9e783df0d8_720"></p><p>即便服务有什么问题。该服务能使用的线程数一直是10</p><h6 id="5-服务熔断"><a href="#5-服务熔断" class="headerlink" title="5.服务熔断"></a>5.服务熔断</h6><p>服务熔断<br><strong>问题-我们设置了线程熔断和QPS限制-那么被拒绝的服务就会被抛出异常</strong><br><strong>我们应该给一个降级处理</strong><br>2-<br>查询的延迟极高-还是会一直消耗资源-我们可以设置阈值-到达就熔断服务</p><p>1.编写降级处理<br>FeignClient编写失败后的降级逻辑<br>1.FallbackClass，无法对远程调用的异常做处理<br>2.：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/56ceaa1b237096af7d548dff22f64079.png" alt="56ceaa1b237096af7d548dff22f64079"></p><p><strong>ItemClientFallback</strong> 类实现了 <code>FallbackFactory&lt;ItemClient&gt;</code>，当 <code>ItemClient</code> 调用失败时，<code>create()</code> 方法会被调用，并接收一个 <code>Throwable cause</code> 参数，表示引发失败的异常。</p><p>该方法为默认实现</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/46c47701adaebf8ecdf3bedffcebfcd2.png" alt="46c47701adaebf8ecdf3bedffcebfcd2"></p><p>注册为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b8be56aab96f78ab8cc6280a940b9654.png" alt="b8be56aab96f78ab8cc6280a940b9654"></p><p>指定回调</p><p>降级之后-我们就设置服务熔断</p><p><strong>断路器的工作模式</strong><br>Sentinel中的断路器不仅可以统计某个接口的慢请求比例，还可以统计异常请求比例。<strong>当这些比例超出阈值时，就会熔断该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c41d54b8f48ef781a5719d594365b351.png" alt="c41d54b8f48ef781a5719d594365b351"></p><hr><hr><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7186f713c807cd96f4f0736cfdf33eb9.png" alt="7186f713c807cd96f4f0736cfdf33eb9"></p><h4 id="微服务事务"><a href="#微服务事务" class="headerlink" title="微服务事务"></a>微服务事务</h4><h6 id="1-微服务事务了解"><a href="#1-微服务事务了解" class="headerlink" title="1.微服务事务了解"></a>1.微服务事务了解</h6><ul><li><ul><li>在单体应用中，事务是通过数据库的 <strong>ACID</strong> 特性（原子性、一致性、隔离性、持久性）来保证的。然而，在微服务架构中，每个服务都有自己独立的数据源（数据库、缓存等），通常无法再通过传统的本地事务管理工具来保证整体事务的一致性。这时会出现如下问题：<ul><li><strong>跨服务的事务一致性</strong>：比如用户下单时，订单服务、库存服务、支付服务需要在不同的数据库中进行操作，如何保证所有服务的数据操作要么全部成功，要么全部回滚？</li><li><strong>网络延迟与失败</strong>：微服务间的调用是通过网络进行的，网络的延迟或失败会使事务变得复杂。</li><li><strong>独立性与隔离性</strong>：不同的微服务通常需要尽量保持高自治性和松耦合性，但在分布式事务中，需要一定的协调性。</li></ul></li></ul></li></ul><h6 id="2-分布式事务场景"><a href="#2-分布式事务场景" class="headerlink" title="2.分布式事务场景"></a>2.分布式事务场景</h6><p>1,.单服务请求多数据库完成一次事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165833626.png" alt="image-20241001165833626"></p><p>2.多服务请求单数据库完成一次事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165844052.png" alt="image-20241001165844052"></p><p>1、跨服务完成一次事务</p><p>2、跨数据源完成一次事务</p><h6 id="3-Cap原则"><a href="#3-Cap原则" class="headerlink" title="3.Cap原则"></a>3.Cap原则</h6><p>CAP是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165924978.png" alt="image-20241001165924978"></p><p>C<strong>一致性:</strong> 向系统写一个新数据再次读取到的也一定是这个新数据。拿上图举例，请求订单服务下单，订单服务请求库存服务扣减库存，只要下单成功则库存扣减成功。</p><p><strong>A可用性：</strong>任何时间都可以访问订单服务和库存服务，系统保证可用。</p><p>p<strong>分区容忍性：</strong>也叫分区容错性，分布式系统在部署时服务器可能部署在不同的网络分区，比如上图中订单服务在北京，库存服务在上海，由于处于不同的网络分区如果网络通信异常就会导致节点 之间无法通信，当出现由于网络问题导致节点 之间无法通信，此时仍然是对外提供服务的这叫做满足分区容忍性。</p><p><strong>CAP理论要强调在<strong><strong>分布式</strong></strong>系统中C、A、P这三点不能全部满足。</strong></p><h6 id="4-CP"><a href="#4-CP" class="headerlink" title="4.CP"></a>4.CP</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001165947190.png" alt="image-20241001165947190"></p><h6 id="5-Ap"><a href="#5-Ap" class="headerlink" title="5.Ap"></a>5.Ap</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001170026148.png" alt="image-20241001170026148"></p><h6 id="6-实际场景"><a href="#6-实际场景" class="headerlink" title="6.实际场景"></a>6.实际场景</h6><p>满足CP的要求：</p><p><strong>创建订单和优惠券核销要么都成功要么都失败，不能存在一个成功一个失败</strong>，如果要实现CP需要在下单和核销优惠券操作前进行一次预操作，如果预操作成功将优惠券锁定避免在执行事务期间优惠券被其它订单使用。</p><p>满足AP的要求：</p><p><strong>创建订单和优惠券核销要么都成功要么都失败，可以暂时存在一个成功一个失败，最终要保证数据的一致性</strong>，如果要实现AP，不需要提前锁定资源，在执行事务期间有一个失败则么另一个操作回滚即可，最终实现数据一致性。</p><p>基于上边的分析，实现CP更麻烦，实现AP同样满足的需求，本项目优惠券核销操作实现AP。</p><p>实现方案</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001170311395.png" alt="image-20241001170311395"></p><h4 id="2-Seata"><a href="#2-Seata" class="headerlink" title="2.Seata"></a>2.Seata</h4><h6 id="0-seata模式"><a href="#0-seata模式" class="headerlink" title="0.seata模式"></a>0.seata模式</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241001170352060.png" alt="image-20241001170352060"></p><h6 id="1-Seata了解"><a href="#1-Seata了解" class="headerlink" title="1.Seata了解"></a>1.Seata了解</h6><p>分布式事务-<strong>各个单个事务直接无法感应对方的失败或者成功</strong><br>事务协调者，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。<br><strong>回调检查-或者建立通信协议</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c45f4302dfe6ec401b7166531e8d0ee.png" alt="0c45f4302dfe6ec401b7166531e8d0ee"></p><h6 id="2-Seata部署"><a href="#2-Seata部署" class="headerlink" title="2.Seata部署"></a>2.Seata部署</h6><p>部署TC-DOCKER<br>1.<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/13bdfa580099aaad3e6b5b6b3a658b23.png" alt="img"><br>2.<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/954d7d66dc6aede16d41e72775d344aa_720.png" alt="img"><br>3.<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/47128070412f9199c201de643d226dfe.png" alt="img"></p><hr><hr><p>微服务集成Seata</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4e467740c6cae0760dfeeec1f185a409.png" alt="4e467740c6cae0760dfeeec1f185a409"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/969b0797c9e9111080031504307f449a.png" alt="969b0797c9e9111080031504307f449a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5a81cb44028665de51944504b72b9d05.png" alt="5a81cb44028665de51944504b72b9d05"></p><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。<br>将课前资料的seata-at.sql-导入进行事务控制的数据库中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/661baa4e424fa939c19202b5b66381c0.png" alt="661baa4e424fa939c19202b5b66381c0"></p><h6 id="3-Seata使用"><a href="#3-Seata使用" class="headerlink" title="3.Seata使用"></a>3.Seata使用</h6><p>@Transactional注解改为Seata提供的@GlobalTransactional</p><p>微服务事务</p><p><strong>@GlobalTransactional注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。</strong></p><h6 id="4-分布式解决方案"><a href="#4-分布式解决方案" class="headerlink" title="4.分布式解决方案"></a>4.分布式解决方案</h6><p><strong>两阶段提交（2PC，Two-Phase Commit）</strong>：</p><ul><li>在第一阶段（准备阶段），所有涉及事务的服务都会“准备”它们的操作，并告知协调者准备状态。</li><li>在第二阶段（提交阶段），如果所有服务都准备成功，则协调者通知所有服务提交事务；否则，所有服务都回滚事务。</li><li>缺点：两阶段提交的锁定资源时间较长，可能导致性能问题和死锁。</li></ul><p><strong>TCC 模型（Try-Confirm-Cancel）</strong>：</p><ul><li>TCC 模型是一种细化的两阶段提交方案，服务在业务逻辑上实现 <code>Try</code>（准备）、<code>Confirm</code>（确认）、<code>Cancel</code>（取消）三个步骤。</li><li>在 <code>Try</code> 阶段，服务会预留资源（例如预扣库存）；在 <code>Confirm</code> 阶段，服务确认资源的操作；在 <code>Cancel</code> 阶段，取消预留操作。</li></ul><p><strong>基于消息的最终一致性</strong>：</p><ul><li>使用消息队列来保证跨服务的数据一致性。当事务的一部分成功后，其他微服务通过异步消息更新自己的数据，保证最终一致性。</li><li>优点：弱化了实时性，较适合对一致性要求不高的场景。</li></ul><p><strong>SAGA 模型</strong>：</p><ul><li>SAGA 是一种分布式事务模式，将每个服务的事务划分为多个小事务，每个小事务有对应的补偿操作。</li><li>如果某个小事务失败，已经完成的小事务会通过调用补偿逻辑（如回滚、撤销操作）来恢复到一致状态。</li></ul><h6 id="5-Xa模式"><a href="#5-Xa模式" class="headerlink" title="5.Xa模式"></a>5.Xa模式</h6><p>A是规范-原理是两阶段提交</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55c86dd3399de2a54a2a7529aba97425.png" alt="img"></p><p>一阶段：</p><p>tm告诉TC开启全局事务</p><p>tm-调用rm</p><ul><li>事务协调者TC通知每个事务参与者执行本地事务</li><li>rm执行sql</li><li>本地事务执行完成后报告事务执行状态给<strong>事务协调者</strong>，此时事务不提交，<strong>继续持有数据库锁</strong></li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><p>也就是-<strong>事务锁只有等一阶段所有RM执行完毕-等待通知-开启2阶段</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/709e85023e48ff24e13992252e2462ce.png" alt="709e85023e48ff24e13992252e2462ce"></p><p>优缺点<br>行锁的缺点-优点</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7db161ff42213ab817db33e83bb099e7.png" alt="7db161ff42213ab817db33e83bb099e7"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eec304cd22421ef584ef0d4365467799_720.png" alt="eec304cd22421ef584ef0d4365467799_720"></p><h6 id="6-At模式"><a href="#6-At模式" class="headerlink" title="6.At模式"></a>6.At模式</h6><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/649c531678978500ca68bd26a8db0c6a_720.png" alt="649c531678978500ca68bd26a8db0c6a_720"></p><p>取消行锁-改为本地log缓存</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/15c2cee13194b25bd165d5980011e9ed.png" alt="15c2cee13194b25bd165d5980011e9ed"></p><h2 id="阶段一-每个数据库都直接提交-同时备份一个undo-log"><a href="#阶段一-每个数据库都直接提交-同时备份一个undo-log" class="headerlink" title="阶段一 每个数据库都直接提交-同时备份一个undo-log"></a>阶段一 每个数据库都直接提交-同时备份一个undo-log</h2><p>一旦某个地方出现异常-RM回滚-同时TC-检测-分发没个事务进行回滚</p><p>流程</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88b2c6ae733ee58267bce34f201a1f25.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/05e2129219408c89e3e555605e1ff6cd.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c8c093537f83c8d013dc24d35de1ca5.png" alt="0c8c093537f83c8d013dc24d35de1ca5"></p><p>AT模式下分支事务会立即提交，虽然回滚可以通过快照恢复原始数据，但在异常发生之前，其他事务读取的数据可能是已经修改但未最终确定的状态。因此，若需要保证严格的数据一致性，可能需要结合隔离级别控制和快照机制，或者对已读数据的后续处理进行特殊设计。</p><h6 id="Xa-At区别"><a href="#Xa-At区别" class="headerlink" title="Xa At区别"></a>Xa At区别</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e527cdc2f3f935ead60411649086b841.png" alt="e527cdc2f3f935ead60411649086b841"></p><p>tm-&gt;告知TC开启事务<br>RM执行sql-并且保存sql快照-&gt;提交</p><p>事务介绍-&gt;tm告知-&gt;tc结束</p><p>tc检查是否有异常-无异常提交-有异常回档</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-单链表02</title>
    <link href="/2024/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表-单链表探究"><a href="#线性表-单链表探究" class="headerlink" title="线性表-单链表探究"></a>线性表-单链表探究</h1><h4 id="2-3-1-单链表定义"><a href="#2-3-1-单链表定义" class="headerlink" title="2.3.1  单链表定义"></a>2.3.1  单链表定义</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dc7d4713cc2eff99fc5b308c557c8a30.png" alt="dc7d4713cc2eff99fc5b308c557c8a30"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">单链表分为带头结点和不带头结点两种类型。在许多情况下，带头结点的单链表能够简化运算的实现过程。<br>因此这里讨论的单链表除特别指出外均指带头结点的单链表<br></code></pre></td></tr></table></figure><p>单链表结构</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span><br>&#123;  ElemType data;<span class="hljs-comment">//数据域</span><br>   <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span> *next;<span class="hljs-comment">//指针域</span><br>&#125; SLinkNode;<span class="hljs-comment">//单链表结点类型</span><br><br></code></pre></td></tr></table></figure><p>尾节点next探究-  1.指向null 2.指向头节点-循环单链表</p><h4 id="2-3-2线性表基本运算在单链表上的"><a href="#2-3-2线性表基本运算在单链表上的" class="headerlink" title="2.3.2线性表基本运算在单链表上的"></a>2.3.2线性表基本运算在单链表上的</h4><p>数据结构</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d42879b92325190541fb4481ce40e7f.png" alt="8d42879b92325190541fb4481ce40e7f"></p><h6 id="1-初始化线性表运算算法"><a href="#1-初始化线性表运算算法" class="headerlink" title="1.初始化线性表运算算法"></a>1.<strong>初始化线性表运算算法</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">创建一个空的单链表，它只有一个头结点，由L指向它。该结点的next域为空，data域未设定任何值。对应的算法如下：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SLinkNode *&amp;L)</span>　　　<span class="hljs-comment">//L为引用型参数</span></span><br><span class="hljs-function"></span>&#123;  L=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode)); <span class="hljs-comment">//创建头结点L</span><br>   L-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法"><a href="#2-销毁线性表运算算法" class="headerlink" title="2.销毁线性表运算算法"></a>2.<strong>销毁线性表运算算法</strong></h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">一个单链表中的所有结点空间都是通过malloc函数分配的，在不再需要时需通过free函数释放所有结点的空间。 循环<span class="hljs-keyword">next</span>  <span class="hljs-keyword">delete</span>吗 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">DestroyList</span><span class="hljs-params">(SLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>SLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>   &#123;  <span class="hljs-built_in">free</span>(pre);<br>      pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-求线性表的长度运算算法"><a href="#3-求线性表的长度运算算法" class="headerlink" title="3.求线性表的长度运算算法"></a>3.<strong>求线性表的长度运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">设置一个整型变量<span class="hljs-selector-tag">i</span>作为计数器，<span class="hljs-selector-tag">i</span>初值为<span class="hljs-number">0</span>，<span class="hljs-selector-tag">p</span>初始时指向第一个数据结点。然后沿next域逐个往后查找，每移动一次，<span class="hljs-selector-tag">i</span>值增<span class="hljs-number">1</span>。当<span class="hljs-selector-tag">p</span>所指结点为空时，结束这个过程，<span class="hljs-selector-tag">i</span>之值即为表长。 <br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int GetLength(SLinkNode *L)<br>&#123;  <br>       <span class="hljs-attribute">int</span>=0;<br>       SLinkNode *<span class="hljs-attribute">p_next</span>=L-&gt;next;<br>       <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)<br>       &#123;<br>       i++;<br>       <span class="hljs-attribute">L</span>=p_next;<br>&#125;<br>return i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法"><a href="#4-求线性表中第i个元素运算算法" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用<span class="hljs-selector-tag">p</span>从头开始遍历单链表L中的结点，用计数器j累计遍历过的结点，其初值为<span class="hljs-number">0</span>。<br>在遍历时j等于<span class="hljs-selector-tag">i</span>时，若<span class="hljs-selector-tag">p</span>不为空，则<span class="hljs-selector-tag">p</span>所指结点即为要找的结点，查找成功，算法返回<span class="hljs-number">1</span>。<br>否则算法返回<span class="hljs-number">0</span>表示未找到这样的结点。<br><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int GetElem(SLinkNode *L,int i,ElemType &amp;e)<br>&#123;  int <span class="hljs-attribute">j</span>=0;<br>SLinkNode *<span class="hljs-attribute">P</span>=L;<br><span class="hljs-keyword">if</span>(i&lt;=0 )<br>&#123;<br>return 0;<br>&#125;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span> &amp;&amp;j&lt;I)<br>&#123;<br>j++;<br><span class="hljs-attribute">p</span>=p-&gt;next;<br>&#125;<br>j-节点数量 -第i个元素<br><span class="hljs-attribute">j</span>=i;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">p</span>==null)<br>&#123;<br>return 0;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-attribute">e</span>=p-&gt;data;<br>return 1;<br>&#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法"><a href="#5-按值查找运算算法" class="headerlink" title="5.按值查找运算算法"></a>5.<strong>按值查找运算算法</strong></h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在单链表L中从第一个数据结点开始查找第一个值域与e相等的结点，若存在这样的结点，则返回其逻辑序号；否则返回0。<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int Locate(SLinkNode *L,ElemType e)<br>&#123;  <br>SLinkNode *<span class="hljs-attribute">p</span>=L-&gt;next;<br>int <span class="hljs-attribute">j</span>=1;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span> &amp;&amp;p-&gt;data!=e)<br>&#123;<br><span class="hljs-attribute">p</span>=p.next;<br>j++;<br><br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">p</span>==null)<br>&#123;<br>rerturn -1;<br>&#125;<br>return j;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-插入元素运算算法"><a href="#6-插入元素运算算法" class="headerlink" title="6.插入元素运算算法"></a>6.<strong>插入元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">在单链表L中插入第<span class="hljs-selector-tag">i</span>个值为<span class="hljs-attribute">x</span>的结点。<br>先在单链表L中查找第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，若未找到返回<span class="hljs-number">0</span>；<br>找到后由<span class="hljs-selector-tag">p</span>指向该结点，创建一个以<span class="hljs-attribute">x</span>为值的新结点s，将其插入到<span class="hljs-selector-tag">p</span>指结点之后。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/439df81a0b8ea9dfe5d48ad618bad001.png" alt="439df81a0b8ea9dfe5d48ad618bad001"></p><p>头插</p><p>尾插</p><p><strong>中间插</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> InsElem(SLinkNode *&amp;L,ElemType x,<span class="hljs-keyword">int</span> i)<br>&#123;  <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>   SLinkNode *p=L,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span> &amp;&amp; j&lt;i-<span class="hljs-number">1</span>)  <span class="hljs-comment">//查找第i-1个结点p</span><br>   &#123;j++;<br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-comment">//找到替换位置指针</span><br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-keyword">NULL</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//未找到第i-1个结点时返回0</span><br>   <span class="hljs-keyword">else</span>  <span class="hljs-comment">//找到第i-1个结点p</span><br>   &#123;s=(SLinkNode *)malloc(sizeof(SLinkNode));<br>s-&gt;data=x;  <span class="hljs-comment">//创建存放元素x的新结点s</span><br>s-&gt;<span class="hljs-keyword">next</span>=p-&gt;<span class="hljs-keyword">next</span>;  <span class="hljs-comment">//将s结点插入到p结点之后</span><br>p-&gt;<span class="hljs-keyword">next</span>=s;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="7-删除操作"><a href="#7-删除操作" class="headerlink" title="7.删除操作"></a>7.删除操作</h6><p>中间删</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d483479c3492507a1d6036710c6ec846.png" alt="d483479c3492507a1d6036710c6ec846"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelElem</span><span class="hljs-params">(SLinkNode *&amp;L,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   SLinkNode *p=L,*q;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)  <span class="hljs-comment">//查找第i-1个结点</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//未找到第i-1个结点时返回0</span><br>   <span class="hljs-keyword">else</span>  <span class="hljs-comment">//找到第i-1个结点p</span><br>   &#123;q=p-&gt;next;  <span class="hljs-comment">//q指向被删结点</span><br><span class="hljs-keyword">if</span> (q==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//没有第i个结点时返回0</span><br><span class="hljs-keyword">else</span><br>&#123;   p-&gt;next=q-&gt;next;  <span class="hljs-comment">//从单链表中删除q结点</span><br>　　<span class="hljs-built_in">free</span>(q);  <span class="hljs-comment">//释放其空间</span><br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="8-输出线性表运算算法"><a href="#8-输出线性表运算算法" class="headerlink" title="8.输出线性表运算算法"></a>8.<strong>输出线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">从第一个数据结点开始，沿next域逐个往下遍历，输出每个遍历到结点的<span class="hljs-class"><span class="hljs-keyword">data</span>域，直到尾结点为止。</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">DispList</span><span class="hljs-params">(SLinkNode *L)</span><br>&#123;  SLinkNode *p=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=NULL)<br>   &#123;printf(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;data);<br>p=p-&gt;next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="整体创建单链表的算法"><a href="#整体创建单链表的算法" class="headerlink" title="整体创建单链表的算法"></a><strong>整体创建单链表的算法</strong></h4><p>可以通过调用基本运算算法来创建单链表，其过程是先初始化一个单链表，然后向其中一个一个地插入元素。<br>这里介绍是快速创建整个单链表的算法，也称为整体建表。<br><strong>假设给定一个含有n个元素的数组a，由它来创建单链表，这种建立单链表的常用方法有两种。</strong></p><h6 id="1-头插"><a href="#1-头插" class="headerlink" title="1.头插"></a>1.头插</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空单链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>将新结点s插入到当前链表的表头上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到单链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止。<br><br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> CreateListF(SLinkNode *&amp;L,ElemType a[],<span class="hljs-keyword">int</span> n)<br>&#123;  SLinkNode *s;  <span class="hljs-keyword">int</span> i;<br>   L=(SLinkNode *)malloc(sizeof(SLinkNode));<span class="hljs-comment">//创建头结点</span><br>   L-&gt;<span class="hljs-keyword">next</span>=<span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//头结点的next域置空，表示一个空单链表</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//遍历a数组所有元素</span><br>   &#123;s=(SLinkNode *)malloc(sizeof(SLinkNode));<br>s-&gt;data=a[i];<span class="hljs-comment">//创建存放a[i]元素的新结点s</span><br>s-&gt;<span class="hljs-keyword">next</span>=L-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//将s插在头结点之后</span><br>L-&gt;<span class="hljs-keyword">next</span>=s;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/86120495f4b2c71b0d16a605c858d0cf.png" alt="86120495f4b2c71b0d16a605c858d0cf"></p><h6 id="2-尾插"><a href="#2-尾插" class="headerlink" title="2.尾插"></a>2.尾插</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空单链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>将新结点s插入到当前链表的表尾上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到单链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止。<br>由于尾插法算法每次将新结点插到当前链表的表尾上，为此增加一个尾指针tc，使其始终指向当前链表的尾结点。<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateListR</span><span class="hljs-params">(SLinkNode *&amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;  SLinkNode *s,*tc;  <span class="hljs-type">int</span> i;<br>   L=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode));  <span class="hljs-comment">//创建头结点</span><br>   tc=L;<span class="hljs-comment">//tc始终指向尾结点,初始时指向头结点</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;s=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode));<br>s-&gt;data=a[i];<span class="hljs-comment">//创建存放a[i]元素的新结点s</span><br>tc-&gt;next=s;<span class="hljs-comment">//将s插入tc之后</span><br>tc=s;<br>   &#125;<br>   tc-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//尾结点next域置为NULL</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/12438238fcfd7d0f1b5b1b2d2ae161c8.png" alt="12438238fcfd7d0f1b5b1b2d2ae161c8"></h6><h4 id="单链表算法示例"><a href="#单链表算法示例" class="headerlink" title="单链表算法示例"></a>单链表算法示例</h4><h5 id="1-基于单链表基本操作的算法设计"><a href="#1-基于单链表基本操作的算法设计" class="headerlink" title="1. 基于单链表基本操作的算法设计"></a><strong>1.</strong> <strong>基于单链表基本操作的算法设计</strong></h5><h6 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h6><h6 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h6><h5 id="2-基于整体建表的算法设计"><a href="#2-基于整体建表的算法设计" class="headerlink" title="2. 基于整体建表的算法设计"></a><strong>2.</strong> 基于整体建表的算法设计</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">这类算法设计中需要根据条件产生新的结果单链表。<br>而创建结果单链表的方法有头插法和尾插法。<br><br></code></pre></td></tr></table></figure><h6 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h6><h5 id="3-有序单链表的二路归并算法"><a href="#3-有序单链表的二路归并算法" class="headerlink" title="3. 有序单链表的二路归并算法"></a><strong>3.</strong> 有序单链表的二路归并算法</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">有序单链表是有序表的单链表存储结构，同样可以利用有序表元素的有序性提高相关算法的效率。<br>当数据采用单链表存储时，对应的二路归并就是单链表二路归并算法。<br><br></code></pre></td></tr></table></figure><h6 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h6><h5 id="4-单链表的排序"><a href="#4-单链表的排序" class="headerlink" title="4. 单链表的排序"></a><strong>4.</strong> <strong>单链表的排序</strong></h5><h6 id="2-18"><a href="#2-18" class="headerlink" title="2.18"></a>2.18</h6><h1 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h1><h6 id="2-3-4-1-循环单链表定义"><a href="#2-3-4-1-循环单链表定义" class="headerlink" title="2.3.4.1 循环单链表定义"></a>2.3.4.1 循环单链表定义</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4253efe9dd66b03ed40ea343337ca5fd.png" alt="4253efe9dd66b03ed40ea343337ca5fd"></p><h4 id="2-3-1-2-算法定义"><a href="#2-3-1-2-算法定义" class="headerlink" title="2.3.1.2 算法定义"></a>2.3.1.2 算法定义</h4><h6 id="1-初始化线性表运算算法-1"><a href="#1-初始化线性表运算算法-1" class="headerlink" title="1.初始化线性表运算算法"></a>1.初始化线性表运算算法</h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">创建一个空的循环单链表，它只有头结点，由<span class="hljs-type">L</span>指向它。该结点的next域指向该头结点，<span class="hljs-class"><span class="hljs-keyword">data</span>域未设定任何值。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SLinkNode *&amp;L)</span>　　<span class="hljs-comment">//L为引用型参数</span></span><br><span class="hljs-function"></span>&#123;  L=(SLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLinkNode));<br>   L-&gt;next=L;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法-1"><a href="#2-销毁线性表运算算法-1" class="headerlink" title="2.销毁线性表运算算法"></a>2.销毁线性表运算算法</h6><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">一个循环单链表中的所有结点空间都是通过<span class="hljs-keyword">malloc</span>函数分配的，在不再需要时需通过<span class="hljs-keyword">free</span>函数释放所有结点的空间。 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  SLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-built_in">free</span>(pre);<br>pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-求线性表的长度运算算法-1"><a href="#3-求线性表的长度运算算法-1" class="headerlink" title="3.求线性表的长度运算算法"></a>3.<strong>求线性表的长度运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">设置一个整型变量<span class="hljs-selector-tag">i</span>作为计数器，<span class="hljs-selector-tag">i</span>初值为<span class="hljs-number">0</span>，<span class="hljs-selector-tag">p</span>初始时指向第一个结点。然后沿next域逐个往下移动，每移动一次，<span class="hljs-selector-tag">i</span>值增<span class="hljs-number">1</span>。当<span class="hljs-selector-tag">p</span>所指结点为头结点时这一过程结束，<span class="hljs-selector-tag">i</span>之值即为表长。 <br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int GetLength(SLinkNode *L)<br>&#123;  int <span class="hljs-attribute">i</span>=0;<br>   SLinkNode *<span class="hljs-attribute">p</span>=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;i++;<br><span class="hljs-attribute">p</span>=p-&gt;next;<br>   &#125;<br>   return i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法-1"><a href="#4-求线性表中第i个元素运算算法-1" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用<span class="hljs-selector-tag">p</span>从头开始遍历循环单链表L中的结点（初值指向第一个数据结点），用计数器j累计遍历过的结点，其初值为<span class="hljs-number">1</span>。<br>当<span class="hljs-selector-tag">p</span>不为L且j&lt;<span class="hljs-selector-tag">i</span>时循环，<span class="hljs-selector-tag">p</span>后移一个结点，j增<span class="hljs-number">1</span>。<br>当循环结束时，若<span class="hljs-selector-tag">p</span>指向头结点则表示查找失败返回<span class="hljs-number">0</span>，否则<span class="hljs-selector-tag">p</span>所指结点即为要找的结点，查找成功，算法返回<span class="hljs-number">1</span>。 <br><br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> GetElem(SLinkNode *L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)<br>&#123;  <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>   SLinkNode *p=L-&gt;next;   <span class="hljs-comment">//p指向首结点，计数器j置为1</span><br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<span class="hljs-comment">//找第i个结点p</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;e=p-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//找到后返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法-1"><a href="#5-按值查找运算算法-1" class="headerlink" title="5.按值查找运算算法"></a>5.<strong>按值查找运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">用<span class="hljs-selector-tag">i</span>累计查找数据结点的个数，从第一个数据结点开始，由前往后依次比较单链表中各结点数据域的值。<br>若某结点数据域的值等于给定值<span class="hljs-attribute">x</span>，则返回<span class="hljs-selector-tag">i</span>；否则继续向后比较。<br>若整个单链表中没有这样的结点，则返回<span class="hljs-number">0</span>。 <br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> Locate(SLinkNode *L,ElemType x)<br>&#123;  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>   SLinkNode *p=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; p-&gt;data!=x)<br>                 <span class="hljs-comment">//从第1个数据结点开始查找data域为x的结点</span><br>   &#123;p=p-&gt;next;<br>i++;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//未找到值为x的结点返回0</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;   <span class="hljs-comment">//找到第一个值为x的结点返回其序号</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-插入元素运算算法-1"><a href="#6-插入元素运算算法-1" class="headerlink" title="6.插入元素运算算法"></a>6.<strong>插入元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">在循环单链表L中查找第<span class="hljs-selector-tag">i</span>个结点<span class="hljs-selector-tag">p</span>及其前驱结点pre。<br>若没有这样的结点<span class="hljs-selector-tag">p</span>返回<span class="hljs-number">0</span>。<br>否则创建一个以<span class="hljs-attribute">x</span>为值的新结点s，将结点s插入在pre结点之后，返回<span class="hljs-number">1</span>。<br><br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xl">int InsElem(SLinkNode *&amp;L,ElemType x,int i)<span class="hljs-comment">//插入结点算法</span><br>&#123;  int j=<span class="hljs-number">1</span>;<br>   SL<span class="hljs-function"><span class="hljs-title">inkNode</span> *pre=L,*p=pre-&gt;</span>next,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<span class="hljs-comment">//查找第i个结点p和其前驱结点pre</span><br>   &#123;j++;<br><span class="hljs-function"><span class="hljs-title">pre</span>=p; p=p-&gt;</span>next;<span class="hljs-comment">//pre、p同步后移一个结点</span><br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L &amp;&amp; i&gt;j+<span class="hljs-number">1</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i&gt;n+1时错误返回0</span><br>   <span class="hljs-keyword">else</span><span class="hljs-comment">//成功查找到第i个结点的前驱结点pre</span><br>   &#123;s=(SLinkNode *)malloc(sizeof(SLinkNode));<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-keyword">data</span>=x;<span class="hljs-comment">//创建新结点用于存放元素x</span><br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=pre-&gt;</span>next;<span class="hljs-comment">//将s结点插入到pre结点之后</span><br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span>next=s;<br>return <span class="hljs-number">1</span>;<span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">在循环链表中，用p指针扫描所有结点时，方式有两种：<br>以p!=L作为循环条件，当p==L时循环结束，此时p回过来指向头结点，所以p应该初始化指向第一个数据结点而不是头结点，否则循环内的语句不会执行。<br>扫描指针p的初始化为p=L，循环的条件应该为p-&gt;next!=L，当p-&gt;next==L时循环结束，此时p指向尾结点<br></code></pre></td></tr></table></figure><h6 id="7-删除元素运算算法"><a href="#7-删除元素运算算法" class="headerlink" title="7.删除元素运算算法"></a>7.<strong>删除元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">在循环单链表L中查找第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，若不存在这样的结点返回<span class="hljs-number">0</span>。<br>否则让<span class="hljs-selector-tag">p</span>指第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，<span class="hljs-selector-tag">q</span>指向后继结点，当<span class="hljs-selector-tag">q</span>为NULL时返回<span class="hljs-number">0</span>，否则将<span class="hljs-selector-tag">q</span>所指结点删除并释放其空间，返回<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> DelElem(SLinkNode *&amp;L,<span class="hljs-built_in">int</span> i)<br>&#123;  <span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;<br>   SLinkNode *p=L,*q;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p-&gt;<span class="hljs-keyword">next</span>!=L &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)<span class="hljs-comment">//查找第i-1个结点p</span><br>   &#123;j++;<br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p-&gt;<span class="hljs-keyword">next</span>==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到这样的结点返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;q=p-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//q指向被删结点</span><br><span class="hljs-keyword">if</span> (q==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//没有第i个结点时返回0</span><br><span class="hljs-keyword">else</span><br>&#123;   p-&gt;<span class="hljs-keyword">next</span>=q-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//从单链表中删除q结点</span><br>　　free(q);<span class="hljs-comment">//释放其空间</span><br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//成功删除返回1</span><br>&#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="8-输出线性表运算算法-1"><a href="#8-输出线性表运算算法-1" class="headerlink" title="8.输出线性表运算算法"></a>8.<strong>输出线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">从第一个数据结点开始，沿next域逐个往下遍历，输出每个遍历到结点的<span class="hljs-class"><span class="hljs-keyword">data</span>域，直到头结点为止。</span><br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DispList(SLinkNode *L)<br>&#123;  SL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%d &quot;,p-&gt;</span><span class="hljs-keyword">data</span>);<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-3-5-循环单链表算法"><a href="#2-3-5-循环单链表算法" class="headerlink" title="2.3.5 循环单链表算法"></a>2.3.5 循环单链表算法</h4><h6 id="2-19"><a href="#2-19" class="headerlink" title="2.19"></a>2.19</h6><h6 id="2-20"><a href="#2-20" class="headerlink" title="2.20"></a>2.20</h6><h6 id="2-21"><a href="#2-21" class="headerlink" title="2.21"></a>2.21</h6>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-顺序表01</title>
    <link href="/2024/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%A1%BA%E5%BA%8F%E8%A1%A80)/"/>
    <url>/2024/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%A1%BA%E5%BA%8F%E8%A1%A80)/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p><strong>2.1</strong> <strong>线性表的基本概念</strong></p><p><strong>2.2</strong> <strong>顺序表</strong></p><p><strong>2.3</strong> <strong>单链表和循环单链表</strong></p><p><strong>2.4</strong> <strong>双链表****和循环双链表</strong></p><p><strong>2.5</strong> <strong>线性表的应用</strong></p><h4 id="2-1-线性表基本概念"><a href="#2-1-线性表基本概念" class="headerlink" title="2.1 线性表基本概念"></a>2.1 线性表基本概念</h4><h6 id="1-认识线性表"><a href="#1-认识线性表" class="headerlink" title="1.认识线性表"></a>1.认识线性表</h6><p>线性表（Linear List）是计算机科学中的一种数据结构，用于存储有限数量的元素，并且这些元素具有线性关系，即每个元素除了第一个和最后一个之外，都有一个前驱和一个后继。线性表的元素之间具有明确的顺序关系，可以通过其位置进行访问和操作。</p><p><strong>有序性</strong>：线性表中的元素按照一定的顺序排列，每个元素都有确定的位置。</p><p><strong>唯一性</strong>：线性表中每个元素都有唯一的<strong>前驱</strong>和<strong>后继</strong>（<strong>除了第一个元素没有前驱，最后一个元素没有后</strong>继）。</p><p><strong>长度有限</strong>：线性表中的元素个数是有限的，可以为空表（长度为零）。</p><p>双向链表规则</p><blockquote><p><strong>顺序存储结构</strong>：用一组地址连续的存储单元依次存储线性表中的元素，例如数组。顺序存储结构的优点是支持随机访问（通过下标访问），缺点是在插入和删除元素时需要大量的移动操作。</p><p><strong>链式存储结构</strong>：用一组任意的存储单元存储线性表的元素，并通过指针链接这些存储单元，例如链表。链式存储结构的优点是插入和删除操作较为高效，但访问速度较慢（需要从头遍历）。</p></blockquote><h6 id="2-线性表定义"><a href="#2-线性表定义" class="headerlink" title="2.线性表定义"></a>2.线性表定义</h6><p>1,线性表由n(n&gt;&#x3D;0)个相同类型的数据元素组成的有限序列</p><p>有序性</p><p>2.当n&#x3D;0时为空表 记为()  <strong>Φ</strong></p><p>3.线性表的表示</p><p>有序性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0c3803f4fdf75b4424564fdf688ece46.png" alt="0c3803f4fdf75b4424564fdf688ece46"></p><p>4.线性表特殊</p><p>n&gt;1 只有唯一的开始元素和终端元素</p><p><strong>唯一性</strong>：</p><p>5.标号序</p><p>线性表每个元素都有序号( 1 2 3 4 5)逻辑上 程序上从0开始-同时允许存储多个元素</p><h6 id="3-线性表实现和运算"><a href="#3-线性表实现和运算" class="headerlink" title="3.线性表实现和运算"></a>3.线性表实现和运算</h6><p>思路构造为:单链表</p><p>链表基础代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义链表节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;      <span class="hljs-comment">// 节点存储的数据</span><br>    ListNode next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br><br>    <span class="hljs-comment">// 构造函数</span><br>    ListNode(<span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-keyword">private</span> ListNode head;  <span class="hljs-comment">// 链表头指针</span><br><br>    <span class="hljs-comment">// 构造函数，初始化链表为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入节点的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 插入新节点的逻辑 头插 记录old指针 新头+4指向old指针 尾插 尾next指向新开辟的节点地址 中间插  前链表+4-&gt;指向插入地址-插入地址+4指向下一个地址</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除节点的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 删除节点的逻辑-前链表指针指向删除节点地址+4的地址-即可删除-本地还需delete -头删:直接删除-新头指针指向old指针+4的地址 尾删-链表-1遍历到第2个链接位置 +4位置=null;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查找节点的方法</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 查找节点的逻辑-&gt;遍历头指针+4的地址就是下个链表地址</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 遍历并打印链表的逻辑-自写迭代器</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>线性表基本运算方法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/da15cc5e809c8c28b188b72abb581438.png" alt="da15cc5e809c8c28b188b72abb581438"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fbe2b89d6443062cd08447d07620a599.png" alt="fbe2b89d6443062cd08447d07620a599"></p><blockquote><h3 id="初始化-InitList-L"><a href="#初始化-InitList-L" class="headerlink" title="初始化 InitList(L)"></a><strong>初始化 <code>InitList(L)</code></strong></h3><ul><li><strong>逻辑</strong>：创建一个空的线性表 <code>L</code>，将其长度设为 <code>0</code>，或者创建一个数据结构（例如数组或链表）来表示空表。</li></ul><h3 id="销毁线性表-DestroyList-L"><a href="#销毁线性表-DestroyList-L" class="headerlink" title="销毁线性表 DestroyList(L)"></a><strong>销毁线性表 <code>DestroyList(L)</code></strong></h3><ul><li><strong>逻辑</strong>：释放线性表 <code>L</code> 所占的内存空间，将表设置为空，防止内存泄漏。</li><li>迭代器销毁吗?一个个mc</li></ul><h3 id="求线性表的长度-GetLength-L"><a href="#求线性表的长度-GetLength-L" class="headerlink" title="求线性表的长度 GetLength(L)**"></a>求线性表的长度 <code>GetLength(L)</code>**</h3><ul><li><strong>逻辑</strong>：返回线性表 <code>L</code> 的当前长度（即线性表中元素的数量）。</li><li>还是迭代-只有next有指向就++-直到没指向</li></ul><h3 id="求线性表中第-i-个元素-GetElem-L-i-e"><a href="#求线性表中第-i-个元素-GetElem-L-i-e" class="headerlink" title="求线性表中第 i 个元素 GetElem(L, i, e)**"></a>求线性表中第 <code>i</code> 个元素 <code>GetElem(L, i, e)</code>**</h3><ul><li><strong>逻辑</strong>：检查位置 <code>i</code> 是否有效（在范围内），如果有效，返回位置 <code>i</code> 处的元素 <code>e</code>；否则，返回一个错误或特殊值。</li><li>从头next尾 -找到i就返回</li></ul><h3 id="按值查找-Locate-L-x"><a href="#按值查找-Locate-L-x" class="headerlink" title="按值查找 Locate(L, x)"></a><strong>按值查找 <code>Locate(L, x)</code></strong></h3><ul><li><strong>逻辑</strong>：从线性表 <code>L</code> 的头开始，依次遍历每个元素，判断其值是否等于 <code>x</code>。如果找到，返回元素的位置索引；如果没有找到，返回一个表示未找到的特殊值（例如 <code>-1</code>）。</li><li>从头next尾</li></ul><h3 id="插入元素-InsElem-L-x-i"><a href="#插入元素-InsElem-L-x-i" class="headerlink" title="插入元素 InsElem(L, x, i)**"></a>插入元素 <code>InsElem(L, x, i)</code>**</h3><ul><li><strong>逻辑</strong>：首先检查插入位置 <code>i</code> 是否有效（例如是否在当前表的长度范围内）。然后从最后一个元素开始向后移动元素，腾出位置 <code>i</code>，最后在位置 <code>i</code> 插入新元素 <code>x</code>，并将线性表的长度加 1。</li><li>头插 尾插 中间插(上面代码思路-未考虑长度)</li></ul><h3 id="删除元素-DelElem-L-i"><a href="#删除元素-DelElem-L-i" class="headerlink" title="删除元素 DelElem(L, i)"></a><strong>删除元素 <code>DelElem(L, i)</code></strong></h3><ul><li><strong>逻辑</strong>：检查要删除的位置 <code>i</code> 是否有效。如果有效，从位置 <code>i+1</code> 开始的每个元素向前移动一位，覆盖位置 <code>i</code> 的元素。最后，减少线性表的长度。</li><li>next遍历索引</li></ul><h3 id="输出元素值-DispList-L"><a href="#输出元素值-DispList-L" class="headerlink" title="输出元素值 DispList(L)"></a><strong>输出元素值 <code>DispList(L)</code></strong></h3><ul><li><p><strong>逻辑</strong>：从线性表 <code>L</code> 的头开始，依次遍历每个元素，将其值按顺序打印或存储</p></li><li><p>netx到尾部-迭代器写法</p></li></ul></blockquote><p>List-&gt;线性表</p><blockquote><p>利用线性表List的基本运算，设计一个由线性表A和B中的公共元素产生线性表C的算法</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a44dd445a0470ae167ed779690fcbd4c.png" alt="a44dd445a0470ae167ed779690fcbd4c"></p><h4 id="2-2-顺序表"><a href="#2-2-顺序表" class="headerlink" title="2.2 顺序表"></a>2.2 顺序表</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb24d731f11ddcce85e4836fbc183460.png" alt="bb24d731f11ddcce85e4836fbc183460"></p><p>ps:纳闷了一下-以为ai归纳错了-把顺序结构也包含在线性表中了</p><h6 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h6><p><strong>顺序表</strong>是在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98">计算机内存</a>中以<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组</a>的形式保存的<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a>，是指用一组<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80">地址</a>连续的<a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83">存储单元</a>依次存储数据元素的线性结构，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<span class="hljs-comment">//假设顺序表中所有元素为int类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;  ElemType data[MaxSize];<span class="hljs-comment">//存放顺序表的元素-初始大小</span><br>   <span class="hljs-type">int</span> length;<span class="hljs-comment">//顺序表的实际长度</span><br>&#125; SqList;<span class="hljs-comment">//顺序表类型</span><br><br></code></pre></td></tr></table></figure><p>定义了数组长度为100的 int类型的数据</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">SqList list;   <span class="hljs-comment">// 定义一个顺序表</span><br>list.<span class="hljs-built_in">length</span> = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 初始化长度为 0</span><br>list.data[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 插入第一个元素</span><br>list.<span class="hljs-built_in">length</span>++;  <span class="hljs-comment">// 长度增加</span><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/724b39523239a1da419d0f99ca38b84d.png" alt="724b39523239a1da419d0f99ca38b84d"></p><p>**<code>ArrayList</code>**：适合大部分顺序表场景，动态数组实现，随机访问高效。</p><p>**<code>Vector</code>**：线程安全的动态数组，适合多线程环境，但性能略差。</p><p>**<code>LinkedList</code>**：双向链表，适合频繁插入和删除操作，但随机访问效率较低。</p><p>**<code>CopyOnWriteArrayList</code>**：线程安全，适合读多写少的场景。</p><p>**<code>Arrays.asList()</code>**：固定大小的顺序表，不能动态调整大小。</p><h4 id="顺序表的基本运算"><a href="#顺序表的基本运算" class="headerlink" title="顺序表的基本运算"></a>顺序表的基本运算</h4><h6 id="1-初始化线性表运算算法"><a href="#1-初始化线性表运算算法" class="headerlink" title="1.初始化线性表运算算法"></a>1.初始化线性表运算算法</h6><p>设置初始长度-存储个数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> InitList(SqList &amp;L) <span class="hljs-comment">//引用修改</span><br><span class="hljs-comment">//由于L要回传给实参，所以用引用类型</span><br>&#123;<br>　　L.<span class="hljs-built_in">length</span>=<span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法"><a href="#2-销毁线性表运算算法" class="headerlink" title="2.销毁线性表运算算法"></a>2.销毁线性表运算算法</h6><p>　L若在栈则return销毁 –也就是变量的生命周期</p><h6 id="3-线性表长度运算算法"><a href="#3-线性表长度运算算法" class="headerlink" title="3.线性表长度运算算法"></a>3.线性表长度运算算法</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span><br><span class="hljs-function"></span>&#123;<br>　　<span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法"><a href="#4-求线性表中第i个元素运算算法" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">在逻辑序号i无效时返回特殊值<span class="hljs-number">0</span>（假），有效时返回<span class="hljs-number">1</span>（真），并用引用型形参e返回第i个元素的值。<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L.length)<span class="hljs-comment">//无效的i值返回0 判断长度和下标合法性</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">else</span><br>   &#123;  e=L.data[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//取元素值并返回1</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ElemType &amp;e-取引用类型0类型是T泛型-这里没指定而且</p><h6 id="5-按值查找运算算法"><a href="#5-按值查找运算算法" class="headerlink" title="5.按值查找运算算法"></a>5.按值查找运算算法</h6><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl">在顺序表L找第一个值为x的元素，找到后返回其逻辑序号，否则返回<span class="hljs-number">0</span>（由于线性表的逻辑序号从<span class="hljs-number">1</span>开始，这里用<span class="hljs-number">0</span>表示没有找到值为x的元素）。<br><span class="hljs-type">int</span> Locate(SqList L,ElemType x)<br>&#123;  <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span> (i&lt;L.<span class="hljs-built_in">length</span> &amp;&amp; L.data[i]!=x)<br>     i++; <span class="hljs-comment">//查找值为x的第1个元素,查找范围为0～L.length-1</span><br>   <span class="hljs-keyword">if</span> (i&gt;=L.<span class="hljs-built_in">length</span>) <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>(i+<span class="hljs-number">1</span>);   <span class="hljs-comment">//找到后返回其逻辑序号</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>逻辑序号就是下标+1</p><h6 id="6-插入元素运算法"><a href="#6-插入元素运算法" class="headerlink" title="6.插入元素运算法"></a>6.插入元素运算法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">将新元素<span class="hljs-attribute">x</span>插入到顺序表L中逻辑序号为<span class="hljs-selector-tag">i</span>的位置（如果插入成功，元素<span class="hljs-attribute">x</span>成为线性表的第<span class="hljs-selector-tag">i</span>个元素）。<br>当<span class="hljs-selector-tag">i</span>无效时返回<span class="hljs-number">0</span>（表示插入失败）。<br>有效时将L<span class="hljs-selector-class">.data</span><span class="hljs-selector-attr">[i-1..L.length-1]</span>后移一个位置，在L<span class="hljs-selector-class">.data</span><span class="hljs-selector-attr">[i-1]</span>处插入<span class="hljs-attribute">x</span>，顺序表长度增<span class="hljs-number">1</span>，并返回<span class="hljs-number">1</span>（表示插入成功。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7759631b5998f2d56609e561e79b99d8.png" alt="7759631b5998f2d56609e561e79b99d8"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsElem</span><span class="hljs-params">(SqList &amp;L,ElemType x,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j;<br>   <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;L.length<span class="hljs-number">+1</span>)<span class="hljs-comment">//无效的参数i</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (j=L.length;j&gt;i;j--)<span class="hljs-comment">//将位置为i的结点及之后的结点后移</span><br>   &#123;<br>       L.data[j]=L.data[j<span class="hljs-number">-1</span>];<br>    &#125;<br> <br> <br> L.data[i<span class="hljs-number">-1</span>]=x;<span class="hljs-comment">//在位置i处放入x</span><br>   L.length++;<span class="hljs-comment">//线性表长度增1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>j-i 是逻辑位置-下标+1所想</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">当<span class="hljs-attribute">i</span>=n+1时（插入尾元素），移动次数为0，呈现最好的情况。<br>当<span class="hljs-attribute">i</span>=1时（插入第一个元素），移动次数为n，呈现最坏的情况。<br><br></code></pre></td></tr></table></figure><p>n是最大下标</p><p>平均情况分析</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/32db9894cf39150fb84a0ee2cefe595d.png" alt="32db9894cf39150fb84a0ee2cefe595d"></p><p>回头看看这个公式的计算方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">插入算法的主要时间花费在元素移动上，所以算法<span class="hljs-built_in">InsElem</span>()的平均时间复杂度为<span class="hljs-built_in">O</span>(n)。<br></code></pre></td></tr></table></figure><h6 id="7-删除元素运算算法"><a href="#7-删除元素运算算法" class="headerlink" title="7.删除元素运算算法"></a>7.<strong>删除元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">删除顺序表L中逻辑序号为<span class="hljs-selector-tag">i</span>的元素。<br>在<span class="hljs-selector-tag">i</span>无效时返回<span class="hljs-number">0</span>（表示删除失败）。<br>有效时将L<span class="hljs-selector-class">.data</span><span class="hljs-selector-attr">[i..length-1]</span>前移一个位置，顺序表长度减<span class="hljs-number">1</span>，并返回<span class="hljs-number">1</span>（表示删除成功。<br><br><br></code></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span> DelElem(SqList &amp;L,<span class="hljs-type">int</span> i)<br>&#123; <span class="hljs-type">int</span> j;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.<span class="hljs-built_in">length</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">for</span>(j=i,j&lt;L.<span class="hljs-built_in">length</span>;j++) <span class="hljs-comment">//将位置为i的结点之后的结点前移</span><br><br>&#123;<br>L.data[j<span class="hljs-number">-1</span>]=L.data[j];<br>&#125;<br>L.<span class="hljs-built_in">length</span>--;<span class="hljs-comment">//线性表长度减1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">当<span class="hljs-attribute">i</span>=n时（删除尾元素），移动次数为0，呈现最好的情况。<br>当<span class="hljs-attribute">i</span>=1时（删除第一个元素），移动次数为n-1，呈现最坏的情况。<br><br>删除算法的主要时间花费在元素移动上，所以算法DelElem()的平均时间复杂度为O(n)。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c419faf1b6160678f0145ea2ec2804cc.png" alt="c419faf1b6160678f0145ea2ec2804cc"></p><h6 id="8-输出元素值运算算法"><a href="#8-输出元素值运算算法" class="headerlink" title="8.输出元素值运算算法"></a>8.输出元素值运算算法</h6><p>迭代器写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispList</span><span class="hljs-params">(SqList L)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> i;<br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;L.length;i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,L.data[i]);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="9-顺序表测试"><a href="#9-顺序表测试" class="headerlink" title="9.顺序表测试"></a>9.顺序表测试</h6><blockquote><p>将顺序表类型声明及其基本运算函数存放在*SqList.cpp文件中</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &quot;SqList.cpp&quot;     //包括前面的顺序表基本运算函数</span><br>void main()<br>&#123;  <span class="hljs-keyword">int</span> i; ElemType e;<br>   SqList L;<span class="hljs-regexp">//</span>定义一个顺序表L<br>   InitList(L);<span class="hljs-regexp">//</span>初始化顺序表L<br>   InsElem(L,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">1</span><br>   InsElem(L,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">3</span><br>   InsElem(L,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">1</span><br>   InsElem(L,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">5</span><br>   InsElem(L,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">4</span><br>   InsElem(L,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);<span class="hljs-regexp">//</span>插入元素<span class="hljs-number">2</span><br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;线性表:&quot;</span>);DispList(L);<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;长度:<span class="hljs-variable">%d</span>\n&quot;</span>,GetLength(L));<br>   i=<span class="hljs-number">3</span>; GetElem(L,i,e);<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;第<span class="hljs-variable">%d</span>个元素:<span class="hljs-variable">%d</span>\n&quot;</span>,i,e);<br>   e=<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;元素<span class="hljs-variable">%d</span>是第<span class="hljs-variable">%d</span>个元素\n&quot;</span>,e,Locate(L,e));<br>   i=<span class="hljs-number">4</span>; <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;删除第<span class="hljs-variable">%d</span>个元素\n&quot;</span>,i);<br>   DelElem(L,i);<br>   <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;线性表:&quot;</span>);DispList(L);<br>   DestroyList(L);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<span class="hljs-comment">//假设顺序表中所有元素为int类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;  ElemType data[MaxSize];<span class="hljs-comment">//存放顺序表的元素-初始大小</span><br>   <span class="hljs-type">int</span> length;<span class="hljs-comment">//顺序表的实际长度</span><br>&#125; SqList;<span class="hljs-comment">//顺序表类型</span><br><br></code></pre></td></tr></table></figure><h6 id="10-数组值创建顺序表"><a href="#10-数组值创建顺序表" class="headerlink" title="10.数组值创建顺序表"></a>10.数组值创建顺序表</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">假设给定一个含有n个元素的数组a，由它来创建顺序表。<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList</span><span class="hljs-params">(SqList &amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> i,k=<span class="hljs-number">0</span>;<span class="hljs-comment">//k累计顺序表L中的元素个数</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;  L.data[k]=a[i];<span class="hljs-comment">//向L中添加一个元素</span><br>      k++;<span class="hljs-comment">//L中元素个数增1</span><br>   &#125;<br>   L.length=k;<span class="hljs-comment">//设置L的长度</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-2-3-顺序表的算法设计示例"><a href="#2-2-3-顺序表的算法设计示例" class="headerlink" title="2.2.3 顺序表的算法设计示例"></a><strong>2.2.3</strong> <strong>顺序表的算法设计示例</strong></h3><p>ps:上数据结构课的时候观看案例</p><h5 id="1-基于顺序表基本操作的算法设计"><a href="#1-基于顺序表基本操作的算法设计" class="headerlink" title="1.基于顺序表基本操作的算法设计"></a>1.基于顺序表基本操作的算法设计</h5><p><strong>这类算法设计中包括顺序表元素的查找、插入和删除等</strong></p><h6 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h6><h6 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h6><h6 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h6><h5 id="2-基于整体建表的算法设计"><a href="#2-基于整体建表的算法设计" class="headerlink" title="2.基于整体建表的算法设计"></a>2.基于整体建表的算法设计</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">这类算法设计中需要根据条件产生新的结果顺序表。<br><br></code></pre></td></tr></table></figure><h6 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h6><h6 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h6><h5 id="3-有序顺序表的二路归并算法"><a href="#3-有序顺序表的二路归并算法" class="headerlink" title="3.有序顺序表的二路归并算法"></a>3.有序顺序表的二路归并算法</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">有序表是指按元素值递增或者递减排列的线性表。<br>有序顺序表是有序表的顺序存储结构。也可以采用链式存储结构。<br>对于有序表可以利用其元素的有序性提高相关算法的效率。<br>二路归并就是有序表的一种经典算法。<br><br></code></pre></td></tr></table></figure><h6 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h6><h6 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h6><h6 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h6>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring boot探究</title>
    <link href="/2024/09/15/Springboot%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/15/Springboot%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot复习"><a href="#Springboot复习" class="headerlink" title="Springboot复习"></a>Springboot复习</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Mybatis-plus.png" alt="Mybatis-plus"></p><h4 id="0-Spring不同"><a href="#0-Spring不同" class="headerlink" title="0.Spring不同"></a>0.Spring不同</h4><p><strong>Spring Framework</strong> 是一个全面的编程和配置模型，为基于 Java 的企业应用提供了一个全方位的基础设施支持。Spring 处理了 Java 应用的基础建设，如事务管理、依赖注入、面向切面编程等。</p><p><strong>Spring MVC</strong> 是 Spring 的一个模块，用于构建 Web 应用程序。Spring MVC 遵循 MVC（模型-视图-控制器）-vue 设计模式，并提供了一套丰富的功能来建立可扩展的动态 Web 应用。使用 Spring MVC，开发者需要配置大量的组件，如视图解析器、消息转换器、数据绑定器等，这些都需要在 Spring 的配置文件中明确设置。</p><blockquote><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><ul><li><p><strong>自动配置</strong>：自动配置 Spring 应用程序的大部分常用设置，尽可能减少开发者的配置代码。</p><p><strong>启动器依赖</strong>：提供了一系列的“启动器”依赖项来简化 Maven 配置。</p><p><strong>内嵌服务器</strong>：如 Tomcat、Jetty 或 Undertow，默认不需要部署 WAR 文件。</p><p><strong>运行独立应用</strong>：支持打包为 jar，并通过 <code>java -jar</code> 运行应用程序。</p><p><strong>操作和管理功能</strong>：提供生产级别的特性如健康检查、度量信息统计及外部配置。</p></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3></blockquote><blockquote><p><strong>配置</strong>：Spring MVC 需要详细的配置，包括 URL 到控制器方法的映射、视图解析等，而 Spring Boot 则提供自动配置，极大简化了这一过程。</p><p><strong>启动</strong>：Spring MVC 需要部署到一个外部的 Web 应用服务器，如 Tomcat 或 Jetty，而 Spring Boot 提供了内嵌的服务器，简化了部署和分发过程。</p><p><strong>项目依赖</strong>：Spring Boot 采用了起步依赖的概念，可以通过这些预先设定的依赖来简化构建配置。</p></blockquote><h4 id="1-Springboot启动类分析"><a href="#1-Springboot启动类分析" class="headerlink" title="1.Springboot启动类分析"></a>1.Springboot启动类分析</h4><p>springboot-简化了开发-比如-我们之前导入依赖–到需要自己写配置类-返回Bean</p><p>springboot 帮我们简化了这个工程</p><p>SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想</p><p>spring 缺点 1.配置繁琐 2.依赖繁琐</p><p>springboot -1.自动配置 2.起步依赖 3.辅助功能</p><p>再起步依赖中导入了很多依赖 这使得我们不需要一个个找版本</p><p>&#x2F;&#x2F;引导类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ItemApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><h4 id="启动类探究"><a href="#启动类探究" class="headerlink" title="启动类探究"></a>启动类探究</h4><p><strong>启动类</strong>（通常是带有 <code>@SpringBootApplication</code> 注解的类）是整个应用的入口点，负责启动并配置 Spring 应用的运行环境。</p><h5 id="1-启动-Spring-应用上下文"><a href="#1-启动-Spring-应用上下文" class="headerlink" title="1. 启动 Spring 应用上下文"></a>1. <strong>启动 Spring 应用上下文</strong></h5><p>启动类通过调用 <code>SpringApplication.run()</code> 方法来启动 Spring 应用上下文（Application Context）。Spring 应用上下文是 Spring 管理的所有 Bean、配置和依赖注入的核心。具体步骤包括：</p><ul><li><p><strong>扫描组件</strong>：启动类会触发组件扫描（Component Scan），自动发现并注册使用诸如 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code> 等注解的 Bean。</p></li><li><p><strong>加载配置</strong>：读取项目中的配置文件（如 <code>application.properties</code> 或 <code>application.yml</code>），并应用相应的配置。</p></li><li><p><strong>初始化 Bean</strong>：启动 Spring IoC 容器，管理 Bean 的生命周期，包括创建、依赖注入、初始化和销毁。</p></li><li><h5 id="2-自动配置"><a href="#2-自动配置" class="headerlink" title="2. 自动配置"></a>2. <strong>自动配置</strong></h5><p>Spring Boot 的核心之一是自动配置（Auto Configuration），启动类会启动自动配置机制：@EnableAutoConfiguration</p><p>@SpringBootApplication 注解包含了 @EnableAutoConfiguration</p><p>它告诉 Spring Boot 根据类路径中的依赖项、配置文件中的属性等来自动配置应用程序。</p><ul><li>例如，如果类路径中有 <code>spring-boot-starter-web</code> 依赖，Spring Boot 会自动配置 Tomcat 作为嵌入式服务器，并配置 Spring MVC 的相关 Bean。</li></ul></li></ul></blockquote><blockquote><h6 id="3-启用嵌入式服务器"><a href="#3-启用嵌入式服务器" class="headerlink" title="3. 启用嵌入式服务器"></a>3. <strong>启用嵌入式服务器</strong></h6><p>在传统的 Spring MVC 应用中，应用需要打包成 WAR 文件并部署到外部的应用服务器（如 Tomcat、Jetty 等）。而在 Spring Boot 中，启动类会启动嵌入式服务器（如嵌入式的 Tomcat、Jetty 或 Undertow），这使得应用可以独立运行，不依赖外部的容器环境。</p><ul><li>启动类通过调用 <code>SpringApplication.run()</code> 方法自动启动嵌入式服务器，并运行 Web 应用，这就是为什么你可以直接用 <code>java -jar</code> 来运行一个 Spring Boot 应用。</li></ul><h6 id="4-管理外部配置"><a href="#4-管理外部配置" class="headerlink" title="4. 管理外部配置"></a>4. <strong>管理外部配置</strong></h6><p>Spring Boot 提供了一种灵活的方式来管理应用程序的配置，启动类会加载并管理这些外部配置：</p><ul><li>启动类会加载默认的 <code>application.properties</code> 或 <code>application.yml</code> 配置文件。</li><li>如果需要，可以通过命令行参数或环境变量来覆盖配置。</li></ul><h6 id="5-支持生产级别特性"><a href="#5-支持生产级别特性" class="headerlink" title="5. 支持生产级别特性"></a>5. <strong>支持生产级别特性</strong></h6><p>Spring Boot 的启动类还会为应用程序自动启用一些生产环境的特性，如：</p><ul><li><p><strong>健康检查（Actuator）</strong>：提供运行时的健康检查、度量指标等。</p></li><li><p><strong>外部化配置</strong>：通过环境变量或命令行参数来外部化配置。</p></li><li><p><strong>安全性</strong>：默认提供了基础的安全配置，可以进行扩展。</p><h6 id="6-简化应用启动过程"><a href="#6-简化应用启动过程" class="headerlink" title="6.简化应用启动过程"></a>6.<strong>简化应用启动过程</strong></h6><p>启动类通过 <code>@SpringBootApplication</code> 注解，大大简化了应用的启动配置。该注解实际上是以下三个注解的组合：</p><ul><li><p>@SpringBootApplication</p><p> 等价于：</p><ul><li><code>@Configuration</code>：表示该类可以用作 Spring 的 Java 配置类，代替传统的 XML 配置文件。</li><li><code>@EnableAutoConfiguration</code>：启用自动配置，基于类路径中的依赖项和配置来自动创建 Spring Beans。</li><li><code>@ComponentScan</code>：启用组件扫描，默认扫描该类所在的包及其子包，自动发现并注册 Spring 组件。</li></ul></li></ul></li></ul></blockquote><p><strong>启动 Spring 应用上下文</strong>，初始化所有的 Spring 组件和依赖注入。</p><p><strong>启用自动配置</strong>，根据项目的依赖自动配置应用所需的 Bean 和配置。</p><p><strong>启动嵌入式服务器</strong>，使得应用可以直接运行，不依赖外部服务器。</p><p><strong>管理外部配置</strong>，从配置文件、环境变量等地方加载应用的配置。</p><p><strong>简化开发</strong>，通过 <code>@SpringBootApplication</code> 注解减少手动配置。</p><h4 id="2-起步依赖分析"><a href="#2-起步依赖分析" class="headerlink" title="2.起步依赖分析"></a>2.起步依赖分析</h4><p>1.继承父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>⚫ 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。</p><p> 2.导入起步依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--web开发的起步依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。 ⚫ 我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在 版本冲突等问题。</p><p>-&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starters<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../spring-boot-parent<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>-&gt;追到底-最后继承的父pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>-这里面规范了大量的依赖版本</p><h4 id="3-配置文件读取"><a href="#3-配置文件读取" class="headerlink" title="3.配置文件读取"></a>3.配置文件读取</h4><h6 id="1-配置文件了解"><a href="#1-配置文件了解" class="headerlink" title="1.配置文件了解"></a>1.配置文件了解</h6><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用 application.properties或者application.yml（application.yaml）进行配置。</p><p>properties： server.port&#x3D;8080</p><p> yml: server: port: 8080</p><p> 在同一级目录下优先级为：properties &gt; yml &gt; yaml</p><h6 id="2-yaml"><a href="#2-yaml" class="headerlink" title="2.yaml"></a>2.yaml</h6><p>yaml-是一种数据序列化格式-知识的它具有丰富的跨平台性</p><p>对比</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/420f1f189299beef2d6b83fd89aea2e9.png" alt="420f1f189299beef2d6b83fd89aea2e9"></p><hr><p>语法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/12f41b7bed6805dd726a730295af95c3.png" alt="12f41b7bed6805dd726a730295af95c3"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e5554d0928c36cb20902c0cc1e30017b.png" alt="e5554d0928c36cb20902c0cc1e30017b"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a0698b803cd925e2e094f38a2f2be6e8.png" alt="a0698b803cd925e2e094f38a2f2be6e8"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/63d0fdcc32b52981fab07613eae525f1.png" alt="63d0fdcc32b52981fab07613eae525f1"></p><h4 id="3-读取配置文件内容"><a href="#3-读取配置文件内容" class="headerlink" title="3.读取配置文件内容"></a>3.读取配置文件内容</h4><h6 id="1-读取大类"><a href="#1-读取大类" class="headerlink" title="1.读取大类"></a>1.读取大类</h6><p>@Value </p><p><code>@Value</code> 注解用于将配置文件中的单个属性注入到 Spring Bean 中，适合用于简单的配置读取。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">app.name</span>=MyApp<br><span class="hljs-attr">app.version</span>=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;app.name&#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> appName;<br><br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;app.version&#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> appVersion;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> appName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppVersion</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> appVersion;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Environment </p><blockquote><p><code>Environment</code> 接口用于访问 Spring 环境中的属性和配置，提供了一种灵活的方式来读取配置文件中的属性，适用于动态读取或者需要条件处理的场景。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Environment</span> env;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> env.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&quot;app.name&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppVersion</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> env.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&quot;app.version&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**<code>env.getProperty()</code>**：通过 <code>Environment</code> 获取属性值，支持动态读取。</p><p>如果属性不存在，返回 <code>null</code>。 </p><blockquote><p>适合动态获取配置属性。</p><p>灵活性更高，尤其适合条件性的属性获取。</p><p>可用于编写较复杂的配置处理逻辑。</p></blockquote><p>@ConfigurationProperties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">app.name</span>=MyApp<br><span class="hljs-attr">app.version</span>=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><span class="hljs-attr">app.description</span>=This is my application<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;app&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> version;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> description;<br><br>    <span class="hljs-comment">// getters and setters</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setName</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getVersion</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> version;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setVersion</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> version</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">version</span> = version;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getDescription</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setDescription</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> description</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">description</span> = description;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>**<code>@ConfigurationProperties(prefix = &quot;app&quot;)</code>**：指定配置项的前缀，所有以 <code>app</code> 开头的属性都会映射到 <code>AppConfig</code> 类中。</li><li>自动将配置属性注入到对应的类属性中。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>适合批量处理和嵌套配置，配置项较多时使用更加方便。</li><li>需要配合 Spring Boot 的 <code>@EnableConfigurationProperties</code> 或自动配置来启用。</li></ul></blockquote><p>总结</p><p>**<code>@Value</code>**：适合注入单个或少量配置属性，语法简单直观。</p><p>**<code>Environment</code>**：适合动态读取属性或者在运行时根据条件获取属性。</p><p>**<code>@ConfigurationProperties</code>**：适合批量读取属性，将多个配置项封装为对象，便于管理复杂的配置结构。</p><blockquote><p>对于少量的简单配置，使用 <code>@Value</code> 更直接。</p><p>当需要动态获取配置时，使用 <code>Environment</code> 提供了灵活性。</p><p>如果需要处理大量配置或复杂结构的配置，<code>@ConfigurationProperties</code> 是最佳选择。</p></blockquote><h6 id="2-profile"><a href="#2-profile" class="headerlink" title="2.profile"></a>2.profile</h6><p>多配置文件切换-比如我们生产环境-每一套生产环境有对应的配置文件</p><p>配置方式</p><p>profile配置方式 ⚫</p><p> 多profile文件方式：提供多个配置文件，每个代表一种环境。 </p><p>• application-dev.properties&#x2F;yml 开发环境</p><p> • application-test.properties&#x2F;yml 测试环境 •</p><p> application-pro.properties&#x2F;yml 生产环境</p><hr><p>激活方式</p><p>⚫ 配置文件： 再配置文件中配置：spring.profiles.active&#x3D;dev</p><p> ⚫ 虚拟机参数：在jVM options 指定：-Dspring.profiles.active&#x3D;dev </p><p>⚫ 命令行参数：java –jar xxx.jar –spring.profiles.active&#x3D;dev</p><h6 id="3-内部加载顺序"><a href="#3-内部加载顺序" class="headerlink" title="3.内部加载顺序"></a>3.内部加载顺序</h6><p>Springboot程序启动时，会从以下位置加载配置文件： </p><ol><li>file:.&#x2F;config&#x2F;：当前项目下的&#x2F;config目录下 </li><li><ol start="2"><li>file:.&#x2F; ：当前项目的根目录</li><li><ol start="3"><li>classpath:&#x2F;config&#x2F;：classpath的&#x2F;config目录</li><li><ol start="4"><li>classpath:&#x2F; ：classpath的根目录 加载顺序为上文的排列顺序，高优先级配置的属性会生效</li></ol></li></ol></li></ol></li></ol><p>加载顺序为上文的排列顺序，高优先级配置的属性会生</p><h4 id="Spring-整合框架"><a href="#Spring-整合框架" class="headerlink" title="Spring-整合框架"></a>Spring-整合框架</h4><h6 id="1-Spring-整合junit"><a href="#1-Spring-整合junit" class="headerlink" title="1.Spring 整合junit"></a>1.Spring 整合junit</h6><p>1.导入依赖-springboot 工程</p><p>2.编写测试类</p><p>3.添加注解</p><blockquote><p>Spring JUnit 是 Spring 框架和 JUnit 测试框架的结合，常用于测试 Spring 应用中的组件、服务和数据访问层。JUnit 是一个流行的 Java 测试框架，帮助开发者编写和运行单元测试，而 Spring 提供了丰富的依赖注入、事务管理等功能。</p><p>当使用 Spring 和 JUnit 进行测试时，通常会结合 Spring 的测试支持类，例如 <code>@SpringBootTest</code>、<code>@ContextConfiguration</code> 等注解，它们帮助你在测试中加载 Spring 应用上下文，方便测试 Spring 组件的行为。</p><h5 id="常用注解和功能"><a href="#常用注解和功能" class="headerlink" title="常用注解和功能"></a>常用注解和功能</h5><ol><li><strong>@SpringBootTest</strong>: 用于启动整个 Spring 应用上下文，可以测试多个组件之间的交互。</li><li><strong>@ContextConfiguration</strong>: 指定 Spring 配置文件或类，用于加载应用上下文。</li><li><strong>@MockBean</strong>: 用于在测试中模拟 Spring Bean。</li><li><strong>@Before</strong>: 在每个测试方法执行之前运行，用于初始化测试环境。</li><li><strong>@Test</strong>: 用于标记测试方法。</li></ol><p>通过结合 JUnit 和 Spring，你可以轻松地测试 Spring 应用中的各个部分，包括控制器、服务、DAO 等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest(classes = SpringbootJunitApplication.class )</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-number">111</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-Spring-整合redis"><a href="#2-Spring-整合redis" class="headerlink" title="2.Spring 整合redis"></a>2.Spring 整合redis</h6><p>① 搭建SpringBoot工程</p><p> ② 引入redis起步依赖</p><p> ③ 配置redis相关属性 </p><p>④ 注入RedisTemplate模板 </p><p>⑤ 编写测试方法，测试</p><p>redis-键值存储</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span>()</span> &#123;<br>    <span class="hljs-comment">//存入数据</span><br>    redisTemplate.boundValueOps(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>&#125;<br><br>@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span>()</span> &#123;<br>    <span class="hljs-comment">//获取数据</span><br>    Object name = redisTemplate.boundValueOps(<span class="hljs-string">&quot;name&quot;</span>).<span class="hljs-keyword">get</span>();<br>    System.<span class="hljs-keyword">out</span>.println(name);<br>&#125;<br>---<br>redisTemplate<br><br>----<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BoundValueOperations&lt;K, V&gt; <span class="hljs-title">boundValueOps</span>(<span class="hljs-params">K key</span>)</span> &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span>(<span class="hljs-params">V var1</span>)</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultBoundValueOperations(key, <span class="hljs-keyword">this</span>);<br>    &#125;<br>---<br><br></code></pre></td></tr></table></figure><h6 id="3-spring-整合myBatis"><a href="#3-spring-整合myBatis" class="headerlink" title="3.spring 整合myBatis"></a>3.spring 整合myBatis</h6><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Mapper</span><br><span class="hljs-variable">@Repository</span><br>public interface UserMapper &#123;<br><br>    <span class="hljs-variable">@Select</span>(<span class="hljs-string">&quot;select * from t_user&quot;</span>)<br>    public List&lt;User&gt; <span class="hljs-built_in">findAll</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>放入依赖mapper-哦、配置文件放入配置</p><p> 搭建SpringBoot工程 </p><p>② 引入mybatis起步依赖，添加mysql驱动 </p><p>③ 编写DataSource和MyBatis相关配置 </p><p>④ 定义表和实体类</p><p> ⑤ 编写dao和mapper文件&#x2F;纯注解开发</p><p> ⑥ 测试</p><h1 id="Spring-boot高级"><a href="#Spring-boot高级" class="headerlink" title="Spring boot高级"></a>Spring boot高级</h1><h5 id="1-Spring-启动流程"><a href="#1-Spring-启动流程" class="headerlink" title="1.Spring 启动流程"></a>1.Spring 启动流程</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="SpringBoot启动流程"></p><p>四个步骤</p><blockquote><p><strong>启动 Spring 应用上下文</strong>，初始化所有的 Spring 组件和依赖注入。</p><p><strong>启用自动配置</strong>，根据项目的依赖自动配置应用所需的 Bean 和配置。</p><p><strong>启动嵌入式服务器</strong>，使得应用可以直接运行，不依赖外部服务器。</p><p><strong>管理外部配置</strong>，从配置文件、环境变量等地方加载应用的配置。</p><p><strong>简化开发</strong>，通过 <code>@SpringBootApplication</code> 注解减少手动配置。</p></blockquote><h5 id="2-Spring自动配置"><a href="#2-Spring自动配置" class="headerlink" title="2.Spring自动配置"></a>2.Spring自动配置</h5><h6 id="1-Condition"><a href="#1-Condition" class="headerlink" title="1.Condition"></a>1.Condition</h6><p>案例</p><blockquote><h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3></blockquote><p>Condition 是在Spring 4.0 增加的条件判断功能，通过这个可以功能可以实现选择性的创建 Bean 操作。</p><blockquote><p>Spring Boot 的自动配置依赖于 <code>@EnableAutoConfiguration</code> 注解，它会自动加载并配置合适的 Bean。Spring Boot 内部通过 <code>spring.factories</code> 文件定义了一系列的自动配置类，当应用启动时，这些配置类会被加载。</p></blockquote><p>SpringBoot是如何知道要创建哪个Bean的？比如SpringBoot是如 何知道要创建RedisTemplate的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># spring-boot-<span class="hljs-built_in">auto</span>configure jar 内的 spring.factories 文件<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.EnableAutoConfiguration=\<br>org.springframework.boot.<span class="hljs-built_in">auto</span>configure.data.redis.RedisAutoConfiguration,\<br>...<br><br></code></pre></td></tr></table></figure><p>–</p><p>条件配置的实现：<code>@Conditional</code></p><p>Spring Boot 使用了 <code>@Conditional</code> 注解来实现基于条件的自动配置。<code>RedisAutoConfiguration</code> 是 Spring Boot 为 Redis 提供的自动配置类，它的配置是有条件的。条件配置通过 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等注解实现。</p><p><strong>案例实现</strong></p><p>关键条件注解：</p><ul><li><strong>@ConditionalOnClass</strong>：当指定的类在类路径中存在时，才会执行配置。对于 Redis 来说，只有在 Redis 相关的类（如 <code>RedisTemplate</code>、<code>JedisConnectionFactory</code> 等）存在时，Spring Boot 才会去配置它们。</li><li><strong>@ConditionalOnMissingBean</strong>：如果 Spring 上下文中没有指定的 Bean，才会创建新的 Bean。</li><li><strong>@ConditionalOnProperty</strong>：根据配置属性（通常在 <code>application.properties</code> 或 <code>application.yml</code> 中）是否存在或其值来决定是否创建 Bean。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(RedisTemplate.class)</span> <span class="hljs-comment">// 只有在类路径中有 RedisTemplate 类时才进行配置</span><br><span class="hljs-meta">@ConditionalOnBean(RedisConnectionFactory.class)</span> <span class="hljs-comment">// RedisConnectionFactory Bean 存在时才进行配置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisAutoConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="hljs-comment">// 如果容器中没有名为 redisTemplate 的 Bean，才创建</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他配置</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>加载自动配置类</strong>：<code>@EnableAutoConfiguration</code> 会在 Spring Boot 启动时加载 <code>RedisAutoConfiguration</code> 类（通过 <code>spring.factories</code> 注册）。</p><p><strong>检查条件</strong>：</p><ul><li><code>@ConditionalOnClass(RedisTemplate.class)</code>：检查类路径中是否有 <code>RedisTemplate</code> 类。如果 Redis 依赖存在，类路径中会包含此类，条件成立。</li><li><code>@ConditionalOnBean(RedisConnectionFactory.class)</code>：检查 Spring 容器中是否已经有 <code>RedisConnectionFactory</code>。如果条件满足（通常会通过自动配置或手动配置创建 <code>RedisConnectionFactory</code>），继续执行。</li></ul><p><strong>创建 RedisTemplate</strong>：如果条件成立，且没有手动定义 <code>RedisTemplate</code> Bean，那么自动配置将为你创建一个默认的 <code>RedisTemplate</code>。</p></blockquote><h6 id="2-Enable-注解"><a href="#2-Enable-注解" class="headerlink" title="2.@Enable*注解"></a>2.@Enable*注解</h6><p><code>@Enable</code> 开头的注解在 Spring Boot 中非常常见，主要用于启用某些功能或模块。它们的核心原理是使用 <code>@Import</code> 注解来导入配置类或其他需要的 Bean，从而实现功能的动态开启。</p><blockquote><h5 id="Enable-注解的核心原理"><a href="#Enable-注解的核心原理" class="headerlink" title="@Enable* 注解的核心原理"></a><code>@Enable*</code> 注解的核心原理</h5><ol><li><strong><code>@Import</code> 注解</strong>：<code>@Enable</code> 开头的注解通常内部会使用 <code>@Import</code>，其作用是将指定的配置类或相关的组件导入到 Spring 容器中，参与 Bean 的定义和管理。</li><li><strong>配置类或自动配置</strong>：这些 <code>@Enable</code> 注解导入的通常是特定功能模块的配置类，可能包含多个 Bean 的定义，用来开启该模块的相关功能。例如 <code>@EnableScheduling</code> 用于启用 Spring 的定时任务功能，其底层导入了与任务调度相关的配置类。</li><li><strong>实现动态 Bean 加载</strong>：通过 <code>@Enable</code> 注解启用的功能是动态的，不需要手动在配置文件中去定义。注解本身相当于一个开关，当添加到某个类上时，会加载对应的配置，注册相关的 Bean。</li></ol></blockquote><p><em><strong>常见注解</strong></em></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EnableAutoConfiguration</span>：启用 Spring Boot 的自动配置机制，根据类路径中的依赖和自定义的配置自动配置 Spring 应用。<br><span class="hljs-comment">//启动类就有该注解 </span><br><br><span class="hljs-variable">@EnableScheduling</span>：启用定时任务支持。<br><span class="hljs-variable">@EnableAsync</span>：启用异步方法调用。<br><span class="hljs-variable">@EnableCaching</span>：启用缓存支持。<br><span class="hljs-variable">@EnableWebMvc</span>：启用 Spring MVC 的配置，常用于 Spring Web 应用。<br><span class="hljs-variable">@EnableJpaRepositories</span>：启用 JPA 仓库的支持。<br></code></pre></td></tr></table></figure><blockquote><h5 id="底层工作机制"><a href="#底层工作机制" class="headerlink" title="底层工作机制"></a>底层工作机制</h5><p>当使用 <code>@Enable*</code> 注解时，Spring 会扫描并导入指定的配置类，这些类通常会包含必要的 Bean 定义和配置。<code>@Import</code> 注解可以导入普通的 Java 配置类，也可以导入 <code>ImportSelector</code> 或 <code>ImportBeanDefinitionRegistrar</code>，后者可以提供更为灵活的控制和动态 Bean 注册。</p><p>通过这种机制，开发者可以非常方便地启用所需的功能，而不需要手动编写大量的配置代码。</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE&#125;)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Import</span>(&#123;SchedulingConfiguration.class&#125;)<br><span class="hljs-variable">@Documented</span><br>public <span class="hljs-variable">@interface</span> EnableScheduling &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-Import注解"><a href="#3-Import注解" class="headerlink" title="3.Import注解"></a>3.Import注解</h6><p>@Enable*底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用 法： </p><blockquote><p><strong>导入普通的 Bean 类</strong>：最简单的用法是直接将某个类通过 <code>@Import</code> 导入到 Spring IOC 容器中，Spring 会自动将该类作为 Bean 进行管理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 普通的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> String sayHello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, Spring!&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 @Import 导入类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyService.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 使用 MyService 的类</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyService myService;<br><br>    <span class="hljs-keyword">public</span> MyController(MyService myService) &#123;<br>        <span class="hljs-keyword">this</span>.myService = myService;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String hello() &#123;<br>        <span class="hljs-keyword">return</span> myService.sayHello();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>导入配置类</strong>：可以通过 <code>@Import</code> 导入一个配置类（通常带有 <code>@Configuration</code> 注解的类）。该配置类中的 Bean 定义会被 Spring 自动加载。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService myService() &#123;<br>        <span class="hljs-keyword">return</span> new MyService();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 @Import 导入配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(ServiceConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 使用 MyService 的类</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyService myService;<br><br>    <span class="hljs-keyword">public</span> MyController(MyService myService) &#123;<br>        <span class="hljs-keyword">this</span>.myService = myService;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String hello() &#123;<br>        <span class="hljs-keyword">return</span> myService.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>导入 <code>ImportSelector</code> 实现类</strong>：<code>ImportSelector</code> 是一个接口，用于根据特定逻辑返回一组类名，Spring 会将这些类导入到容器中。这种方式通常用于根据条件动态地加载多个配置类或组件。通过实现 <code>ImportSelector</code>，你可以基于某些条件（如配置文件、依赖关系等）来决定哪些类需要被加载。</p><ul><li><p><em><strong><code>AutoConfigurationImportSelector</code></strong></em> 就是一个典型的 <code>ImportSelector</code> 实现类，它根据 <code>META-INF/spring.factories</code> 文件中的配置来决定哪些自动配置类需要被导入。</p></li><li><p>**<code>importingClassMetadata</code>**：代表的是使用 <code>@Import(MyImportSelector.class)</code> 注解的类的元数据。你可以通过它来获取导入这个 <code>ImportSelector</code> 的类的所有注解信息，包括该类上的注解、注解属性值等。</p></li><li></li><li><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface EnableFeatureX &#123;    boolean enable() default true;&#125;    <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br>```java<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-built_in">String</span>[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>        <span class="hljs-comment">// 获取使用 @EnableFeatureX 注解的类上的注解属性</span><br>        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; attributes = importingClassMetadata.getAnnotationAttributes(EnableFeatureX.<span class="hljs-keyword">class</span>.getName());<br>        boolean enable = (Boolean) attributes.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;enable&quot;</span>);<br>    <br>        <span class="hljs-comment">// 根据注解属性值决定要导入的类</span><br>        <span class="hljs-keyword">if</span> (enable) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;FeatureXService.<span class="hljs-keyword">class</span>.getName()&#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableFeatureX</span>(enable = true)<br><span class="hljs-variable">@Import</span>(MyImportSelector.class)<br>public class AppConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">在这个例子中，importingClassMetadata 允许你获取 <span class="hljs-meta">@EnableFeatureX</span> 注解的属性值，从而根据注解的配置动态决定是否导入 FeatureXService 类。<br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>导入 <code>ImportBeanDefinitionRegistrar</code> 实现类</strong>：<code>ImportBeanDefinitionRegistrar</code> 接口用于以编程的方式注册 Bean 定义，允许开发者手动控制 Bean 的注册过程，而不需要依赖注解或自动扫描。这提供了极大的灵活性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义 ImportBeanDefinitionRegistrar 实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanDefinitionRegistrar</span> <span class="hljs-title">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;<br>        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(MyService.<span class="hljs-keyword">class</span>);<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;myService&quot;</span>, beanDefinitionBuilder.getBeanDefinition());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 @Import 导入 ImportBeanDefinitionRegistrar</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyBeanDefinitionRegistrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 使用 MyService 的类</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyService myService;<br><br>    <span class="hljs-keyword">public</span> MyController(MyService myService) &#123;<br>        <span class="hljs-keyword">this</span>.myService = myService;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String hello() &#123;<br>        <span class="hljs-keyword">return</span> myService.sayHello();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h6 id="4-启动自动配置流程"><a href="#4-启动自动配置流程" class="headerlink" title="4.启动自动配置流程"></a>4.启动自动配置流程</h6><p>启动类探究</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">appmain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(appmain.<span class="hljs-property">class</span>,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入启动依赖</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE&#125;)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Inherited</span><br><span class="hljs-variable">@SpringBootConfiguration</span><span class="hljs-comment">//</span><br><span class="hljs-variable">@EnableAutoConfiguration</span><span class="hljs-comment">//启用自动配置-&gt;跟踪</span><br><span class="hljs-variable">@ComponentScan</span>(<br>    excludeFilters = &#123;<span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;TypeExcludeFilter.class&#125;<br>), <span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;AutoConfigurationExcludeFilter.class&#125;<br>)&#125;<br>)<br>public <span class="hljs-variable">@interface</span> SpringBootApplication &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@EnableAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><span class="hljs-comment">//根据路径匹配bean</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>AutoConfigurationImportSelector-&gt;返回全类名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> NO_IMPORTS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        AutoConfigurationEntry autoConfigurationEntry = <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);<br>        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">当 Spring Boot 应用启动时，@EnableAutoConfiguration 会被处理，AutoConfigurationImportSelector 会读取 META-INF/<span class="hljs-keyword">spring</span>.factories 中列出的所有自动配置类。<br><br>然后，它会根据配置类中的条件（@Conditional 等注解）进行判断，决定哪些 Bean 应该被加载。<br><br>满足条件的自动配置类会被导入，进而初始化相应的 Bean，完成自动配置。<br></code></pre></td></tr></table></figure><h4 id="3-Springboot监听机制"><a href="#3-Springboot监听机制" class="headerlink" title="3.Springboot监听机制"></a>3.Springboot监听机制</h4><p>Java 监听机制 SpringBoot 的监听机制，其实是对Java提供的事件监听机制的封装。 Java中的事件监听机制定义了以下几个角色： </p><p>① 事件：Event，继承 java.util.EventObject 类的对象 </p><p>② 事件源：产生事件的对象，通常是任意类型的 Java 对象</p><p>③ 监听器：实现 <code>java.util.EventListener</code> 接口的类，用来监听和处理事件。</p><p>SpringBoot 在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成 一些操作。 ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p><p>案例:ApplicationContextInitializer</p><p>该接口允许在 <code>ApplicationContext</code> 刷新之前进行自定义初始化操作。通过实现这个接口，你可以在 Spring 上下文创建前对其进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ApplicationContextInitializer: Application Context is initializing&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Springboot自动装配探究"><a href="#Springboot自动装配探究" class="headerlink" title="Springboot自动装配探究"></a>Springboot自动装配探究</h5><h6 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h6><p>概述 :某些对象自动存入IOC容器<br> 例子<br> 比如：配置类GsonAutoConfiguration里面有一个bean，bean的名字叫gson，它的类型是Gson。  -&gt;专门用来处理json数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgramApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Gson</span> gson;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">mmm</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title class_">String</span> json = gson.<span class="hljs-title function_">toJson</span>(<span class="hljs-title class_">Result</span>.<span class="hljs-title function_">success</span>());<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(json);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此处 我们没有手动将该gson对象放入ioc容器 但他确可以拿出来 这就是spring在启动时候 就完成了bean对象的创建</p><p>其实分析自动配置原理就是来解析在SpringBoot项目中，在引入依赖之后是如何将依赖jar包当中所定义的配置类以及bean加载到SpringIOC容器中的。</p><h4 id="2-自写自动装配"><a href="#2-自写自动装配" class="headerlink" title="2.自写自动装配"></a>2.自写自动装配</h4><h6 id="1-问题发现"><a href="#1-问题发现" class="headerlink" title="1.问题发现"></a>1.问题发现</h6><p>javen jar包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenParser</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;TokenParser ... parse ...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span>     <br><span class="hljs-keyword">private</span> ApplicationContext applicationContext;  <br><span class="hljs-meta">@Test</span>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTokenParse</span><span class="hljs-params">()</span>&#123;          System.out.println(applicationContext.getBean(TokenParser.class));   <br>&#125;<br></code></pre></td></tr></table></figure><p>&#96;<br> 报错 表示容器内没有找到这个bean</p><ul><li>原因在我们之前讲解IOC的时候有提到过，在类上添加@Component注解来声明bean对象时，还需要保证@Component注解能被Spring的组件扫描到。</li><li>SpringBoot项目中的@SpringBootApplication注解，具有包扫描的作用，但是它只会扫描启动类所在的当前包以及子包。</li><li>当前包：com.itheima， 第三方依赖中提供的包：com.example（扫描不到）</li></ul><h5 id="2-两种解决方法"><a href="#2-两种解决方法" class="headerlink" title="2.两种解决方法"></a>2.两种解决方法</h5><p>解决方法</p><ul><li>方案1：@ComponentScan 组件扫描</li><li>方案2：@Import 导入（使用@Import导入的类会被Spring加载到IOC容器中</li></ul><p>方案一 指定扫描<br> @ComponentScan({“com.example.program”,”com.example”})</p><p>但是每一个依赖包都要指定对应目录 太过麻烦 对此 进行方案2</p><h6 id="Import导入的三种方法"><a href="#Import导入的三种方法" class="headerlink" title="@Import导入的三种方法"></a>@Import导入的三种方法</h6><p> 1.普通类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@Import(<span class="hljs-params">TokenParser.<span class="hljs-keyword">class</span></span>) 自己加入bean容器</span><br></code></pre></td></tr></table></figure><p>2.配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeaderConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HeaderParser <span class="hljs-title function_">headerParser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderParser</span>();<br>    &#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> HeaderGenerator <span class="hljs-title function_">headerGenerator</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderGenerator</span>();<br>&#125;<br>&#125;<br>启动类--放到任意地方都行的<br><br><span class="hljs-meta">@Import(HeaderConfig.class)</span> <span class="hljs-comment">//导入配置类 </span><br>扫描到Bean 自动注册 其他地方就可以拿取该bean<br><br></code></pre></td></tr></table></figure><p>3.使用@Import导入ImportSelector接口实现类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Import</span>(<span class="hljs-title class_">MyImportSelector</span>.<span class="hljs-property">class</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span>[] <span class="hljs-title function_">selectImports</span>(<span class="hljs-params"><span class="hljs-title class_">AnnotationMetadata</span> importingClassMetadata</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.example.HeaderConfig&quot;</span>&#125;;<span class="hljs-comment">//返回全类名</span><br>    &#125;<br>&#125;<br><br>那两个 对象也会被加入进对应容器 <br></code></pre></td></tr></table></figure><p>你所提供的代码是Spring中ImportSelector接口的一个实现。ImportSelector接口是Spring的@Import注解处理的一部分，它允许我们动态加载（或导入）一些Spring的配置。</p><p>MyImportSelector类实现ImportSelector接口的selectImports方法，这个方法的作用是返回一个包含希望Spring加载的类全限定名称的字符串数组。</p><p>在你的例子中，selectImports方法返回一个字符串数组，包含一个元素”com.example.HeaderConfig”。这表示Spring会尝试将com.example.HeaderConfig这个类加载到Spring的应用上下文中。</p><hr><hr><hr><hr><hr><p>如图-三种方法都可以进行依赖注入</p><h5 id="第三方依赖探究"><a href="#第三方依赖探究" class="headerlink" title="第三方依赖探究"></a>第三方依赖探究</h5><p>如果基于以上方式完成自动配置，当要引入一个第三方依赖时，是不是还要知道第三方依赖中有哪些配置类和哪些Bean对象？</p><p>思考：当我们要使用第三方依赖，依赖中到底有哪些bean和配置类，谁最清楚？</p><ul><li>答案：第三方依赖自身最清楚。</li></ul><p><strong>结论：我们不用自己指定要导入哪些bean对象和配置类了，让第三方依赖它自己来指定。</strong>‘’</p><p>怎么让第三方依赖自己指定bean对象和配置类？</p><ul><li>比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解</li></ul><p>使用第三方依赖提供的 @EnableXxxxx注解</p><hr><p>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.TYPE)<br>@Import(MyImportSelector.class)&#x2F;&#x2F;指定要导入哪些bean对象或配置类<br>public @interface EnableHeaderConfig {<br>}</p><p>前两个注解详解</p><pre><code class="hljs">@Retention: 这个注解决定了被修饰的注解信息在什么级别可用。    RetentionPolicy.SOURCE：注解只保留在源码中，编译时会被丢弃，不会写入字节码。    RetentionPolicy.CLASS：注解在编译时被保留在字节码中，但JVM加载类时不会将其加载到反射数据中，这是默认的生命周期。    RetentionPolicy.RUNTIME：注解在编译后也会被保存在字节码中，JVM加载类时将其加载到反射数据中，所以它们能在运行时被读取到。因此，@Retention(RetentionPolicy.RUNTIME)意味着被修饰的注解在运行时仍然有效，可以通过反射机制读取到。@Target: 这个注解用来指定被修饰的注解可以用在哪些元素上。元素类型包括：CONSTRUCTOR（构造器声明），FIELD（字段声明），LOCAL_VARIABLE（局部变量声明），METHOD（方法声明），PACKAGE（包声明），PARAMETER（参数声明）, TYPE（类、接口或枚举声明）等。所以，@Target(ElementType.TYPE)表示被修饰的注解只能用来修饰类、接口或枚举。</code></pre><p>以上四种方式都可以完成导入操作，但是第4种方式会更方便更优雅，而这种方式也是SpringBoot当中所采用的方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootMybatisApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">SpringbootMybatisApplication</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE&#125;) 该注解意味着<span class="hljs-variable">@SpringBootApplication</span>只能用于类、接口或枚举类型。<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME) 表示<span class="hljs-variable">@SpringBootApplication</span>注解会被保留在运行时，因此可以通过反射获取其信息。<br><span class="hljs-variable">@Documented</span>  表明如果一个类使用了<span class="hljs-variable">@SpringBootApplication</span>注解，那么这个注解应该被包含在JavaDoc中。<br><span class="hljs-variable">@Inherited</span>    表示<span class="hljs-variable">@SpringBootApplication</span>注解可以被子类继承。<span class="hljs-comment">//配置类</span><br><span class="hljs-variable">@SpringBootConfiguration</span> <span class="hljs-comment">//起步依赖--通过 @SpringBootApplication 注解启动时，Spring Boot 会自动扫描并加载所有 @SpringBootConfiguration 注解的配置类，并根据配置类中的内容进行自动装配，从而实现对应用的自动配置和启动。</span><br><span class="hljs-variable">@EnableAutoConfiguration</span>启动Spring Boot的自动配置机制。<br><span class="hljs-variable">@ComponentScan</span>(<br>    excludeFilters = &#123;<span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;TypeExcludeFilter.class&#125;<br>), <span class="hljs-variable">@Filter</span>(<br>    type = FilterType.CUSTOM,<br>    classes = &#123;AutoConfigurationExcludeFilter.class&#125;<br>)&#125;<br>)使Spring Boot能够扫描当前类所在的包以及子包，查找Component，Configuration等。<br></code></pre></td></tr></table></figure><p>如上-跟踪自动装配的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span> <br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <br><span class="hljs-meta">@Documented</span> <br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><span class="hljs-comment">// 这是一个Spring Boot的内部注解，用于自动配置包扫描路径。Spring Boot将从声明@EnableAutoConfiguration的类的包开始，向下扫描包结构。</span><br><br><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br>AutoConfigurationImportSelector.class<br><br><br>在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration<br>  <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br><br><br><br><br><br><br>     <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> NO_IMPORTS;<br>            <span class="hljs-comment">/*这里调用了 isEnabled(annotationMetadata) 方法，它的作用是判断当前是否应该启用自动配置。通常，这种检查会依据某些条件，比如某些注解的存在与否、某个配置开关是否打开等。*/</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//配置导入</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">           调用 getAutoConfigurationEntry(annotationMetadata) 获取自动配置条目，通常这个条目会包含多个配置类。</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br>            <span class="hljs-comment">//第一个参数</span><br>         <br>       <br>            <span class="hljs-comment">//第一个参数加载代码-解释</span><br>            <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);<br>            <br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            将配置类名列表转换为字符串数组并返回，Spring 会根据返回的类名将它们导入到 IOC 容器中，作为自动配置的一部分。</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">///    AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br>    <br>-----------autoConfigurationMetadata<br>    <br>    <br>       <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);<br>    --&gt;load方法<br>        <br>        <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AutoConfigurationMetadata <span class="hljs-title function_">loadMetadata</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>        <span class="hljs-keyword">return</span> loadMetadata(classLoader, <span class="hljs-string">&quot;META-INF/spring-autoconfigure-metadata.properties&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><hr><hr><p>在META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-class">.GsonAutoConfiguration</span>,\<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.gson</span><span class="hljs-selector-class">.GsonAutoConfiguration</span>,\<br></code></pre></td></tr></table></figure><p>—这就是要加入ioc容器的类<br> 这么多 不会累坏吗 spring怎么知道哪些要加入哪些不加入呢</p><p> org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//表面该类是自动配置类</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;Gson.class&#125;)</span><span class="hljs-comment">//类的是否创建 类在类路径生效才生效--在spirng中-要存在配置才导入</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;GsonProperties.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GsonAutoConfiguration</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GsonAutoConfiguration</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <br>    <br>      <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-comment">//条件注解 这意味着只有当Spring容器中不存在类型为Gson 的Bean时，该方法返回的实例才会被注册为Bean</span><br>    <span class="hljs-keyword">public</span> Gson <span class="hljs-title function_">gson</span><span class="hljs-params">(GsonBuilder gsonBuilder)</span> &#123;<br>        <span class="hljs-keyword">return</span> gsonBuilder.create();<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>条件注解详解<br> @Configuration<br> public class HeaderConfig {</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><br><span class="hljs-variable">@ConditionalOnClass</span>(name=<span class="hljs-string">&quot;io.jsonwebtoken.Jwts&quot;</span>)<span class="hljs-comment">//环境中存在指定的这个类，才会将该bean加入IOC容器</span><br>public HeaderParser <span class="hljs-built_in">headerParser</span>()&#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">HeaderParser</span>();<br>&#125;<br><br><span class="hljs-comment">//省略其他代码...</span><br></code></pre></td></tr></table></figure><p>理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。</p><p>@ConditionalOnMissingBean &#x2F;&#x2F;不存在该类型的bean，才会将该bean加入IOC容器<br> @ConditionalOnMissingBean(name&#x3D;”deptController2”)&#x2F;&#x2F;不存在指定名称的bean，才会将该bean加入IOC容器<br> @ConditionalOnMissingBean(HeaderConfig.class)&#x2F;&#x2F;不存在指定类型的bean，才会将bean加入IOC容器<br> @ConditionalOnProperty(name &#x3D;”name”,havingValue &#x3D; “itheima”)&#x2F;&#x2F;配置文件中存在指定属性名与值，才会将bean加入IOC容器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197287-20231024124652432-47953813.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197287-20231023235331923-676978176.png" alt="image"></p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>总结-从启动类依赖开始找-&gt;自动装配依赖-&gt;自动装配依赖类的依赖-&gt;这个依赖的参数_&gt;selectImport函数-&gt;配置代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>-&gt;<span class="hljs-meta">@EnableAutoConfiguration</span>-&gt;<span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>-&gt;AutoConfigurationImportSelector-&gt;<br>-&gt;selectImport-&gt;<span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br>   -&gt; 探究方法参数<br> <span class="hljs-type">AutoConfigurationMetadata</span> <span class="hljs-variable">autoConfigurationMetadata</span> <span class="hljs-operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);-&gt;loadMetadata<br>           <br>    -&gt;代码方法-根据获取类全命名<br>    <br>    <br><br>-&gt;返回<br>      <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br></code></pre></td></tr></table></figure><p>这个过程就是spirng-boot-再启动的时候-&gt;会依据配置文件 去读取加载的Bean</p><p>bean中又包含了条件创建bean的结构</p><p>   @Bean<br>    @ConditionalOnMissingBean&#x2F;&#x2F;条件注解 这意味着只有当Spring容器中不存在类型为Gson 的Bean时，该方法返回的实例才会被注册为Bean<br>    public Gson gson(GsonBuilder gsonBuilder) {<br>        return gsonBuilder.create();<br>    }</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="/2024/09/14/MybitsPlus/"/>
    <url>/2024/09/14/MybitsPlus/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Mybatis-plus.png" alt="Mybatis-plus"></p><h4 id="MyBatis-Plus快速入门"><a href="#MyBatis-Plus快速入门" class="headerlink" title="MyBatis-Plus快速入门"></a>MyBatis-Plus快速入门</h4><p>MyBatis-Plus-&gt;基于MyBatis进行了一系列的开发</p><p>配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 数据库--&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mysql.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- MyBatis Plus 依赖 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用最新稳定版本 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">&quot;com.anli1.mapper&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Case01Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Case01Application</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>官方配置</p><p><a href="https://baomidou.com/introduce/">https://baomidou.com/introduce/</a></p><h6 id="0-了解mybatis封装"><a href="#0-了解mybatis封装" class="headerlink" title="0.了解mybatis封装"></a>0.了解mybatis封装</h6><p>1.自动生成sql</p><p><code>MyBatis-Plus</code> 提供了一套自动生成 CRUD（增删改查）操作的方法，这些方法包括：</p><ul><li><code>insert()</code>：插入数据。</li><li><code>deleteById()</code> &#x2F; <code>deleteBatchIds()</code>：根据 ID 或一组 ID 删除数据。</li><li><code>updateById()</code>：根据 ID 更新数据。</li><li><code>selectById()</code> &#x2F; <code>selectBatchIds()</code>：根据 ID 或一组 ID 查询数据。</li></ul><p>这些方法避免了手动编写重复的 SQL 语句和 DAO 层代码，显著提高了开发效率。</p><p>2.内置分页插件</p><p><code>MyBatis-Plus</code> 内置了分页插件，可以自动处理分页逻辑。开发者只需配置插件，调用相应的分页方法，框架会自动生成分页查询语句并返回分页结果。</p><p>3.<strong>条件构造器</strong></p><p><code>MyBatis-Plus</code> 提供了 <code>QueryWrapper</code>、<code>UpdateWrapper</code> 等条件构造器，使得开发者可以以更加简洁的方式构造复杂的查询或更新条件。例如，可以使用链式方法调用来构建查询条件，替代传统的手动拼接 SQL 的方式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();<br>queryWrapper.e<span class="hljs-string">q(&quot;name&quot;, &quot;Tom&quot;)</span>.ge(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>后续的就是不怎么用的内容</p><p>4.<strong>多种插件支持</strong></p><p><code>MyBatis-Plus</code> 提供了一系列插件，以扩展框架的功能，例如：</p><ul><li><strong>分页插件</strong>：支持自动分页。</li><li><strong>性能分析插件</strong>：帮助分析 SQL 性能。</li><li><strong>多租户插件</strong>：支持多租户应用程序开发。</li><li><strong>乐观锁插件</strong>：支持乐观锁控制，实现高并发场景下的数据安全。</li><li><strong>数据权限插件</strong>：可以在不同层级上控制数据访问权限。</li></ul><p>5.代码生成器</p><p><code>MyBatis-Plus</code> 提供了代码生成器工具，可以根据数据库表结构自动生成实体类、Mapper 接口、Service 类和 Controller 类。这样，大大减少了开发者的工作量，加快了开发速度。</p><p>6.逻辑删除</p><p><code>MyBatis-Plus</code> 支持逻辑删除功能，即在删除记录时，不是真的删除数据，而是将记录的某个标志位进行更新。<code>MyBatis-Plus</code> 会自动处理带有逻辑删除标记的数据，使其在查询时被自动排除。</p><p>7.自动填充功能</p><p>支持自动填充字段功能，例如创建时间、更新时间等字段，可以在插入或更新数据时自动填充指定的字段值。</p><p>8.sql性能优化</p><p><code>MyBatis-Plus</code> 对常见的 SQL 语句进行了优化，提高了执行效率。此外，还增强了 SQL 的功能，例如多表关联查询、Lambda 表达式构建器等。</p><p>总结</p><p>自动 CRUD 操作、内置分页、条件构造器、多种插件支持、代码生成器、逻辑删除、自动填充功能 sql优化</p><h6 id="1-BaseMapper类"><a href="#1-BaseMapper类" class="headerlink" title="1.BaseMapper类"></a>1.BaseMapper类</h6><p><code>BaseMapper</code> 是 <code>MyBatis-Plus</code> 提供的一个基础接口，它的作用是为所有的数据库实体类提供通用的 CRUD（增删改查）操作方法。通过继承 <code>BaseMapper</code>，开发者可以避免手动编写大量的重复性代码，大大简化了持久层的开发工作。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/84af32c461349faaa0e4f957c97a049b.png" alt="84af32c461349faaa0e4f957c97a049b"></p><p>mapper-&gt;继承该方法-这些方法名也是说的非常易懂的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// Mapper 接口继承 </span><br>BaseMapper <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserMapper</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BaseMapper</span>&lt;<span class="hljs-symbol">User</span>&gt; &#123;   <br><span class="hljs-comment">// 你可以在这里定义自定义方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-Mybits-映射Pojo"><a href="#2-Mybits-映射Pojo" class="headerlink" title="2.Mybits 映射Pojo"></a>2.Mybits 映射Pojo</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3c3e138598f90a383add182c550745da.png" alt="3c3e138598f90a383add182c550745da"></p><p>驼峰命名法是一种命名约定，其中每个单词的首字母大写，没有空格或标点符号来分隔单词，例如：camelCase。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@TableName(<span class="hljs-string">&quot;user&quot;</span>)</span> <span class="hljs-comment">// 指定表名为 &#x27;user&#x27;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span> <span class="hljs-comment">// 指定主键策略</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id; <span class="hljs-comment">// 与表中的 &#x27;id&#x27; 字段对应</span><br><br>    <span class="hljs-meta">@TableField(<span class="hljs-string">&quot;name&quot;</span>)</span> <span class="hljs-comment">// 指定映射字段名为 &#x27;name&#x27;</span><br>    <span class="hljs-keyword">private</span> String username; <span class="hljs-comment">// 与表中的 &#x27;name&#x27; 字段对应</span><br>    <br>    <span class="hljs-keyword">private</span> Integer age; <span class="hljs-comment">// 与表中的 &#x27;age&#x27; 字段对应</span><br>    <br>    <span class="hljs-comment">// Getters and Setters...</span><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h6 id="3-注解-TableName-表名注解"><a href="#3-注解-TableName-表名注解" class="headerlink" title="3.注解@TableName -表名注解"></a>3.注解@TableName -表名注解</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5963a7ca700c1878c285ab9ae2347046.png" alt="5963a7ca700c1878c285ab9ae2347046"></p><h6 id="4-主键注解-Tableid"><a href="#4-主键注解-Tableid" class="headerlink" title="4.主键注解 @Tableid"></a>4.主键注解 @Tableid</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed012758973b1755cdcd1d1ddc0e991c.png" alt="ed012758973b1755cdcd1d1ddc0e991c"></p><p> @TableId<br>    private Long id;<br>属性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/242fd1966addaff8b3313118e48981a7.png" alt="242fd1966addaff8b3313118e48981a7"></p><h6 id="5-普通字段注解-TableField"><a href="#5-普通字段注解-TableField" class="headerlink" title="5.普通字段注解@TableField"></a>5.普通字段注解@TableField</h6><p>@TableField(“isMarried”)<br>    private Boolean isMarried;</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95e9bd49c3b791c708e964a2f4b15e2a.png" alt="95e9bd49c3b791c708e964a2f4b15e2a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5fe85caf87e0fab3483354cb7fd499ad.png" alt="5fe85caf87e0fab3483354cb7fd499ad"></p><h6 id="6-常见配置"><a href="#6-常见配置" class="headerlink" title="6.常见配置"></a>6.常见配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/034876e14a71af1ec8524063ba29c738.png" alt="034876e14a71af1ec8524063ba29c738"></p><hr><p>mybitspro 也支持手写sql</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7441706e396a4cab007d33e7e1dd4469.png" alt="7441706e396a4cab007d33e7e1dd4469"></p><p>mybitsx+mybitsplus-&gt;可以支持跳转写-具体方法就是mybits</p><h4 id="7-条件构造器"><a href="#7-条件构造器" class="headerlink" title="7.条件构造器"></a>7.条件构造器</h4><h6 id="1-构造器了解"><a href="#1-构造器了解" class="headerlink" title="1.构造器了解"></a>1.构造器了解</h6><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/52da0353c64f7992f277a55d5d69307d.png" alt="52da0353c64f7992f277a55d5d69307d"></p><p>Wrapper关系</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95aa614360e41a40e6eb3aeb95743c0a.png" alt="95aa614360e41a40e6eb3aeb95743c0a"></p><h6 id="1-AbstractWrapper"><a href="#1-AbstractWrapper" class="headerlink" title="1.AbstractWrapper"></a>1.AbstractWrapper</h6><p>提供了where中包含的所有条件构造方法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/336fb5b4722bff7397e6c30eb5dea9bf.png" alt="336fb5b4722bff7397e6c30eb5dea9bf"></p><h6 id="2-QueryWrapper"><a href="#2-QueryWrapper" class="headerlink" title="2.QueryWrapper"></a>2.QueryWrapper</h6><p>拓展了一个select方法，允许指定查询字段</p><p>-&gt;查询id</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/47543da4a82f7a8134c43b19b1e10502.png" alt="47543da4a82f7a8134c43b19b1e10502"></p><h6 id="3-UpdateWrapper"><a href="#3-UpdateWrapper" class="headerlink" title="3.UpdateWrapper"></a>3.UpdateWrapper</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c1893ba09ded9c12a23470e6000d7325.png" alt="c1893ba09ded9c12a23470e6000d7325"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/99ec8027977a2561dadf41ef09a948ad.png" alt="99ec8027977a2561dadf41ef09a948ad"></p><h6 id="4-LambdaQueryWrapper"><a href="#4-LambdaQueryWrapper" class="headerlink" title="4.LambdaQueryWrapper"></a>4.LambdaQueryWrapper</h6><blockquote><p>-无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。</p><p><code>QueryWrapper</code> 和 <code>UpdateWrapper</code> 常用于构建数据库查询或更新的条件。在使用这些类构造查询条件时，字段名是以字符串形式硬编码在代码中的。</p><p><strong>字符串魔法值</strong>：直接在代码中写死字段名是一个“魔法值”（Magic String），即无法直观地知道这个字符串代表什么意思，如果需要修改字段名，则必须在代码中找到所有使用该字符串的地方并手动更改。</p><p><strong>不安全且容易出错</strong>：硬编码的字符串字段名在编译时不会被检查，当字段名拼写错误或发生变化时，可能导致运行时错误（如 SQL 执行失败），但编译器无法检测到这个问题。</p><p><strong>难以维护</strong>：如果表的字段名称发生更改，代码中的所有字符串字段名都需要手动调整，增加了代码维护的成本。</p></blockquote><p>写死值案例</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();<br>queryWrapper.e<span class="hljs-string">q(&quot;name&quot;, &quot;John&quot;)</span>; <span class="hljs-regexp">//</span> 使用字符串字段名<br>queryWrapper.ge(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>MyBatis-Plus 提供了 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code> 来解决上述问题。这些类允许你使用 Lambda 表达式来引用字段，而不是直接使用字符串。这种方式有以下好处：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); lambdaQueryWrapper.e<span class="hljs-string">q(User::getName, &quot;John&quot;)</span>; <span class="hljs-regexp">//</span> 使用 Lambda 表达式引用字段 lambdaQueryWrapper.ge(User::getAge, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>使用 <code>User::getName</code> 和 <code>User::getAge</code> 作为字段的引用。<code>User</code> 是实体类，<code>getName</code> 和 <code>getAge</code> 是其字段的 Getter 方法。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b0ffa0bb1d852812ad294a35b8fd888.png" alt="1b0ffa0bb1d852812ad294a35b8fd888"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/46be4929662ae5ef628b043e12c85c09.png" alt="46be4929662ae5ef628b043e12c85c09"></p><h4 id="自定义sql-注解"><a href="#自定义sql-注解" class="headerlink" title="自定义sql-注解"></a>自定义sql-注解</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/96f49f3a8be18ed697e8915da140bed9.png" alt="96f49f3a8be18ed697e8915da140bed9"></p><p>改</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d725d5559e95de38132857f497800bd.png" alt="8d725d5559e95de38132857f497800bd"></p><p>基于注解写sql-是mybitsplus功能</p><h4 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h4><h6 id="1-Service了解"><a href="#1-Service了解" class="headerlink" title="1.Service了解"></a>1.Service了解</h6><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。如下</p><p><code>IService</code> 和 <code>ServiceImpl</code> 是用于简化对数据库操作的通用接口和默认实现。<code>IService</code> 提供了一套通用的服务接口，而 <code>ServiceImpl</code> 则是对这些接口的具体实现。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3dcaf6a956fe9fe726dd0f071b0c71bc.png" alt="3dcaf6a956fe9fe726dd0f071b0c71bc"></p><h6 id="2-新增"><a href="#2-新增" class="headerlink" title="2.新增"></a>2.新增</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/13c96b5cebd34752b567c130b95bf94f.png" alt="13c96b5cebd34752b567c130b95bf94f"></p><h6 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/223e551718256b2c4ccb496ab27fd928.png" alt="223e551718256b2c4ccb496ab27fd928"></p><h6 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/15250e865364a0a81ebc28c32da5d578.png" alt="15250e865364a0a81ebc28c32da5d578"></p><h6 id="4-查找单个"><a href="#4-查找单个" class="headerlink" title="4.查找单个"></a>4.查找单个</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4ae94dcbfb1f9c6c65304c24b0345a83.png" alt="4ae94dcbfb1f9c6c65304c24b0345a83"></p><h6 id="5-查询集合"><a href="#5-查询集合" class="headerlink" title="5.查询集合"></a>5.查询集合</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/49306fabfb10f5443ed6af5be333fd1e.png" alt="49306fabfb10f5443ed6af5be333fd1e"></p><h6 id="6-计数"><a href="#6-计数" class="headerlink" title="6.计数"></a>6.计数</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c48dc029d0bd68c01a7dfbe8b5a6fc45.png" alt="c48dc029d0bd68c01a7dfbe8b5a6fc45"></p><h6 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7.分页查询"></a>7.分页查询</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1cd184ca76dc2163ff33cff11f550075.png" alt="1cd184ca76dc2163ff33cff11f550075"></p><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><blockquote><p>MyBatis（包括 MyBatis-Plus）中使用了 Lambda 表达式来简化查询操作，使代码更加简洁和易于维护。Lambda 表达式通常与 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code> 一起使用，提供一种类型安全的方式来编写条件查询和更新语句。</p></blockquote><h6 id="1-LambdaQueryWrapper"><a href="#1-LambdaQueryWrapper" class="headerlink" title="1.LambdaQueryWrapper"></a>1.<code>LambdaQueryWrapper</code></h6><p><code>LambdaQueryWrapper</code> 用于构建查询条件。它利用 Java 8 的 Lambda 表达式特性，使条件构造更加直观和安全。以下是一些常用的方法：\</p><p><code>eq</code>：相等查询</p><p><code>ne</code>：不等于查询</p><p><code>gt</code>：大于查询</p><p><code>ge</code>：大于等于查询</p><p><code>lt</code>：小于查询</p><p><code>le</code>：小于等于查询</p><p><code>like</code>：模糊查询</p><p><code>notLike</code>：不匹配查询</p><p><code>likeLeft</code>：左匹配查询</p><p><code>likeRight</code>：右匹配查询</p><p><code>between</code>：在区间内查询</p><p><code>notBetween</code>：不在区间内查询</p><p><code>isNull</code>：字段为空查询</p><p><code>isNotNull</code>：字段不为空查询</p><p><code>in</code>：包含查询</p><p><code>notIn</code>：不包含查询</p><p><code>orderByAsc</code>：升序排序</p><p><code>orderByDesc</code>：降序排序</p><h6 id="2-LambdaUpdateWrapper"><a href="#2-LambdaUpdateWrapper" class="headerlink" title="2.LambdaUpdateWrapper"></a>2.LambdaUpdateWrapper</h6><p><code>set</code>：设置要更新的字段和值</p><p><code>eq</code>：相等查询</p><p><code>ne</code>：不等于查询</p><p><code>gt</code>：大于查询</p><p><code>ge</code>：大于等于查询</p><p><code>lt</code>：小于查询</p><p><code>le</code>：小于等于查询</p><p><code>like</code>：模糊查询</p><p><code>between</code>：在区间内查询</p><p><code>isNull</code>：字段为空查询</p><p><code>isNotNull</code>：字段不为空查询</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">LambdaUpdateWrapper&lt;<span class="hljs-keyword">User</span>&gt; updateWrapper = <span class="hljs-built_in">new</span> LambdaUpdateWrapper&lt;&gt;();<br>updateWrapper.eq(<span class="hljs-keyword">User</span>::getId, <span class="hljs-number">1</span>)<br>             .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getName, &quot;李四&quot;)<br>             .<span class="hljs-keyword">set</span>(<span class="hljs-keyword">User</span>::getAge, <span class="hljs-number">25</span>);<br>userMapper.<span class="hljs-keyword">update</span>(<span class="hljs-keyword">null</span>, updateWrapper);<br></code></pre></td></tr></table></figure><h6 id="3-lambda简化"><a href="#3-lambda简化" class="headerlink" title="3.lambda简化"></a>3.lambda简化</h6><p>如果你不想在 MyBatis-Plus 中每次都使用 <code>new LambdaQueryWrapper&lt;&gt;()</code> 或 <code>new LambdaUpdateWrapper&lt;&gt;()</code>，你可以使用 MyBatis-Plus 提供的静态方法来简化代码。MyBatis-Plus 的 <code>Wrappers</code> 类提供了多个静态方法，用于构建 Lambda 表达式的查询和更新条件。</p><p>MyBatis-Plus 提供了 <code>Wrappers.lambdaQuery()</code> 和 <code>Wrappers.lambdaUpdate()</code> 方法来创建 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code> 的实例。这些方法使代码更加简洁，省去了显式创建对象的步骤。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/23977048b3aead660e100eb55b7391b2.png" alt="23977048b3aead660e100eb55b7391b2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c243ec58a30cfb1eaaa8fe38a934fd14.png" alt="c243ec58a30cfb1eaaa8fe38a934fd14"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68eda2f47849ac7f17f343f9d71147bf.png" alt="68eda2f47849ac7f17f343f9d71147bf"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bbffabb2a6d9fd54b8984cbe194d1457.png" alt="bbffabb2a6d9fd54b8984cbe194d1457"></p><p>改造根据id修改用户余额的接口，要求如下</p><ul><li>如果扣减后余额为0，则将用户status修改为冻结状态（2）</li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/467e0f04ce771a195c18e1c64970a3ae.png" alt="467e0f04ce771a195c18e1c64970a3ae"></p><p>动态sql</p><p>mybits批量处理</p><p>IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务</p><p>—也就是不需要构造条件-直接可以用lambda-进行查询</p><h4 id="Mybits批处理"><a href="#Mybits批处理" class="headerlink" title="Mybits批处理"></a>Mybits批处理</h4><p>逐条插入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/101b580959e40e749e63af58e1ac2bd9.png" alt="101b580959e40e749e63af58e1ac2bd9"></p><p>mybits批处理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/866ee7682e72520e58686b6b1bc60e46.png" alt="866ee7682e72520e58686b6b1bc60e46"></p><p>每1000条批量插入一次</p><p>为什么mybits插入速度就快</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-built_in">Transactional</span>(rollbackFor = Exception.<span class="hljs-keyword">class</span>)<br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">saveBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList, <span class="hljs-type">int</span> batchSize)</span> </span>&#123;<br><span class="hljs-comment">//传入集合和集合大小</span><br>    <br><span class="hljs-type">String</span> sqlStatement = <span class="hljs-built_in">getSqlStatement</span>(SqlMethod.INSERT_ONE);<br>获取预处理<span class="hljs-function">sql</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">executeBatch</span><span class="hljs-params">(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity))</span></span>;<br>&#125;<br>-&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-type">boolean</span> <span class="hljs-title">executeBatch</span><span class="hljs-params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="hljs-type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;<br>    Assert.<span class="hljs-built_in">isFalse</span>(batchSize &lt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;batchSize must not be less than one&quot;</span>);<span class="hljs-comment">///断言语句</span><br><span class="hljs-comment">///三元运算</span><br>    <span class="hljs-keyword">return</span> <br>!CollectionUtils.<span class="hljs-built_in">isEmpty</span>(list)<span class="hljs-comment">//检查集合是否为空</span><br> &amp;&amp; <span class="hljs-built_in">executeBatch</span>(entityClass, log, sqlSession -&gt; &#123;<br>        <span class="hljs-type">int</span> size = list.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> idxLimit = Math.<span class="hljs-built_in">min</span>(batchSize, size);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (E element : list) &#123;<br>            consumer.<span class="hljs-built_in">accept</span>(sqlSession, element);<br>            <span class="hljs-keyword">if</span> (i == idxLimit) &#123;<br>                sqlSession.<span class="hljs-built_in">flushStatements</span>();<br>                idxLimit = Math.<span class="hljs-built_in">min</span>(idxLimit + batchSize, size);<br>            &#125;<br>            i++;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>executeBatch(entityClass, log, sqlSession -&gt; { … }): 这是一个方法调用，调用了名为 executeBatch 的方法，并传递了 entityClass、log 和一个 Lambda 表达式作为参数。Lambda 表达式中的代码块将会在 executeBatch 方法内部执行。</p><p>Lambda 表达式内部的逻辑：</p><pre><code class="hljs">首先，获取集合 list 的大小，并将其存储在变量 size 中。然后，计算循环的上限索引 idxLimit，它等于批处理大小 batchSize 和集合大小 size 中的较小值。接着，初始化变量 i 为 1，用于追踪当前处理的元素索引。在循环中，遍历集合 list 中的每个元素 element：    使用 consumer.accept(sqlSession, element) 方法处理当前元素，其中 consumer 是一个函数接口，用于执行特定的操作。    如果当前处理的索引 i 等于上限索引 idxLimit，则调用 sqlSession.flushStatements() 方法来刷新 SQL 语句，并更新上限索引 idxLimit 为下一个批次的上限索引。    最后，增加索引变量 i 的值，进入下一轮循环。</code></pre><p>整个 Lambda 表达式的执行结果将作为 executeBatch 方法的返回值。</p><p>}</p><p>以发现其实MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0d893a2bdab9ed10ad0c7284e6823446.png" alt="0d893a2bdab9ed10ad0c7284e6823446"></p><p>——-开启重新批处理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e5d8dd6fc91bf3b8183f433d705a8485.png" alt="e5d8dd6fc91bf3b8183f433d705a8485">****</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/accd1ecdecd550e717eaffb8a07860cc.png" alt="accd1ecdecd550e717eaffb8a07860cc"></p><h4 id="mybitsplus-代码生成"><a href="#mybitsplus-代码生成" class="headerlink" title="mybitsplus-&gt;代码生成"></a>mybitsplus-&gt;代码生成</h4><p>在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/640804c8b4ef9653c763c7c457d5c1e9.png" alt="640804c8b4ef9653c763c7c457d5c1e9"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8be53fe79baa68053e1013376f8ea342.png" alt="8be53fe79baa68053e1013376f8ea342"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/42bb2850b64b4a5daa22cf5a3e19e92a.png" alt="42bb2850b64b4a5daa22cf5a3e19e92a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/465db4382ca68f36c25c79a80bbce054.png" alt="465db4382ca68f36c25c79a80bbce054"></p><h4 id="MybitsPlus静态"><a href="#MybitsPlus静态" class="headerlink" title="MybitsPlus静态"></a>MybitsPlus静态</h4><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c1f46709369d86eee7c03df671545992.png" alt="c1f46709369d86eee7c03df671545992"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/59a15e1243bd819dbc3e3d4869dd7b79.png" alt="59a15e1243bd819dbc3e3d4869dd7b79"></p><p>案例</p><p>改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9982422351f6ecc277ededc0e803296.png" alt="c9982422351f6ecc277ededc0e803296"></p><h4 id="逻辑删除优化"><a href="#逻辑删除优化" class="headerlink" title="逻辑删除优化"></a>逻辑删除优化</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/edb312802503c8139e9606f8ae74f0d8.png" alt="edb312802503c8139e9606f8ae74f0d8"></p><p>确实<br>比如云盘项目-就是要过滤这些条件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c7bda4e8f8266db45e4908e922627b8a.png" alt="c7bda4e8f8266db45e4908e922627b8a"></p><p>配置逻辑删除</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0dd9aceaa2940ed98150df3ea6b48312.png" alt="0dd9aceaa2940ed98150df3ea6b48312"></p><p>查询测试</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/64779cb8ce59b7e93069adc874ce93ed.png" alt="64779cb8ce59b7e93069adc874ce93ed"></p><h4 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/60a018a6f80a6f46b6c5c4f5bf7fb176.png" alt="60a018a6f80a6f46b6c5c4f5bf7fb176"></p><p>mybits-&gt;提供枚举类型与数据库类型自动转换</p><p>MyBatis-Plus  通过注解 <code>@EnumValue</code> 指定数据库字段和枚举字段的映射。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cb75a3b930d23430174c125921d14601.png" alt="cb75a3b930d23430174c125921d14601"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4934929e1a9c7b79d79f04adf975105.png" alt="c4934929e1a9c7b79d79f04adf975105"></p><p>同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/28cfbac5f5fa1ffc563eb851a3f65f25.png" alt="28cfbac5f5fa1ffc563eb851a3f65f25"></p><p>0—会自动根据数字-对应正常或者冻结</p><h4 id="json类型处理器"><a href="#json类型处理器" class="headerlink" title="json类型处理器"></a>json类型处理器</h4><blockquote><p>在 MyBatis-Plus 中，我们可以使用 <code>JacksonTypeHandler</code> 类型处理器来自动将 JSON 数据库字段与 Java 对象之间进行转换，这样就不需要手动进行字符串与 JSON 对象之间的转换了。<code>JacksonTypeHandler</code> 使用了 Jackson 库来进行 JSON 序列化和反序列化操作。</p></blockquote><p>在 MyBatis-Plus 中，我们可以使用 <code>JacksonTypeHandler</code> 类型处理器来自动将 JSON 数据库字段与 Java 对象之间进行转换，这样就不需要手动进行字符串与 JSON 对象之间的转换了。<code>JacksonTypeHandler</code> 使用了 Jackson 库来进行 JSON 序列化和反序列化操作。</p><p>假设你有一个 <code>user</code> 表，其中 <code>info</code> 字段是 JSON 类型。在 <code>User</code> 实体类中，我们希望将 <code>info</code> 映射为一个 Java 对象（如 <code>Map</code> 或一个自定义的 Java 类），而不是 <code>String</code>。我们可以使用 <code>JacksonTypeHandler</code> 来实现这种自动转换。</p><blockquote><p>在实体类的对应字段上使用 <code>@TableField</code> 注解，并指定 <code>typeHandler</code> 为 <code>JacksonTypeHandler</code>。</p><p>如果 <code>info</code> 字段是一个 Map 或者自定义对象类型，<code>JacksonTypeHandler</code> 会自动完成 JSON 与 Java 对象之间的转换。</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6d0855f286d0ffdb19096463987947fb.png" alt="6d0855f286d0ffdb19096463987947fb"></p><p><code>JacksonTypeHandler</code> 会将数据库中的 JSON 数据自动转换为 <code>UserInfo</code> 对象，并且在保存时会自动将 <code>UserInfo</code> 转换为 JSON 字符串。</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><h6 id="1-配置分页插件"><a href="#1-配置分页插件" class="headerlink" title="1.配置分页插件"></a>1.配置分页插件</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/12944f422088ff0097b7beb2b0d835d3.png" alt="12944f422088ff0097b7beb2b0d835d3"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><br><span class="hljs-variable">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br>    <span class="hljs-variable">@Bean</span><br>    public PaginationInterceptor paginationInterceptor() &#123;<br>        <span class="hljs-keyword">return</span> new PaginationInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>PaginationInterceptor</code> 插件是 MyBatis-Plus 提供的分页插件，它会自动处理分页逻辑，支持多种数据库。</p><h6 id="2-分页api"><a href="#2-分页api" class="headerlink" title="2.分页api"></a>2.分页api</h6><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-keyword">public</span> Page&lt;User&gt; getUsersByPage(<span class="hljs-keyword">int</span> currentPage, <span class="hljs-keyword">int</span> pageSize) &#123;<br>        <span class="hljs-comment">// 创建 Page 对象</span><br>        Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(currentPage, pageSize);<br><br>        <span class="hljs-comment">// 创建 QueryWrapper 对象</span><br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>        queryWrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 按照 id 降序排列</span><br><br>        <span class="hljs-comment">// 执行分页查询</span><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> userMapper.<span class="hljs-title">selectPage</span><span class="hljs-params">(page, queryWrapper)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 <code>Page</code> 类创建了一个分页对象，并指定了当前页码和每页显示的记录数。<code>selectPage</code> 方法会执行分页查询，并将结果封装在 <code>Page</code> 对象中返回。</p></blockquote><h6 id="3-Page-对象的属性"><a href="#3-Page-对象的属性" class="headerlink" title="3.,Page 对象的属性"></a>3.,<code>Page</code> 对象的属性</h6><p><code>Page</code> 对象包含以下属性：</p><ul><li>**<code>current</code>**：当前页码。</li><li>**<code>size</code>**：每页显示的记录数。</li><li>**<code>total</code>**：总记录数。</li><li>**<code>pages</code>**：总页数。</li><li>**<code>records</code>**：当前页的数据记录列表。</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">Page<span class="hljs-variable">&lt;User&gt;</span> <span class="hljs-keyword">user</span>Page = <span class="hljs-keyword">user</span>Service.getUsersByPage(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>List<span class="hljs-variable">&lt;User&gt;</span> users = <span class="hljs-keyword">user</span>Page.getRecords(); // 当前页的数据记录<br>long total = <span class="hljs-keyword">user</span>Page.getTotal(); // 总记录数<br>long pages = <span class="hljs-keyword">user</span>Page.getPages(); // 总页数<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring mvc</title>
    <link href="/2024/09/13/Spring%20mvc%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/13/Spring%20mvc%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-mvc复习"><a href="#Spring-mvc复习" class="headerlink" title="Spring mvc复习"></a>Spring mvc复习</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/SpringMvc.png" alt="SpringMvc"></p><h4 id="0-spring-springmvc"><a href="#0-spring-springmvc" class="headerlink" title="0.spring-springmvc"></a>0.spring-springmvc</h4><p>Spring 和 Spring MVC 是两个相关但独立的框架，它们解决了不同的问题。简单来说，<strong>Spring</strong> 是一个通用的应用框架，而 <strong>Spring MVC</strong> 是一个基于 Spring 的 Web 框架，用于构建 Web 应用程序。</p><blockquote><p><strong>Spring 的主要作用</strong>：</p><ul><li><strong>依赖注入（Dependency Injection, DI）</strong>：Spring 最主要的功能是依赖注入，它通过控制反转（Inversion of Control, IoC）容器来管理对象之间的依赖关系，使代码更加模块化和可测试。</li><li><strong>面向切面编程（Aspect-Oriented Programming, AOP）</strong>：Spring 支持 AOP，允许在不修改原始代码的情况下添加额外的行为，例如日志记录、事务管理和安全检查。</li><li><strong>数据访问集成</strong>：Spring 提供对多种数据访问技术（如 JDBC、JPA、Hibernate）的集成和支持，简化了与数据库的交互。</li><li><strong>事务管理</strong>：Spring 提供了声明性事务管理，可以让开发者更轻松地管理事务。</li><li><strong>其他支持</strong>：如邮件发送、消息队列集成、缓存等。</li></ul><p><strong>Spring MVC 的主要作用</strong>：</p><ul><li><strong>专门用于 Web 开发</strong>：Spring MVC 是 Spring 框架中用于构建 Web 应用的部分，它遵循 Model-View-Controller (MVC) 设计模式，帮助开发者更容易地构建基于 HTTP 协议的 Web 应用程序。</li><li><strong>请求处理流程</strong>：Spring MVC 提供了一整套用于处理 HTTP 请求和响应的机制，例如 <code>DispatcherServlet</code> 作为前端控制器，将请求分发给适当的处理器（Controller）。</li><li><strong>视图解析</strong>：Spring MVC 提供视图解析机制，将模型数据绑定到视图（例如 JSP、Thymeleaf、Freemarker 等）。</li><li><strong>数据绑定与验证</strong>：提供了数据绑定功能，将请求参数绑定到 Java 对象，还支持数据验证和格式化。</li><li><strong>国际化（I18n）支持</strong>：Spring MVC 提供了内置的国际化支持，方便开发多语言 Web 应用程序。</li><li><strong>集成与扩展</strong>：与 Spring 生态系统中的其他模块（如 Spring Security、Spring Data 等）无缝集成。</li></ul></blockquote><p>Spring 和 Spring MVC 的关系</p><p>Spring MVC 是 Spring 框架中的一个模块，它依赖于 Spring 核心容器（Core Container）来工作。它利用了 Spring 的 IoC 和 AOP 功能来管理 Web 应用程序的组件（如控制器、服务、数据访问层等）。因此，Spring MVC 本质上是一个基于 Spring 的 Web 框架。</p><h4 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h4><p>Spirngmvc-Servlet</p><p>Controller-&gt;Springmvc 产物</p><p>1.SpringMVC是一种表现层框架技术–</p><p>SpringMVC用于进行表现层功能开发</p><p>使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标</p><p>创建Springfmvc控制器类</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a20b723675912525bb7fa4b6861f2445.png" alt="a20b723675912525bb7fa4b6861f2445"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/804db24f3395fe5d5940d26edfc3ea33.png" alt="804db24f3395fe5d5940d26edfc3ea33"></p><p>springmvc0需要设定springmcv加载对应Bean</p><h4 id="1-1-Springmvc配置"><a href="#1-1-Springmvc配置" class="headerlink" title="1.1 Springmvc配置"></a>1.1 Springmvc配置</h4><p><code>ServletContainersInitConfig</code> 类扩展了 <code>AbstractDispatcherServletInitializer</code>，这个类是 Spring MVC 提供的一个抽象类，用于快速初始化基于 Servlet 3.0 的 Web 容器（如 Tomcat）。它通过实现三个方法来配置 Spring 和 Spring MVC 的应用上下文以及 Servlet 的映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContainersInitConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDispatcherServletInitializer</span> &#123;<br>    <br>    <span class="hljs-comment">//加载springMVC配置 -第一个接口 创建Servlet容器时，加载SpringMVC对应的bean并放入</span><br>    <span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createServletApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//初始化WebApplicationContext对象</span><br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        <span class="hljs-comment">//加载指定配置类</span><br>        ctx.register(SpringMvcConfig.class);<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>作用：</p><ul><li>创建和配置 Spring MVC 的应用上下文（<code>WebApplicationContext</code>）<ul><li><code>WebApplicationContext</code> 是 Spring 中用于 Web 应用程序的应用上下文，它扩展了 <code>ApplicationContext</code>，提供了面向 Web 的额外功能。</li></ul></li><li>在这个方法中：<ul><li><strong>创建 <code>AnnotationConfigWebApplicationContext</code> 对象</strong>：这是一个基于注解配置的 <code>WebApplicationContext</code> 实现，能够扫描和加载配置类。</li><li><strong>注册配置类</strong>：<code>ctx.register(SpringMvcConfig.class)</code>，将指定的配置类 <code>SpringMvcConfig</code> 注册到 <code>WebApplicationContext</code> 中，这样 Spring MVC 就可以根据这个配置类初始化它所需的 bean 和其他配置。</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置Tomcat接收的请求哪些归SpringMVC处理</span><br><span class="hljs-comment">//getServletMappings()方法，设定SpringMVC对应的请求映射路径，设置为/表示拦截所有请求，任意请求都将转入到SpringMVC进行处理</span><br><br><span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>&#125;<br><br><span class="hljs-comment">//设置spring相关配置 如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，</span><br><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createRootApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解</p><blockquote><p>Controller 设定SpringMVC的核心控制器bean</p><p>@RequestMapping  设置当前控制器方法请求访问路径</p><p>@ResponseBody  设置当前控制器方法响应内容为当前返回值，无需解析</p></blockquote><p>综上-我们要导入spirngmvc容器</p><blockquote><p>1.导入springmvc坐标 2.创建springmvc核心控制器bean 3.再配置类中进行指定加载4.配置tocat的路径哪些被springmvc管理</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/67f41aab7f091ea29d50d4b977866e31.png" alt="67f41aab7f091ea29d50d4b977866e31"></p><p>* </p><h4 id="2-bean加载控制"><a href="#2-bean加载控制" class="headerlink" title="2.bean加载控制"></a>2.bean加载控制</h4><p>在 Spring 应用程序中，通常会有两种类型的配置：</p><ol><li><strong>Spring 容器配置</strong>：用于管理应用程序的核心业务逻辑组件，例如服务层（Service）、数据访问层（DAO）等。</li><li><strong>Spring MVC 容器配置</strong>：用于管理 Web 层的组件，例如控制器（Controller）、视图解析器（View Resolver）等。</li></ol><p>当一个应用程序使用了 Spring 和 Spring MVC 时，通常会有两个 <code>ApplicationContext</code>：</p><ul><li><strong>根应用上下文（Root ApplicationContext）</strong>：由 Spring 容器管理，包含业务逻辑层的 bean（如 Service、DAO 等）。</li><li><strong>Web 应用上下文（WebApplicationContext）</strong>：由 Spring MVC 容器管理，包含 Web 层的 bean（如 Controller、视图解析器等）。</li></ul><p>我们就需要避免加载</p><p>springmvc-controller –mvc  bean</p><p>业务层的service–注册为spirngbean的bean</p><blockquote><p><strong>将业务层的 bean（如 Service、DAO）注册到根应用上下文中</strong>，这些 bean 应该由 Spring 容器管理。</p><p><strong>将 Web 层的 bean（如 Controller）注册到 Web 应用上下文中</strong>，这些 bean 应该由 Spring MVC 容器管理。</p></blockquote><p>1.因为功能不同，如何避免Spring错误的加载到SpringMVC的bean——加载Spring控制的bean的时候排除掉SpringMVC控制的bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48eb36fe246fbb47facf7e8f5eb31ff6.png" alt="48eb36fe246fbb47facf7e8f5eb31ff6"></p><p>非常麻烦 –还需要分开加载</p><p>案例、</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f924b648ab257fbefa08c871b796ebb5.png" alt="f924b648ab257fbefa08c871b796ebb5"></p><p>这里就排除加载了springmvc的bean- 我们需要在写一个配置类来导入spirngmvc的bena </p><p>@Configuration<br>@ComponentScan(“com.itheima.controller”)—自动扫描<br>public class SpringMvcConfig {<br>}</p><h4 id="3-springmvc容器的简化开发"><a href="#3-springmvc容器的简化开发" class="headerlink" title="3.springmvc容器的简化开发"></a>3.springmvc容器的简化开发</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b0641d49bc4e25a589d46b048d0c712.png" alt="1b0641d49bc4e25a589d46b048d0c712"></p><h4 id="4-请求响应"><a href="#4-请求响应" class="headerlink" title="4.请求响应"></a>4.请求响应</h4><h6 id="1-请求映射路径"><a href="#1-请求映射路径" class="headerlink" title="1.请求映射路径"></a>1.请求映射路径</h6><p>@RequestMapping</p><p>l设置当前控制器方法请求访问路径，如果设置在类上统一设置当前控制器方法请求访问路径前缀</p><h6 id="2-请求传参"><a href="#2-请求传参" class="headerlink" title="2.请求传参"></a>2.请求传参</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ae8f28c7e68ec356172c7f4f322aabc.png" alt="0ae8f28c7e68ec356172c7f4f322aabc"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5fd3828d3099bff24bbf90834041bff.png" alt="d5fd3828d3099bff24bbf90834041bff"></p><h3 id="2-请求传参-1"><a href="#2-请求传参-1" class="headerlink" title="2.请求传参"></a>2.请求传参</h3><h5 id="1-普通参数"><a href="#1-普通参数" class="headerlink" title="1.普通参数"></a>1.普通参数</h5><p>1.url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数</p><p>2.请求参数名与形参变量名不同，使用@RequestParam绑定参数关系</p><p><strong>@RequestParam</strong>(“name”)String userName </p><h6 id="2-pojo类型参数"><a href="#2-pojo类型参数" class="headerlink" title="2.pojo类型参数"></a>2.pojo类型参数</h6><p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</p><h6 id="3-嵌套pojo参数"><a href="#3-嵌套pojo参数" class="headerlink" title="3.嵌套pojo参数"></a>3.嵌套pojo参数</h6><p>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><h6 id="4-数组类型"><a href="#4-数组类型" class="headerlink" title="4.数组类型"></a>4.数组类型</h6><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数 String[] likes</p><p>l</p><h6 id="5-集合类型-RequestParam"><a href="#5-集合类型-RequestParam" class="headerlink" title="5.集合类型 RequestParam"></a>5.集合类型 RequestParam</h6><p>l集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系</p><p>@RequestParam List<String> likes</p><h4 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2.JSON"></a>2.JSON</h4><p>添加json数据转换相关坐标</p><dependency>  <groupId>com.fasterxml.jackson.core</groupId>  <artifactId>jackson-databind</artifactId>  <version>2.9.0</version> </dependency><p>开启自动转换json数据的支持</p><p>@Configuration<br> @ComponentScan(“com.itheima.controller”)<br> <strong>@EnableWebMvc</strong>@EnableWebMvc注解功能强大，该注解整合了多个功能，此处仅使用其中一部分功能，即json数据进行自动类型转换<br> public class SpringMvcConfig {<br> }</p><h6 id="1-json数组-RequestBody"><a href="#1-json数组-RequestBody" class="headerlink" title="1.json数组 @RequestBody"></a>1.json数组 @RequestBody</h6><p>将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</p><p>@RequestBody List<String> likes</p><h6 id="2-json对象"><a href="#2-json对象" class="headerlink" title="2.json对象"></a>2.json对象</h6><p>json数据与形参对象属性名相同，定义POJO类型形参即可接收参数</p><p>@RequestBody User user</p><h6 id="3-json对象数组"><a href="#3-json对象数组" class="headerlink" title="3.json对象数组"></a>3.json对象数组</h6><p>json数组数据与集合泛型属性名相同，定义List类型形参即可接收参数</p><p>@RequestBody List<User> list</p><h6 id="0-区别"><a href="#0-区别" class="headerlink" title="0.区别"></a>0.区别</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/697f5240f2ca11734b8ddf804fa935bc.png" alt="697f5240f2ca11734b8ddf804fa935bc"></p><h6 id="3-日期传参"><a href="#3-日期传参" class="headerlink" title="3.日期传参"></a>3.日期传参</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/192cc0e58e4cc136b34168f56ccf355a.png" alt="192cc0e58e4cc136b34168f56ccf355a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab3b6686ddb4ec826f2990c1c925d36b.png" alt="ab3b6686ddb4ec826f2990c1c925d36b"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240414172132046.png" alt="image-20240414172132046"></p><h4 id="3-响应传递"><a href="#3-响应传递" class="headerlink" title="3.响应传递"></a>3.响应传递</h4><h6 id="1-文本返回"><a href="#1-文本返回" class="headerlink" title="1.文本返回"></a>1.文本返回</h6><p>  @ResponseBody -不仅仅可以将JSON对应类-还能告诉编译器转的是文本,而不是文件</p><h6 id="2-json返回"><a href="#2-json返回" class="headerlink" title="2.json返回"></a>2.json返回</h6><p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖&#x3D;&#x3D;@ResponseBody&#x3D;&#x3D;注解和&#x3D;&#x3D;@EnableWebMvc&#x3D;&#x3D;注解</p><h6 id="3-响应pojo集合"><a href="#3-响应pojo集合" class="headerlink" title="3.响应pojo集合"></a>3.响应pojo集合</h6><p>开对象-然后存进list集合中-返回list集合 默认返回的就是集合</p><p> List<User> userList &#x3D; new ArrayList<User>();<br>        userList.add(user1);<br>        userList.add(user2);</p><h6 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h6><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;方法\类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法定义上方和控制类上</td></tr><tr><td>作用</td><td>设置当前控制器返回值作为响应体,<br/>写在类上，该类的所有方法都有该注解功能</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>该注解可以写在类上或者方法上</li><li>写在类上就是该类下的所有方法都有@ReponseBody功能</li><li>当方法上有@ReponseBody注解后<ul><li>方法的返回值为字符串，会将其作为文本内容直接响应给前端</li><li>方法的返回值为对象，会将对象转换成JSON响应给前端</li></ul></li></ul><p>此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:</p><ul><li>对象转Json数据(POJO -&gt; json)</li><li>集合转Json数据(Collection -&gt; json)</li></ul><h4 id="Rest风格"><a href="#Rest风格" class="headerlink" title="Rest风格"></a>Rest风格</h4><h6 id="1-rest风格介绍"><a href="#1-rest风格介绍" class="headerlink" title="1.rest风格介绍"></a>1.rest风格介绍</h6><p>传统风格</p><ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul><p>REST</p><ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li><li>根据路径 无法看出对应功能–具有隐私保护性</li><li></li></ul><p>请求的方式比较多，但是比较常用的就4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。</p><p>按照不同的请求方式代表不同的操作类型。</p><ul><li>发送GET请求是用来做查询</li><li>发送POST请求是用来做新增</li><li>发送PUT请求是用来做修改</li><li>发送DELETE请求是用来做删除</li><li></li></ul><p>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范</p><h6 id="2-路径传参-PathVariable"><a href="#2-路径传参-PathVariable" class="headerlink" title="2.路径传参 @PathVariable"></a>2.路径传参 @PathVariable</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置当前请求方法为DELETE，表示REST风格中的删除操作</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/users/&#123;id&#125;/&#123;name&#125;&quot;,method = RequestMethod.DELETE)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id,<span class="hljs-meta">@PathVariable</span> String name)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>@PathVariable</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;形参注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</td></tr></tbody></table><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h4 id="springmvc开发特性"><a href="#springmvc开发特性" class="headerlink" title="springmvc开发特性"></a>springmvc开发特性</h4><h6 id="1-知识点1：-RestController"><a href="#1-知识点1：-RestController" class="headerlink" title="1.知识点1：@RestController"></a>1.知识点1：@RestController</h6><table><thead><tr><th>名称</th><th>@RestController</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>基于SpringMVC的RESTful开发控制器类定义上方</td></tr><tr><td>作用</td><td>设置当前控制器类为RESTful风格，<br/>等同于@Controller与@ResponseBody两个注解组合功能</td></tr></tbody></table><h6 id="知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping"></a>知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping</h6><table><thead><tr><th>名称</th><th align="right">@GetMapping @PostMapping @PutMapping @DeleteMapping</th></tr></thead><tbody><tr><td>类型</td><td align="right">&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td align="right">基于SpringMVC的RESTful开发控制器方法定义上方</td></tr><tr><td>作用</td><td align="right">设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，<br/>例如@GetMapping对应GET请求</td></tr><tr><td>相关属性</td><td align="right">value（默认）：请求访问路径</td></tr></tbody></table><h4 id="Spring-mvc-异常处理机制"><a href="#Spring-mvc-异常处理机制" class="headerlink" title="Spring mvc 异常处理机制"></a>Spring mvc 异常处理机制</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a4c33d1fd830a4bf2508db2f6b98e836.jpeg" alt="a4c33d1fd830a4bf2508db2f6b98e836"></p><p><code>@ControllerAdvice</code> 是一个全局异常处理注解，用于定义一个全局的异常处理类。这个类中的方法可以处理所有控制器中抛出的异常</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler</span>(<span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>)<span class="hljs-comment">//异常捕获</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">handleAllExceptions</span>(<span class="hljs-params"><span class="hljs-title class_">Exception</span> ex</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(<span class="hljs-string">&quot;Handled Exception: &quot;</span> + ex.<span class="hljs-title function_">getMessage</span>(), <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">INTERNAL_SERVER_ERROR</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b59e8bf4c2fbcc6be6fc912192f6f2df.jpg" alt="b59e8bf4c2fbcc6be6fc912192f6f2df"></p><p><code>@ExceptionHandler</code> 是 Spring MVC 提供的一种注解，用于定义处理特定异常的方法。可以在控制器类中使用该注解来捕获和处理特定类型的异常。</p><p>–增强类上指定-异常拦截器处理–基于AOP切面编程实现</p><hr><p>案例处理-如题 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/42419f57ee0003c58e6c059ba4fc1f58.jpeg" alt="42419f57ee0003c58e6c059ba4fc1f58"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b3b21d20c96ae90d732ce3cac09d5f68.jpeg" alt="b3b21d20c96ae90d732ce3cac09d5f68"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2bb0878bbc88b02c0ce024647e49ec70.jpeg" alt="2bb0878bbc88b02c0ce024647e49ec70"></p><p>自写异常-根据异常严重程度来进行对应的出来</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6241b3e5f0b6762d7a7166eac8e101ba.jpeg" alt="6241b3e5f0b6762d7a7166eac8e101ba"></p><p>抛出异常</p><p>拦截处理异常</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4cc146a7a81d28def5a9f72534f22ad3.jpeg" alt="4cc146a7a81d28def5a9f72534f22ad3"></p><h4 id="Springmvc-拦截器"><a href="#Springmvc-拦截器" class="headerlink" title="Springmvc -拦截器"></a>Springmvc -拦截器</h4><p> Spring MVC 中，拦截器（Interceptor）是一种用于对请求进行预处理和后处理的机制。拦截器类似于 Servlet 的过滤器（Filter），但提供了更灵活和强大的功能。它们可以用于权限检查、日志记录、性能监控等场景。</p><hr><p>Spring MVC 的拦截器基于 <code>HandlerInterceptor</code> 接口，它允许我们在处理 HTTP 请求的过程中插入自定义的逻辑。拦截器可以在以下三个阶段执行：</p><ol><li><strong>预处理阶段（preHandle）</strong>：在请求到达控制器之前执行。</li><li><strong>后处理阶段（postHandle）</strong>：在请求被控制器处理之后，但在视图渲染之前执行。</li><li><strong>完成后处理阶段（afterCompletion）</strong>：在整个请求完成之后执行，通常用于资源清理。</li></ol><h6 id="1-拦截器案例"><a href="#1-拦截器案例" class="headerlink" title="1.拦截器案例"></a>1.拦截器案例</h6><p>1.声明拦截器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/50fccfc54a1ef08467fab507b7fbce62.jpeg" alt="50fccfc54a1ef08467fab507b7fbce62"></p><p>实现HandlerInt接口</p><p>–</p><blockquote><p>在 Spring Boot 或 Spring MVC 的 Java 配置中，可以通过实现 <code>WebMvcConfigurer</code> 接口的 <code>addInterceptors</code> 方法来添加拦截器</p></blockquote><p>添加拦截器指定路径</p><p>在 Spring Boot 或 Spring MVC 的 Java 配置中，可以通过实现 <code>WebMvcConfigurer</code> 接口的 <code>addInterceptors</code> 方法来添加拦截器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>) &#123;<br>        <span class="hljs-comment">// 注册自定义的拦截器，并指定拦截路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截所有请求</span><br>                .<span class="hljs-title function_">excludePathPatterns</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/error&quot;</span>); <span class="hljs-comment">// 排除某些路径不拦截</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>addInterceptors(InterceptorRegistry registry)</code>：添加拦截器的方法。</p><p><code>addInterceptor(new MyInterceptor())</code>：注册自定义拦截器。</p><p><code>addPathPatterns(&quot;/**&quot;)</code>：设置拦截器拦截的路径模式，例如，<code>/**</code> 表示拦截所有请求。</p><p><code>excludePathPatterns(&quot;/login&quot;, &quot;/error&quot;)</code>：设置不需要拦截的路径模式，例如登录页和错误页。</p><h6 id="2-拦截器流程"><a href="#2-拦截器流程" class="headerlink" title="2.拦截器流程"></a>2.拦截器流程</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4caa6002de9cae7bb61d1f4dc79fbf40.jpeg" alt="4caa6002de9cae7bb61d1f4dc79fbf40"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d63b5afd7e7aaff800a0a7fa06a00c25.jpeg" alt="d63b5afd7e7aaff800a0a7fa06a00c25"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/267baa636fd682717e63a956def32ec5.jpeg" alt="267baa636fd682717e63a956def32ec5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4b425f5665648fd64d2371a8e70aa4b7.jpeg" alt="4b425f5665648fd64d2371a8e70aa4b7"></p><h6 id="3-多拦截器"><a href="#3-多拦截器" class="headerlink" title="3.多拦截器"></a>3.多拦截器</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4698693771084332a51d147c5cdd2e7.jpeg" alt="c4698693771084332a51d147c5cdd2e7"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>) &#123;<br>        <span class="hljs-comment">// 注册第一个拦截器，拦截所有路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>);<br><br>        <span class="hljs-comment">// 注册第二个拦截器，拦截所有路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>addInterceptor()</code> 方法按顺序注册拦截器，Spring MVC 将按照注册顺序执行这些拦截器的 <code>preHandle()</code> 方法，<code>postHandle()</code> 和 <code>afterCompletion()</code> 方法则按相反顺序执行。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95d7648e9ae71b1f8e4a5ccf424adb04.jpeg" alt="95d7648e9ae71b1f8e4a5ccf424adb04"></p><h6 id="4-基于AOP实现拦截器"><a href="#4-基于AOP实现拦截器" class="headerlink" title="4.基于AOP实现拦截器"></a>4.基于AOP实现拦截器</h6><p><strong>MVC 拦截器</strong>：基于 <code>HandlerInterceptor</code> 接口，可以在处理 HTTP 请求的生命周期的特定点执行代码。适用于 Web 层的请求预处理和后处理。</p><p>使用 AOP 实现类似的拦截功能，可以在控制器方法执行前后插入一些通用的逻辑。使用 AOP 可以更灵活地选择何时何地应用这些逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>   <br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">annotatedMethod</span><span class="hljs-params">(CustomAnnotation customAnnotation)</span> &#123;&#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">   这个切入点表达式 `@annotation(customAnnotation)` 的作用是匹配所有被 `@CustomAnnotation` 注解标记的方法。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">`@annotation(customAnnotation)` 是 AspectJ 提供的一个语法，用来匹配方法级别的注解。这里，`customAnnotation` 是一个参数，它表示目标方法上使用的 `@CustomAnnotation`。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">同时`annotatedMethod` f方法的主要用处是可以在通知（Advice）方法中使用一个更清晰、易读的命名标识来引用切入点。*/</span><br><br>    <span class="hljs-comment">// 在控制器中的任何方法执行之前执行</span><br>    <span class="hljs-meta">@Before(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeControllerMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之前执行的逻辑&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在控制器方法执行之后执行</span><br>    <span class="hljs-meta">@After(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterControllerMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之后执行的逻辑&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知，可以在方法执行前后都进行拦截</span><br>    <span class="hljs-meta">@Around(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundControllerMethod</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之前执行的逻辑&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();  <span class="hljs-comment">// 执行目标方法</span><br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之后执行的逻辑&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">public <span class="hljs-keyword">@interface</span> CustomAnnotation &#123;<br>    String <span class="hljs-built_in">value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="WebApplicationContext探究"><a href="#WebApplicationContext探究" class="headerlink" title="WebApplicationContext探究"></a>WebApplicationContext探究</h4><blockquote><p><code>WebApplicationContext</code> 是一个容器类，它是 Spring 框架中专门用于 Web 应用程序的应用上下文（<code>ApplicationContext</code>）接口的扩展。</p><h3 id="什么是-WebApplicationContext？"><a href="#什么是-WebApplicationContext？" class="headerlink" title="什么是 WebApplicationContext？"></a>什么是 <code>WebApplicationContext</code>？</h3><p><code>WebApplicationContext</code> 是 Spring 框架中的一个接口，它继承了 <code>ApplicationContext</code> 接口，并添加了特定于 Web 应用程序的功能。它提供了一些额外的方法和功能来处理 Web 应用程序的特定需求，例如管理与 Servlet、过滤器和监听器相关的 Web 组件。</p><h3 id="WebApplicationContext-的特点"><a href="#WebApplicationContext-的特点" class="headerlink" title="WebApplicationContext 的特点"></a><code>WebApplicationContext</code> 的特点</h3><ol><li><p>**扩展 <code>ApplicationContext</code>**：</p><ul><li><code>WebApplicationContext</code> 继承自 <code>ApplicationContext</code>，而 <code>ApplicationContext</code> 是 Spring 的核心容器接口，用于管理和配置应用程序中的 bean。<code>ApplicationContext</code> 提供了 Spring IoC 容器的基本功能，如依赖注入、事件发布、国际化支持等。</li><li><code>WebApplicationContext</code> 是 <code>ApplicationContext</code> 的一个特化版本，增加了与 Web 环境相关的特性。</li></ul></li><li><p><strong>面向 Web 应用程序</strong>：</p><ul><li><pre><code class="hljs">WebApplicationContext</code></pre><p> 是为 Web 应用程序设计的，它能够处理 Web 相关的上下文信息，例如：</p><ul><li><strong>ServletContext</strong>：<code>WebApplicationContext</code> 可以访问 Servlet 容器的 <code>ServletContext</code>，这使它能够与 Servlet API 集成，并提供与 Web 容器的交互能力。</li><li><strong>会话作用域和请求作用域</strong>：<code>WebApplicationContext</code> 支持 Web 特定的作用域（如会话作用域和请求作用域），这对于 Web 应用程序非常有用。</li></ul></li></ul></li><li><p><strong>Web 应用程序的根上下文</strong>：</p><ul><li>在典型的 Spring Web 应用程序中，<code>WebApplicationContext</code> 通常是应用程序的根上下文（Root Context），它在 Web 应用程序启动时由 Spring 的前端控制器 <code>DispatcherServlet</code> 或 <code>ContextLoaderListener</code> 创建。</li><li>它管理 Web 应用程序的所有 bean，包括控制器、服务层组件、数据访问层组件等。</li></ul></li></ol><h3 id="WebApplicationContext-的具体实现类"><a href="#WebApplicationContext-的具体实现类" class="headerlink" title="WebApplicationContext 的具体实现类"></a><code>WebApplicationContext</code> 的具体实现类</h3><p>在 Spring 中，<code>WebApplicationContext</code> 有多个实现类，其中最常用的是：</p><ol><li><p><code>XmlWebApplicationContext</code></p><p>：</p><ul><li>基于 XML 配置文件的 <code>WebApplicationContext</code> 实现，它从指定的 XML 文件中加载 bean 定义。</li></ul></li><li><p><code>AnnotationConfigWebApplicationContext</code></p><p>：</p><ul><li>基于 Java 注解的 <code>WebApplicationContext</code> 实现，通常用于配置类（使用 <code>@Configuration</code> 注解的类）而非 XML 文件的方式进行 bean 定义的加载。</li></ul></li><li><p><code>GenericWebApplicationContext</code></p><p>：</p><ul><li>通用的 <code>WebApplicationContext</code> 实现，它既可以从 XML 文件加载配置，也可以使用注解或其他方式加载配置。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>WebApplicationContext</code> 是一个面向 Web 的 Spring 容器类，它继承了 <code>ApplicationContext</code> 并扩展了与 Web 相关的功能。它能够管理 Web 应用程序的 bean，处理与 Web 环境相关的上下文信息，并与 Servlet 容器紧密集成。因此，<code>WebApplicationContext</code> 是 Spring Web 应用程序中非常重要的容器类。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构概论 01</title>
    <link href="/2024/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构概论"><a href="#数据结构概论" class="headerlink" title="数据结构概论"></a>数据结构概论</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章-概述"></a>第一章-概述</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><h5 id="1-1-1-什么是数据结构"><a href="#1-1-1-什么是数据结构" class="headerlink" title="1.1.1:什么是数据结构"></a>1.1.1:什么是数据结构</h5><blockquote><h4 id="数据与信息"><a href="#数据与信息" class="headerlink" title="数据与信息"></a>数据与信息</h4><ul><li><strong>数据</strong>是信息的载体，可以被计算机识别、存储和加工处理。数据包括文字、表格、图像等形式。</li><li><strong>信息</strong>是数据的内涵，即数据所表达的意义。例如，成绩单中某次考试的成绩是数据，但平均分就是信息。</li></ul><h4 id="数据元素和数据项"><a href="#数据元素和数据项" class="headerlink" title="数据元素和数据项"></a>数据元素和数据项</h4><ul><li><strong>数据元素</strong>是数据的基本单位（有时称为元素、结点或记录等），通常作为一个整体进行处理。例如，一个学生的成绩单包含了若干个数据元素。</li><li><strong>数据对象</strong>是具有相同类型的数据元素的集合。</li><li><strong>数据项</strong>是数据元素的不可分割的最小标识单元。例如，一个学生记录可以包含姓名、学号等数据项。</li></ul><h4 id="数据的结构"><a href="#数据的结构" class="headerlink" title="数据的结构"></a>数据的结构</h4><ul><li>数据的结构化表示方式便于数据的存储和处理。在数据结构中，除非特别指明，数据通常都是数据对象。</li></ul><p>：</p><h3 id="数据结构的定义和内容"><a href="#数据结构的定义和内容" class="headerlink" title="数据结构的定义和内容"></a>数据结构的定义和内容</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素不是孤立存在的，而是相互之间通过某种关系连接，形成一个整体结构。数据结构的主要内容包括以下三个方面：</p><ol><li><strong>逻辑结构</strong>：描述数据元素之间的逻辑关系，是数据结构的抽象形式。逻辑结构通常通过图形表示，例如线性结构、树形结构和图结构等。</li><li><strong>存储结构</strong>：也称为“物理结构”或“存储映像”，是将数据的逻辑结构映射到计算机存储器中的形式。数据的存储结构决定了数据在计算机内存中的布局方式，包括顺序存储、链式存储等。</li><li><strong>数据运算</strong>：指的是在数据结构上进行的各种操作，是数据结构的功能体现。例如，常见的数据操作包括查找、插入、删除、排序等。这些操作通常是通过特定的算法在存储结构上实现的。</li></ol></blockquote><h5 id="1-1-2-逻辑结构探究"><a href="#1-1-2-逻辑结构探究" class="headerlink" title="1.1.2 逻辑结构探究"></a>1.1.2 逻辑结构探究</h5><blockquote><h3 id="逻辑结构的定义"><a href="#逻辑结构的定义" class="headerlink" title="逻辑结构的定义"></a>逻辑结构的定义</h3><ul><li><p><strong>逻辑结构</strong>是指数据元素之间的逻辑关系，它表示数据元素之间如何相互关联。逻辑结构不涉及数据在计算机中的存储方式，只描述数据元素之间的关系。</p></li><li><h3 id="逻辑结构的四种类型"><a href="#逻辑结构的四种类型" class="headerlink" title="逻辑结构的四种类型"></a>逻辑结构的四种类型</h3><ol><li><p><strong>集合结构</strong>：所有数据元素之间没有任何关系。</p></li><li><p><strong>线性结构</strong>：所有数据元素之间存在一对一的关系。</p></li><li><p><strong>树形结构</strong>：数据元素之间存在一对多的层次关系。</p></li><li><p><strong>图形结构</strong>（网状结构）：数据元素之间存在多对多的任意关系。</p><h3 id="逻辑结构的表示方法-书中是公式"><a href="#逻辑结构的表示方法-书中是公式" class="headerlink" title="逻辑结构的表示方法-书中是公式"></a>逻辑结构的表示方法-书中是公式</h3><ul><li><p><strong>线性结构（Linear Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间具有一对一的关系，即每个数据元素除了第一个和最后一个之外，都有唯一的前驱和后继。常见的线性结构有数组、链表、栈和队列等。</li><li><strong>特点</strong>：数据按照一定的顺序排成一条直线，每个元素只有一个前驱和一个后继（除第一个和最后一个元素）。</li><li><strong>例子</strong>：数组是一种典型的线性结构，数据元素按顺序存储在内存中，元素之间的关系通过索引来表示。</li></ul><p><strong>树形结构（Tree Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间具有一对多的层次关系。树形结构中，每个元素称为“节点”，顶层节点称为“根节点”，其余节点有且仅有一个父节点，可能有多个子节点。</li><li><strong>特点</strong>：数据以层级形式组织，每个节点有一个父节点和零个或多个子节点，除了根节点外，每个节点只有一个父节点。</li><li><strong>例子</strong>：二叉树是一种常见的树形结构，其中每个节点最多有两个子节点（左子节点和右子节点）。</li></ul><p><strong>图形结构（Graph Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间可以有任意多的关系，数据元素称为“节点”或“顶点”，它们之间的关系称为“边”。</li><li><strong>特点</strong>：数据元素之间的关系不再是简单的一对一或一对多，可以是多对多的关系。图可以是有向的或无向的，有环的或无环的。</li><li><strong>例子</strong>：社交网络中的好友关系可以用图来表示，用户是节点，好友关系是边。</li></ul><p><strong>逻辑表示</strong>：学生按学号从小到大排列，每个学生只有一个前驱和一个后继（除了第一个和最后一个）。这种逻辑表示方式告诉我们数据元素的相对关系和结构。</p><p><strong>物理表示</strong>：在计算机中，可以用一个数组来顺序存储这些学生信息，或者用一个链表来链式存储这些学生信息。</p></li><li><p><strong>逻辑结构图的表示</strong></p></li><li><p>：</p><ul><li>数据逻辑结构可以通过二元组 (D,R)(<em>D</em>,<em>R</em>) 来表示，其中 D<em>D</em> 是数据元素的集合，R<em>R</em> 是数据元素之间的逻辑关系集合。</li></ul></li><li><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf1f08b63104c88f692a527f21308624.png" alt="cf1f08b63104c88f692a527f21308624"></p></li></ul></li></ol></li></ul></blockquote><blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/53667aed05cf29e331afb013cad99845.png" alt="53667aed05cf29e331afb013cad99845"></p></blockquote><h4 id="1-1-3-存储结构探究"><a href="#1-1-3-存储结构探究" class="headerlink" title="1.1.3 存储结构探究"></a>1.1.3 存储结构探究</h4><h6 id="存储结构定义"><a href="#存储结构定义" class="headerlink" title="存储结构定义"></a><strong>存储结构定义</strong></h6><blockquote><ol><li><h6 id="存储结构定义："><a href="#存储结构定义：" class="headerlink" title="存储结构定义："></a><strong>存储结构定义</strong>：</h6><ul><li>数据的存储结构是指数据逻辑结构在计算机存储器中的表示，它也被称为物理结构。</li></ul></li></ol></blockquote><ol><li><blockquote><p><strong>存储结构与逻辑结构的关系</strong>：</p><ul><li>同一种逻辑结构可以设计成多种不同的存储结构。</li><li>在不同的存储结构中，实现相同运算的算法可能会有所不同。</li></ul></blockquote></li><li><blockquote><p><strong>逻辑结构、存储结构和运算之间的关系</strong>：</p><ul><li>逻辑结构通过映射到存储结构，进而实现具体的运算。</li><li>运算定义和运算实现之间存在映射关系，逻辑结构是运算定义的基础，而存储结构是运算实现的基础。</li></ul></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/37a0f47f6721fdf22db0eb82ac7865b2.png" alt="37a0f47f6721fdf22db0eb82ac7865b2"></p><h6 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h6><p><img src="https://majorli.github.io/algo_guide/_images/311_sequence_list.png" alt="../../_images/311_sequence_list.png"></p><p>顺序存储结构通过连续存储单元实现数据的逻辑结构映射，具有存储空间节省和快速随机存取的优点，但同时也存在修改不便的缺点。这种存储方式适用于数据元素数量固定或变动较少的场景。</p><ol><li><strong>顺序存储结构定义</strong>：<ul><li>顺序存储结构是使用一组连续的存储单元来存放所有数据元素，其中逻辑上相邻的元素在物理存储上也是相邻的。</li><li>元素之间的逻辑关系通过存储单元地址的相邻关系隐含表示，即将数据的逻辑结构直接映射到存储结构。</li></ul></li><li><strong>顺序存储结构的实现示例</strong>：<ul><li>以“Score”逻辑结构为例，假设每个元素占用30字节（B），从100号存储单元开始，按低地址到高地址方向存储。</li></ul></li><li><strong>顺序存储结构的优点</strong>：<ul><li><strong>节省存储空间</strong>：分配给数据的存储单元全部用于存放元素值，元素之间的逻辑关系表示不占用额外存储空间。</li><li><strong>随机存取</strong>：可以实现对数据元素的快速随机存取。给定元素的逻辑序号，可以在常量时间内查找到对应的元素值。</li></ul></li><li><strong>随机存取的计算公式</strong>：<ul><li>存储地址计算公式为： LOC(ai)&#x3D;p+(i−1)×k<em>L**OC</em>(<em>a**i</em>)&#x3D;<em>p</em>+(<em>i</em>−1)×<em>k</em></li><li>其中，k<em>k</em> 是每个元素所占的存储单元数，p<em>p</em> 是第一个元素所占存储单元的首地址。</li></ul></li><li><strong>顺序存储结构的缺点</strong>：<ul><li><strong>不便于修改</strong>：在进行元素的插入或删除操作时，可能需要移动一系列元素，这在大规模数据操作时效率较低。</li></ul></li></ol><blockquote><p>ArrayList- Vector CopyOnWriteArrayList</p><p>如上都实现了 <code>List</code> 接口，并具有顺序访问的特点。</p></blockquote><h6 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h6><p><img src="https://majorli.github.io/algo_guide/_images/317_linkedlist.png" alt="../../_images/317_linkedlist.png"></p><ol><li><blockquote><p><strong>链式存储结构定义</strong>：</p><ul><li>链式存储结构不要求所有元素在内存中连续存放，每个节点独立存储，不需要占用一整块连续的存储空间。</li><li>为了表示节点之间的关系，每个节点包含一个或多个指针字段，用于存放相邻节点的存储地址。</li></ul></blockquote></li></ol><blockquote><ol><li><strong>链式存储结构的优点</strong>：<ul><li><strong>便于修改</strong>：在进行插入、删除操作时，只需修改节点的指针域，不需要移动节点本身。</li></ul></li><li><strong>链式存储结构的缺点</strong>：<ul><li><strong>存储空间利用率较低</strong>：分配给数据元素的存储单元中有一部分被用来存放节点之间的逻辑关系。</li><li><strong>不能进行随机存取</strong>：由于逻辑上相邻的节点在存储器中不一定相邻，因此不能对节点进行随机存取。</li></ul></li></ol></blockquote><p>LinkedList  双向链表</p><p>ConcurrentLinkedQueue  线程安全的非阻塞队列 </p><p><strong><code>LinkedBlockingQueue</code></strong> 和 <strong><code>LinkedBlockingDeque</code></strong></p><h6 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h6><ol><li><p><strong>索引存储结构定义</strong>：</p><ul><li>索引存储结构是在存储数据（主数据表）的同时，建立一个附加的索引表。</li><li>索引表中的每一项称为索引项，通常包含关键字和对应的地址。</li></ul></li><li><p><strong>索引项的一般形式</strong>：</p><ul><li>索引项的一般形式为：(关键字, 对应地址)</li><li>索引表中的关键字有序排列（如递增），每个关键字的对应地址指向该关键字记录在数据表中的存储地址。</li></ul></li><li><p><strong>索引存储结构的查找过程</strong>：</p><ul><li>在进行关键字（如学号）查找时，先在索引表中快速查找（因为索引表中按关键字有序排列，可以采用二分查找）到相应的关键字。</li><li>然后通过对应地址在数据表中找到该记录的数据。</li></ul></li><li><p><strong>索引存储结构的优点</strong>：</p><ul><li><strong>查找效率高</strong>：由于索引表中关键字有序排列，可以采用二分查找等高效查找算法。</li></ul></li><li><p><strong>索引存储结构的缺点</strong>：</p><ul><li><strong>增加时间和空间开销</strong>：需要建立索引表，从而增加了存储空间的开销。</li><li><strong>维护成本</strong>：在数据表更新（插入、删除、修改）时，需要同步更新索引表，增加了维护成本。</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2efbc94f98d8f0fe441857b7f84d636d.png" alt="2efbc94f98d8f0fe441857b7f84d636d"></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2022080309560424.jpg" alt="img"></p><p><strong><code>HashMap</code></strong> &#x2F; <strong><code>TreeMap</code></strong>  键可以视作索引，值为实际数据类似</p><h6 id="哈希结构"><a href="#哈希结构" class="headerlink" title="哈希结构"></a>哈希结构</h6><ol><li><p><strong>哈希存储结构定义</strong>：</p><ul><li>哈希存储结构根据元素的关键字来确定其存储地址。</li><li>通过哈希函数 H(key)<em>H</em>(<em>k**ey</em>)（或散列函数）计算关键字对应的函数值，该函数值用作元素的存储地址。</li></ul></li><li><p><strong>哈希函数的选择</strong>：</p><ul><li><p>以学号作为自变量，选择一个合适的哈希函数，例如 h(学号)&#x3D;学号−201201<em>h</em>(学号)&#x3D;学号−201201。</p></li><li></li></ul></li><li><p><strong>哈希存储结构的查找过程</strong>：</p><ul><li>要查找学号为 id<em>i**d</em> 的学生记录，只需计算 h(id)<em>h</em>(<em>i**d</em>)，以它为地址在哈希表中直接找到该学号的学生记录。</li></ul></li><li><p><strong>哈希存储结构的优点</strong>：</p><ul><li><strong>查找速度快</strong>：只要给出待查找节点的关键字，就可以立即计算出对应记录的存储地址。</li><li><strong>存储效率高</strong>：只存储数据元素本身，不存储数据元素之间的逻辑关系。</li></ul></li><li><p><strong>哈希存储结构的缺点</strong>：</p><ul><li><strong>冲突处理</strong>：不同的关键字可能通过哈希函数计算得到相同的地址，需要处理这种“冲突”。</li><li><strong>哈希函数的选择</strong>：选择合适的哈希函数和冲突解决策略是关键。</li></ul></li><li><p><strong>哈希存储结构的应用场合</strong>：</p><ul><li>适用于要求对数据能够进行快速查找、插入的场合。</li></ul></li></ol><p><code>HashMap</code> 和 <code>HashSet</code> 提供了基础的哈希功能；<code>LinkedHashMap</code> 和 <code>LinkedHashSet</code> 在保证哈希效率的同时维护插入顺序；<code>ConcurrentHashMap</code> 提供线程安全的哈希表实现，而 <code>WeakHashMap</code> 和 <code>IdentityHashMap</code> 提供了特定应用场景的支持。</p><h4 id="1-14-数据运算"><a href="#1-14-数据运算" class="headerlink" title="1.14 数据运算"></a>1.14 数据运算</h4><blockquote><ol><li><strong>数据运算的定义</strong>：<ul><li>数据运算是施加于数据的操作，它包括对数据进行的各种处理活动。</li></ul></li><li><strong>运算的两个部分</strong>： <strong>分离思想</strong><ul><li><strong>运算定义</strong>：描述运算的功能和目的，是抽象的描述，不涉及具体的实现细节。</li><li><strong>运算实现</strong>：在特定的数据存储结构上设计算法来实现这些运算，是具体的实现步骤。</li></ul></li></ol></blockquote><h4 id="1-15-数据结构-数据类型-和抽象数据类型"><a href="#1-15-数据结构-数据类型-和抽象数据类型" class="headerlink" title="1.15 数据结构  数据类型 和抽象数据类型"></a>1.15 数据结构  数据类型 和抽象数据类型</h4><h6 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h6><p>数据结构 :带结构的数据元素的集合 包含数据逻辑 存储逻辑 运算运算逻辑</p><h6 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h6><p>数据类型显示或隐式的定义了数据的存储格式 数据范围 允许进行的计算</p><p>1.c++基本数据类型</p><p>省</p><p>2.指针类型</p><p>int * a&#x3D;&b; -&gt;   b(地址)-&gt;123(真实数据)</p><p>int ** &#x3D;&a; 嵌套类-不知道行不行</p><p>3.c++数组类型</p><p>int a[10];</p><p>4.结构体类型</p><p>struct t{</p><p>int a;</p><p>char a;</p><p>}</p><p>集体占的大小还要适配内存对齐-防止缓存失效解决</p><p>5.共用体类型</p><p>省</p><p>6.自定义类型</p><p>typedef struct ttudent{<br>}studtype</p><p>别名 -&gt;根结构体差不多</p><h6 id="3-抽象数据类型"><a href="#3-抽象数据类型" class="headerlink" title="3.抽象数据类型"></a>3.抽象数据类型</h6><p>抽象数据类型是一种数据模型的抽象，描述了数据类型的操作和功能，而不关心其具体实现。ADT提供了一组操作和数学模型，用于定义数据类型的行为和性质。ADT定义时包含了操作的逻辑及功能描述，具体实现则留给程序设计者。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dcc57cf60c33af3dd920d15376ccad4a.png" alt="dcc57cf60c33af3dd920d15376ccad4a"></p><p>ps:说白了就是想像一个结构体出来-但是没有具体实现</p><h4 id="1-1-总结"><a href="#1-1-总结" class="headerlink" title="1.1 总结"></a>1.1 总结</h4><p>概念上的东西，没刷题不知道-但是非常概念的就是-抽象数据类型 数据运算 概述和数据结构</p><h3 id="1-2-算法和算法分析"><a href="#1-2-算法和算法分析" class="headerlink" title="1.2 算法和算法分析"></a>1.2 算法和算法分析</h3><h4 id="1-2-1算法及描述"><a href="#1-2-1算法及描述" class="headerlink" title="1.2.1算法及描述"></a>1.2.1算法及描述</h4><h6 id="1-算法特性"><a href="#1-算法特性" class="headerlink" title="1.算法特性"></a>1.算法特性</h6><p>算法-对特定问题求解步骤的描述</p><p>算法设计满足目标</p><p><strong>正确性</strong>：算法必须能够正确执行其规定的功能和性能要求，这是最重要的标准。</p><p><strong>可使用性</strong>：算法应易于理解和使用，即具有用户友好性。</p><p><strong>可读性</strong>：算法应该便于人的理解，逻辑必须明确、简单、结构良好。</p><p><strong>健壮性</strong>：算法应具备很好的容错能力，即使遇到异常数据，也能处理或防止崩溃。</p><p><strong>高效性与低存储性</strong>：算法应在执行时间和存储空间上高效，对同一问题，算法的效率越高越好，同时要求其存储消耗低。</p><p>算法特性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4a5032bae80dd2445ae8a06cb1ea232e.png" alt="4a5032bae80dd2445ae8a06cb1ea232e"></p><h6 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2.算法描述"></a>2.算法描述</h6><p>算法描述:算法可由多种语言来描述-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7121e96e74080a4416b2c76d17c7908a.png" alt="7121e96e74080a4416b2c76d17c7908a"></p><p>如上-代码-s&#x3D;s+i-&gt;修改是地址的值-栈压得值-可修改call栈外的局部变量-</p><p>ps:前提是s&#x3D;s+1-是对外部指针指向的数据操作-而不是拷贝了一份-(cpp好久没看过了)</p><p>这里应该表面 -算法的输入 输出 是s-同一个吗-不知道，文字太多不想看</p><h4 id="1-2-3算法分析"><a href="#1-2-3算法分析" class="headerlink" title="1.2.3算法分析"></a>1.2.3算法分析</h4><h6 id="1-算法时间复杂度"><a href="#1-算法时间复杂度" class="headerlink" title="1.算法时间复杂度"></a>1.算法时间复杂度</h6><p><strong>时间复杂度</strong>（Time Complexity）是用来估计一个算法运行时间的一个指标，表示算法执行所需时间相对于输入规模的增长关系。它反映了算法随着输入数据量增大，运行时间增加的情况。</p><p>时间复杂度通常使用大O符号（Big O Notation）表示，如 <code>O(1)</code>、<code>O(n)</code>、<code>O(n^2)</code> 等。大O符号描述了最坏情况下算法的运行时间。</p><p>常见时间复杂度及其含义</p><ol><li><p><strong>O(1) - 常数时间复杂度</strong></p><ul><li><p>算法的执行时间不依赖于输入数据的规模。例如，访问数组中的某个元素。</p></li><li><p>示例：<code>a = array[5]</code> 这个操作总是执行一个步骤，因此时间复杂度是 <code>O(1)</code>。</p></li><li><p>2.<strong>O(n) - 线性时间复杂度</strong></p></li><li><p>算法的执行时间随着输入数据的规模 <code>n</code> 线性增长。也就是说，输入数据翻倍，运行时间也会翻倍。</p></li><li><p>示例：一个简单的 <code>for</code> 循环遍历 <code>n</code> 个元素。</p></li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">python</span>复制代码<span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-variable">n</span>):</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>O(n^2) - 二次时间复杂度</strong></p><ul><li>算法的执行时间与输入规模的平方成正比。通常出现在嵌套循环中，外层和内层都循环 <code>n</code> 次。</li><li>示例：双重嵌套循环遍历二维数组。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python复制代码<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">i</span>, j)<br></code></pre></td></tr></table></figure><p>O(log n) - 对数时间复杂度</p><ul><li>算法的执行时间随着输入数据的规模呈对数增长，通常出现在“二分”算法中，比如二分查找。每次操作将问题规模减半。</li><li>示例：在一个排序数组中查找元素的位置。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LogarithmicTimeExample &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> result = binarySearch(<span class="hljs-keyword">array</span>, target);<br>        <br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Element not found.&quot;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Element found at index: &quot; + result);<br>        &#125;<br>    &#125;<br><br>    // 二分查找实现<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> binarySearch(<span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span>, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-keyword">array</span>.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span>[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span>[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; // 未找到目标元素<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>O(n log n) - 线性对数时间复杂度</strong></p><ul><li><p>常见于高效的排序算法，如快速排序（Quick Sort）和归并排序（Merge Sort）。它的时间复杂度是 <code>n</code> 和 <code>log n</code> 的乘积。</p></li><li><p>示例：归并排序。</p></li><li><pre><code class="hljs">import java.util.Arrays;public class MergeSortExample &#123;    public static void main(String[] args) &#123;        int[] array = &#123;38, 27, 43, 3, 9, 82, 10&#125;;        mergeSort(array, 0, array.length - 1);        System.out.println(&quot;Sorted array: &quot; + Arrays.toString(array));    &#125;    // 归并排序算法    public static void mergeSort(int[] array, int left, int right) &#123;        if (left &lt; right) &#123;            int mid = (left + right) / 2;            mergeSort(array, left, mid); // 递归排序左半部分            mergeSort(array, mid + 1, right); // 递归排序右半部分            merge(array, left, mid, right); // 合并两部分        &#125;    &#125;    // 合并两个子数组的函数    public static void merge(int[] array, int left, int mid, int right) &#123;        int n1 = mid - left + 1;        int n2 = right - mid;        int[] leftArray = new int[n1];        int[] rightArray = new int[n2];        for (int i<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br>**O(<span class="hljs-number">2</span>^<span class="hljs-built_in">n</span>) - 指数时间复杂度**<br><br>- 随着输入规模增加，算法运行时间以指数方式增长。通常出现在解决递归问题（如斐波那契数列）时。<br><br>- 示例：递归计算斐波那契数列。<br><br>- ```<br>  def fibonacci(<span class="hljs-built_in">n</span>)<span class="hljs-symbol">:</span><br>      <span class="hljs-built_in">if</span> <span class="hljs-built_in">n</span> &lt;= <span class="hljs-symbol">1:</span><br>          return <span class="hljs-built_in">n</span><br>      el<span class="hljs-symbol">se:</span><br>          return fibonacci(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + fibonacci(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>)<br>  <br></code></pre></td></tr></table></figure>  **O(n!) - 阶乘时间复杂度**  最糟糕的时间复杂度，通常出现在解决组合问题时，如全排列生成或旅行商问题（TSP）。  示例：生成一个数组的所有排列。</code></pre></li></ul><p>如何计算时间复杂度</p><ol><li><strong>分析算法的基本操作</strong>：找出算法中最常执行的基本操作（如循环中的一次迭代）。</li><li><strong>确定基本操作的执行次数</strong>：计算该操作在最坏情况下的执行次数。</li><li><strong>去掉低阶项和常数</strong>：只关注增长速度最快的项，并忽略常数因子（如 <code>5n</code> 和 <code>n</code> 都视为 <code>O(n)</code>）。</li></ol><p>总结 </p><p><strong>O(1)</strong> - 常数时间复杂度</p><p><strong>O(log n)</strong> - 对数时间复杂度</p><p><strong>O(n)</strong> - 线性时间复杂度</p><p><strong>O(n log n)</strong> - 线性对数时间复杂度</p><p><strong>O(n^2)</strong> - 二次时间复杂度</p><p><strong>O(n^3)</strong> - 三次时间复杂度</p><p><strong>O(2^n)</strong> - 指数时间复杂度</p><p><strong>O(n!)</strong> - 阶乘时间复杂度</p><p>案例:<a href="https://www.cnblogs.com/Agtw/p/17173051.html">https://www.cnblogs.com/Agtw/p/17173051.html</a> -</p><h6 id="2-算法空间复杂度"><a href="#2-算法空间复杂度" class="headerlink" title="2.算法空间复杂度"></a>2.算法空间复杂度</h6><p>1.空间复杂度<br>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。空间复杂度不是程序占用<br>了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计<br>算规则基本跟实践复杂度类似，也使用大O渐进表示法.-<br>就是一段函数在堆栈中开辟的堆栈大小</p><p><strong>空间复杂度</strong>衡量了算法所需的额外内存空间，帮助我们理解和优化程序的内存使用。</p><p>选择合适的算法时，既要考虑时间复杂度，也要考虑空间复杂度，特别是在处理大规模数据或资源有限的情况下。</p><p><strong>O(1)</strong> - 常数空间复杂度</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan">public <span class="hljs-type">int</span> findMax(<span class="hljs-type">int</span>[] <span class="hljs-type">array</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-type">array</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// O(1) 空间复杂度，仅使用一个额外变量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-type">array</span>.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">array</span>[i] &gt; <span class="hljs-built_in">max</span>) &#123;<br>            <span class="hljs-built_in">max</span> = <span class="hljs-type">array</span>[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>O(log n)</strong> - 对数空间复杂度</p><p><strong>O(n)</strong> - 线性空间复杂度\</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title function_ invoke__">copyArray</span>(<span class="hljs-keyword">int</span>[] <span class="hljs-keyword">array</span>) &#123;<br>    <span class="hljs-keyword">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">array</span>.length]; <span class="hljs-comment">// O(n) 空间复杂度，因需分配与输入规模相同的空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">array</span>.length; i++) &#123;<br>        newArray[i] = <span class="hljs-keyword">array</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArray;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>O(n log n)</strong> - 线性对数空间复杂度</p><p><strong>O(n^2)</strong> - 二次空间复杂度</p><p><strong>O(n^3)</strong> - 三次空间复杂度</p><p><strong>O(2^n)</strong> - 指数空间复杂度</p><p><strong>O(n!)</strong> - 阶乘空间复杂度</p><h3 id="1-3-数据程序结构设计"><a href="#1-3-数据程序结构设计" class="headerlink" title="1.3 数据程序结构设计"></a>1.3 数据程序结构设计</h3><h4 id="1-3-1-数据结构程序设计步骤"><a href="#1-3-1-数据结构程序设计步骤" class="headerlink" title="1.3.1 数据结构程序设计步骤"></a>1.3.1 数据结构程序设计步骤</h4><ol><li><strong>设计数据结构程序的步骤</strong>：<ul><li><strong>第一步</strong>：分析问题的数据和求解功能，使用抽象数据类型（ADT）来描述问题，包括数据逻辑结构和运算定义。</li><li><strong>第二步</strong>：设计逻辑结构对应的存储结构。</li><li><strong>第三步</strong>：在选定的存储结构上设计实现运算定义的算法。</li></ul></li></ol><h4 id="1-3-2-应用程序结构"><a href="#1-3-2-应用程序结构" class="headerlink" title="1.3.2 应用程序结构"></a>1.3.2 应用程序结构</h4><p>![a1b9aa105652fe4d7386574ca6429d89](G:\360MoveData\Users\nixg\Documents\Tencent Files\1332425260\nt_qq\nt_data\Pic\2024-09\Ori\a1b9aa105652fe4d7386574ca6429d89.png)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些文件提供了关于数据结构、算法以及它们在程序设计中应用的全面概述。以下是核心内容的整理：</p><ol><li><p><strong>数据结构的定义</strong>：</p><ul><li>数据结构是存在特定关系的数据元素集合，包括数据项和数据元素。</li></ul></li><li><p><strong>数据结构的组成</strong>：</p><ul><li>包括数据逻辑结构、数据存储结构和数据运算。</li></ul></li><li><p><strong>数据逻辑结构的分类</strong>：</p><ul><li>集合、线性结构、树状结构和图形结构，其中树状和图形结构是非线性结构。</li></ul></li><li><p><strong>数据存储结构的类型</strong>：</p><ul><li>顺序存储、链式存储、索引存储和哈希存储。</li></ul></li><li><p><strong>存储结构的设计</strong>：</p><ul><li>存储结构设计需考虑存储元素及其逻辑关系，同一逻辑结构可对应多个存储结构。</li></ul></li><li><p><strong>抽象数据类型</strong>：</p><ul><li>由数据逻辑结构和抽象运算组成。</li></ul></li><li><p><strong>算法的定义</strong>：</p><ul><li>算法是特定问题求解步骤的描述，具有有限性、确定性、可行性、输入性和输出性。</li></ul></li><li><p><strong>算法描述</strong>：</p><ul><li>算法通常用C&#x2F;C++函数的形式描述，复杂算法可能需要多个函数。</li></ul></li><li><p><strong>算法设计考虑</strong>：</p><ul><li>明确算法的输入和输出，通常作为函数的形参和返回值。</li></ul></li><li><p><strong>算法条件的有效性</strong>：</p><ul><li>条件有效时返回1（真），否则返回0（假）。</li></ul></li><li><p><strong>算法分析</strong>：</p><ul><li>包括时间复杂度和空间复杂度分析，目的是提高算法效率。</li></ul></li><li><p><strong>时间复杂度分析</strong>：</p><ul><li>选取基本运算，求其频度，取最高阶并置系数为1。</li></ul></li><li><p><strong>存储结构与算法的关系</strong>：</p><ul><li>良好的存储结构可以提高算法效率。</li></ul></li><li><p><strong>求解问题的步骤</strong>：</p><ul><li>建立抽象数据类型，设计合理的存储结构，在此基础上设计高效算法。</li></ul></li></ol><hr><hr><hr><hr><p>本文大部分内容来自数据结构 数据结构简明教程(第2版)</p><p>由本人经过gdp润色后+加上自己理解所抄录笔记-</p><hr><hr><p>第一章算是润色把 自我感觉有用的就是1</p><p>.数据结构的定义和组成</p><p>逻辑结构+存储结构</p><p>算法-算法的五要素 算法时间复杂度和空间复杂度</p><p>这些内容以前学比特数据结构1h学完</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-线性表-双向链表探究</title>
    <link href="/2024/09/12/data%20structure/%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E4%B8%8B/"/>
    <url>/2024/09/12/data%20structure/%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表-下"><a href="#线性表-下" class="headerlink" title="线性表 下"></a>线性表 下</h1><h3 id="双线性表链表和循环双链表"><a href="#双线性表链表和循环双链表" class="headerlink" title="双线性表链表和循环双链表"></a>双线性表链表和循环双链表</h3><h5 id="2-4-1双链表"><a href="#2-4-1双链表" class="headerlink" title="2.4.1双链表"></a>2.4.1双链表</h5><p><strong>算法不同的只有插入和删除</strong></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">双链表中用两个指针表示结点间的逻辑关系。<br>指向其前驱结点的指针域<span class="hljs-built_in">prior</span>。<br>指向其后继结点的指针域<span class="hljs-built_in">next</span>。<br><br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">T9 ypedef <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span><br>&#123;  ElemType data;<span class="hljs-comment">//数据域</span><br>   <span class="hljs-keyword">struct</span> <span class="hljs-type">node</span> *prior,*next;<span class="hljs-comment">//分别指向前驱结点</span><br><span class="hljs-comment">//和后继结点的指针</span><br>&#125; DLinkNode;<span class="hljs-comment">//双链表结点类型</span><br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c573523b45ca172d7da989dc240d1574.png" alt="c573523b45ca172d7da989dc240d1574"></p><p><strong>双链表基本运算算法</strong></p><h6 id="1-初始化线性表运算算法"><a href="#1-初始化线性表运算算法" class="headerlink" title="1.初始化线性表运算算法"></a>1.<strong>初始化线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">创建一个空的双链表，它只有一个头结点，由<span class="hljs-type">L</span>指向它，该结点的next域和prior域均为空，<span class="hljs-class"><span class="hljs-keyword">data</span>域未设定任何值。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(DLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  L=(DLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DLinkNode));  <br><span class="hljs-comment">//创建头结点L</span><br>   L-&gt;prior=L-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表运算算法"><a href="#2-销毁线性表运算算法" class="headerlink" title="2.销毁线性表运算算法"></a>2.<strong>销毁线性表运算算法</strong></h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">销毁一个双链表中的所有结点的算法思路与单链表的销毁算法相同。 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(DLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  DLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>   &#123;<span class="hljs-built_in">free</span>(pre);<br>pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-求线性表长度运算算法"><a href="#3-求线性表长度运算算法" class="headerlink" title="3.求线性表长度运算算法"></a>3.<strong>求线性表长度运算算法</strong></h6><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> GetLength(DLinkNode *L)<br>&#123;  <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-comment">//p指向第一个数据结点</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span>)<br>   &#123;i++;<span class="hljs-comment">//i累加数据结点个数</span><br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法"><a href="#4-求线性表中第i个元素运算算法" class="headerlink" title="4.求线性表中第i个元素运算算法"></a>4.求线性表中第i个元素运算算法</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(DLinkNode *L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L;<span class="hljs-comment">//p指向头结点，计数器j置为0</span><br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i)<br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;e=p-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//找到后返回1</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法"><a href="#5-按值查找运算算法" class="headerlink" title="5.按值查找运算算法"></a><strong>5.按值查找运算算法</strong></h6><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> Locate(DLinkNode *L,ElemType e)<br>&#123;  DLinkNode *p=L-&gt;<span class="hljs-keyword">next</span>;<br>   <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<span class="hljs-comment">//p指向第一个数据结点，i置为其序号1</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span> &amp;&amp; p-&gt;data!=e)<br>   &#123;p=p-&gt;<span class="hljs-keyword">next</span>;<br>i++;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//找到后返回其序号</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>6.<strong>插入元素运算算法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">先在双链表中查找到第<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>个结点，若成功找到该结点（由<span class="hljs-selector-tag">p</span>所指向），创建一个以<span class="hljs-attribute">x</span>为值的新结点s，将s结点插入到<span class="hljs-selector-tag">p</span>之后即可。<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd8d02c1e5b1665943a48ad7fb2100b9.png" alt="dd8d02c1e5b1665943a48ad7fb2100b9"></p><p>若插入节点为i位置 需要修改i内存的前 后指针</p><p>同时i-1位置的next  i+1的前置  prior</p><p>需要修改四个位置-找到2个内存地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InsElem</span><span class="hljs-params">(DLinkNode *&amp;L,ElemType x,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)<span class="hljs-comment">//查找第i-1个结点p</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<span class="hljs-comment">////找到了需要修改的节点的位置 </span><br>   <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;<br>    s=(DLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DLinkNode));<br>s-&gt;data=x;<span class="hljs-comment">//创建一个存放元素x的新结点</span><br>s-&gt;next=p-&gt;next;<span class="hljs-comment">//对应插入操作的步骤①</span><br><span class="hljs-keyword">if</span> (p-&gt;next!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//对应插入操作的步骤②</span><br>　　p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<span class="hljs-comment">//对应插入操作的步骤③</span><br>p-&gt;next=s;<span class="hljs-comment">//对应插入操作的步骤④</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-删除结点运算算法"><a href="#6-删除结点运算算法" class="headerlink" title="6.删除结点运算算法"></a>6.<strong>删除结点运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">先在双链表中查找到第<span class="hljs-selector-tag">i</span>个结点，若成功找到该结点（由<span class="hljs-selector-tag">p</span>所指向），通过前驱结点和后继结点的指针域改变来删除<span class="hljs-selector-tag">p</span>结点<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240922224934131.png" alt="image-20240922224934131"></p><p>假设删除i -i-1的next指向改变 i+1的prior改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">DelElem</span><span class="hljs-params">(DLinkNode *&amp;L,<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//删除结点</span><br>&#123;  <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L,*pre;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=NULL &amp;&amp; j&lt;i)<span class="hljs-comment">//查找第i个结点p</span><br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==NULL) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到第i个结点时返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;pre=p-&gt;prior;<span class="hljs-comment">//pre指向被删结点的前驱结点</span><br><span class="hljs-keyword">if</span> (p-&gt;next!=NULL)<span class="hljs-comment">//从单链表中删除p结点</span><br>　　p-&gt;next-&gt;prior=pre;<br>pre-&gt;next=p-&gt;next;<br>free(p);<span class="hljs-comment">//释放其空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="7-输出线性表运算算法"><a href="#7-输出线性表运算算法" class="headerlink" title="7.输出线性表运算算法"></a>7.<strong>输出线性表运算算法</strong></h6><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DispList(DLinkNode *L)<br>&#123;  DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next;<br>   <span class="hljs-keyword">while</span> (p!=NULL)<br>   &#123;<span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%d &quot;,p-&gt;</span><span class="hljs-keyword">data</span>);<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="整体创建双链表的算法"><a href="#整体创建双链表的算法" class="headerlink" title="整体创建双链表的算法"></a>整体创建双链表的算法</h4><h6 id="1-头插法"><a href="#1-头插法" class="headerlink" title="1.头插法"></a>1.头插法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空双链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>然后将新结点s插入到当前链表的表头上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到双链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateListF</span><span class="hljs-params">(DLinkNode *&amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span><br>&#123;  DLinkNode *s;<span class="hljs-type">int</span> i;<br>   L=(DLinkNode *)malloc(sizeof(DLinkNode));  <span class="hljs-comment">//创建头结点</span><br>   L-&gt;next=NULL;<br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;  s=(DLinkNode *)malloc(sizeof(DLinkNode)); <span class="hljs-comment">//创建新结点</span><br>      s-&gt;data=a[i];<br>      s-&gt;next=L-&gt;next;<span class="hljs-comment">//将s插入到头结点之后</span><br>      s-&gt;prior=L;<br>      <span class="hljs-keyword">if</span> (L-&gt;next!=NULL)<span class="hljs-comment">//若s不是作为尾结点插入</span><br>L-&gt;next-&gt;prior=s;<br>      L-&gt;next=s;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-尾插法"><a href="#2-尾插法" class="headerlink" title="2.尾插法"></a>2.尾插法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">从一个空双链表（含有一个L指向的头结点）开始。<br>读取数组<span class="hljs-selector-tag">a</span>（含有n个元素）中的一个元素，生成一个新结点s，将读取的数据元素存放到新结点的数据域中。<br>然后将新结点s插入到当前链表的表尾上。<br>再读取数组<span class="hljs-selector-tag">a</span>的下一个元素，采用相同的操作建立新结点s并插入到双链表L中，直到数组<span class="hljs-selector-tag">a</span>中所有元素读完为止。<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">CreateListR</span><span class="hljs-params">(DLinkNode *&amp;L,ElemType a[],<span class="hljs-type">int</span> n)</span><br>&#123;  DLinkNode *s,*tc; <span class="hljs-type">int</span> i;<br>   L=(DLinkNode *)malloc(sizeof(DLinkNode)); <span class="hljs-comment">//创建头结点</span><br>   tc=L;<span class="hljs-comment">//tc始终指向尾结点,开始时指向头结点</span><br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>   &#123;s=(DLinkNode *)malloc(sizeof(DLinkNode));<span class="hljs-comment">//创建新结点</span><br>s-&gt;data=a[i];<br>tc-&gt;next=s;<span class="hljs-comment">//将s插入tc之后</span><br>s-&gt;prior=tc;<br>tc=s;<br>   &#125;<br>   tc-&gt;next=NULL;<span class="hljs-comment">//尾结点next域置为NULL</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="双链表的算法设计示例"><a href="#双链表的算法设计示例" class="headerlink" title="双链表的算法设计示例"></a><strong>双链表的算法设计示例</strong></h4><h6 id="2-22"><a href="#2-22" class="headerlink" title="2.22"></a>2.22</h6><h6 id="2-18"><a href="#2-18" class="headerlink" title="2.18"></a>2.18</h6><h3 id="2-4-4循环双链表"><a href="#2-4-4循环双链表" class="headerlink" title="2.4.4循环双链表"></a>2.4.4循环双链表</h3><h4 id="了解循环双链表"><a href="#了解循环双链表" class="headerlink" title="了解循环双链表"></a>了解循环双链表</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">与循环单链表一样，也可以使用循环双链表。<br>循环双链表的结点类型与双链表的结点类型相同，也采用前面声明的DLinkNode类型。<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/397fa82d4cb7db052147d65dcaea0689.png" alt="397fa82d4cb7db052147d65dcaea0689"></p><h6 id="1-初始化线性表运算算法-1"><a href="#1-初始化线性表运算算法-1" class="headerlink" title="1.初始化线性表运算算法"></a>1.<strong>初始化线性表运算算法</strong></h6><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell">创建一个空的循环双链表，它只有一个头结点，由<span class="hljs-type">L</span>指向它，该结点的next域和prior域均指向该头结点，<span class="hljs-class"><span class="hljs-keyword">data</span>域未设定任何值</span><br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">void</span> <span class="hljs-function"><span class="hljs-title">InitList</span>(<span class="hljs-variable">DLinkNode</span> *&amp;<span class="hljs-variable">L</span>)</span><br>&#123;  <span class="hljs-variable">L</span>=(<span class="hljs-variable">DLinkNode</span> *)<span class="hljs-function"><span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-variable">DLinkNode</span>));</span><br><span class="hljs-function">   <span class="hljs-variable">L</span>-&gt;<span class="hljs-variable">prior</span>=<span class="hljs-variable">L</span>-&gt;<span class="hljs-variable">next</span>=<span class="hljs-variable">L</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h6 id="2-销毁线性表"><a href="#2-销毁线性表" class="headerlink" title="2.销毁线性表"></a>2.销毁线性表</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(DLinkNode *&amp;L)</span></span><br><span class="hljs-function"></span>&#123;  DLinkNode *pre=L,*p=pre-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-built_in">free</span>(pre);<br>pre=p; p=p-&gt;next;<span class="hljs-comment">//pre、p同步后移</span><br>   &#125;<br>   <span class="hljs-built_in">free</span>(pre);<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="3-求线性表长度运算算法-1"><a href="#3-求线性表长度运算算法-1" class="headerlink" title="3.求线性表长度运算算法"></a>3.<strong>求线性表长度运算算法</strong></h6><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> GetLength(DLinkNode *L)<span class="hljs-comment">//求表长运算</span><br>&#123;  <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>   DLinkNode *p=L-&gt;<span class="hljs-keyword">next</span>;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;i++;<br>p=p-&gt;<span class="hljs-keyword">next</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="4-求线性表中第i个元素运算算法-1"><a href="#4-求线性表中第i个元素运算算法-1" class="headerlink" title="4.**求线性表中第i个元素运算算法"></a>4.**求线性表中第i个元素运算算法</h6><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> GetElem(DLinkNode *L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)<br>&#123;  <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>   DLinkNode *p=L-&gt;next;<span class="hljs-comment">//p指向第一个数据结点，j置为1</span><br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<br>   &#123;j++;<br>p=p-&gt;next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;e=p-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//找到后返回1</span><br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-按值查找运算算法-1"><a href="#5-按值查找运算算法-1" class="headerlink" title="5.按值查找运算算法"></a>5.<strong>按值查找运算算法</strong></h6><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">int</span> Locate(DLinkNode *L,ElemType x)<br>&#123;  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>   DLinkNode *p=L-&gt;next;<br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; p-&gt;data!=x)<br>            <span class="hljs-comment">//从第1个结点开始查找data域为x的结点</span><br>   &#123;p=p-&gt;next;<br>i++;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="6-插入元素运算算法"><a href="#6-插入元素运算算法" class="headerlink" title="6.插入元素运算算法"></a>6.<strong>插入元素运算算法</strong></h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">先在循环双链表L中查找第i个结点<span class="hljs-keyword">p</span>及其前驱结点<span class="hljs-keyword">pre</span>，用<span class="hljs-keyword">j</span>记录<span class="hljs-keyword">p</span>结点的序号。<br>当<span class="hljs-keyword">p</span>==L且i&gt;<span class="hljs-keyword">j</span>+<span class="hljs-number">1</span>时表示i参数错误（如循环双链表中只有<span class="hljs-number">3</span>个结点，当i&gt;<span class="hljs-number">4</span>时出现这种错误）。<br>当成功找到<span class="hljs-keyword">pre</span>结点后，创建data域为<span class="hljs-keyword">x</span>的结点s。<br>在<span class="hljs-keyword">pre</span>结点之后插入s结点<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">int InsElem(DLinkNode *&amp;L,ElemType x,int i)<br>&#123;  int j=<span class="hljs-number">0</span>;<br>   DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *pre=L,*p=pre-&gt;</span>next,*s;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i-<span class="hljs-number">1</span>)<span class="hljs-comment">//查找第i个结点p和其前驱结点pre</span><br>   &#123;j++;<br><span class="hljs-function"><span class="hljs-title">pre</span>=p; p=p-&gt;</span>next;<span class="hljs-comment">//pre、p同步后移一个结点</span><br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L &amp;&amp; i&gt;j+<span class="hljs-number">1</span>) return <span class="hljs-number">0</span>;  <span class="hljs-comment">//参数i&gt;n+1时错误返回0</span><br>   <span class="hljs-keyword">else</span><span class="hljs-comment">//成功查找到p结点的前驱结点pre</span><br>   &#123;s=(DLinkNode *)malloc(sizeof(DLinkNode));<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-keyword">data</span>=x;<span class="hljs-comment">//创建新结点s用于存放元素x</span><br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prior=s;<span class="hljs-comment">//将s结点插入到pre结点之后</span><br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=pre-&gt;</span>next;<br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span>next=s;<br><span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span>prior=pre;<br>return <span class="hljs-number">1</span>;<span class="hljs-comment">//插入运算成功,返回1</span><br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="7-删除元素运算算法"><a href="#7-删除元素运算算法" class="headerlink" title="7.删除元素运算算法"></a>7.<strong>删除元素运算算法</strong></h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">先在循环双链表L中查找第<span class="hljs-selector-tag">i</span>个结点<span class="hljs-selector-tag">p</span>，若成功找到后通过其前驱结点pre将<span class="hljs-selector-tag">p</span>结点删除。 <br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">int DelElem(DLinkNode *&amp;L,int i) <span class="hljs-comment">//删除结点算法</span><br>&#123;  int j=<span class="hljs-number">1</span>;<br>   DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next,*pre;<br>   <span class="hljs-keyword">if</span> (i&lt;=<span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<span class="hljs-comment">//参数i错误返回0</span><br>   <span class="hljs-function"><span class="hljs-title">if</span> (L-&gt;</span>next==L) return <span class="hljs-number">0</span>;<span class="hljs-comment">//空循环双链表不能删除，返回0</span><br>   <span class="hljs-keyword">while</span> (p!=L &amp;&amp; j&lt;i)<span class="hljs-comment">//查找第i个结点p</span><br>   &#123;j++;<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (p==L) return <span class="hljs-number">0</span>;<span class="hljs-comment">//未找到第i个结点返回0</span><br>   <span class="hljs-keyword">else</span><br>   &#123;<span class="hljs-function"><span class="hljs-title">pre</span>=p-&gt;</span>prior;<span class="hljs-comment">//pre指向被删结点的前驱结点</span><br><span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prior=pre;<br><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=p-&gt;</span>next;<br>free(p);<span class="hljs-comment">//释放其空间</span><br>return <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="8-输出线性表运算算法"><a href="#8-输出线性表运算算法" class="headerlink" title="8.输出线性表运算算法"></a>8.<strong>输出线性表运算算法</strong></h6><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">void DispList(DLinkNode *L)<br>&#123;  DL<span class="hljs-function"><span class="hljs-title">inkNode</span> *p=L-&gt;</span>next;<br>   <span class="hljs-keyword">while</span> (p!=L)<br>   &#123;<span class="hljs-function"><span class="hljs-title">printf</span>(&quot;%d &quot;,p-&gt;</span><span class="hljs-keyword">data</span>);<br><span class="hljs-function"><span class="hljs-title">p</span>=p-&gt;</span>next;<br>   &#125;<br>   printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="循环双链表的算法设计示例"><a href="#循环双链表的算法设计示例" class="headerlink" title="循环双链表的算法设计示例"></a><strong>循环双链表的算法设计示例</strong></h4><h6 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h6><h6 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h6><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h6 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">　当通过分析确定了求解问题中数据逻辑结构为线性关系时，设计线性表应用程序的一般步骤如下：<br>　　（1）根据求解功能的特点设计相应的存储结构。<br>　　（2）设计相应的基本运算算法。<br>　　（3）设计求解问题的主程序。<br><br></code></pre></td></tr></table></figure><h6 id="2-顺序存储和线性存储区别"><a href="#2-顺序存储和线性存储区别" class="headerlink" title="2.顺序存储和线性存储区别"></a>2.顺序存储和线性存储区别</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9a2f7bc0ba094ad50f1764926b9b59c.png" alt="c9a2f7bc0ba094ad50f1764926b9b59c"></p><h1 id="java线性结构探究"><a href="#java线性结构探究" class="headerlink" title="java线性结构探究"></a>java线性结构探究</h1><h4 id="顺序存储结构的代表："><a href="#顺序存储结构的代表：" class="headerlink" title="顺序存储结构的代表："></a><strong>顺序存储结构的代表：</strong></h4><ul><li>数组（Array）   在 Java 中，数组是一种基础的顺序存储结构，元素连续存储在内存中。</li><li>ArrayList     <code>ArrayList</code> 是 Java 中基于数组实现的动态数组，容量可以根据需要自动扩展。</li><li>String     java 中的 <code>String</code> 本质上是一个字符数组，它也是顺序存储的经典例子。</li><li>Vector     <code>Vector</code> 和 <code>ArrayList</code> 类似，但它是线程安全的。它内部也是基于数组实现的。</li><li>Stack       Java 中的 <code>Stack</code> 是基于 <code>Vector</code> 实现的，元素按顺序存储，具有先进后出的特点。</li></ul><h4 id="链式存储结构的代表："><a href="#链式存储结构的代表：" class="headerlink" title="链式存储结构的代表："></a><strong>链式存储结构的代表：</strong></h4><ul><li>LinkedList       <code>LinkedList</code> 是 Java 中的双向链表，节点通过指针相互链接。</li><li>HashMap 中的链表         <code>HashMap</code> 和 <code>HashTable</code> 的底层实现之一是链表，在发生哈希冲突时，将多个冲突的键值对存储在链表中。 </li><li>Queue         Java 中的 <code>LinkedList</code> 也可以用作队列，队列是先进先出（FIFO）的数据结构。</li><li>PriorityQueue       <code>PriorityQueue</code> 是一种特殊的队列，元素按优先级排序，而不是按插入顺序存储。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mybatis框架</title>
    <link href="/2024/09/11/mybits/"/>
    <url>/2024/09/11/mybits/</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis框架"><a href="#mybatis框架" class="headerlink" title="mybatis框架"></a>mybatis框架</h1><p>ps：mybits-&gt;mybatis-&gt;本人以前未在意 后续才发现一直拼错了</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Mybits.png" alt="Mybits"></p><h1 id="Mybits"><a href="#Mybits" class="headerlink" title="Mybits"></a>Mybits</h1><h4 id="了解mybits"><a href="#了解mybits" class="headerlink" title="了解mybits"></a>了解mybits</h4><blockquote><p>“MyBatis” 是一个用于 Java 的持久层框架，它简化了数据库访问的过程。其主要作用包括：</p><ol><li><strong>简化数据库操作</strong>：MyBatis 可以通过 XML 或注解的方式，将 SQL 语句直接写在代码中，避免了使用传统 JDBC 时需要编写大量重复的代码，使得数据库操作更加简洁。</li><li><strong>灵活的 SQL 映射</strong>：MyBatis 允许开发人员编写自定义的 SQL 语句，然后将其与 Java 对象映射。这种方式提供了高度的灵活性，特别适用于复杂的查询操作。</li><li><strong>自动映射结果集</strong>：MyBatis 能够将 SQL 查询的结果集自动映射到 Java 对象中，这样开发者不需要手动解析 ResultSet，大大简化了开发过程。</li><li><strong>动态 SQL 支持</strong>：MyBatis 提供了一种动态 SQL 的能力，通过标签（如 <code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code> 等）来生成动态 SQL 语句，满足各种复杂的查询需求。</li></ol><p>MyBatis 可以进行数据库操作的原因是，它封装了 <strong>JDBC</strong> 操作，将 SQL 查询的执行与结果的处理自动化，并且与 Java 应用程序的对象模型无缝集成。这使得开发人员可以专注于业务逻辑，而不需要关心底层的数据库操作细节。</p></blockquote><h4 id="mybits原理"><a href="#mybits原理" class="headerlink" title="mybits原理"></a>mybits原理</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6daa7e673d972cdd3a904b3bc10d63ee.png" alt="6daa7e673d972cdd3a904b3bc10d63ee"></p><blockquote><p><strong>MyBatis 配置文件</strong>：</p><ul><li><code>SqlMapConfig.xml</code> 是 MyBatis 的全局配置文件，用于配置 MyBatis 的运行环境等信息。</li><li><code>mapper.xml</code> 是用于 SQL 语句和对象映射的文件，这些文件配置了操作数据库的 SQL 语句，需要在 <code>SqlMapConfig.xml</code> 中加载这些文件。</li></ul></blockquote><blockquote><p><strong>通过 MyBatis 环境配置创建 SqlSessionFactory（会话工厂）</strong>：</p><ul><li>通过 MyBatis 的环境配置信息构造一个 <code>SqlSessionFactory</code>，它用于创建会话（<code>SqlSession</code>）实例。</li></ul></blockquote><blockquote><p><strong>会话（SqlSession）的作用</strong>：</p><ul><li>由会话工厂创建的 <code>SqlSession</code> 用于执行数据库操作，开发者在代码中使用 <code>SqlSession</code> 对象来执行 SQL 语句。</li></ul></blockquote><blockquote><p><strong>Executor 执行器</strong>：</p><ul><li>MyBatis 底层定义了 <code>Executor</code> 执行器接口，负责接收并执行 SQL 语句，有两个实现：一个是批量执行器（Batch Executor），一个是缓存执行器（Caching Executor）。</li></ul></blockquote><blockquote><p><strong>Mapped Statement</strong>：-mapper</p><ul><li><code>Mapped Statement</code> 是 MyBatis 底层封装的对象，包含了 MyBatis 配置信息、SQL 映射信息等。</li><li>在 <code>mapper.xml</code> 文件中，每个 SQL 语句对应一个 <code>Mapped Statement</code> 对象，SQL 的 <code>id</code> 对应 Mapped Statement 的 <code>id</code>。</li></ul></blockquote><blockquote><p><strong>输入参数映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输入参数进行定义，包括 <code>HashMap</code>、基本类型、POJO（普通的 Java 对象）。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 前将输入的 Java 对象映射为 SQL 中的参数，类似于 JDBC 编程中 <code>PreparedStatement</code> 的设定参数的过程。</li></ul></blockquote><blockquote><p><strong>输出结果映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输出结果进行定义，包括 <code>HashMap</code>、基本类型、POJO。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 后将输出结果映射至 Java 对象，类似于 JDBC 编程中结果集（<code>ResultSet</code>）的解析处理过程。</li></ul></blockquote><h4 id="Mybits入门"><a href="#Mybits入门" class="headerlink" title="Mybits入门"></a>Mybits入门</h4><h6 id="1-mybits使用"><a href="#1-mybits使用" class="headerlink" title="1.mybits使用"></a>1.mybits使用</h6><p>1.创建工程<br>2.导入依赖<br>3.创建配置文件</p><p>以下是一个 MyBatis 使用案例，包括配置文件 <code>mybatis-config.xml</code>、映射文件 <code>UserMapper.xml</code>、实体类 <code>User</code>、映射接口 <code>UserMapper</code>，以及一个使用 MyBatis 的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;!DOCTYPE configuration<br>  PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br>  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;<br>&lt;configuration&gt;<br>  &lt;!-- 环境配置 --&gt;<br>  &lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>    &lt;environment id=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>      &lt;!-- 使用 JDBC 事务管理器 --&gt;<br>      &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span> /&gt;<br>      &lt;!-- 配置数据源 --&gt;<br>      &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb?useSSL=false&amp;serverTimezone=UTC&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;root&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;password&quot;</span> /&gt;<br>      &lt;/dataSource&gt;<br>    &lt;/environment&gt;<br>  &lt;/environments&gt;<br>  <br>  &lt;!-- 指定映射文件 --&gt;<br>  &lt;mappers&gt;<br>    &lt;mapper resource=<span class="hljs-string">&quot;com/example/mapper/UserMapper.xml&quot;</span> /&gt;<br>  &lt;/mappers&gt;<br>&lt;/configuration&gt;<br><br></code></pre></td></tr></table></figure><p> 映射文件 <code>UserMapper.xml</code></p><p>这个文件包含 SQL 语句和 Java 方法的映射。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="language-xml">  ///对应路径映射</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="language-xml">///</span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 插入用户 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="language-xml">    INSERT INTO user (name, age) VALUES (#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">, #</span><span class="hljs-template-variable">&#123;age&#125;</span><span class="language-xml">)</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>映射接口 <code>UserMapper</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//会生成代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserMapper</span> &#123;<br>    <span class="hljs-built_in">void</span> insertUser(User user);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程</p><p><strong>配置加载</strong>：读取 MyBatis 配置文件，初始化 <code>SqlSessionFactory</code>。</p><p><strong>会话创建</strong>：通过 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code>，作为数据库操作的会话</p><p><strong>Mapper 映射</strong>：获取映射接口（Mapper）的代理对象，映射接口方法与 SQL 语句对应。</p><blockquote><p>通过 <code>SqlSession</code> 实例的 <code>getMapper(UserMapper.class)</code> 方法，获取 <code>UserMapper</code> 映射接口的代理对象。</p><p>MyBatis 底层会根据 <code>UserMapper.xml</code> 映射文件中定义的 SQL 语句和 <code>UserMapper</code> 接口中的方法进行绑定。</p></blockquote><p><strong>执行 SQL</strong>：使用 <code>Executor</code> 执行映射 SQL 语句，对数据库进行 CRUD 操作。</p><p><strong>参数映射</strong>：在执行 SQL 前，将输入参数映射到 SQL 语句中；执行 SQL 后，将结果集映射为 Java 对象。</p><p><strong>事务控制</strong>：通过 <code>SqlSession</code> 的 <code>commit()</code> 和 <code>rollback()</code> 控制事务。</p><p><strong>会话关闭</strong>：操作完成后，关闭 <code>SqlSession</code>，释放资源。</p><h6 id="2-占位符"><a href="#2-占位符" class="headerlink" title="2.占位符"></a>2.占位符</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;insertUser&quot; parameterType=&quot;com.example.model.User&quot;&gt;    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (<span class="hljs-type">name</span>, age) <span class="hljs-keyword">VALUES</span> (#&#123;<span class="hljs-type">name</span>&#125;, #&#123;age&#125;)  &lt;/<span class="hljs-keyword">insert</span>&gt;<br></code></pre></td></tr></table></figure><p>#{} 实现向占位符添加值-自动进行java类型和jdbc类型转换-可以防止sql注入-可接收简单类型值和pojo属性值</p><p> ￥s{}拼接sql传&#x3D;不进行类型转换&#x3D;</p><h6 id="3-parameterType-resultType"><a href="#3-parameterType-resultType" class="headerlink" title="3.parameterType-resultType"></a>3.parameterType-resultType</h6><p>parameterType-传入的参数类型</p><p>resultType返回值类型</p><h6 id="4-selectOne和selectList"><a href="#4-selectOne和selectList" class="headerlink" title="4..selectOne和selectList"></a>4..selectOne和selectList</h6><p>selectOne查询一条记录</p><p>selectList查询多条记录</p><h6 id="5-mybits-主键"><a href="#5-mybits-主键" class="headerlink" title="5.mybits-主键"></a>5.mybits-主键</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f2a7da3c2707062c15cbbfc7c5f51f9.png" alt="3f2a7da3c2707062c15cbbfc7c5f51f9"></p><p>使用</p><p>SqlSession.insert(“test.insertUser”,user);</p><p>selectkey-&gt;select Last_INSERT_ID–用户添加后自动返回主键-</p><p>—返回主键 </p><p>uuid生成主键</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69eddd3b9e877d74e91d107aad7b6940.png" alt="69eddd3b9e877d74e91d107aad7b6940"></p><h6 id="6-mybits-删除"><a href="#6-mybits-删除" class="headerlink" title="6.mybits-删除"></a>6.mybits-删除</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f16033409c2f9eb00418ede68cffc228.png" alt="f16033409c2f9eb00418ede68cffc228"></p><p>sqlSession.delete(“test.deleteUser”,39);</p><h6 id="7-mybiits-更新用户"><a href="#7-mybiits-更新用户" class="headerlink" title="7.mybiits-&gt;更新用户"></a>7.mybiits-&gt;更新用户</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95864300169e8c1df1b79f4d0102505e.png" alt="95864300169e8c1df1b79f4d0102505e"></p><p>sqlSession.update(“test.updateUser”,user);</p><h4 id="mybits-Dao开发"><a href="#mybits-Dao开发" class="headerlink" title="mybits-Dao开发"></a>mybits-Dao开发</h4><h6 id="1-Dao开发配置入门"><a href="#1-Dao开发配置入门" class="headerlink" title="1.Dao开发配置入门"></a>1.Dao开发配置入门</h6><p>Impl层</p><p>前言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个请求 都会创建 SqlSessionFactory  SqlSessionFactoryBuilder-影响资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61928ee9fd81bc3528cdddda96a0d8be.png" alt="61928ee9fd81bc3528cdddda96a0d8be"></p><p><code>SqlSessionFactoryBuilder</code> 只是一个构建器，它的生命周期是短暂的，只需在创建 <code>SqlSessionFactory</code> 时使用一次。创建好 <code>SqlSessionFactory</code> 后，就不需要再保留 <code>SqlSessionFactoryBuilder</code> 实例。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a59f5c6efc930fdf24b4753e2d6c0165.png" alt="a59f5c6efc930fdf24b4753e2d6c0165"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8f73ed7437e15b3fd61ff570da0b265.png" alt="e8f73ed7437e15b3fd61ff570da0b265"></p><p>解决多次创建后代码–bean-单例bena实现 -如图还未bean 也就是简单的单例模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f89faf38a206b6547777bbea1aa5e14.png" alt="8f89faf38a206b6547777bbea1aa5e14"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d751486c93be306c26947fa45914c821.png" alt="d751486c93be306c26947fa45914c821"></p><p>dao层面-有非常多的重复代码-比如释放资源-拿取selSession-</p><h6 id="2-Mapper开发"><a href="#2-Mapper开发" class="headerlink" title="2.Mapper开发"></a>2.Mapper开发</h6><p>mapper代理方法（程序员只需要mapper接口）<br>程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a8d02d56bb89ffa8d43fd55385bb115a.png" alt="a8d02d56bb89ffa8d43fd55385bb115a"></p><p>需要一一对应进行映射</p><p>也就是mapper-函数映射到xml文件中–需要进行一一对应</p><h6 id="3-mapper代理"><a href="#3-mapper代理" class="headerlink" title="3.mapper代理"></a>3.mapper代理</h6><p>xml定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab74d1f694af3fb743e294f135a4041a.png" alt="ab74d1f694af3fb743e294f135a4041a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5eea9b8887ac8e1894fd8520adf4dcec.png" alt="5eea9b8887ac8e1894fd8520adf4dcec"></p><p>加载</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/922160ede6004b8fb5aea389641d68c2.png" alt="922160ede6004b8fb5aea389641d68c2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45e07e2b4ddd60cd021dcc2f31c066c8.png" alt="45e07e2b4ddd60cd021dcc2f31c066c8"></p><p>—如图–userMapper-来调用方法0由sqlSession-来生成代理对象</p><p>   代理对象内部调用selectOne或selectList<br>如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。<br>如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库</p><hr><p>mapper接口方法参数只能有一个，系统是否不利于扩展维护。</p><p>系统 框架中，dao层的代码是被业务层公用的。<br>即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。</p><p>注意：持久层方法的参数可以包装类型、map。。。，service方法中建议不要使用包装类型（不利于业务层的可扩展）。</p><h6 id="4-l配置"><a href="#4-l配置" class="headerlink" title="4.l配置"></a>4.l配置</h6><p>SqlMapConfig.xm</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a05192e83f10245208db8c09e74468f.png" alt="0a05192e83f10245208db8c09e74468f"></p><p> properties属性</p><p>将数据库连接参数只配置在db.properties中，原因：方便对参数进行统一管理，其它xml可以引用该db.properties</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5afb2ae748e665a0957970ae4a909e5d.png" alt="5afb2ae748e665a0957970ae4a909e5d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a29db16646c4c42d5d9896bd292741d.png" alt="2a29db16646c4c42d5d9896bd292741d"></p><p> settings全局参数配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0070c06383100dde987ddc21ea4a4b3a.png" alt="0070c06383100dde987ddc21ea4a4b3a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62169f009b19205c6220b75f7a4bcb5a.png" alt="62169f009b19205c6220b75f7a4bcb5a"></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><blockquote><p>类型别名（Type Alias）是为了简化和减少 XML 配置文件中的类全限定名而引入的一种便捷方式。通过定义类型别名，你可以使用更短的名称来引用 Java 类，从而使得 Mapper XML 文件更简洁和易读。</p></blockquote><blockquote><p><strong>定义类型别名</strong>：在 MyBatis 配置文件 (<code>mybatis-config.xml</code>) 中，可以为 Java 类指定一个别名。</p><p><strong>使用类型别名</strong>：在 Mapper XML 文件中使用别名来代替类的全限定名。</p></blockquote><h6 id="1-普通类型别名"><a href="#1-普通类型别名" class="headerlink" title="1.普通类型别名"></a>1.普通类型别名</h6><p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p><p>自定义别名-当我们参数的pojo大部分一致的时候 定义别名可以减少代码繁杂</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e1d9343cb1eb8b59a484042657ed0f6.png" alt="8e1d9343cb1eb8b59a484042657ed0f6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7ae2a441a846072ed1c64575f9fa045.png" alt="d7ae2a441a846072ed1c64575f9fa045"></p><p>批量别名-常用-扫描po文件 给所有pojo注册别名</p><h6 id="3-mybits-类型处理器"><a href="#3-mybits-类型处理器" class="headerlink" title="3.mybits 类型处理器"></a>3.mybits 类型处理器</h6><blockquote><p>在 MyBatis 中，<strong>类型处理器（Type Handlers）</strong> 用于处理 Java 类型与 JDBC 类型之间的转换。它们在 MyBatis 从数据库中读取数据（结果集映射）或将数据写入数据库（参数映射）时起着关键作用。<br>例子</p><p><strong>Java 类型到 JDBC 类型的转换</strong>：将 Java 对象类型转换为 SQL 参数，发送到数据库。例如，将 <code>Integer</code> 类型的 Java 对象转换为数据库的 <code>INTEGER</code> 类型。</p><p><strong>JDBC 类型到 Java 类型的转换</strong>：将从数据库查询的结果转换为 Java 对象。例如，将数据库查询结果中的 <code>INTEGER</code> 类型转换为 Java 的 <code>Integer</code> 或 <code>int</code>。</p></blockquote><h6 id="4-mappers-映射配置"><a href="#4-mappers-映射配置" class="headerlink" title="4.  mappers 映射配置"></a>4.  mappers 映射配置</h6><ol><li><p>通过resource加载单个映射文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/982f90b2b3ead1f97c7560fa9326b4fe.png" alt="982f90b2b3ead1f97c7560fa9326b4fe"></p></li><li><p>通过mapper接口加载单个mapper</p></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5c7c2136386dd9b06663cdf3631c412c.png" alt="5c7c2136386dd9b06663cdf3631c412c"></p><p>按照上边的规范，将mapper.java和mapper.xml放在一个目录 ，且同名</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de35b2cb9ffb9c7af48ac36f9586f000.png" alt="de35b2cb9ffb9c7af48ac36f9586f000"></p><p>3 .  批量加载mapper(推荐使用)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3cc05d3339e8ebae691aaac0073392fa.png" alt="3cc05d3339e8ebae691aaac0073392fa"></p><p>4.输入映射</p><p>通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/80e95beb88e2a055ee91e47d12c5bc6e.png" alt="80e95beb88e2a055ee91e47d12c5bc6e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/16e891a8f40288f28679241a5f4a6dd0.png" alt="16e891a8f40288f28679241a5f4a6dd0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eec86ff7c8c1cc0c909076d9d0827b36.png" alt="eec86ff7c8c1cc0c909076d9d0827b36"></p><h5 id="Mybits高级"><a href="#Mybits高级" class="headerlink" title="Mybits高级"></a>Mybits高级</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ec78fe0039ba4d7a0f0e93edde34ffd.png" alt="3ec78fe0039ba4d7a0f0e93edde34ffd"></p><h6 id="1-一对一查询"><a href="#1-一对一查询" class="headerlink" title="1.一对一查询"></a>1.一对一查询</h6><p>查询订单信息，关联查询创建订单的用户信息<br>sql语句<br>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS,USER WHRE ORDERS.USER_ID&#x3D;USER.ID;</p><p>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS JOIN USER ON ORDERS.USER_ID&#x3D;USER.ID;</p><p>实现该查询</p><p>1.创建pojo</p><p>2.mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;SELECT ID=<span class="hljs-string">&quot;FINDorderUser&quot;</span> resultType=<span class="hljs-string">&#x27;pojo&#x27;</span>&gt;<br>select orders.*,user.username,user.sexmuser.address from orders,user WHRE ORDERS.USER_ID=USER.ID;<br><br>&lt;/lelect&gt;<br></code></pre></td></tr></table></figure><p>3.mapper.java</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5efc0b312fab4d35aa879dd46fae93a0.png" alt="5efc0b312fab4d35aa879dd46fae93a0"></p><p>这个时候-只需要获取即可使用该sql语句<br>–    使用resultMap映射的思路<br>使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f8a7cbf8b3875476e103b0733ac7f7f5.png" alt="f8a7cbf8b3875476e103b0733ac7f7f5"></p><p>定义resultMap</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ee4c7227c01ec39fa1bfa811976628dc.png" alt="ee4c7227c01ec39fa1bfa811976628dc"></p><p>S定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e92a4eb35812042de17a350aa5405bc7.png" alt="e92a4eb35812042de17a350aa5405bc7"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55906bbde71b042c14daf40325e2734a.png" alt="55906bbde71b042c14daf40325e2734a"></p><h6 id="2-一对多查询"><a href="#2-一对多查询" class="headerlink" title="2.一对多查询"></a>2.一对多查询</h6><p>查询订单及订单明细的信息。<br>SELECT<br>  orders.*,<br>  USER.username,<br>  USER.sex,<br>  USER.address,<br>  orderdetail.id orderdetail_id,<br>  orderdetail.items_id,<br>  orderdetail.items_num,<br>  orderdetail.orders_id<br>from<br> orders,<br>  USER,<br>  orderdetail<br>whrer<br>orders.user_id &#x3D; user.id AND orderdetail.orders_id&#x3D;orders.id</p><hr><hr><hr><hr><p>使用resultType将上边的 查询结果映射到pojo中，订单信息的就是重复<br>要求：<br>对orders映射不能出现重复记录。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/affb5c09f23f5c042208c4323940698f.png" alt="affb5c09f23f5c042208c4323940698f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6c2accdfd7490aa05255bb2aaa6f9807.png" alt="6c2accdfd7490aa05255bb2aaa6f9807"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7c536bcee1988bbddfd784e6de1204ec.png" alt="7c536bcee1988bbddfd784e6de1204ec"></p><p>map-&gt;映射关系<br>将数据库字段-&gt;对象的字段中<br>同时会指定映射的属性和集合中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/44c0fb3e4d6de667636651db0026ad85.png" alt="44c0fb3e4d6de667636651db0026ad85"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e59fc4b2bdacf3621426fec322ad24c3.png" alt="e59fc4b2bdacf3621426fec322ad24c3"></p><h6 id="3-多对多查询案例"><a href="#3-多对多查询案例" class="headerlink" title="3.多对多查询案例"></a>3.多对多查询案例</h6><hr><p>查询主表是：用户表<br>关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：<br>orders、orderdetail、items</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5d503cb8e549dc16e9fb2f3d9f972be9.png" alt="5d503cb8e549dc16e9fb2f3d9f972be9"></p><p>映射</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c9ea555f307b956af31dbce8415170.png" alt="b4c9ea555f307b956af31dbce8415170"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb9ca63b64a989b5b020ebe231fb555d.png" alt="bb9ca63b64a989b5b020ebe231fb555d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/314f0ba042424242c4135b4302a65f13.png" alt="314f0ba042424242c4135b4302a65f13"></p><h4 id="resultmap总结"><a href="#resultmap总结" class="headerlink" title="resultmap总结"></a>resultmap总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/863ba0486e9be85c0c64ea7eccdead9a.png" alt="863ba0486e9be85c0c64ea7eccdead9a"></p><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>如果查询两张表-如果只需要查询一张表即可满足条件的情况下-那么就不需要查询下一章表<br>关联查询-&gt;单表查询<br>1.使用association实现延迟加载</p><p>查询订单并且关联查询用户信息</p><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf67701ceb62d4d73d31491daee4f282.png" alt="cf67701ceb62d4d73d31491daee4f282"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>resultMap type<span class="hljs-operator">=</span>&quot;orders&quot; id&quot;map&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--对订单信息进行映射配置  --&gt;</span><br>            <span class="hljs-operator">&lt;</span>id <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;id&quot; property<span class="hljs-operator">=</span>&quot;id&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot; property<span class="hljs-operator">=</span>&quot;userId&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;number&quot; property<span class="hljs-operator">=</span>&quot;number&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;createtime&quot; property<span class="hljs-operator">=</span>&quot;createtime&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;note&quot; property<span class="hljs-operator">=</span>&quot;note&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 实现对用户信息进行延迟加载</span><br>            <span class="hljs-keyword">select</span>：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）<br>            要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace<br>            <span class="hljs-keyword">column</span>：订单信息中关联用户信息查询的列，是user_id<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span>association property<span class="hljs-operator">=</span>&quot;user&quot; javaType<span class="hljs-operator">=</span>&quot;user&quot;<br>  <span class="hljs-keyword">select</span><span class="hljs-operator">=</span>&quot;cn.itcast.mybatis.mapper.UserMapper.findUserById&quot; <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>association<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>resultMap<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62a5de17ceb2efb1cb23ce43c27b6311.png" alt="62a5de17ceb2efb1cb23ce43c27b6311"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/83717cda1037366a4cc5b930afeefd1d.png" alt="83717cda1037366a4cc5b930afeefd1d"></p><p>也就是-我们编译器没有访问到user内容就不会去加载吗 2.延迟加载配置<br>mybits默认没有开启延迟加载-需要自己手动开启<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3055bee2e2c581a6d17f4c89b04fb4c.png" alt="img"><br>3.</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41591507899361a44254c502150f44f5.png" alt="img"></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h6 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h6><p>第一层查询-如果没有-从数据库查 再添加进缓存中<br>sqlSession去执行增删改-清空一级缓存<br>2次发起-&gt;缓存有直接返回</p><p>redis缓存思路</p><p>mybits默认支持一级缓存<br>Sqlsession sqlsession&#x3D;sqlsessionfactry.ioensession();<br>UserMapper userMapper&#x3D;sqlsession.getMapper(usermapper.class);<br>User user&#x3D;usermapper.finduserbyid(1);第一层查询-如果没有-从数据库查 再添加进缓存中</p><p>User user&#x3D;usermapper.finduserbyid(1); 2次发起-&gt;缓存有直接返回</p><p>usermapper.updateuser(user1);sqlSession去执行增删改-清空一级缓存</p><p>一级缓存应用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ada7a24f8aeae89ccbcdb1d4e103400.png" alt="2ada7a24f8aeae89ccbcdb1d4e103400"></p><h6 id="2-2级缓存"><a href="#2-2级缓存" class="headerlink" title="2.2级缓存"></a>2.2级缓存</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0e49bf45af19e07fa4ee06a0b7335180.png" alt="0e49bf45af19e07fa4ee06a0b7335180"></p><p>二级缓存范围大-多个sqlsession可以共享一个usermapper二级缓存区域<br>二级缓存区域是按照namespace分-其他不同的mapper也有自己的二级缓存区域</p><p>一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同 的二级缓存区域中。</p><p>开启二级缓存<br>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a1dafc8e5fd22b6cf93d8e8aae31c4e.png" alt="0a1dafc8e5fd22b6cf93d8e8aae31c4e"></p><h4 id="mybits整合ehcache"><a href="#mybits整合ehcache" class="headerlink" title="mybits整合ehcache"></a>mybits整合ehcache</h4><p>mybits整合ehcache<br>ehcache是一个分布式缓存框架<br>缓存的数据-进行集中管理-分布式集中访问 整合方法</p><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。<br>mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45eaa4a652048030f4b17712288fbc56.png" alt="img"><br>ehcache配置<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/687820640853663a040469325cfb6a5b.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68e729a0da44d9d806007bc8178478d5.png" alt="img"></p><h6 id="二级应用场景"><a href="#二级应用场景" class="headerlink" title="二级应用场景"></a>二级应用场景</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fcf22de20a326941945b31d902fd8608.png" alt="fcf22de20a326941945b31d902fd8608"></p><h4 id="Mybits整合Spring"><a href="#Mybits整合Spring" class="headerlink" title="Mybits整合Spring"></a>Mybits整合Spring</h4><h6 id="1-bean配置"><a href="#1-bean配置" class="headerlink" title="1.bean配置"></a>1.bean配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/af73e0779b8e3e14680320c06a1d3e29_720.jpg" alt="af73e0779b8e3e14680320c06a1d3e29_720"></p><p>bean的配置</p><p> user.xml</p><p>![b13f504c2f17c64e26097dff4834aed8](G:\360MoveData\Users\nixg\Documents\Tencent Files\2760045743\nt_qq\nt_data\Pic\2024-04\Ori\b13f504c2f17c64e26097dff4834aed8.jpg)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/92c073b510f63afca1597faf32e1d6be.jpg" alt="92c073b510f63afca1597faf32e1d6be"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68ba41b8d0cb810134cb064e6eed67c5.jpg" alt="68ba41b8d0cb810134cb064e6eed67c5"></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4b6944e971eb9c6af10fdffe3f6cd943.jpeg" alt="4b6944e971eb9c6af10fdffe3f6cd943"></strong></p><p>以上bean去读xml配置<br>然后mybits去注册 在接口实现类进行查询<br>之后注册为bean</p><p>后续直接使用</p><h6 id="2-mapper"><a href="#2-mapper" class="headerlink" title="2.mapper"></a>2.mapper</h6><p>还是要在同级目录以下 </p><p>注册为bean 扫描xml文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dad5b70ff70703d57a807c3d9a740926_720.jpg" alt="dad5b70ff70703d57a807c3d9a740926_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/38fcb7f3871e63a3686786685b0671b7.jpg" alt="38fcb7f3871e63a3686786685b0671b7"></p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java字节码</title>
    <link href="/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <url>/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>1</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架</title>
    <link href="/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h1 id="Spring复习"><a href="#Spring复习" class="headerlink" title="Spring复习"></a>Spring复习</h1><h4 id="1-了解Spirng"><a href="#1-了解Spirng" class="headerlink" title="1.了解Spirng"></a>1.了解Spirng</h4><p>spirng-&gt;spring mvc -&gt;spring boot -&gt;spring cloud</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48b2da9ced4cd0074a9fdd4f7c0a4318.png" alt="48b2da9ced4cd0074a9fdd4f7c0a4318"></p><p>层层递进–</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3a684778fcbcadf529eaad2b4e9ca34d.png" alt="3a684778fcbcadf529eaad2b4e9ca34d"></p><h4 id="2-IOC-Di-了解"><a href="#2-IOC-Di-了解" class="headerlink" title="2.IOC -Di 了解"></a>2.IOC -Di 了解</h4><p>由分层解耦引出的依赖注入 以及依赖反转</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab5ce66c757c262b95bdbeb4ec1862ad.png" alt="ab5ce66c757c262b95bdbeb4ec1862ad"></p><p>如图 -&gt;当我们想更改对象 BookDaoImp12 名字时候-&gt;时 -&gt;所有业务代码都需要改动改动过大-&gt;</p><p>Ioc-&gt;控制反转<br>使用对象–由主动new-改为外部提供对象-&gt;对象控制器转移到外部</p><p>对此-spring提供容器-&gt;ioc容器 -&gt;提供了对象的创建和管理</p><p>依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1f0310fa78da12366d47e8d7844a002a.png" alt="1f0310fa78da12366d47e8d7844a002a"></p><p>IOC-&gt;容器管理Bean-&gt;容器管理bookdaoimpl</p><p>DI-&gt;将具有依赖关系的Bean进行关系绑定-&gt;例如上面的bookdao-&gt;与bookdaoimpl进行绑定  Spring利用依赖注入机制来处理这些Bean之间的依赖关系，从而实现对象之间的松耦合。</p><h4 id="3-加入IOC-容器"><a href="#3-加入IOC-容器" class="headerlink" title="3.加入IOC 容器"></a>3.加入IOC 容器<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed3173cdd0c9bc6ba6d44953a8c38e0a.png" alt="ed3173cdd0c9bc6ba6d44953a8c38e0a"></h4><h6 id="1-配置Bean"><a href="#1-配置Bean" class="headerlink" title="1.配置Bean"></a>1.配置Bean</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/19c1fd155ec41e2182592cffc5262d96.png" alt="19c1fd155ec41e2182592cffc5262d96"></p><p>2.获取Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/506c12b2db4dd7aca712594fa5e279fa.png" alt="506c12b2db4dd7aca712594fa5e279fa"></p><p>当我们配置bean的时候–容器内就保存了我们的对象地址-&gt;单例-&gt;谁需要就给予</p><h6 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/838a65e2572d2c5fafc8c03d3a3ffd44.png" alt="838a65e2572d2c5fafc8c03d3a3ffd44"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dace05b9aa02d6ab02fd488a060b202e.png" alt="dace05b9aa02d6ab02fd488a060b202e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eed54b5a29e21c9568ee7b195168d180.png" alt="eed54b5a29e21c9568ee7b195168d180"></p><p>set容器执行-&gt;最后还是容器将Bean给予了</p><p>spring-&gt;编译 –自动找set 依赖方法注入</p><h4 id="4-Bean配置"><a href="#4-Bean配置" class="headerlink" title="4.Bean配置"></a>4.Bean配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a1a6f9cec7eca02be1d7807228f64ae.png" alt="2a1a6f9cec7eca02be1d7807228f64ae"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/316948bfd792a80f844396040f862c94.png" alt="316948bfd792a80f844396040f862c94"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f41e07fcd21e2e60e49873e445f8656.png" alt="8f41e07fcd21e2e60e49873e445f8656"></p><p>spring-&gt;默认的Bean是单例的</p><p>如果需要多例 就需要修改配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20bd78b82f85ef5660348295b0f97bf6.png" alt="20bd78b82f85ef5660348295b0f97bf6"></p><p>为什么bean要单例–<br>开对象-&gt;耗费内存</p><p>由于是单例-&gt;需要改变的数据就不能加入spring管理-&gt;除非开多例</p><h4 id="5-Bean实例化"><a href="#5-Bean实例化" class="headerlink" title="5.Bean实例化"></a>5.Bean实例化</h4><h6 id="1-ioc过程"><a href="#1-ioc过程" class="headerlink" title="1.ioc过程"></a>1.ioc过程</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2509eb7c62e476183b724c53e7881f29.png" alt="2509eb7c62e476183b724c53e7881f29"></p><p>给接口内-&gt;一个构造-&gt;通过xml解析出 需要构造的对象-&gt;通过反射 -&gt;创建出对象返回-&gt;默认单例</p><p>通过类名动态加载类的方法</p><p>在使用 <code>Class.forName()</code> 方法时，情况会根据加载的类是否已存在而有所不同：</p><ol><li><strong>类已存在</strong>：<ul><li>如果使用 <code>Class.forName()</code> 加载的类在类路径中已经存在，则会返回对应的 Class 对象，而不会创建新的对象。这意味着它只是获取已加载类的引用，不会触发类的初始化和实例化。</li></ul></li><li><strong>类不存在</strong>：<ul><li>如果要加载的类在类路径中不存在，则会抛出 <code>ClassNotFoundException</code> 异常，而不会创建新的类对象。在这种情况下，不会创建新的类对象，因为类根本就没有被加载到内存中</li></ul></li></ol><h6 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h6><p>工厂模式 -&gt;由一个类中的静态方法-&gt;返回对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 静态工厂方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyService <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;通过静态工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createInstance()</code> 是静态工厂方法，负责返回 <code>MyService</code> 类型的对象。</p><p>在 Spring 配置文件中使用 <code>&lt;bean&gt;</code> 标签指定静态工厂方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span> <span class="hljs-attribute">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p> Java 注解配置静态工厂方法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-variable">@Bean</span><br>    public MyService myService() &#123;<br>        <span class="hljs-keyword">return</span> MyServiceFactory.createInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-实例工厂"><a href="#3-实例工厂" class="headerlink" title="3.实例工厂-"></a>3.实例工厂-</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 实例工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyService <span class="hljs-title">createInstance</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;通过实例工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Spring 配置文件（<code>applicationContext.xml</code>）中，通过 <code>&lt;bean&gt;</code> 标签配置实例工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-comment">&lt;!-- 配置工厂类的 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用工厂类的实例方法创建 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>获取bean</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br>MyService myService <span class="hljs-operator">=</span> (MyService) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>)<span class="hljs-comment">;</span><br>myService.doSomething()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Spring 容器首先会创建 <code>MyServiceFactory</code> 的实例，然后调用其 <code>createInstance</code> 方法来创建 <code>MyService</code> 实例。</p><p> Java 注解配置实例工厂方法</p><p>&#x2F;&#x2F;多了一步-先获取到实例工厂bean才能够注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyServiceFactory <span class="hljs-title function_">myServiceFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceFactory</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> myServiceFactory().createInstance();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h6><p>在 Spring 框架中，<code>FactoryBean</code> 是一个特殊的接口，用于自定义 Bean 的创建逻辑</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Object <span class="hljs-title">getObject</span>(): 返回要创建的 Bean 实例。这个方法用于定义实际的对象创建逻辑。</span><br><span class="hljs-function">Class&lt;?&gt; <span class="hljs-title">getObjectType</span>(): 返回创建的 Bean 的类型。</span><br><span class="hljs-function">boolean <span class="hljs-title">isSingleton</span>(): 指示这个 Bean 是否是单例模式。返回 <span class="hljs-literal">true</span> 表示单例，<span class="hljs-literal">false</span> 表示每次请求都会创建一个新的实例。</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd082cfbea4d7e4b13aa31843b6f35c3.jpeg" alt="dd082cfbea4d7e4b13aa31843b6f35c3"></p><p>指定类-扫描</p><p>Spring 容器会创建一个 <code>CarFactoryBean</code> 的实例，并调用它的 <code>getObject()</code> 方法来获取 <code>Car</code> 对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br><br>// 获取由 CarFactoryBean 创建的 UserDao 实例<br>UserDao car <span class="hljs-operator">=</span> (Car) context.getBean(<span class="hljs-string">&quot;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(car)<span class="hljs-comment">;</span><br><br>// 获取 CarFactoryBean 实例本身<br>CarFactoryBean factoryBean <span class="hljs-operator">=</span> (CarFactoryBean) context.getBean(<span class="hljs-string">&quot;&amp;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(factoryBean)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="6-Bean生命周期"><a href="#6-Bean生命周期" class="headerlink" title="6.Bean生命周期"></a>6.Bean生命周期</h4><h6 id="1-生命周期配置"><a href="#1-生命周期配置" class="headerlink" title="1.生命周期配置"></a>1.生命周期配置</h6><p>1.配置法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f411aabb27ce975d2121258bbe3d082.jpeg" alt="3f411aabb27ce975d2121258bbe3d082"></p><p>2.接口法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a1a7897db2e6c6a81a71ae18c1629103.jpg" alt="a1a7897db2e6c6a81a71ae18c1629103"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0b42710ae7bb291a8a7f65ac715b86bc.png" alt="0b42710ae7bb291a8a7f65ac715b86bc"></p><h6 id="2-bean销毁时间"><a href="#2-bean销毁时间" class="headerlink" title="2.bean销毁时间"></a>2.bean销毁时间</h6><p>为了体现生命周期-&gt;我们提前销毁bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/87ed0bfac3a4d77291ac594173873a77.jpeg" alt="87ed0bfac3a4d77291ac594173873a77"></p><h4 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7.依赖注入"></a>7.依赖注入</h4><h6 id="1-了解依赖注入"><a href="#1-了解依赖注入" class="headerlink" title="1.了解依赖注入"></a>1.了解依赖注入</h6><p>有Bean关系的类进行自动注入 —向类传递数据方式-set 传递 –构造传参</p><hr><p>参数–引用类型和简单类型</p><h6 id="2-引用注入"><a href="#2-引用注入" class="headerlink" title="2.引用注入"></a>2.引用注入</h6><p><strong>引用注入</strong> 是指将一个对象作为另一个对象的属性注入。例如，在一个类中注入另一个类的实例。在 XML 配置或基于注解的方式中，都可以实现引用注入。</p><p><strong>引用注入是指将一个 Bean 注入到另一个 Bean 中，这个 Bean 可以通过构造器、Setter 方法、或其他方式注入。引用注入强调的是一种</strong>引用关系**。</p><p><code>Person</code> 类需要 <code>Address</code> 类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String street;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">// 引用注入</span><br><span class="hljs-comment">// getters and setters</span><br><br><span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <span class="hljs-comment">//构造器</span><br>Person(Address address)<br>&#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Person</code> 类依赖于 <code>Address</code> 类，即 <code>Person</code> 拥有一个 <code>Address</code> 类型的属性。我们可以通过 Spring 配置文件来实现引用注入。</p><p>XML 配置引用注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;New York&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5th Avenue&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John Doe&quot;</span>/&gt;</span>//属性注入<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 引用注入 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>///ref 属性表示引用另一个 Bean。<br></code></pre></td></tr></table></figure><p>基于注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <br><span class="hljs-keyword">private</span> String name;    <br><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 注解方式引用注入    </span><br><span class="hljs-keyword">private</span> Address address;   <br>/<br>/ getters and setters    <span class="hljs-comment">//... &#125;</span><br></code></pre></td></tr></table></figure><h6 id="3-setter注入"><a href="#3-setter注入" class="headerlink" title="3.setter注入"></a>3.setter注入</h6><p><strong>Setter 注入</strong> 是一种通过提供 setter 方法来实现依赖注入的方式</p><p>Setter 注入通常用于将简单数据类型（如 <code>String</code>、<code>int</code>）或引用类型注入到 Bean 中。在 XML 配置中使用 <code>&lt;property&gt;</code> 标签来定义：</p><p><code>&lt;property&gt;</code> 标签的 <code>name</code> 属性表示要注入的属性名称，<code>value</code> 属性表示简单数据类型的值，<code>ref</code> 属性表示对其他 Bean 的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;Jane Doe&quot;</span>/&gt; &lt;!-- 简单类型 --&gt;<br>    &lt;property name=<span class="hljs-string">&quot;address&quot;</span> ref=<span class="hljs-string">&quot;address&quot;</span>/&gt; &lt;!-- 引用类型 --&gt;<br>&lt;/bean&gt;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Address</span> address;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Address</span> <span class="hljs-title function_">getAddress</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">Address</span> address</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="4-构造器注入"><a href="#4-构造器注入" class="headerlink" title="4.构造器注入"></a>4.构造器注入</h6><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ac8de3631e734a2817de72f0e21076e.jpeg" alt="2ac8de3631e734a2817de72f0e21076e"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/906d5345ed81c62f2ca79c2c87182043.jpeg" alt="906d5345ed81c62f2ca79c2c87182043"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/37aa8dfa1862573eb20ad4710135f7a0.jpeg" alt="37aa8dfa1862573eb20ad4710135f7a0"></strong></p><h6 id="4-依赖注入方式选择"><a href="#4-依赖注入方式选择" class="headerlink" title="4.依赖注入方式选择"></a>4.依赖注入方式选择</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7f4076b8a85df6389a465186386ba9f.jpeg" alt="d7f4076b8a85df6389a465186386ba9f"></p><h6 id="5-依赖自动装配"><a href="#5-依赖自动装配" class="headerlink" title="5.依赖自动装配"></a>5.依赖自动装配</h6><p>IOC容器根据bean所依赖的资源在容器中自动查找并注入到bena的过程称为自动装配</p><p>1.按类型</p><p>2.按名称</p><p>3.按构造方法</p><p>4.不启用自动装配</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d604dff0d944968b0f83ef5e0ed9148f.png" alt="d604dff0d944968b0f83ef5e0ed9148f"></strong></p><p>更改自动装配为按照类型</p><p>比如bookServcice依赖BookDao–我们不需要描述其关系 程序会自动根据名字找到对应类的bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入 不需要`&lt;property&gt;来描述引用关系</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">BookDao</span> bookDao</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">bookDao</span> = bookDao;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="8-集合注入"><a href="#8-集合注入" class="headerlink" title="8.集合注入"></a>8.集合注入</h4><h6 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6956e79faab9804acbd6a47b860b0245.png" alt="6956e79faab9804acbd6a47b860b0245"></p><h6 id="2-list"><a href="#2-list" class="headerlink" title="2.list"></a>2.list</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/43ed876a380305fa263d981c7a984c74.png" alt="43ed876a380305fa263d981c7a984c74"></p><h6 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;p&gt;</span><br><span class="hljs-section">&lt;set&gt;</span><br><br><span class="hljs-section">&lt;/set&gt;</span><br><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ca7bbcd65d882884d7297dd75609d006.png" alt="ca7bbcd65d882884d7297dd75609d006"></p><h6 id="5-Properties"><a href="#5-Properties" class="headerlink" title="5.Properties"></a>5.Properties</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2fac8b9f2d57b4c92547d6a8235169a4.png" alt="2fac8b9f2d57b4c92547d6a8235169a4"></p><h4 id="9-案例分析-bean注入"><a href="#9-案例分析-bean注入" class="headerlink" title="9.案例分析-bean注入"></a>9.案例分析-bean注入</h4><p>我们要拿到druid的连接</p><p>1.配置bean -注入参数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/00252469c47ede33f309cf222de6d27a.png" alt="00252469c47ede33f309cf222de6d27a"></p><p>我们就可以进行拿取</p><p>Set注入–进行注入传普通参数</p><h4 id="10-加载properties文件"><a href="#10-加载properties文件" class="headerlink" title="10.加载properties文件"></a>10.加载properties文件</h4><p><code>.properties</code> 文件的结构和格式</p><ul><li><strong>文件扩展名</strong>：<code>.properties</code></li><li><strong>基本格式</strong>：每行包含一个键值对，格式为 <code>key=value</code></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3259185201691e092710f1c19ad74f73.png" alt="3259185201691e092710f1c19ad74f73"></p><p>加载模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e482c7cd8837d44f0b1684ae235838c7.png" alt="e482c7cd8837d44f0b1684ae235838c7"></p><h4 id="11-容器"><a href="#11-容器" class="headerlink" title="11.容器"></a>11.容器</h4><p>创建过程包括多个关键步骤，从加载配置文件、解析 Bean 定义，到创建和初始化 Bean，再到处理 Bean 的生命周期和容器的启动与关闭。</p><h6 id="1-初始化容器"><a href="#1-初始化容器" class="headerlink" title="1.初始化容器"></a>1.初始化容器</h6><p><strong>加载配置</strong>：Spring 容器从配置文件或注解中加载应用程序的配置。这些配置文件可以是 XML 文件、Java 配置类（使用 <code>@Configuration</code> 注解）、或通过其他方式如 YAML 文件等</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88afb0e3109da0ceb049ce45b2ea81dd.png" alt="88afb0e3109da0ceb049ce45b2ea81dd"></p><p>创建 ApplicationContext 实例</p><p>ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p><h6 id="2-加载-Bean-定义"><a href="#2-加载-Bean-定义" class="headerlink" title="2.加载 Bean 定义"></a>2.加载 Bean 定义</h6><p>流程</p><p><strong>解析配置</strong>：Spring 容器解析配置文件中的 Bean 定义（包括 Bean 的类名、构造器参数、属性值等），或扫描标注有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类。</p><p><strong>注册 Bean 定义</strong>：将解析得到的 Bean 定义注册到容器中。这包括 Bean 的名称、类型、作用域（如单例或原型）、依赖关系等信息。</p><p><strong>创建 Bean 实例</strong>：根据 Bean 定义，Spring 容器创建 Bean 实例。Spring 使用反射机制调用 Bean 的构造函数（若是构造器注入）或默认构造函数。</p><p><strong>依赖注入</strong>：在 Bean 实例创建后，Spring 容器根据 Bean 定义的依赖关系注入所需的依赖。这包括构造器注入、Setter 注入、字段注入等方式。</p><p><strong>执行初始化方法</strong>：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6441e65ec06a343800d7d118ec915bf7.png" alt="6441e65ec06a343800d7d118ec915bf7"></p><p>处理 Bean 的生命周期</p><p><strong>Bean 销毁</strong>：在容器关闭时，Spring 会销毁 Bean。-&gt;bean生命周期方法</p><p> <strong>容器的启动和关闭</strong></p><p><strong>启动容器</strong>：Spring 容器在创建完成后会启动并准备好处理应用程序的请求和交互。此时，所有的 Bean 都已经被创建和初始化完毕，可以使用它们提供的功能。</p><p><strong>关闭容器</strong>：容器可以通过调用 <code>ApplicationContext</code> 的 <code>close</code> 方法来关闭。在关闭过程中，容器会执行 Bean 的销毁操作，释放资源，完成容器的清理工作。</p><h6 id="3-容器接口分析"><a href="#3-容器接口分析" class="headerlink" title="3.容器接口分析"></a>3.容器接口分析</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d310da378a35e1bc86067389adf5c3b.png" alt="8d310da378a35e1bc86067389adf5c3b"></p><h6 id="4-BeanFactory初始化"><a href="#4-BeanFactory初始化" class="headerlink" title="4.BeanFactory初始化"></a>4.BeanFactory初始化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ccb6cf9576f42e82a4190ea129f29b18.png" alt="ccb6cf9576f42e82a4190ea129f29b18"></p><h2 id="IOC-DI-Bean总结"><a href="#IOC-DI-Bean总结" class="headerlink" title="IOC DI Bean总结"></a>IOC DI Bean总结</h2><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aec185bb8dc978e09e302c6e168d677e.jpeg" alt="aec185bb8dc978e09e302c6e168d677e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/18abb534418dab1c205c287cd041975f.jpeg" alt="18abb534418dab1c205c287cd041975f"></p><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h4 id="12-注解"><a href="#12-注解" class="headerlink" title="12.注解"></a>12.注解</h4><h6 id="1-声明为Bean"><a href="#1-声明为Bean" class="headerlink" title="1.@声明为Bean"></a>1.@声明为Bean</h6><p>将一个类声明为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/86b345941eab120771d71166dbf2beb3.png" alt="86b345941eab120771d71166dbf2beb3"></p><p>为了适配MVC-&gt;故此还有 @Controller @Service @Repository</p><h6 id="2-纯注解配置"><a href="#2-纯注解配置" class="headerlink" title="2.纯注解配置"></a>2.纯注解配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/547c0427ec597688cc1c0ec42b75f8a2.png" alt="547c0427ec597688cc1c0ec42b75f8a2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e5159d69c7dd85c33f019d20ac3be99.png" alt="8e5159d69c7dd85c33f019d20ac3be99"></p><h6 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ede5cccd6b754d10bd7e5d2dfb4db131.png" alt="ede5cccd6b754d10bd7e5d2dfb4db131"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f4d394d6384f8e1211f0b8775862a884.png" alt="f4d394d6384f8e1211f0b8775862a884"></p><p>简单类型注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2cde566b050a6d34fbe85be5502e6c50.png" alt="2cde566b050a6d34fbe85be5502e6c50"></p><h6 id="4-加载properties文件"><a href="#4-加载properties文件" class="headerlink" title="4.加载properties文件"></a>4.加载properties文件</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/73301e328b26e40279005a10ac179d9b.png" alt="73301e328b26e40279005a10ac179d9b"></p><p>![22a1fbb70d0306860f7d4ce5107158b5](G:\360MoveData\Users\nixg\Documents\Tencent Files\819429207\nt_qq\nt_data\Pic\2024-03\Ori\22a1fbb70d0306860f7d4ce5107158b5.png)</p><h6 id="5-第三方bean管理例子"><a href="#5-第三方bean管理例子" class="headerlink" title="5.第三方bean管理例子"></a>5.第三方bean管理例子</h6><p>1.注册为bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b515a9216fdb4b0cf13229af949a5107.png" alt="b515a9216fdb4b0cf13229af949a5107"></p><p>2.加入管理-导入式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/26e0669596d4e65ef8badc876869a654.png" alt="26e0669596d4e65ef8badc876869a654"></p><p>扫描式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f1c3b59e56b859a8a04b94fa9cc65876.png" alt="f1c3b59e56b859a8a04b94fa9cc65876"></p><p>简单依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240330164305805.png" alt="image-20240330164305805"></p><p>—连接池配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f09511581cde24e3c7dfcb783c3dc4c.png" alt="2f09511581cde24e3c7dfcb783c3dc4c"></p><h4 id="XML与注解-配置区别"><a href="#XML与注解-配置区别" class="headerlink" title="XML与注解 配置区别"></a>XML与注解 配置区别</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4f6fbbd9134d7813d17dec19a77cd8c.jpeg" alt="b4f6fbbd9134d7813d17dec19a77cd8c"></p><h4 id="13-aop"><a href="#13-aop" class="headerlink" title="13.aop"></a>13.aop</h4><h5 id="1-Aop基础"><a href="#1-Aop基础" class="headerlink" title="1.Aop基础"></a>1.Aop基础</h5><h6 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h6><p>AOP的原理主要是通过使用代理对象来实现，在Spring中，AOP通过代理对象包装目标对象（被代理的对象），在代理对象中插入切面（aspect），实现对目标对象方法的增强。Spring AOP主要采用动态代理技术来实现AOP，其中包括JDK动态代理和CGLIB动态代理两种方式。</p><blockquote><p>只有那些被 Spring 容器管理的 Bean（例如使用 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, 或 <code>@Controller</code> 等注解的类，或者通过 XML 配置的 Bean），Spring 才能为它们创建代理对象。</p></blockquote><p>代理对象的工作原理</p><ol><li><p><strong>代理对象的生成</strong>：</p><ul><li>当容器启动并扫描到 <code>@EnableAspectJAutoProxy</code> 注解时，Spring AOP 框架会自动创建一个代理对象来包装原始的 <code>UserServiceImpl</code> 对象。</li><li>根据 <code>UserService</code> 接口类型，Spring 将使用 <strong>JDK 动态代理</strong> 创建代理对象。</li></ul></li><li><p><strong>切面拦截方法</strong>：</p><ul><li>代理对象接收到方法调用时，它会拦截调用并根据 AOP 配置执行相应的切面逻辑。</li><li>在这个例子中，代理对象会在方法执行前和执行后调用 <code>LoggingAspect</code> 中的切面方法 <code>logBeforeMethod()</code> 和 <code>logAfterMethod()</code>。</li></ul></li><li><p><strong>方法调用的委托</strong>：</p><ul><li><p>在执行完切面方法后，代理对象会将方法调用委托给实际的目标对象 (<code>UserServiceImpl</code>) 以完成核心业务逻辑4</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserService</span> <span class="hljs-title function_">userService</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-title function_">loggingAspect</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingAspect</span>();<br>    &#125;<br>&#125;<br>---------------------------------<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">&quot;execution(* com.example.service.UserService.*(..))&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">allUserServiceMethods</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logBeforeMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: Before method execution&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logAfterMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: After method execution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><p>再框架中添加了个拦截器-&gt;依据正则过滤</p><h6 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h6><ol><li><strong>日志记录</strong>：记录方法的调用、参数、返回值等信息。</li><li><strong>事务管理</strong>：管理事务的开始、提交、回滚等操作。</li><li><strong>安全性</strong>：实现权限控制、加密解密等安全相关功能。</li><li><strong>性能监控</strong>：统计方法的执行时间、次数等性能指标。</li></ol><h6 id="3-连接点-切面-切入点-通知"><a href="#3-连接点-切面-切入点-通知" class="headerlink" title="3.连接点 切面 切入点 通知"></a>3.连接点 切面 切入点 通知</h6><hr><p>切面 @Aspect</p><p>定义一个类为切面类 -通知和切入点</p><p>@Aspect注解标识一个类为切面类，Spring会在扫描到这个注解的类时，自动创建代理对象，并将切面逻辑织入到目标方法中。</p><hr><p>通知</p><p>通知（Advice）是指切面（Aspect）中定义的在程序执行过程中插入的代码片段，它们是在指定的连接点（Join Point）处执行的行为逻辑。通知的主要作用是定义在目标方法执行前后、异常抛出时等特定情况下，应该执行的动作或逻辑。</p><p>@Before和@After</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeMethod</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Before method execution&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>切入点</p><p>它用于定义通知（Advice）应用的具体位置（方法或类）。切入点决定了通知在哪些连接点（Join Point）上执行。切入点的主要作用是<strong>定义通知的应用范围</strong>，即通知应该在什么情况下、对哪些方法或类生效。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* Calculator.divide(..)</span></span>)<br><br></code></pre></td></tr></table></figure><p>-通知+切入点-哪个方法被aop进行管理-再什么时候运行</p><hr><p>连接点</p><p>连接点是代码执行过程中的具体位置，可以被切面（Aspect）拦截并注入相应的增强逻辑。</p><p>当切入点表达式匹配到一个被 AOP 管理的类的方法时，这些方法就被认为是 <strong>连接点（Join Points）</strong>。</p><hr><p>@Before(“execution(* Calculator.add(..))”)</p><p>通知+切入点</p><p>代表了 Calculator类的add方法上执行增强操作</p><p>案例代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-comment">//连接点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-comment">//切面</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* Calculator.add(..))&quot;)</span><br>    <span class="hljs-comment">///通知 切入点 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeAdd</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging before the add method is called&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;execution(* Calculator.divide(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterDivide</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging after the divide method is called&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">&lt;aop:aspectj-autoproxy/&gt;<br>&lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="2-Aop进阶"><a href="#2-Aop进阶" class="headerlink" title="2.Aop进阶"></a>2.Aop进阶</h5><h6 id="1-通知类型"><a href="#1-通知类型" class="headerlink" title="1.通知类型"></a>1.通知类型</h6><ol><li><p>前置通知（Before Advice）：在目标方法执行之前调用通知方法。</p><p>对应注解：<code>@Before</code></p></li><li><p>后置通知（After Returning Advice）：在目标方法成功执行之后调用通知方法。</p><p>对应注解：<code>@AfterReturning</code></p></li><li><p>后置异常通知（After Throwing Advice）：在目标方法抛出异常后调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@AfterThrowing</span><br></code></pre></td></tr></table></figure></li><li><p>后置通知（After (finally) Advice）：无论目标方法是否成功执行，都会调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@After</span><br></code></pre></td></tr></table></figure></li><li><p>环绕通知（Around Advice）：在目标方法之前和之后执行通知方法，可以控制目标方法的执行过程。</p><p>对应注解：<code>@Around</code></p></li><li><p>引入通知（Introduction Advice）：向现有的对象添加新的方法或属性。</p></li><li><p>织入通知（AspectJ Advice）：在AOP中指定切点和通知的组合。</p></li></ol><hr><p>案例</p><ol><li><p>前置通知（Before Advice）：在用户进行结账操作时，检查用户的权限，确保用户具有足够的权限进行结账操作。</p></li><li><p>后置通知（After Returning Advice）：在用户提交订单成功后，记录订单信息到日志中，或者发送确认邮件给用户。</p></li><li><p>后置异常通知（After Throwing Advice）：如果订单处理过程中出现异常，比如库存不足，就发送通知给相关人员进行处理。</p></li><li><p>后置最终通知（After (finally) Advice）：无论订单处理成功与否，都需要关闭数据库连接或释放其他资源。</p></li><li><p>环绕通知（Around Advice）：在处理订单之前和之后记录订单处理时间，以及性能监控等功能。</p></li><li><p>引入通知（Introduction Advice）：向订单类引入一个新的接口，比如可追踪变更历史的接口。</p></li><li><p>织入通知（AspectJ Advice）：定义一个切面，将上述的各种通知类型织入到订单处理的流程中。</p></li></ol><p>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.aspectj.lang.annotation.AfterReturning;<br>import org.aspectj.lang.annotation.AfterThrowing;<br>import org.aspectj.lang.annotation.After;<br>import org.aspectj.lang.annotation.Around;<br>import org.aspectj.lang.ProceedingJoinPoint;</p><p>@Aspect<br>public class LoggingAspect {</p><pre><code class="hljs">@Before(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void beforeProcessOrder() &#123;    System.out.println(&quot;Before processing order...&quot;);&#125;@AfterReturning(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, returning = &quot;result&quot;)public void afterProcessOrder(Object result) &#123;    System.out.println(&quot;After processing order. Result: &quot; + result);&#125;@AfterThrowing(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, throwing = &quot;exception&quot;)public void afterThrowingProcessOrder(Exception exception) &#123;    System.out.println(&quot;Exception thrown during order processing: &quot; + exception.getMessage());&#125;@After(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void afterProcessOrderCompletion() &#123;    System.out.println(&quot;After processing order completion...&quot;);&#125;@Around(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123;    long startTime = System.currentTimeMillis();    Object result = joinPoint.proceed();    long endTime = System.currentTimeMillis();    System.out.println(&quot;Order processing time: &quot; + (endTime - startTime) + &quot; milliseconds&quot;);    return result;&#125;</code></pre><h6 id="2-通知顺序"><a href="#2-通知顺序" class="headerlink" title="2.通知顺序"></a>2.通知顺序</h6><p>当多个切面匹配到同一个类时，可以按照切入点所在类的字母顺序来决定通知方法的执行顺序</p><p>1.类字母</p><p>按照匹配到的切入点的类字母决定先后顺讯</p><p>1.前置-字母排名靠前的先执行</p><p>2.后置-字母排名靠前的后执行</p><p>2.@Order</p><p>可以使用<code>@Order</code>注解来控制多个通知方法的执行顺序。通过<code>@Order</code>注解可以指定通知方法的执行顺序，数值越小的通知方法优先执行。</p><p>具体步骤如下：</p><ol><li>在定义通知方法的类上添加<code>@Component</code>或其他相关注解，使其成为Spring容器中的Bean。</li><li>在通知方法上添加<code>@Order</code>注解，并指定执行顺序的数值，数值越小优先级越高。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(1)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 前置通知的实现</span><br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 后置通知的实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标前-数字小的先执行</p><p>目标后-数字小的后执行</p><h6 id="3-切入点"><a href="#3-切入点" class="headerlink" title="3.切入点"></a>3.切入点</h6><p>1.execution</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0484d9f1bbe10d4207d84882472bf29.png" alt="b0484d9f1bbe10d4207d84882472bf29"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e0a84ff1d8ccee34eb3876e12a63ef97.png" alt="e0a84ff1d8ccee34eb3876e12a63ef97"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ce5a2480e7eaf7f880d1624f4013487.png" alt="3ce5a2480e7eaf7f880d1624f4013487"></p><h4 id="2-注解aop开发"><a href="#2-注解aop开发" class="headerlink" title="2.注解aop开发"></a>2.注解aop开发</h4><p>代码案例</p><p>首先，定义一个自定义注解<code>CustomAnnotation</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-comment">//@Target(ElementType.METHOD)：表示该注解可以用于方法上。这意味着CustomAnnotation只能用于方法的声明中，而不能用于其他地方，比如类、字段等。</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-comment">///@Retention(RetentionPolicy.RUNTIME)：表示该注解在运行时可以被反射读取。这意味着在运行时，我们可以通过Java的反射机制来获取并处理带有CustomAnnotation注解的方法。</span><br>public <span class="hljs-variable">@interface</span> CustomAnnotation &#123;<br>    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">value</span>();<br>&#125;<br>这两个元数据的设定确保了<span class="hljs-selector-tag">CustomAnnotation</span>注解的使用方式和其在程序运行期间的可见性，使其可以被<span class="hljs-selector-tag">AOP</span>或其他机制所识别并进行相应的处理。<br></code></pre></td></tr></table></figure><p>接着，在一个服务类中使用<code>CustomAnnotation</code>注解：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Service</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;<br><br>    <span class="hljs-variable">@CustomAnnotation</span>(<span class="hljs-string">&quot;Custom Annotation Example&quot;</span>)<br>    public void myMethod() &#123;<br>        <span class="hljs-regexp">//</span> 方法实现<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>@CustomAnnotation(&quot;Custom Annotation Example&quot;)</code>这个注解中，双引号里面的参数是注解的属性值。在定义自定义注解时，可以为注解定义属性，并在使用注解时为这些属性赋值。</p><p>在这个示例中，自定义注解<code>CustomAnnotation</code>定义了一个名为<code>value</code>的属性，因此在使用这个注解时，需要为<code>value</code>属性赋值。双引号中的内容 <code>&quot;Custom Annotation Example&quot;</code> 就是为<code>value</code>属性赋的具体数值。</p><p>当在切面类中通过反射获取带有<code>CustomAnnotation</code>注解的方法时，可以通过访问注解的属性值来获取这里传入的参数值，从而实现根据不同的属性值执行不同的逻辑处理。</p><hr><p>然后，在切面类中使用<code>@annotation</code>注解匹配带有<code>CustomAnnotation</code>注解的方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Aspect</span><br>public class MyAspect &#123;<br><br>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;@annotation(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">annotatedMethod</span>(CustomAnnotation customAnnotation) &#123;&#125;<br><br>    <span class="hljs-variable">@Before</span>(<span class="hljs-string">&quot;annotatedMethod(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">beforeAnnotatedMethod</span>(CustomAnnotation customAnnotation) &#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Before advice for method with custom annotation: &quot;</span> + customAnnotation.<span class="hljs-built_in">value</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个切入点表达式 <code>@annotation(customAnnotation)</code> 的作用是匹配所有被 <code>@CustomAnnotation</code> 注解标记的方法。</p><p><code>@annotation(customAnnotation)</code> 是 AspectJ 提供的一个语法，用来匹配方法级别的注解。这里，<code>customAnnotation</code> 是一个参数，它表示目标方法上使用的 <code>@CustomAnnotation</code>。</p><p>同时<code>annotatedMethod</code> f方法的主要用处是可以在通知（Advice）方法中使用一个更清晰、易读的命名标识来引用切入点。</p><hr><p><code>@Before(&quot;annotatedMethod(customAnnotation)&quot;)</code> 表示在所有匹配 <code>@annotation(customAnnotation)</code> 切入点的方法执行之前，执行 <code>beforeAnnotatedMethod</code> 这个方法。</p><p><code>beforeAnnotatedMethod</code> 方法将会在任何被 <code>@CustomAnnotation</code> 标记的方法执行之前运行。它可以访问这个自定义注解实例 <code>customAnnotation</code>，并获取该注解中的属性（例如 <code>value()</code> 方法）。</p><h6 id="4-连接点"><a href="#4-连接点" class="headerlink" title="4.连接点"></a>4.连接点</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9a1881e71612ce58b920331bae4d304.png" alt="c9a1881e71612ce58b920331bae4d304"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6ecb0785b0a6a59af4c08f919aeb6b9e.png" alt="6ecb0785b0a6a59af4c08f919aeb6b9e"></p><h4 id="14-事务"><a href="#14-事务" class="headerlink" title="14.事务"></a>14.事务</h4><h6 id="0-事务的声明式管理"><a href="#0-事务的声明式管理" class="headerlink" title="0.事务的声明式管理"></a>0.事务的声明式管理</h6><p><strong>Spring 事务管理</strong> 依赖于 <strong>AOP 的思想和机制</strong> 来实现声明式事务管理。</p><p>在 Spring 中，当你使用 <code>@Transactional</code> 注解声明一个方法或类需要事务管理时，Spring AOP 会在运行时为这些方法或类创建一个代理对象（Proxy）。代理对象负责在方法调用之前开始事务，在方法调用之后提交或回滚事务。</p><p>Spring 使用 AOP 机制来织入事务管理代码。<code>@Transactional</code> 注解背后是通过 AOP 来实现的。在方法执行的前后，AOP 拦截器会自动进行事务管理操作（如事务开启、提交和回滚），而这些操作对业务代码是透明的。</p><p>这种方式被称为 <strong>声明式事务管理</strong>，它使用 <code>@Transactional</code> 注解指定哪些方法或类需要事务支持，不需要在业务代码中显式地编写事务处理逻辑。</p><p>切面</p><p>Spring 框架定义了一个 <strong>事务切面</strong>（Transaction Aspect），用来拦截被 <code>@Transactional</code> 标记的方法。这个切面是在方法调用前后执行相应的事务操作。</p><p>切入点</p><p>@Transactional</p><p>通知</p><p>通知逻辑</p><p>在方法执行前，事务切面拦截器会开启一个事务。</p><p>如果方法正常执行完成，则事务切面拦截器会提交事务。</p><p>如果方法执行过程中抛出了异常，事务切面拦截器会根据配置决定是回滚事务还是提交事务。</p><h6 id="1-事务入门-例子"><a href="#1-事务入门-例子" class="headerlink" title="1.事务入门 -例子"></a>1.事务入门 -例子</h6><p>假设我们有一个简单的用户管理系统，其中包括一个服务类 <code>UserService</code>，负责创建用户。我们希望在执行用户</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserRepository</span> userRepository;<br><br>    <span class="hljs-comment">// 被 @Transactional 注解的方法将由 Spring AOP 管理</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> username</span>) &#123;<br>        <span class="hljs-comment">// 保存用户</span><br>        userRepository.<span class="hljs-title function_">save</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(username));<br><br>        <span class="hljs-comment">// 模拟一个异常情况，测试事务回滚</span><br>        <span class="hljs-keyword">if</span> (username == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Username cannot be null&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br>----------<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);<br>        <span class="hljs-title class_">UserService</span> userService = context.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">UserService</span>.<span class="hljs-property">class</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.<span class="hljs-title function_">createUser</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 将会导致事务回滚</span><br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Exception caught: &quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-事务管理员-事务协调员"><a href="#2-事务管理员-事务协调员" class="headerlink" title="2.事务管理员 事务协调员"></a>2.事务管理员 事务协调员</h6><p>例子事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/342dd9a76057ac1992637973417a63c8.png" alt="342dd9a76057ac1992637973417a63c8"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9b888313da273ab68bfb514f19274a0b.png" alt="9b888313da273ab68bfb514f19274a0b"></p><h6 id="3-事务配置"><a href="#3-事务配置" class="headerlink" title="3.事务配置"></a>3.事务配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f65b886518d3736b235a310f1a6754.png" alt="b6f65b886518d3736b235a310f1a6754"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/59d7f8499d23c0a2bcfdb780f1e00ea3.png" alt="59d7f8499d23c0a2bcfdb780f1e00ea3"></p><h5 id="4-事务加入-规则"><a href="#4-事务加入-规则" class="headerlink" title="4.事务加入-规则"></a>4.事务加入-规则</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/03f05df2aa222c9fb3abd3efb44ef699.png" alt="03f05df2aa222c9fb3abd3efb44ef699"></p><p>例子</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5dde408db43ac7d09f859c76ed257c91.png" alt="5dde408db43ac7d09f859c76ed257c91"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fba20ae7cf0e8f32ff7aa3de0fb42e42.png" alt="fba20ae7cf0e8f32ff7aa3de0fb42e42"></p><p>如图-都加入同一事务-一旦有异常-日志也会回滚</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9972f6f167883d144abc515733c62536.png" alt="9972f6f167883d144abc515733c62536"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5f99a409d1ff453639c1d9cc7aa2fcf2.png" alt="5f99a409d1ff453639c1d9cc7aa2fcf2"></p><p>解决</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf8e05d7e9f071a8464d78b45eab2ae5.png" alt="cf8e05d7e9f071a8464d78b45eab2ae5"></p><h6 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fa818038f3cf6f80cf14608cec80c598.png" alt="fa818038f3cf6f80cf14608cec80c598"></p><h4 id="0-1-Spring-整合mybatis"><a href="#0-1-Spring-整合mybatis" class="headerlink" title="0.1 Spring 整合mybatis"></a>0.1 Spring 整合mybatis</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/11abe4ba3472982e3b1b217edb94c96e.png" alt="11abe4ba3472982e3b1b217edb94c96e"></p><p>-&gt;将该注册为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e038210f851e6d054f2de5a40605d29c.png" alt="e038210f851e6d054f2de5a40605d29c"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb16bf7c1655375464b67dcd0194534b.png" alt="eb16bf7c1655375464b67dcd0194534b"></p><p>如图–以上配置全部进行修改</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/241a0676f37e4b12a5eef8cdc8e7fe35.png" alt="241a0676f37e4b12a5eef8cdc8e7fe35"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79a9256b4115e3f74adcb4dfc1db5f30.png" alt="79a9256b4115e3f74adcb4dfc1db5f30"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ba320445dccb955e30224a3bbee6193.png" alt="3ba320445dccb955e30224a3bbee6193"></p><p>收纳</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7ff11a9112a3615d298943a68b54e9d6.png" alt="7ff11a9112a3615d298943a68b54e9d6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55cab2a9fb9c8def31581e7f33474ad0.png" alt="55cab2a9fb9c8def31581e7f33474ad0"></p><h4 id="0-2-Spring整合测试"><a href="#0-2-Spring整合测试" class="headerlink" title="0.2 Spring整合测试"></a>0.2 Spring整合测试</h4><p>设定类运行器</p><p>整合spring运行器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6981732edb98c9b849ff758c5c4053c1.png" alt="6981732edb98c9b849ff758c5c4053c1"></p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>maven笔记</title>
    <link href="/2024/09/10/maven%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/10/maven%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="maven笔记"><a href="#maven笔记" class="headerlink" title="maven笔记"></a>maven笔记</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Maven.png" alt="Maven"></p><h4 id="1-Maven入门"><a href="#1-Maven入门" class="headerlink" title="1.Maven入门"></a>1.Maven入门</h4><h6 id="1-maven是什么"><a href="#1-maven是什么" class="headerlink" title="1.maven是什么"></a>1.maven是什么</h6><p>maven是一个统一构建工具-帮助我们快速的导入jar包-同时通过pom对jar进行统一管理–maen还统一了目录结构</p><p>项目构建–依赖管理-统一开发结构</p><h6 id="2-maven仓库"><a href="#2-maven仓库" class="headerlink" title="2.maven仓库"></a>2.maven仓库</h6><p>云端存储jar包—同时本地-私服</p><h6 id="3-坐标"><a href="#3-坐标" class="headerlink" title="3.坐标"></a>3.坐标</h6><p>groupld-定义maven项目组织名称</p><p>artifactld–定义当前maven项目名称</p><p>version-定义当前版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>坐标作用-使用唯一表示-定位资源位置</p><h6 id="4-手动创建maven工程"><a href="#4-手动创建maven工程" class="headerlink" title="4.手动创建maven工程"></a>4.手动创建maven工程</h6><p>–省-就是用命令来创建</p><h4 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2.依赖管理"></a>2.依赖管理</h4><h6 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1.依赖配置"></a>1.依赖配置</h6><dependencies></dependency><dependency></dependencies><h6 id="2-依赖传递"><a href="#2-依赖传递" class="headerlink" title="2.依赖传递"></a>2.依赖传递</h6><p>直接依赖–再当前项目内直接通过pom建立依赖关系</p><p>间接依赖-一个依赖依赖于其他依赖–当前项目会都导入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88a5b650615c05bdb3b51bb6518a3044.png" alt="88a5b650615c05bdb3b51bb6518a3044"></p><h6 id="3-可选依赖"><a href="#3-可选依赖" class="headerlink" title="3.可选依赖"></a>3.可选依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69b032579ca283056eb5f2d056059bf4.png" alt="69b032579ca283056eb5f2d056059bf4"></p><h6 id="4-排查依赖"><a href="#4-排查依赖" class="headerlink" title="4.排查依赖"></a>4.排查依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e2be3508cc74b63a6c7f32972fa4017e.png" alt="e2be3508cc74b63a6c7f32972fa4017e"></p><h6 id="5-依赖范围"><a href="#5-依赖范围" class="headerlink" title="5.依赖范围"></a>5.依赖范围</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eaf5484e109c98583c4af32c8cc48353.png" alt="eaf5484e109c98583c4af32c8cc48353"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e74890abdf3d3cbdd37154251a5c005.png" alt="9e74890abdf3d3cbdd37154251a5c005"></p><h4 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h4><p>快速生命周期-compile-test-compile-test-package-install</p><p>生命周期介绍</p><p>clean-清理工作</p><p>default0核心工作-如编译-测试打包-部署</p><p>site-产生报告-发布站点</p><hr><p>Clean生命周期</p><p>pre-clean-执行一些需要再clean之前完成的工作</p><p>clean-移除上一次构建生成的文件</p><p>post-clean-执行一些需要再clean之后立刻完成的工作</p><hr><p>default构建生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1c6053fbcc84183fbc8f1a7789cee3fb.png" alt="1c6053fbcc84183fbc8f1a7789cee3fb"></p><hr><p>site生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7037669c99ca8e172d0144f4de087264.png" alt="7037669c99ca8e172d0144f4de087264"></p><hr><p>default 介绍</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69d200277cfe62e6d98340f0269f0bfe.png" alt="69d200277cfe62e6d98340f0269f0bfe"></p><p>又分为三大周期</p><h4 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/455befffa49ca7d0354264bf3db7dd62.png" alt="455befffa49ca7d0354264bf3db7dd62"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d32a812fe29eddabf67bcda3cfbcae8b.png" alt="d32a812fe29eddabf67bcda3cfbcae8b"></p><h1 id="Maven-高级"><a href="#Maven-高级" class="headerlink" title="Maven-高级"></a>Maven-高级</h1><h4 id="1-分模块开发与设计"><a href="#1-分模块开发与设计" class="headerlink" title="1.分模块开发与设计"></a>1.分模块开发与设计</h4><p>将一个大型项目拆分为多个独立模块的开发方式。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f0de39a2aea7bbe668e3574cef96944.png" alt="8f0de39a2aea7bbe668e3574cef96944"></p><p>如图 分模块开发就是将模块-导成架包–</p><p>例如-公司 -pojo包-导给你，你只需要导入pom即可使用</p><h4 id="2-聚合"><a href="#2-聚合" class="headerlink" title="2.聚合"></a>2.聚合</h4><p>将模块-聚合再一起构建</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/14b16e3b8bff7a90e90f6f6d42086115.png" alt="14b16e3b8bff7a90e90f6f6d42086115"></p><h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f4069f69f02e626eba8d6941cd4394.png" alt="b6f4069f69f02e626eba8d6941cd4394"></p><p>继承依赖使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62d9f5c074c0336ef3fcb5d36fd6546d.png" alt="62d9f5c074c0336ef3fcb5d36fd6546d"></p><p>继承资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3225c0c79867bfb1e4f2abe6cf748d9.png" alt="f3225c0c79867bfb1e4f2abe6cf748d9"></p><p>继承聚合区别</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240414120838551.png" alt="image-20240414120838551"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br>xml<br><span class="hljs-comment">&lt;!-- 子模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-属性"><a href="#4-属性" class="headerlink" title="4.属性"></a>4.属性</h4><p>属性最大的作用-配置-和版本管理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c4f542e3165840110e15b9913de9dc.png" alt="b4c4f542e3165840110e15b9913de9dc"></p><p>1.自定义属性管理</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/90eb8af64c4b02ba15ed77e0ac33fd16.png" alt="90eb8af64c4b02ba15ed77e0ac33fd16" style="zoom:75%;" /><h4 id="5-工厂版本"><a href="#5-工厂版本" class="headerlink" title="5.工厂版本"></a>5.工厂版本</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e1232256a286acb832c2975ad59ea8a1.png" alt="e1232256a286acb832c2975ad59ea8a1"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7d129e90eaca59df9ae2b62f7ab6ca55.png" alt="7d129e90eaca59df9ae2b62f7ab6ca55"></p><h4 id="6-资源配置"><a href="#6-资源配置" class="headerlink" title="6.资源配置"></a>6.资源配置</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9de34d5dbae1ebc7a72669952069638a.png" alt="9de34d5dbae1ebc7a72669952069638a"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5fc90c8dd4f839707b20624bdf4242c6.png" alt="5fc90c8dd4f839707b20624bdf4242c6"></p><h4 id="7-多环境开发配置"><a href="#7-多环境开发配置" class="headerlink" title="7.多环境开发配置"></a>7.多环境开发配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9c38f1922d021ec7c78c0c8ffbb0c0d5.png" alt="9c38f1922d021ec7c78c0c8ffbb0c0d5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2eccbb8497a79d12ba5b7337f7a9d98f.png" alt="2eccbb8497a79d12ba5b7337f7a9d98f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8c84b9496ecb0a2922bc874f8019530.png" alt="e8c84b9496ecb0a2922bc874f8019530"></p><h4 id="8-跳过测试"><a href="#8-跳过测试" class="headerlink" title="8.跳过测试"></a>8.跳过测试</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d039b87b2aa7539c3a17519c5e509652.png" alt="d039b87b2aa7539c3a17519c5e509652"></p><h4 id="9-私服"><a href="#9-私服" class="headerlink" title="9.私服"></a>9.私服</h4><p>省</p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础题目</title>
    <link href="/2024/09/10/nk/"/>
    <url>/2024/09/10/nk/</url>
    
    <content type="html"><![CDATA[<h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h6 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">JAVA2 简单运算<br>题目<br>题解(<span class="hljs-number">32</span>)<br>讨论(<span class="hljs-number">49</span>)<br>排行<br>入门  通过率：<span class="hljs-number">38.22%</span>  时间限制：<span class="hljs-number">1</span>秒  空间限制：<span class="hljs-number">256</span>M<br>warning 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。<br>描述<br>输入两个正整数<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>，输出这两个正整数的和，差，积，商，模（若<span class="hljs-selector-tag">a</span>&gt;<span class="hljs-selector-tag">b</span>则输出<span class="hljs-selector-tag">a</span>-<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>%<span class="hljs-selector-tag">b</span>的值反之输出<span class="hljs-selector-tag">b</span>-<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>/<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>%<span class="hljs-selector-tag">a</span>的值，不考虑小数，请使用int类型）<br>输入描述：<br>两个正整数<br>输出描述：<br>它们的和，差，积，商，模。每个值之间用空格隔开<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">10</span> <span class="hljs-number">5</span><br>复制<br>输出：<br><span class="hljs-number">15</span> <span class="hljs-number">5</span> <span class="hljs-number">50</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> a = scanner.<span class="hljs-built_in">nextInt</span>();<br>        <span class="hljs-type">int</span> b = scanner.<span class="hljs-built_in">nextInt</span>();<br>        scanner.<span class="hljs-built_in">close</span>();<br><br>        <span class="hljs-keyword">if</span>(a&gt;b)<br>        &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<br><br><br>        <span class="hljs-comment">//write your code here......</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt; <span class="hljs-comment">//堆区开辟对象 将它的引用压入操作数栈</span><br> <span class="hljs-number">3</span> dup <span class="hljs-comment">//复制了该对象引用，并再次将其压入操作数栈。</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt; <br> <span class="hljs-comment">///获取 System.in，即标准输入流，并将其压入操作数栈。</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">///调用 Scanner 的构造方法，使用 System.in 作为输入流参数来初始化 Scanner 对象。</span><br><span class="hljs-number">10</span> astore_1<br>将操作数栈顶的引用类型Scanner（对象引用）存储到局部变量表的索引 <span class="hljs-number">1</span> 位置 并弹出<br><span class="hljs-number">11</span> aload_1<br><span class="hljs-comment">//从局部变量表中加载索引为 1 的引用类型（对象引用）到操作数栈。</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextInt 方法，读取输入的下一个整数，并将其结果（一个 int）压入操作数栈。</span><br><span class="hljs-number">15</span> istore_2<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">2</span>）。并弹出<br><span class="hljs-number">16</span> aload_1<br>加载 Scanner 对象引用。<br><span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-number">20</span> istore_3<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">3</span>）。并弹出<br><span class="hljs-number">21</span> aload_1<br>加载 Scanner 对象引用<br><span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.close : ()V&gt;<br>调用 Scanner 的 close 方法，关闭输入流。<br>--------- <br>       <br>       Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> a = scanner.nextInt();<br>        <span class="hljs-keyword">int</span> b = scanner.nextInt();<br>        scanner.close();<br>------------<br><span class="hljs-number">25</span> iload_2<br><span class="hljs-number">26</span> iload_3<br>将 <span class="hljs-number">2</span> <span class="hljs-number">3</span> 索引值存储到操作数栈<br><br><span class="hljs-number">27</span> if_icmple <span class="hljs-number">55</span> (+<span class="hljs-number">28</span>)  <span class="hljs-keyword">if</span>(a&gt;b)<br>-&gt;比较大小<br>  System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><br><span class="hljs-number">30</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-comment">//获取标准输出流 System.out。-到操作数栈</span><br><span class="hljs-number">33</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-comment">//将格式化字符串 &quot;%d&quot; 压入操作数栈。</span><br><span class="hljs-number">35</span> iconst_1<br>将常量整数 <span class="hljs-number">1</span> 压入操作数栈，表示需要一个参数进行格式化。<br><span class="hljs-comment">///</span><br><br><span class="hljs-number">36</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br>创建一个 Object 类型的新数组，大小为 <span class="hljs-number">1</span>。<br><span class="hljs-number">39</span> dup<br>复制新建的数组引用。 压入操作数栈<br><span class="hljs-number">40</span> iconst_0<br>将整数 <span class="hljs-number">0</span> 压入操作数栈，表示数组的索引位置。<br><span class="hljs-number">41</span> iload_2<br><span class="hljs-number">42</span> iload_3<br><span class="hljs-number">43</span> iadd<br><span class="hljs-comment">//将 23 索引数据存储到操作数栈-并且相加</span><br><span class="hljs-number">44</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br>调用 Integer.valueOf 方法，将和转换为 Integer 对象。<br><span class="hljs-number">47</span> aastore<br>将 Integer 对象存储到数组的第一个位置。<br><span class="hljs-number">48</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br>调用 printf 方法输出结果。<br><span class="hljs-number">51</span> <span class="hljs-keyword">pop</span><br>弹出 PrintStream 对象的引用，清理操作数栈。<br><span class="hljs-number">52</span> goto <span class="hljs-number">77</span> (+<span class="hljs-number">25</span>)<br><span class="hljs-number">77</span><br><br>代码跳处 <br> System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><span class="hljs-number">55</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">58</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-number">60</span> iconst_1<br><span class="hljs-number">61</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br><span class="hljs-number">64</span> dup<br><span class="hljs-number">65</span> iconst_0<br><span class="hljs-number">66</span> iload_2<br><span class="hljs-number">67</span> iload_3<br><span class="hljs-number">68</span> iadd<br><span class="hljs-number">69</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br><span class="hljs-number">72</span> aastore<br><span class="hljs-number">73</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">76</span> <span class="hljs-keyword">pop</span><br><span class="hljs-number">77</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h6><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">描述<br>定义一个<span class="hljs-built_in">int</span>类型变量i,i为由浮点数变量d四舍五入后的整数类型，请将转换后的i进行输出<br>输入描述：<br>用户随机输入的浮点数<br>输出描述：<br>四舍五入之后的整数（小数点后一位&gt;=<span class="hljs-number">5</span>则进一，否则舍去）<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">14.99</span><br>复制<br>输出：<br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">double</span> d= scanner.<span class="hljs-built_in">nextDouble</span>();<br><br>        <span class="hljs-comment">//write your code here......</span><br>        <span class="hljs-type">double</span> v = d + <span class="hljs-number">0.5</span>;<br>        <span class="hljs-type">int</span> i= (<span class="hljs-type">int</span>) v;<br>        System.out.<span class="hljs-built_in">println</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码分析</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt;<br> <span class="hljs-comment">//创建scanner引用 压入到操作数栈 1</span><br> <span class="hljs-number">3</span> dup<br> <span class="hljs-comment">//复制操作数栈顶的Scanner对象引用 并将该引用再次压入操作数栈。2</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt;<br> <span class="hljs-comment">//获取输入流 压入到操作数栈 3</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">//调用构造方法 System.in 作为参数</span><br><br><span class="hljs-number">10</span> astore_1 -弹出 <span class="hljs-number">1</span><br><span class="hljs-number">11</span> aload_1  <span class="hljs-number">2</span><br><span class="hljs-comment">//int *1=&amp;input;</span><br><span class="hljs-comment">//int **1=&amp;1;--存到操作数栈</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextDouble : ()D&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextDouble 方法，读取输入的 double 类型的数值，将其压入操作数栈。 3</span><br><span class="hljs-number">15</span> dstore_2 弹出-数据存储到索引 <span class="hljs-number">2</span><br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>      <br>       <span class="hljs-keyword">double</span> d= scanner.nextDouble();<br>       <br>       <br><span class="hljs-number">16</span> dload_2<br>压入操作数栈- <span class="hljs-number">3</span><br><span class="hljs-number">17</span> ldc2_w #<span class="hljs-number">6</span> &lt;<span class="hljs-number">0.5</span>&gt;<br>将常量池中 #<span class="hljs-number">6</span> 位置的 <span class="hljs-keyword">double</span> 类型常量 <span class="hljs-number">0.5</span> 压入操作数栈。 <span class="hljs-number">4</span><br><span class="hljs-number">20</span> dadd<br>相加<br><span class="hljs-number">21</span> dstore <span class="hljs-number">4</span> <span class="hljs-number">3</span><br>弹出 最新的相加值 存储到槽<span class="hljs-number">4</span><br><span class="hljs-number">23</span> dload <span class="hljs-number">4</span> <span class="hljs-number">4</span><br>再压入操作数栈<br><span class="hljs-number">25</span> d2i<br>将栈顶的 <span class="hljs-keyword">double</span> 类型数值转换为 <span class="hljs-keyword">int</span> 类型（取整）。<br><span class="hljs-number">26</span> istore <span class="hljs-number">6</span> <span class="hljs-number">3</span><br>弹出 存储到 <span class="hljs-number">6</span><br><span class="hljs-number">28</span> getstatic #<span class="hljs-number">8</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">31</span> iload <span class="hljs-number">6</span>  <span class="hljs-number">4</span> 弹出 存储槽<span class="hljs-number">6</span> <br><span class="hljs-number">33</span> invokevirtual #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.<span class="hljs-keyword">println</span> : (I)V&gt; 打印<br><span class="hljs-number">36</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h6><p>不使用第三方变量交换值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>        <span class="hljs-comment">//write your code here.......</span><br>        a=a+b;<br>        b=a-b;<br>        a=a-b;<br><br>        System.out.println(a+<span class="hljs-string">&quot; &quot;</span>+b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2048实现秒过关</title>
    <link href="/2024/09/06/2048/"/>
    <url>/2024/09/06/2048/</url>
    
    <content type="html"><![CDATA[<h1 id="so分析"><a href="#so分析" class="headerlink" title="so分析"></a>so分析</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/041e24788116aad3e5b9d66d153c0597.png" alt="041e24788116aad3e5b9d66d153c0597"></p><p>hook其参数-得知</p><p>修改.</p><p>text:000A1CE8 01 32                         ADDS    R2, #1</p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5997fd65e2f23df2dedd500f805418d1.png" alt="5997fd65e2f23df2dedd500f805418d1"></p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0c2eab99470f976c0cc393352fa1b15.png" alt="b0c2eab99470f976c0cc393352fa1b15"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240908230448204.png" alt="`image-20240908230448204`"></p><p>修改盒子初始值达到快速过关</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础笔记</title>
    <link href="/2024/09/06/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/"/>
    <url>/2024/09/06/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础笔记"><a href="#java基础笔记" class="headerlink" title="java基础笔记"></a>java基础笔记</h1><p>ps:很遗憾，由于第一次的笔记很短暂。并不怎么深入<br>后续会更新String流处理 包括多线程 线程共享 线程安全 等<br>还有网络编程-各类心跳处理机制-多线程服务器-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Java.png" alt="Java">通过网盘分享的文件：java2笔记<br>链接: <a href="https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5">https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5</a> 提取码: vka5</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三级缓存解决循环依赖</title>
    <link href="/2024/09/06/huanchun/"/>
    <url>/2024/09/06/huanchun/</url>
    
    <content type="html"><![CDATA[<h1 id="循环依赖解决"><a href="#循环依赖解决" class="headerlink" title="循环依赖解决"></a>循环依赖解决</h1><h6 id="1-了解循环依赖问题"><a href="#1-了解循环依赖问题" class="headerlink" title="1.了解循环依赖问题"></a>1.了解循环依赖问题</h6><p>在 Spring 中，如果一个 bean 尝试将自身引用注入到自身中，通常会引发循环依赖。</p><p>首先搞清楚什么是循环依赖：</p><p>两个Bean，A依赖B，B依赖A就构成了循环依赖，如下图：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240606225332349.png" alt="image-20240606225332349"></p><p>同样的道理，如果在A中注入A表示A依赖A，也就构成了循环依赖。</p><p>创建A实例–》初始化A–》注入B–》创建B实例–》初始化B–》注入A</p><p>A-初始化-需要初始化完成bean-&gt;初始化B-&gt;b也要初始化其中的bean-》A-初始化-</p><p>卡入死循环</p><h6 id="2-避免循环依赖流程"><a href="#2-避免循环依赖流程" class="headerlink" title="2.避免循环依赖流程"></a>2.避免循环依赖流程</h6><p>针对循环依赖的问题Spring会上边的过程调整为下边的流程：</p><p>创建A实例– -》创建B实例–》在B中注入A—*<code>B的成员保存A的内存地址</code>*》B初始化—成员赋值了》在A中注入B–》A初始化。</p><p><strong>实例-内存地址</strong>       </p><p>A -&gt;注入B-&gt;初始化</p><p>B-&gt;A(地址)–{最后存储的就是A}-&gt;初始化</p><p>延迟了A的初始化只保留了地址</p><h6 id="3-三级缓存解决循环依赖"><a href="#3-三级缓存解决循环依赖" class="headerlink" title="3.三级缓存解决循环依赖"></a>3.三级缓存解决循环依赖</h6><p>Spring是如何做到呢？</p><p>Spring会延迟初始化，B需要注入A,此时Spring会先实例化A，把一个半成品A注入给B，延迟A的初始化。</p><p>具体的底层原理是Spring通过三级缓存实现：</p><blockquote><p>1）<strong>singletonObjects缓存</strong>：这是 Spring 容器<strong>用来缓存完全初始化好的****单例</strong> <strong>bean 实例的缓存</strong>。当一个 bean 初始化完成后，它会被放入singletonObjects缓存中。这个缓存是单例 bean 的最终缓存，也是 BeanFactory 中保存 bean 的主要缓存。</p><p>2）<strong>earlySingletonObjects缓存</strong>：这个缓存是<strong>用来保存被实例化但还未完全初始化的 bean 的引用</strong>。当一个 bean 已经被实例化（但还未初始化）时，它会被放入earlySingletonObjects缓存中。</p><p>给空间了-但是类数据没有放入</p><p>3）<strong>singletonFactories缓存</strong>：这个缓存保存的是用于创建 bean 实例的 ObjectFactory，用于支持循环依赖的延迟初始化。当一个 bean 被实例化，但尚未完全初始化时，Spring 会在singletonFactories缓存中查找该 bean 的ObjectFactory。这个ObjectFactory会在需要时被调用来完成 bean 的初始化。</p></blockquote><p>类工厂</p><p>Spring 通过这三级缓存的组合，来确保在循环依赖情况下，能够正常初始化 bean。当两个或多个 bean 之间存在循环依赖时，Spring  使用 singletonFactories 缓存来存储 bean 的提供者（ObjectFactory）。当一个 bean  在初始化过程中需要依赖另一个还未初始化的 bean 时，Spring 会调用相应的 ObjectFactory 来获取对应的 bean  实例，这样就实现了循环依赖的延迟初始化。一旦 bean 初始化完成，它就会被移动到singletonObjects缓存中。</p><p>举例：</p><p>创建A实例–》创建B实例–》在B中注入A–》B初始化—》在A中注入B–》A初始化。</p><p>创建A实例（半成品），在earlySingletonObjects放入A半成品。</p><p>创建B实例（半成品），在earlySingletonObjects放入B半成品。</p><p>在B中注入A，通过singletonFactories拿到A的对象工厂，通过对象工厂拿到A的半成品注入到B中。</p><p>B初始化完成，将B从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>在A中注入B-，通过singletonFactories拿到B的对象工厂，通过对象工厂拿到B的成品注入到A中。</p><p>A初始化完成，将A从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>A是一片空间-当初始化完成后-地址就有数据了</p><p>说来说去 就是个内存地址的问题</p><p>**构造参数注入</p><h6 id="4-构造循环依赖解决"><a href="#4-构造循环依赖解决" class="headerlink" title="4.构造循环依赖解决"></a>4.构造循环依赖解决</h6><p>虽然Spring可以解决上边通过成员变量注入引发的循环依赖问题，但是<strong>通过构造参数注入引发的循环依赖问题是会报错。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e9464064bc6f0632ead497e183ca6d3a-1717687581273-4.png" alt="e9464064bc6f0632ead497e183ca6d3a"></p><p>因为创建C需要调用构造方法，而构造方法需要依赖D，此时C是无法实例化的</p><p>上边分析Spring解决循环依赖是通过延迟初始化，当出现循环依赖问题可以注入一个半成品</p><p><strong>但是如上半成品也无法生成</strong></p><p>如何解决这种通过构造参数注入导致的循环依赖问题呢？</p><p>可以在C或D的任意一方注入另一方的代理对象而不是注入原始对象，如下：</p><p>假设在C的构造方法中注入D的代理对象可以写为：</p><p>在构造参数前加@Lazy注解，表示注入D的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-meta">@Lazy</span> D d)</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏逆向思路cpp</title>
    <link href="/2024/09/06/test2/"/>
    <url>/2024/09/06/test2/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏逆向思路cpp"><a href="#游戏逆向思路cpp" class="headerlink" title="游戏逆向思路cpp"></a>游戏逆向思路cpp</h1><p>游戏引擎 :cocos2dx<br>逆向思路</p><p>libcocos2dcpp.so  libgame.so     &#x2F;data&#x2F;app-lib&#x2F;包名<br>1.字符串信息查找关键函数<br>2.send函数进行定位<br>3.hook hook函数修改参数-返回值-或者多次调用-或者返回-根据情况</p><p><img src="https://s2.loli.net/2024/09/07/yZxfF9IcLlMbUzW.png" alt="2024-09-07 222659.png"></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
