<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring mvc</title>
    <link href="/2024/09/13/Spring%20mvc%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/13/Spring%20mvc%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-mvc复习"><a href="#Spring-mvc复习" class="headerlink" title="Spring mvc复习"></a>Spring mvc复习</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/SpringMvc.png" alt="SpringMvc"></p><h4 id="0-spring-springmvc"><a href="#0-spring-springmvc" class="headerlink" title="0.spring-springmvc"></a>0.spring-springmvc</h4><p>Spring 和 Spring MVC 是两个相关但独立的框架，它们解决了不同的问题。简单来说，<strong>Spring</strong> 是一个通用的应用框架，而 <strong>Spring MVC</strong> 是一个基于 Spring 的 Web 框架，用于构建 Web 应用程序。</p><blockquote><p><strong>Spring 的主要作用</strong>：</p><ul><li><strong>依赖注入（Dependency Injection, DI）</strong>：Spring 最主要的功能是依赖注入，它通过控制反转（Inversion of Control, IoC）容器来管理对象之间的依赖关系，使代码更加模块化和可测试。</li><li><strong>面向切面编程（Aspect-Oriented Programming, AOP）</strong>：Spring 支持 AOP，允许在不修改原始代码的情况下添加额外的行为，例如日志记录、事务管理和安全检查。</li><li><strong>数据访问集成</strong>：Spring 提供对多种数据访问技术（如 JDBC、JPA、Hibernate）的集成和支持，简化了与数据库的交互。</li><li><strong>事务管理</strong>：Spring 提供了声明性事务管理，可以让开发者更轻松地管理事务。</li><li><strong>其他支持</strong>：如邮件发送、消息队列集成、缓存等。</li></ul><p><strong>Spring MVC 的主要作用</strong>：</p><ul><li><strong>专门用于 Web 开发</strong>：Spring MVC 是 Spring 框架中用于构建 Web 应用的部分，它遵循 Model-View-Controller (MVC) 设计模式，帮助开发者更容易地构建基于 HTTP 协议的 Web 应用程序。</li><li><strong>请求处理流程</strong>：Spring MVC 提供了一整套用于处理 HTTP 请求和响应的机制，例如 <code>DispatcherServlet</code> 作为前端控制器，将请求分发给适当的处理器（Controller）。</li><li><strong>视图解析</strong>：Spring MVC 提供视图解析机制，将模型数据绑定到视图（例如 JSP、Thymeleaf、Freemarker 等）。</li><li><strong>数据绑定与验证</strong>：提供了数据绑定功能，将请求参数绑定到 Java 对象，还支持数据验证和格式化。</li><li><strong>国际化（I18n）支持</strong>：Spring MVC 提供了内置的国际化支持，方便开发多语言 Web 应用程序。</li><li><strong>集成与扩展</strong>：与 Spring 生态系统中的其他模块（如 Spring Security、Spring Data 等）无缝集成。</li></ul></blockquote><p>Spring 和 Spring MVC 的关系</p><p>Spring MVC 是 Spring 框架中的一个模块，它依赖于 Spring 核心容器（Core Container）来工作。它利用了 Spring 的 IoC 和 AOP 功能来管理 Web 应用程序的组件（如控制器、服务、数据访问层等）。因此，Spring MVC 本质上是一个基于 Spring 的 Web 框架。</p><h4 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h4><p>Spirngmvc-Servlet</p><p>Controller-&gt;Springmvc 产物</p><p>1.SpringMVC是一种表现层框架技术–</p><p>SpringMVC用于进行表现层功能开发</p><p>使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标</p><p>创建Springfmvc控制器类</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a20b723675912525bb7fa4b6861f2445.png" alt="a20b723675912525bb7fa4b6861f2445"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/804db24f3395fe5d5940d26edfc3ea33.png" alt="804db24f3395fe5d5940d26edfc3ea33"></p><p>springmvc0需要设定springmcv加载对应Bean</p><h4 id="1-1-Springmvc配置"><a href="#1-1-Springmvc配置" class="headerlink" title="1.1 Springmvc配置"></a>1.1 Springmvc配置</h4><p><code>ServletContainersInitConfig</code> 类扩展了 <code>AbstractDispatcherServletInitializer</code>，这个类是 Spring MVC 提供的一个抽象类，用于快速初始化基于 Servlet 3.0 的 Web 容器（如 Tomcat）。它通过实现三个方法来配置 Spring 和 Spring MVC 的应用上下文以及 Servlet 的映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContainersInitConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDispatcherServletInitializer</span> &#123;<br>    <br>    <span class="hljs-comment">//加载springMVC配置 -第一个接口 创建Servlet容器时，加载SpringMVC对应的bean并放入</span><br>    <span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createServletApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//初始化WebApplicationContext对象</span><br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        <span class="hljs-comment">//加载指定配置类</span><br>        ctx.register(SpringMvcConfig.class);<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>作用：</p><ul><li>创建和配置 Spring MVC 的应用上下文（<code>WebApplicationContext</code>）<ul><li><code>WebApplicationContext</code> 是 Spring 中用于 Web 应用程序的应用上下文，它扩展了 <code>ApplicationContext</code>，提供了面向 Web 的额外功能。</li></ul></li><li>在这个方法中：<ul><li><strong>创建 <code>AnnotationConfigWebApplicationContext</code> 对象</strong>：这是一个基于注解配置的 <code>WebApplicationContext</code> 实现，能够扫描和加载配置类。</li><li><strong>注册配置类</strong>：<code>ctx.register(SpringMvcConfig.class)</code>，将指定的配置类 <code>SpringMvcConfig</code> 注册到 <code>WebApplicationContext</code> 中，这样 Spring MVC 就可以根据这个配置类初始化它所需的 bean 和其他配置。</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置Tomcat接收的请求哪些归SpringMVC处理</span><br><span class="hljs-comment">//getServletMappings()方法，设定SpringMVC对应的请求映射路径，设置为/表示拦截所有请求，任意请求都将转入到SpringMVC进行处理</span><br><br><span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>&#125;<br><br><span class="hljs-comment">//设置spring相关配置 如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，</span><br><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createRootApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解</p><blockquote><p>Controller 设定SpringMVC的核心控制器bean</p><p>@RequestMapping  设置当前控制器方法请求访问路径</p><p>@ResponseBody  设置当前控制器方法响应内容为当前返回值，无需解析</p></blockquote><p>综上-我们要导入spirngmvc容器</p><blockquote><p>1.导入springmvc坐标 2.创建springmvc核心控制器bean 3.再配置类中进行指定加载4.配置tocat的路径哪些被springmvc管理</p></blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/67f41aab7f091ea29d50d4b977866e31.png" alt="67f41aab7f091ea29d50d4b977866e31"></p><p>* </p><h4 id="2-bean加载控制"><a href="#2-bean加载控制" class="headerlink" title="2.bean加载控制"></a>2.bean加载控制</h4><p>在 Spring 应用程序中，通常会有两种类型的配置：</p><ol><li><strong>Spring 容器配置</strong>：用于管理应用程序的核心业务逻辑组件，例如服务层（Service）、数据访问层（DAO）等。</li><li><strong>Spring MVC 容器配置</strong>：用于管理 Web 层的组件，例如控制器（Controller）、视图解析器（View Resolver）等。</li></ol><p>当一个应用程序使用了 Spring 和 Spring MVC 时，通常会有两个 <code>ApplicationContext</code>：</p><ul><li><strong>根应用上下文（Root ApplicationContext）</strong>：由 Spring 容器管理，包含业务逻辑层的 bean（如 Service、DAO 等）。</li><li><strong>Web 应用上下文（WebApplicationContext）</strong>：由 Spring MVC 容器管理，包含 Web 层的 bean（如 Controller、视图解析器等）。</li></ul><p>我们就需要避免加载</p><p>springmvc-controller –mvc  bean</p><p>业务层的service–注册为spirngbean的bean</p><blockquote><p><strong>将业务层的 bean（如 Service、DAO）注册到根应用上下文中</strong>，这些 bean 应该由 Spring 容器管理。</p><p><strong>将 Web 层的 bean（如 Controller）注册到 Web 应用上下文中</strong>，这些 bean 应该由 Spring MVC 容器管理。</p></blockquote><p>1.因为功能不同，如何避免Spring错误的加载到SpringMVC的bean——加载Spring控制的bean的时候排除掉SpringMVC控制的bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48eb36fe246fbb47facf7e8f5eb31ff6.png" alt="48eb36fe246fbb47facf7e8f5eb31ff6"></p><p>非常麻烦 –还需要分开加载</p><p>案例、</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f924b648ab257fbefa08c871b796ebb5.png" alt="f924b648ab257fbefa08c871b796ebb5"></p><p>这里就排除加载了springmvc的bean- 我们需要在写一个配置类来导入spirngmvc的bena </p><p>@Configuration<br>@ComponentScan(“com.itheima.controller”)—自动扫描<br>public class SpringMvcConfig {<br>}</p><h4 id="3-springmvc容器的简化开发"><a href="#3-springmvc容器的简化开发" class="headerlink" title="3.springmvc容器的简化开发"></a>3.springmvc容器的简化开发</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1b0641d49bc4e25a589d46b048d0c712.png" alt="1b0641d49bc4e25a589d46b048d0c712"></p><h4 id="4-请求响应"><a href="#4-请求响应" class="headerlink" title="4.请求响应"></a>4.请求响应</h4><h6 id="1-请求映射路径"><a href="#1-请求映射路径" class="headerlink" title="1.请求映射路径"></a>1.请求映射路径</h6><p>@RequestMapping</p><p>l设置当前控制器方法请求访问路径，如果设置在类上统一设置当前控制器方法请求访问路径前缀</p><h6 id="2-请求传参"><a href="#2-请求传参" class="headerlink" title="2.请求传参"></a>2.请求传参</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0ae8f28c7e68ec356172c7f4f322aabc.png" alt="0ae8f28c7e68ec356172c7f4f322aabc"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d5fd3828d3099bff24bbf90834041bff.png" alt="d5fd3828d3099bff24bbf90834041bff"></p><h3 id="2-请求传参-1"><a href="#2-请求传参-1" class="headerlink" title="2.请求传参"></a>2.请求传参</h3><h5 id="1-普通参数"><a href="#1-普通参数" class="headerlink" title="1.普通参数"></a>1.普通参数</h5><p>1.url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数</p><p>2.请求参数名与形参变量名不同，使用@RequestParam绑定参数关系</p><p><strong>@RequestParam</strong>(“name”)String userName </p><h6 id="2-pojo类型参数"><a href="#2-pojo类型参数" class="headerlink" title="2.pojo类型参数"></a>2.pojo类型参数</h6><p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</p><h6 id="3-嵌套pojo参数"><a href="#3-嵌套pojo参数" class="headerlink" title="3.嵌套pojo参数"></a>3.嵌套pojo参数</h6><p>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><h6 id="4-数组类型"><a href="#4-数组类型" class="headerlink" title="4.数组类型"></a>4.数组类型</h6><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数 String[] likes</p><p>l</p><h6 id="5-集合类型-RequestParam"><a href="#5-集合类型-RequestParam" class="headerlink" title="5.集合类型 RequestParam"></a>5.集合类型 RequestParam</h6><p>l集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系</p><p>@RequestParam List<String> likes</p><h4 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2.JSON"></a>2.JSON</h4><p>添加json数据转换相关坐标</p><dependency>  <groupId>com.fasterxml.jackson.core</groupId>  <artifactId>jackson-databind</artifactId>  <version>2.9.0</version> </dependency><p>开启自动转换json数据的支持</p><p>@Configuration<br> @ComponentScan(“com.itheima.controller”)<br> <strong>@EnableWebMvc</strong>@EnableWebMvc注解功能强大，该注解整合了多个功能，此处仅使用其中一部分功能，即json数据进行自动类型转换<br> public class SpringMvcConfig {<br> }</p><h6 id="1-json数组-RequestBody"><a href="#1-json数组-RequestBody" class="headerlink" title="1.json数组 @RequestBody"></a>1.json数组 @RequestBody</h6><p>将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</p><p>@RequestBody List<String> likes</p><h6 id="2-json对象"><a href="#2-json对象" class="headerlink" title="2.json对象"></a>2.json对象</h6><p>json数据与形参对象属性名相同，定义POJO类型形参即可接收参数</p><p>@RequestBody User user</p><h6 id="3-json对象数组"><a href="#3-json对象数组" class="headerlink" title="3.json对象数组"></a>3.json对象数组</h6><p>json数组数据与集合泛型属性名相同，定义List类型形参即可接收参数</p><p>@RequestBody List<User> list</p><h6 id="0-区别"><a href="#0-区别" class="headerlink" title="0.区别"></a>0.区别</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/697f5240f2ca11734b8ddf804fa935bc.png" alt="697f5240f2ca11734b8ddf804fa935bc"></p><h6 id="3-日期传参"><a href="#3-日期传参" class="headerlink" title="3.日期传参"></a>3.日期传参</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/192cc0e58e4cc136b34168f56ccf355a.png" alt="192cc0e58e4cc136b34168f56ccf355a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab3b6686ddb4ec826f2990c1c925d36b.png" alt="ab3b6686ddb4ec826f2990c1c925d36b"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240414172132046.png" alt="image-20240414172132046"></p><h4 id="3-响应传递"><a href="#3-响应传递" class="headerlink" title="3.响应传递"></a>3.响应传递</h4><h6 id="1-文本返回"><a href="#1-文本返回" class="headerlink" title="1.文本返回"></a>1.文本返回</h6><p>  @ResponseBody -不仅仅可以将JSON对应类-还能告诉编译器转的是文本,而不是文件</p><h6 id="2-json返回"><a href="#2-json返回" class="headerlink" title="2.json返回"></a>2.json返回</h6><p>返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖&#x3D;&#x3D;@ResponseBody&#x3D;&#x3D;注解和&#x3D;&#x3D;@EnableWebMvc&#x3D;&#x3D;注解</p><h6 id="3-响应pojo集合"><a href="#3-响应pojo集合" class="headerlink" title="3.响应pojo集合"></a>3.响应pojo集合</h6><p>开对象-然后存进list集合中-返回list集合 默认返回的就是集合</p><p> List<User> userList &#x3D; new ArrayList<User>();<br>        userList.add(user1);<br>        userList.add(user2);</p><h6 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h6><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;方法\类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法定义上方和控制类上</td></tr><tr><td>作用</td><td>设置当前控制器返回值作为响应体,<br/>写在类上，该类的所有方法都有该注解功能</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>该注解可以写在类上或者方法上</li><li>写在类上就是该类下的所有方法都有@ReponseBody功能</li><li>当方法上有@ReponseBody注解后<ul><li>方法的返回值为字符串，会将其作为文本内容直接响应给前端</li><li>方法的返回值为对象，会将对象转换成JSON响应给前端</li></ul></li></ul><p>此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:</p><ul><li>对象转Json数据(POJO -&gt; json)</li><li>集合转Json数据(Collection -&gt; json)</li></ul><h4 id="Rest风格"><a href="#Rest风格" class="headerlink" title="Rest风格"></a>Rest风格</h4><h6 id="1-rest风格介绍"><a href="#1-rest风格介绍" class="headerlink" title="1.rest风格介绍"></a>1.rest风格介绍</h6><p>传统风格</p><ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul><p>REST</p><ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li><li>根据路径 无法看出对应功能–具有隐私保护性</li><li></li></ul><p>请求的方式比较多，但是比较常用的就4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。</p><p>按照不同的请求方式代表不同的操作类型。</p><ul><li>发送GET请求是用来做查询</li><li>发送POST请求是用来做新增</li><li>发送PUT请求是用来做修改</li><li>发送DELETE请求是用来做删除</li><li></li></ul><p>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范</p><h6 id="2-路径传参-PathVariable"><a href="#2-路径传参-PathVariable" class="headerlink" title="2.路径传参 @PathVariable"></a>2.路径传参 @PathVariable</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置当前请求方法为DELETE，表示REST风格中的删除操作</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/users/&#123;id&#125;/&#123;name&#125;&quot;,method = RequestMethod.DELETE)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id,<span class="hljs-meta">@PathVariable</span> String name)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>@PathVariable</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;形参注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法形参定义前面</td></tr><tr><td>作用</td><td>绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</td></tr></tbody></table><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h4 id="springmvc开发特性"><a href="#springmvc开发特性" class="headerlink" title="springmvc开发特性"></a>springmvc开发特性</h4><h6 id="1-知识点1：-RestController"><a href="#1-知识点1：-RestController" class="headerlink" title="1.知识点1：@RestController"></a>1.知识点1：@RestController</h6><table><thead><tr><th>名称</th><th>@RestController</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>基于SpringMVC的RESTful开发控制器类定义上方</td></tr><tr><td>作用</td><td>设置当前控制器类为RESTful风格，<br/>等同于@Controller与@ResponseBody两个注解组合功能</td></tr></tbody></table><h6 id="知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping"></a>知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping</h6><table><thead><tr><th>名称</th><th align="right">@GetMapping @PostMapping @PutMapping @DeleteMapping</th></tr></thead><tbody><tr><td>类型</td><td align="right">&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td align="right">基于SpringMVC的RESTful开发控制器方法定义上方</td></tr><tr><td>作用</td><td align="right">设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，<br/>例如@GetMapping对应GET请求</td></tr><tr><td>相关属性</td><td align="right">value（默认）：请求访问路径</td></tr></tbody></table><h4 id="Spring-mvc-异常处理机制"><a href="#Spring-mvc-异常处理机制" class="headerlink" title="Spring mvc 异常处理机制"></a>Spring mvc 异常处理机制</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a4c33d1fd830a4bf2508db2f6b98e836.jpeg" alt="a4c33d1fd830a4bf2508db2f6b98e836"></p><p><code>@ControllerAdvice</code> 是一个全局异常处理注解，用于定义一个全局的异常处理类。这个类中的方法可以处理所有控制器中抛出的异常</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler</span>(<span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>)<span class="hljs-comment">//异常捕获</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">handleAllExceptions</span>(<span class="hljs-params"><span class="hljs-title class_">Exception</span> ex</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(<span class="hljs-string">&quot;Handled Exception: &quot;</span> + ex.<span class="hljs-title function_">getMessage</span>(), <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">INTERNAL_SERVER_ERROR</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b59e8bf4c2fbcc6be6fc912192f6f2df.jpg" alt="b59e8bf4c2fbcc6be6fc912192f6f2df"></p><p><code>@ExceptionHandler</code> 是 Spring MVC 提供的一种注解，用于定义处理特定异常的方法。可以在控制器类中使用该注解来捕获和处理特定类型的异常。</p><p>–增强类上指定-异常拦截器处理–基于AOP切面编程实现</p><hr><p>案例处理-如题 </p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/42419f57ee0003c58e6c059ba4fc1f58.jpeg" alt="42419f57ee0003c58e6c059ba4fc1f58"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b3b21d20c96ae90d732ce3cac09d5f68.jpeg" alt="b3b21d20c96ae90d732ce3cac09d5f68"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2bb0878bbc88b02c0ce024647e49ec70.jpeg" alt="2bb0878bbc88b02c0ce024647e49ec70"></p><p>自写异常-根据异常严重程度来进行对应的出来</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6241b3e5f0b6762d7a7166eac8e101ba.jpeg" alt="6241b3e5f0b6762d7a7166eac8e101ba"></p><p>抛出异常</p><p>拦截处理异常</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4cc146a7a81d28def5a9f72534f22ad3.jpeg" alt="4cc146a7a81d28def5a9f72534f22ad3"></p><h4 id="Springmvc-拦截器"><a href="#Springmvc-拦截器" class="headerlink" title="Springmvc -拦截器"></a>Springmvc -拦截器</h4><p> Spring MVC 中，拦截器（Interceptor）是一种用于对请求进行预处理和后处理的机制。拦截器类似于 Servlet 的过滤器（Filter），但提供了更灵活和强大的功能。它们可以用于权限检查、日志记录、性能监控等场景。</p><hr><p>Spring MVC 的拦截器基于 <code>HandlerInterceptor</code> 接口，它允许我们在处理 HTTP 请求的过程中插入自定义的逻辑。拦截器可以在以下三个阶段执行：</p><ol><li><strong>预处理阶段（preHandle）</strong>：在请求到达控制器之前执行。</li><li><strong>后处理阶段（postHandle）</strong>：在请求被控制器处理之后，但在视图渲染之前执行。</li><li><strong>完成后处理阶段（afterCompletion）</strong>：在整个请求完成之后执行，通常用于资源清理。</li></ol><h6 id="1-拦截器案例"><a href="#1-拦截器案例" class="headerlink" title="1.拦截器案例"></a>1.拦截器案例</h6><p>1.声明拦截器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/50fccfc54a1ef08467fab507b7fbce62.jpeg" alt="50fccfc54a1ef08467fab507b7fbce62"></p><p>实现HandlerInt接口</p><p>–</p><blockquote><p>在 Spring Boot 或 Spring MVC 的 Java 配置中，可以通过实现 <code>WebMvcConfigurer</code> 接口的 <code>addInterceptors</code> 方法来添加拦截器</p></blockquote><p>添加拦截器指定路径</p><p>在 Spring Boot 或 Spring MVC 的 Java 配置中，可以通过实现 <code>WebMvcConfigurer</code> 接口的 <code>addInterceptors</code> 方法来添加拦截器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>) &#123;<br>        <span class="hljs-comment">// 注册自定义的拦截器，并指定拦截路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截所有请求</span><br>                .<span class="hljs-title function_">excludePathPatterns</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/error&quot;</span>); <span class="hljs-comment">// 排除某些路径不拦截</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>addInterceptors(InterceptorRegistry registry)</code>：添加拦截器的方法。</p><p><code>addInterceptor(new MyInterceptor())</code>：注册自定义拦截器。</p><p><code>addPathPatterns(&quot;/**&quot;)</code>：设置拦截器拦截的路径模式，例如，<code>/**</code> 表示拦截所有请求。</p><p><code>excludePathPatterns(&quot;/login&quot;, &quot;/error&quot;)</code>：设置不需要拦截的路径模式，例如登录页和错误页。</p><h6 id="2-拦截器流程"><a href="#2-拦截器流程" class="headerlink" title="2.拦截器流程"></a>2.拦截器流程</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4caa6002de9cae7bb61d1f4dc79fbf40.jpeg" alt="4caa6002de9cae7bb61d1f4dc79fbf40"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d63b5afd7e7aaff800a0a7fa06a00c25.jpeg" alt="d63b5afd7e7aaff800a0a7fa06a00c25"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/267baa636fd682717e63a956def32ec5.jpeg" alt="267baa636fd682717e63a956def32ec5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4b425f5665648fd64d2371a8e70aa4b7.jpeg" alt="4b425f5665648fd64d2371a8e70aa4b7"></p><h6 id="3-多拦截器"><a href="#3-多拦截器" class="headerlink" title="3.多拦截器"></a>3.多拦截器</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c4698693771084332a51d147c5cdd2e7.jpeg" alt="c4698693771084332a51d147c5cdd2e7"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params"><span class="hljs-title class_">InterceptorRegistry</span> registry</span>) &#123;<br>        <span class="hljs-comment">// 注册第一个拦截器，拦截所有路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>);<br><br>        <span class="hljs-comment">// 注册第二个拦截器，拦截所有路径</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondInterceptor</span>())<br>                .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>addInterceptor()</code> 方法按顺序注册拦截器，Spring MVC 将按照注册顺序执行这些拦截器的 <code>preHandle()</code> 方法，<code>postHandle()</code> 和 <code>afterCompletion()</code> 方法则按相反顺序执行。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95d7648e9ae71b1f8e4a5ccf424adb04.jpeg" alt="95d7648e9ae71b1f8e4a5ccf424adb04"></p><h6 id="4-基于AOP实现拦截器"><a href="#4-基于AOP实现拦截器" class="headerlink" title="4.基于AOP实现拦截器"></a>4.基于AOP实现拦截器</h6><p><strong>MVC 拦截器</strong>：基于 <code>HandlerInterceptor</code> 接口，可以在处理 HTTP 请求的生命周期的特定点执行代码。适用于 Web 层的请求预处理和后处理。</p><p>使用 AOP 实现类似的拦截功能，可以在控制器方法执行前后插入一些通用的逻辑。使用 AOP 可以更灵活地选择何时何地应用这些逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>   <br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">annotatedMethod</span><span class="hljs-params">(CustomAnnotation customAnnotation)</span> &#123;&#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">   这个切入点表达式 `@annotation(customAnnotation)` 的作用是匹配所有被 `@CustomAnnotation` 注解标记的方法。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">`@annotation(customAnnotation)` 是 AspectJ 提供的一个语法，用来匹配方法级别的注解。这里，`customAnnotation` 是一个参数，它表示目标方法上使用的 `@CustomAnnotation`。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">同时`annotatedMethod` f方法的主要用处是可以在通知（Advice）方法中使用一个更清晰、易读的命名标识来引用切入点。*/</span><br><br>    <span class="hljs-comment">// 在控制器中的任何方法执行之前执行</span><br>    <span class="hljs-meta">@Before(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeControllerMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之前执行的逻辑&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在控制器方法执行之后执行</span><br>    <span class="hljs-meta">@After(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterControllerMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之后执行的逻辑&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知，可以在方法执行前后都进行拦截</span><br>    <span class="hljs-meta">@Around(&quot;annotatedMethod(customAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundControllerMethod</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之前执行的逻辑&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();  <span class="hljs-comment">// 执行目标方法</span><br>        System.out.println(<span class="hljs-string">&quot;在控制器方法执行之后执行的逻辑&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">public <span class="hljs-keyword">@interface</span> CustomAnnotation &#123;<br>    String <span class="hljs-built_in">value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="WebApplicationContext探究"><a href="#WebApplicationContext探究" class="headerlink" title="WebApplicationContext探究"></a>WebApplicationContext探究</h4><blockquote><p><code>WebApplicationContext</code> 是一个容器类，它是 Spring 框架中专门用于 Web 应用程序的应用上下文（<code>ApplicationContext</code>）接口的扩展。</p><h3 id="什么是-WebApplicationContext？"><a href="#什么是-WebApplicationContext？" class="headerlink" title="什么是 WebApplicationContext？"></a>什么是 <code>WebApplicationContext</code>？</h3><p><code>WebApplicationContext</code> 是 Spring 框架中的一个接口，它继承了 <code>ApplicationContext</code> 接口，并添加了特定于 Web 应用程序的功能。它提供了一些额外的方法和功能来处理 Web 应用程序的特定需求，例如管理与 Servlet、过滤器和监听器相关的 Web 组件。</p><h3 id="WebApplicationContext-的特点"><a href="#WebApplicationContext-的特点" class="headerlink" title="WebApplicationContext 的特点"></a><code>WebApplicationContext</code> 的特点</h3><ol><li><p>**扩展 <code>ApplicationContext</code>**：</p><ul><li><code>WebApplicationContext</code> 继承自 <code>ApplicationContext</code>，而 <code>ApplicationContext</code> 是 Spring 的核心容器接口，用于管理和配置应用程序中的 bean。<code>ApplicationContext</code> 提供了 Spring IoC 容器的基本功能，如依赖注入、事件发布、国际化支持等。</li><li><code>WebApplicationContext</code> 是 <code>ApplicationContext</code> 的一个特化版本，增加了与 Web 环境相关的特性。</li></ul></li><li><p><strong>面向 Web 应用程序</strong>：</p><ul><li><pre><code class="hljs">WebApplicationContext</code></pre><p> 是为 Web 应用程序设计的，它能够处理 Web 相关的上下文信息，例如：</p><ul><li><strong>ServletContext</strong>：<code>WebApplicationContext</code> 可以访问 Servlet 容器的 <code>ServletContext</code>，这使它能够与 Servlet API 集成，并提供与 Web 容器的交互能力。</li><li><strong>会话作用域和请求作用域</strong>：<code>WebApplicationContext</code> 支持 Web 特定的作用域（如会话作用域和请求作用域），这对于 Web 应用程序非常有用。</li></ul></li></ul></li><li><p><strong>Web 应用程序的根上下文</strong>：</p><ul><li>在典型的 Spring Web 应用程序中，<code>WebApplicationContext</code> 通常是应用程序的根上下文（Root Context），它在 Web 应用程序启动时由 Spring 的前端控制器 <code>DispatcherServlet</code> 或 <code>ContextLoaderListener</code> 创建。</li><li>它管理 Web 应用程序的所有 bean，包括控制器、服务层组件、数据访问层组件等。</li></ul></li></ol><h3 id="WebApplicationContext-的具体实现类"><a href="#WebApplicationContext-的具体实现类" class="headerlink" title="WebApplicationContext 的具体实现类"></a><code>WebApplicationContext</code> 的具体实现类</h3><p>在 Spring 中，<code>WebApplicationContext</code> 有多个实现类，其中最常用的是：</p><ol><li><p><code>XmlWebApplicationContext</code></p><p>：</p><ul><li>基于 XML 配置文件的 <code>WebApplicationContext</code> 实现，它从指定的 XML 文件中加载 bean 定义。</li></ul></li><li><p><code>AnnotationConfigWebApplicationContext</code></p><p>：</p><ul><li>基于 Java 注解的 <code>WebApplicationContext</code> 实现，通常用于配置类（使用 <code>@Configuration</code> 注解的类）而非 XML 文件的方式进行 bean 定义的加载。</li></ul></li><li><p><code>GenericWebApplicationContext</code></p><p>：</p><ul><li>通用的 <code>WebApplicationContext</code> 实现，它既可以从 XML 文件加载配置，也可以使用注解或其他方式加载配置。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>WebApplicationContext</code> 是一个面向 Web 的 Spring 容器类，它继承了 <code>ApplicationContext</code> 并扩展了与 Web 相关的功能。它能够管理 Web 应用程序的 bean，处理与 Web 环境相关的上下文信息，并与 Servlet 容器紧密集成。因此，<code>WebApplicationContext</code> 是 Spring Web 应用程序中非常重要的容器类。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构概论 01</title>
    <link href="/2024/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构概论"><a href="#数据结构概论" class="headerlink" title="数据结构概论"></a>数据结构概论</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章-概述"></a>第一章-概述</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><h5 id="1-1-1-什么是数据结构"><a href="#1-1-1-什么是数据结构" class="headerlink" title="1.1.1:什么是数据结构"></a>1.1.1:什么是数据结构</h5><blockquote><h4 id="数据与信息"><a href="#数据与信息" class="headerlink" title="数据与信息"></a>数据与信息</h4><ul><li><strong>数据</strong>是信息的载体，可以被计算机识别、存储和加工处理。数据包括文字、表格、图像等形式。</li><li><strong>信息</strong>是数据的内涵，即数据所表达的意义。例如，成绩单中某次考试的成绩是数据，但平均分就是信息。</li></ul><h4 id="数据元素和数据项"><a href="#数据元素和数据项" class="headerlink" title="数据元素和数据项"></a>数据元素和数据项</h4><ul><li><strong>数据元素</strong>是数据的基本单位（有时称为元素、结点或记录等），通常作为一个整体进行处理。例如，一个学生的成绩单包含了若干个数据元素。</li><li><strong>数据对象</strong>是具有相同类型的数据元素的集合。</li><li><strong>数据项</strong>是数据元素的不可分割的最小标识单元。例如，一个学生记录可以包含姓名、学号等数据项。</li></ul><h4 id="数据的结构"><a href="#数据的结构" class="headerlink" title="数据的结构"></a>数据的结构</h4><ul><li>数据的结构化表示方式便于数据的存储和处理。在数据结构中，除非特别指明，数据通常都是数据对象。</li></ul><p>：</p><h3 id="数据结构的定义和内容"><a href="#数据结构的定义和内容" class="headerlink" title="数据结构的定义和内容"></a>数据结构的定义和内容</h3><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素不是孤立存在的，而是相互之间通过某种关系连接，形成一个整体结构。数据结构的主要内容包括以下三个方面：</p><ol><li><strong>逻辑结构</strong>：描述数据元素之间的逻辑关系，是数据结构的抽象形式。逻辑结构通常通过图形表示，例如线性结构、树形结构和图结构等。</li><li><strong>存储结构</strong>：也称为“物理结构”或“存储映像”，是将数据的逻辑结构映射到计算机存储器中的形式。数据的存储结构决定了数据在计算机内存中的布局方式，包括顺序存储、链式存储等。</li><li><strong>数据运算</strong>：指的是在数据结构上进行的各种操作，是数据结构的功能体现。例如，常见的数据操作包括查找、插入、删除、排序等。这些操作通常是通过特定的算法在存储结构上实现的。</li></ol></blockquote><h5 id="1-1-2-逻辑结构探究"><a href="#1-1-2-逻辑结构探究" class="headerlink" title="1.1.2 逻辑结构探究"></a>1.1.2 逻辑结构探究</h5><blockquote><h3 id="逻辑结构的定义"><a href="#逻辑结构的定义" class="headerlink" title="逻辑结构的定义"></a>逻辑结构的定义</h3><ul><li><p><strong>逻辑结构</strong>是指数据元素之间的逻辑关系，它表示数据元素之间如何相互关联。逻辑结构不涉及数据在计算机中的存储方式，只描述数据元素之间的关系。</p></li><li><h3 id="逻辑结构的四种类型"><a href="#逻辑结构的四种类型" class="headerlink" title="逻辑结构的四种类型"></a>逻辑结构的四种类型</h3><ol><li><p><strong>集合结构</strong>：所有数据元素之间没有任何关系。</p></li><li><p><strong>线性结构</strong>：所有数据元素之间存在一对一的关系。</p></li><li><p><strong>树形结构</strong>：数据元素之间存在一对多的层次关系。</p></li><li><p><strong>图形结构</strong>（网状结构）：数据元素之间存在多对多的任意关系。</p><h3 id="逻辑结构的表示方法-书中是公式"><a href="#逻辑结构的表示方法-书中是公式" class="headerlink" title="逻辑结构的表示方法-书中是公式"></a>逻辑结构的表示方法-书中是公式</h3><ul><li><p><strong>线性结构（Linear Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间具有一对一的关系，即每个数据元素除了第一个和最后一个之外，都有唯一的前驱和后继。常见的线性结构有数组、链表、栈和队列等。</li><li><strong>特点</strong>：数据按照一定的顺序排成一条直线，每个元素只有一个前驱和一个后继（除第一个和最后一个元素）。</li><li><strong>例子</strong>：数组是一种典型的线性结构，数据元素按顺序存储在内存中，元素之间的关系通过索引来表示。</li></ul><p><strong>树形结构（Tree Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间具有一对多的层次关系。树形结构中，每个元素称为“节点”，顶层节点称为“根节点”，其余节点有且仅有一个父节点，可能有多个子节点。</li><li><strong>特点</strong>：数据以层级形式组织，每个节点有一个父节点和零个或多个子节点，除了根节点外，每个节点只有一个父节点。</li><li><strong>例子</strong>：二叉树是一种常见的树形结构，其中每个节点最多有两个子节点（左子节点和右子节点）。</li></ul><p><strong>图形结构（Graph Structures）</strong>：</p><ul><li><strong>定义</strong>：在这种结构中，数据元素之间可以有任意多的关系，数据元素称为“节点”或“顶点”，它们之间的关系称为“边”。</li><li><strong>特点</strong>：数据元素之间的关系不再是简单的一对一或一对多，可以是多对多的关系。图可以是有向的或无向的，有环的或无环的。</li><li><strong>例子</strong>：社交网络中的好友关系可以用图来表示，用户是节点，好友关系是边。</li></ul><p><strong>逻辑表示</strong>：学生按学号从小到大排列，每个学生只有一个前驱和一个后继（除了第一个和最后一个）。这种逻辑表示方式告诉我们数据元素的相对关系和结构。</p><p><strong>物理表示</strong>：在计算机中，可以用一个数组来顺序存储这些学生信息，或者用一个链表来链式存储这些学生信息。</p></li><li><p><strong>逻辑结构图的表示</strong></p></li><li><p>：</p><ul><li>数据逻辑结构可以通过二元组 (D,R)(<em>D</em>,<em>R</em>) 来表示，其中 D<em>D</em> 是数据元素的集合，R<em>R</em> 是数据元素之间的逻辑关系集合。</li></ul></li><li><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf1f08b63104c88f692a527f21308624.png" alt="cf1f08b63104c88f692a527f21308624"></p></li></ul></li></ol></li></ul></blockquote><blockquote><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/53667aed05cf29e331afb013cad99845.png" alt="53667aed05cf29e331afb013cad99845"></p></blockquote><h4 id="1-1-3-存储结构探究"><a href="#1-1-3-存储结构探究" class="headerlink" title="1.1.3 存储结构探究"></a>1.1.3 存储结构探究</h4><h6 id="存储结构定义"><a href="#存储结构定义" class="headerlink" title="存储结构定义"></a><strong>存储结构定义</strong></h6><blockquote><ol><li><h6 id="存储结构定义："><a href="#存储结构定义：" class="headerlink" title="存储结构定义："></a><strong>存储结构定义</strong>：</h6><ul><li>数据的存储结构是指数据逻辑结构在计算机存储器中的表示，它也被称为物理结构。</li></ul></li></ol></blockquote><ol><li><blockquote><p><strong>存储结构与逻辑结构的关系</strong>：</p><ul><li>同一种逻辑结构可以设计成多种不同的存储结构。</li><li>在不同的存储结构中，实现相同运算的算法可能会有所不同。</li></ul></blockquote></li><li><blockquote><p><strong>逻辑结构、存储结构和运算之间的关系</strong>：</p><ul><li>逻辑结构通过映射到存储结构，进而实现具体的运算。</li><li>运算定义和运算实现之间存在映射关系，逻辑结构是运算定义的基础，而存储结构是运算实现的基础。</li></ul></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/37a0f47f6721fdf22db0eb82ac7865b2.png" alt="37a0f47f6721fdf22db0eb82ac7865b2"></p><h6 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h6><p><img src="https://majorli.github.io/algo_guide/_images/311_sequence_list.png" alt="../../_images/311_sequence_list.png"></p><p>顺序存储结构通过连续存储单元实现数据的逻辑结构映射，具有存储空间节省和快速随机存取的优点，但同时也存在修改不便的缺点。这种存储方式适用于数据元素数量固定或变动较少的场景。</p><ol><li><strong>顺序存储结构定义</strong>：<ul><li>顺序存储结构是使用一组连续的存储单元来存放所有数据元素，其中逻辑上相邻的元素在物理存储上也是相邻的。</li><li>元素之间的逻辑关系通过存储单元地址的相邻关系隐含表示，即将数据的逻辑结构直接映射到存储结构。</li></ul></li><li><strong>顺序存储结构的实现示例</strong>：<ul><li>以“Score”逻辑结构为例，假设每个元素占用30字节（B），从100号存储单元开始，按低地址到高地址方向存储。</li></ul></li><li><strong>顺序存储结构的优点</strong>：<ul><li><strong>节省存储空间</strong>：分配给数据的存储单元全部用于存放元素值，元素之间的逻辑关系表示不占用额外存储空间。</li><li><strong>随机存取</strong>：可以实现对数据元素的快速随机存取。给定元素的逻辑序号，可以在常量时间内查找到对应的元素值。</li></ul></li><li><strong>随机存取的计算公式</strong>：<ul><li>存储地址计算公式为： LOC(ai)&#x3D;p+(i−1)×k<em>L**OC</em>(<em>a**i</em>)&#x3D;<em>p</em>+(<em>i</em>−1)×<em>k</em></li><li>其中，k<em>k</em> 是每个元素所占的存储单元数，p<em>p</em> 是第一个元素所占存储单元的首地址。</li></ul></li><li><strong>顺序存储结构的缺点</strong>：<ul><li><strong>不便于修改</strong>：在进行元素的插入或删除操作时，可能需要移动一系列元素，这在大规模数据操作时效率较低。</li></ul></li></ol><blockquote><p>ArrayList- Vector CopyOnWriteArrayList</p><p>如上都实现了 <code>List</code> 接口，并具有顺序访问的特点。</p></blockquote><h6 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h6><p><img src="https://majorli.github.io/algo_guide/_images/317_linkedlist.png" alt="../../_images/317_linkedlist.png"></p><ol><li><blockquote><p><strong>链式存储结构定义</strong>：</p><ul><li>链式存储结构不要求所有元素在内存中连续存放，每个节点独立存储，不需要占用一整块连续的存储空间。</li><li>为了表示节点之间的关系，每个节点包含一个或多个指针字段，用于存放相邻节点的存储地址。</li></ul></blockquote></li></ol><blockquote><ol><li><strong>链式存储结构的优点</strong>：<ul><li><strong>便于修改</strong>：在进行插入、删除操作时，只需修改节点的指针域，不需要移动节点本身。</li></ul></li><li><strong>链式存储结构的缺点</strong>：<ul><li><strong>存储空间利用率较低</strong>：分配给数据元素的存储单元中有一部分被用来存放节点之间的逻辑关系。</li><li><strong>不能进行随机存取</strong>：由于逻辑上相邻的节点在存储器中不一定相邻，因此不能对节点进行随机存取。</li></ul></li></ol></blockquote><p>LinkedList  双向链表</p><p>ConcurrentLinkedQueue  线程安全的非阻塞队列 </p><p><strong><code>LinkedBlockingQueue</code></strong> 和 <strong><code>LinkedBlockingDeque</code></strong></p><h6 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h6><ol><li><p><strong>索引存储结构定义</strong>：</p><ul><li>索引存储结构是在存储数据（主数据表）的同时，建立一个附加的索引表。</li><li>索引表中的每一项称为索引项，通常包含关键字和对应的地址。</li></ul></li><li><p><strong>索引项的一般形式</strong>：</p><ul><li>索引项的一般形式为：(关键字, 对应地址)</li><li>索引表中的关键字有序排列（如递增），每个关键字的对应地址指向该关键字记录在数据表中的存储地址。</li></ul></li><li><p><strong>索引存储结构的查找过程</strong>：</p><ul><li>在进行关键字（如学号）查找时，先在索引表中快速查找（因为索引表中按关键字有序排列，可以采用二分查找）到相应的关键字。</li><li>然后通过对应地址在数据表中找到该记录的数据。</li></ul></li><li><p><strong>索引存储结构的优点</strong>：</p><ul><li><strong>查找效率高</strong>：由于索引表中关键字有序排列，可以采用二分查找等高效查找算法。</li></ul></li><li><p><strong>索引存储结构的缺点</strong>：</p><ul><li><strong>增加时间和空间开销</strong>：需要建立索引表，从而增加了存储空间的开销。</li><li><strong>维护成本</strong>：在数据表更新（插入、删除、修改）时，需要同步更新索引表，增加了维护成本。</li><li><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2efbc94f98d8f0fe441857b7f84d636d.png" alt="2efbc94f98d8f0fe441857b7f84d636d"></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2022080309560424.jpg" alt="img"></p><p><strong><code>HashMap</code></strong> &#x2F; <strong><code>TreeMap</code></strong>  键可以视作索引，值为实际数据类似</p><h6 id="哈希结构"><a href="#哈希结构" class="headerlink" title="哈希结构"></a>哈希结构</h6><ol><li><p><strong>哈希存储结构定义</strong>：</p><ul><li>哈希存储结构根据元素的关键字来确定其存储地址。</li><li>通过哈希函数 H(key)<em>H</em>(<em>k**ey</em>)（或散列函数）计算关键字对应的函数值，该函数值用作元素的存储地址。</li></ul></li><li><p><strong>哈希函数的选择</strong>：</p><ul><li><p>以学号作为自变量，选择一个合适的哈希函数，例如 h(学号)&#x3D;学号−201201<em>h</em>(学号)&#x3D;学号−201201。</p></li><li></li></ul></li><li><p><strong>哈希存储结构的查找过程</strong>：</p><ul><li>要查找学号为 id<em>i**d</em> 的学生记录，只需计算 h(id)<em>h</em>(<em>i**d</em>)，以它为地址在哈希表中直接找到该学号的学生记录。</li></ul></li><li><p><strong>哈希存储结构的优点</strong>：</p><ul><li><strong>查找速度快</strong>：只要给出待查找节点的关键字，就可以立即计算出对应记录的存储地址。</li><li><strong>存储效率高</strong>：只存储数据元素本身，不存储数据元素之间的逻辑关系。</li></ul></li><li><p><strong>哈希存储结构的缺点</strong>：</p><ul><li><strong>冲突处理</strong>：不同的关键字可能通过哈希函数计算得到相同的地址，需要处理这种“冲突”。</li><li><strong>哈希函数的选择</strong>：选择合适的哈希函数和冲突解决策略是关键。</li></ul></li><li><p><strong>哈希存储结构的应用场合</strong>：</p><ul><li>适用于要求对数据能够进行快速查找、插入的场合。</li></ul></li></ol><p><code>HashMap</code> 和 <code>HashSet</code> 提供了基础的哈希功能；<code>LinkedHashMap</code> 和 <code>LinkedHashSet</code> 在保证哈希效率的同时维护插入顺序；<code>ConcurrentHashMap</code> 提供线程安全的哈希表实现，而 <code>WeakHashMap</code> 和 <code>IdentityHashMap</code> 提供了特定应用场景的支持。</p><h4 id="1-14-数据运算"><a href="#1-14-数据运算" class="headerlink" title="1.14 数据运算"></a>1.14 数据运算</h4><blockquote><ol><li><strong>数据运算的定义</strong>：<ul><li>数据运算是施加于数据的操作，它包括对数据进行的各种处理活动。</li></ul></li><li><strong>运算的两个部分</strong>： <strong>分离思想</strong><ul><li><strong>运算定义</strong>：描述运算的功能和目的，是抽象的描述，不涉及具体的实现细节。</li><li><strong>运算实现</strong>：在特定的数据存储结构上设计算法来实现这些运算，是具体的实现步骤。</li></ul></li></ol></blockquote><h4 id="1-15-数据结构-数据类型-和抽象数据类型"><a href="#1-15-数据结构-数据类型-和抽象数据类型" class="headerlink" title="1.15 数据结构  数据类型 和抽象数据类型"></a>1.15 数据结构  数据类型 和抽象数据类型</h4><h6 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h6><p>数据结构 :带结构的数据元素的集合 包含数据逻辑 存储逻辑 运算运算逻辑</p><h6 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h6><p>数据类型显示或隐式的定义了数据的存储格式 数据范围 允许进行的计算</p><p>1.c++基本数据类型</p><p>省</p><p>2.指针类型</p><p>int * a&#x3D;&b; -&gt;   b(地址)-&gt;123(真实数据)</p><p>int ** &#x3D;&a; 嵌套类-不知道行不行</p><p>3.c++数组类型</p><p>int a[10];</p><p>4.结构体类型</p><p>struct t{</p><p>int a;</p><p>char a;</p><p>}</p><p>集体占的大小还要适配内存对齐-防止缓存失效解决</p><p>5.共用体类型</p><p>省</p><p>6.自定义类型</p><p>typedef struct ttudent{<br>}studtype</p><p>别名 -&gt;根结构体差不多</p><h6 id="3-抽象数据类型"><a href="#3-抽象数据类型" class="headerlink" title="3.抽象数据类型"></a>3.抽象数据类型</h6><p>抽象数据类型是一种数据模型的抽象，描述了数据类型的操作和功能，而不关心其具体实现。ADT提供了一组操作和数学模型，用于定义数据类型的行为和性质。ADT定义时包含了操作的逻辑及功能描述，具体实现则留给程序设计者。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dcc57cf60c33af3dd920d15376ccad4a.png" alt="dcc57cf60c33af3dd920d15376ccad4a"></p><p>ps:说白了就是想像一个结构体出来-但是没有具体实现</p><h4 id="1-1-总结"><a href="#1-1-总结" class="headerlink" title="1.1 总结"></a>1.1 总结</h4><p>概念上的东西，没刷题不知道-但是非常概念的就是-抽象数据类型 数据运算 概述和数据结构</p><h3 id="1-2-算法和算法分析"><a href="#1-2-算法和算法分析" class="headerlink" title="1.2 算法和算法分析"></a>1.2 算法和算法分析</h3><h4 id="1-2-1算法及描述"><a href="#1-2-1算法及描述" class="headerlink" title="1.2.1算法及描述"></a>1.2.1算法及描述</h4><h6 id="1-算法特性"><a href="#1-算法特性" class="headerlink" title="1.算法特性"></a>1.算法特性</h6><p>算法-对特定问题求解步骤的描述</p><p>算法设计满足目标</p><p><strong>正确性</strong>：算法必须能够正确执行其规定的功能和性能要求，这是最重要的标准。</p><p><strong>可使用性</strong>：算法应易于理解和使用，即具有用户友好性。</p><p><strong>可读性</strong>：算法应该便于人的理解，逻辑必须明确、简单、结构良好。</p><p><strong>健壮性</strong>：算法应具备很好的容错能力，即使遇到异常数据，也能处理或防止崩溃。</p><p><strong>高效性与低存储性</strong>：算法应在执行时间和存储空间上高效，对同一问题，算法的效率越高越好，同时要求其存储消耗低。</p><p>算法特性</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4a5032bae80dd2445ae8a06cb1ea232e.png" alt="4a5032bae80dd2445ae8a06cb1ea232e"></p><h6 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2.算法描述"></a>2.算法描述</h6><p>算法描述:算法可由多种语言来描述-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7121e96e74080a4416b2c76d17c7908a.png" alt="7121e96e74080a4416b2c76d17c7908a"></p><p>如上-代码-s&#x3D;s+i-&gt;修改是地址的值-栈压得值-可修改call栈外的局部变量-</p><p>ps:前提是s&#x3D;s+1-是对外部指针指向的数据操作-而不是拷贝了一份-(cpp好久没看过了)</p><p>这里应该表面 -算法的输入 输出 是s-同一个吗-不知道，文字太多不想看</p><h4 id="1-2-3算法分析"><a href="#1-2-3算法分析" class="headerlink" title="1.2.3算法分析"></a>1.2.3算法分析</h4><h6 id="1-算法时间复杂度"><a href="#1-算法时间复杂度" class="headerlink" title="1.算法时间复杂度"></a>1.算法时间复杂度</h6><p><strong>时间复杂度</strong>（Time Complexity）是用来估计一个算法运行时间的一个指标，表示算法执行所需时间相对于输入规模的增长关系。它反映了算法随着输入数据量增大，运行时间增加的情况。</p><p>时间复杂度通常使用大O符号（Big O Notation）表示，如 <code>O(1)</code>、<code>O(n)</code>、<code>O(n^2)</code> 等。大O符号描述了最坏情况下算法的运行时间。</p><p>常见时间复杂度及其含义</p><ol><li><p><strong>O(1) - 常数时间复杂度</strong></p><ul><li><p>算法的执行时间不依赖于输入数据的规模。例如，访问数组中的某个元素。</p></li><li><p>示例：<code>a = array[5]</code> 这个操作总是执行一个步骤，因此时间复杂度是 <code>O(1)</code>。</p></li><li><p>2.<strong>O(n) - 线性时间复杂度</strong></p></li><li><p>算法的执行时间随着输入数据的规模 <code>n</code> 线性增长。也就是说，输入数据翻倍，运行时间也会翻倍。</p></li><li><p>示例：一个简单的 <code>for</code> 循环遍历 <code>n</code> 个元素。</p></li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">python</span>复制代码<span class="hljs-variable">for</span> <span class="hljs-variable">i</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">range</span>(<span class="hljs-variable">n</span>):</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">i</span>)</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>O(n^2) - 二次时间复杂度</strong></p><ul><li>算法的执行时间与输入规模的平方成正比。通常出现在嵌套循环中，外层和内层都循环 <code>n</code> 次。</li><li>示例：双重嵌套循环遍历二维数组。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python复制代码<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">i</span>, j)<br></code></pre></td></tr></table></figure><p>O(log n) - 对数时间复杂度</p><ul><li>算法的执行时间随着输入数据的规模呈对数增长，通常出现在“二分”算法中，比如二分查找。每次操作将问题规模减半。</li><li>示例：在一个排序数组中查找元素的位置。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LogarithmicTimeExample &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> result = binarySearch(<span class="hljs-keyword">array</span>, target);<br>        <br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Element not found.&quot;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Element found at index: &quot; + result);<br>        &#125;<br>    &#125;<br><br>    // 二分查找实现<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> binarySearch(<span class="hljs-type">int</span>[] <span class="hljs-keyword">array</span>, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-keyword">array</span>.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span>[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">array</span>[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; // 未找到目标元素<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>O(n log n) - 线性对数时间复杂度</strong></p><ul><li><p>常见于高效的排序算法，如快速排序（Quick Sort）和归并排序（Merge Sort）。它的时间复杂度是 <code>n</code> 和 <code>log n</code> 的乘积。</p></li><li><p>示例：归并排序。</p></li><li><pre><code class="hljs">import java.util.Arrays;public class MergeSortExample &#123;    public static void main(String[] args) &#123;        int[] array = &#123;38, 27, 43, 3, 9, 82, 10&#125;;        mergeSort(array, 0, array.length - 1);        System.out.println(&quot;Sorted array: &quot; + Arrays.toString(array));    &#125;    // 归并排序算法    public static void mergeSort(int[] array, int left, int right) &#123;        if (left &lt; right) &#123;            int mid = (left + right) / 2;            mergeSort(array, left, mid); // 递归排序左半部分            mergeSort(array, mid + 1, right); // 递归排序右半部分            merge(array, left, mid, right); // 合并两部分        &#125;    &#125;    // 合并两个子数组的函数    public static void merge(int[] array, int left, int mid, int right) &#123;        int n1 = mid - left + 1;        int n2 = right - mid;        int[] leftArray = new int[n1];        int[] rightArray = new int[n2];        for (int i<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br>**O(<span class="hljs-number">2</span>^<span class="hljs-built_in">n</span>) - 指数时间复杂度**<br><br>- 随着输入规模增加，算法运行时间以指数方式增长。通常出现在解决递归问题（如斐波那契数列）时。<br><br>- 示例：递归计算斐波那契数列。<br><br>- ```<br>  def fibonacci(<span class="hljs-built_in">n</span>)<span class="hljs-symbol">:</span><br>      <span class="hljs-built_in">if</span> <span class="hljs-built_in">n</span> &lt;= <span class="hljs-symbol">1:</span><br>          return <span class="hljs-built_in">n</span><br>      el<span class="hljs-symbol">se:</span><br>          return fibonacci(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + fibonacci(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>)<br>  <br></code></pre></td></tr></table></figure>  **O(n!) - 阶乘时间复杂度**  最糟糕的时间复杂度，通常出现在解决组合问题时，如全排列生成或旅行商问题（TSP）。  示例：生成一个数组的所有排列。</code></pre></li></ul><p>如何计算时间复杂度</p><ol><li><strong>分析算法的基本操作</strong>：找出算法中最常执行的基本操作（如循环中的一次迭代）。</li><li><strong>确定基本操作的执行次数</strong>：计算该操作在最坏情况下的执行次数。</li><li><strong>去掉低阶项和常数</strong>：只关注增长速度最快的项，并忽略常数因子（如 <code>5n</code> 和 <code>n</code> 都视为 <code>O(n)</code>）。</li></ol><p>总结 </p><p><strong>O(1)</strong> - 常数时间复杂度</p><p><strong>O(log n)</strong> - 对数时间复杂度</p><p><strong>O(n)</strong> - 线性时间复杂度</p><p><strong>O(n log n)</strong> - 线性对数时间复杂度</p><p><strong>O(n^2)</strong> - 二次时间复杂度</p><p><strong>O(n^3)</strong> - 三次时间复杂度</p><p><strong>O(2^n)</strong> - 指数时间复杂度</p><p><strong>O(n!)</strong> - 阶乘时间复杂度</p><p>案例:<a href="https://www.cnblogs.com/Agtw/p/17173051.html">https://www.cnblogs.com/Agtw/p/17173051.html</a> -</p><h6 id="2-算法空间复杂度"><a href="#2-算法空间复杂度" class="headerlink" title="2.算法空间复杂度"></a>2.算法空间复杂度</h6><p>1.空间复杂度<br>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。空间复杂度不是程序占用<br>了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计<br>算规则基本跟实践复杂度类似，也使用大O渐进表示法.-<br>就是一段函数在堆栈中开辟的堆栈大小</p><p><strong>空间复杂度</strong>衡量了算法所需的额外内存空间，帮助我们理解和优化程序的内存使用。</p><p>选择合适的算法时，既要考虑时间复杂度，也要考虑空间复杂度，特别是在处理大规模数据或资源有限的情况下。</p><p><strong>O(1)</strong> - 常数空间复杂度</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan">public <span class="hljs-type">int</span> findMax(<span class="hljs-type">int</span>[] <span class="hljs-type">array</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-type">array</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// O(1) 空间复杂度，仅使用一个额外变量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-type">array</span>.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">array</span>[i] &gt; <span class="hljs-built_in">max</span>) &#123;<br>            <span class="hljs-built_in">max</span> = <span class="hljs-type">array</span>[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>O(log n)</strong> - 对数空间复杂度</p><p><strong>O(n)</strong> - 线性空间复杂度\</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title function_ invoke__">copyArray</span>(<span class="hljs-keyword">int</span>[] <span class="hljs-keyword">array</span>) &#123;<br>    <span class="hljs-keyword">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">array</span>.length]; <span class="hljs-comment">// O(n) 空间复杂度，因需分配与输入规模相同的空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">array</span>.length; i++) &#123;<br>        newArray[i] = <span class="hljs-keyword">array</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArray;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>O(n log n)</strong> - 线性对数空间复杂度</p><p><strong>O(n^2)</strong> - 二次空间复杂度</p><p><strong>O(n^3)</strong> - 三次空间复杂度</p><p><strong>O(2^n)</strong> - 指数空间复杂度</p><p><strong>O(n!)</strong> - 阶乘空间复杂度</p><h3 id="1-3-数据程序结构设计"><a href="#1-3-数据程序结构设计" class="headerlink" title="1.3 数据程序结构设计"></a>1.3 数据程序结构设计</h3><h4 id="1-3-1-数据结构程序设计步骤"><a href="#1-3-1-数据结构程序设计步骤" class="headerlink" title="1.3.1 数据结构程序设计步骤"></a>1.3.1 数据结构程序设计步骤</h4><ol><li><strong>设计数据结构程序的步骤</strong>：<ul><li><strong>第一步</strong>：分析问题的数据和求解功能，使用抽象数据类型（ADT）来描述问题，包括数据逻辑结构和运算定义。</li><li><strong>第二步</strong>：设计逻辑结构对应的存储结构。</li><li><strong>第三步</strong>：在选定的存储结构上设计实现运算定义的算法。</li></ul></li></ol><h4 id="1-3-2-应用程序结构"><a href="#1-3-2-应用程序结构" class="headerlink" title="1.3.2 应用程序结构"></a>1.3.2 应用程序结构</h4><p>![a1b9aa105652fe4d7386574ca6429d89](G:\360MoveData\Users\nixg\Documents\Tencent Files\1332425260\nt_qq\nt_data\Pic\2024-09\Ori\a1b9aa105652fe4d7386574ca6429d89.png)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些文件提供了关于数据结构、算法以及它们在程序设计中应用的全面概述。以下是核心内容的整理：</p><ol><li><p><strong>数据结构的定义</strong>：</p><ul><li>数据结构是存在特定关系的数据元素集合，包括数据项和数据元素。</li></ul></li><li><p><strong>数据结构的组成</strong>：</p><ul><li>包括数据逻辑结构、数据存储结构和数据运算。</li></ul></li><li><p><strong>数据逻辑结构的分类</strong>：</p><ul><li>集合、线性结构、树状结构和图形结构，其中树状和图形结构是非线性结构。</li></ul></li><li><p><strong>数据存储结构的类型</strong>：</p><ul><li>顺序存储、链式存储、索引存储和哈希存储。</li></ul></li><li><p><strong>存储结构的设计</strong>：</p><ul><li>存储结构设计需考虑存储元素及其逻辑关系，同一逻辑结构可对应多个存储结构。</li></ul></li><li><p><strong>抽象数据类型</strong>：</p><ul><li>由数据逻辑结构和抽象运算组成。</li></ul></li><li><p><strong>算法的定义</strong>：</p><ul><li>算法是特定问题求解步骤的描述，具有有限性、确定性、可行性、输入性和输出性。</li></ul></li><li><p><strong>算法描述</strong>：</p><ul><li>算法通常用C&#x2F;C++函数的形式描述，复杂算法可能需要多个函数。</li></ul></li><li><p><strong>算法设计考虑</strong>：</p><ul><li>明确算法的输入和输出，通常作为函数的形参和返回值。</li></ul></li><li><p><strong>算法条件的有效性</strong>：</p><ul><li>条件有效时返回1（真），否则返回0（假）。</li></ul></li><li><p><strong>算法分析</strong>：</p><ul><li>包括时间复杂度和空间复杂度分析，目的是提高算法效率。</li></ul></li><li><p><strong>时间复杂度分析</strong>：</p><ul><li>选取基本运算，求其频度，取最高阶并置系数为1。</li></ul></li><li><p><strong>存储结构与算法的关系</strong>：</p><ul><li>良好的存储结构可以提高算法效率。</li></ul></li><li><p><strong>求解问题的步骤</strong>：</p><ul><li>建立抽象数据类型，设计合理的存储结构，在此基础上设计高效算法。</li></ul></li></ol><hr><hr><hr><hr><p>本文大部分内容来自数据结构 数据结构简明教程(第2版)</p><p>由本人经过gdp润色后+加上自己理解所抄录笔记-</p><hr><hr><p>第一章算是润色把 自我感觉有用的就是1</p><p>.数据结构的定义和组成</p><p>逻辑结构+存储结构</p><p>算法-算法的五要素 算法时间复杂度和空间复杂度</p><p>这些内容以前学比特数据结构1h学完</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mybits框架</title>
    <link href="/2024/09/11/mybits/"/>
    <url>/2024/09/11/mybits/</url>
    
    <content type="html"><![CDATA[<h1 id="mybits框架"><a href="#mybits框架" class="headerlink" title="mybits框架"></a>mybits框架</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Mybits.png" alt="Mybits"></p><h1 id="Mybits"><a href="#Mybits" class="headerlink" title="Mybits"></a>Mybits</h1><h4 id="了解mybits"><a href="#了解mybits" class="headerlink" title="了解mybits"></a>了解mybits</h4><blockquote><p>“MyBatis” 是一个用于 Java 的持久层框架，它简化了数据库访问的过程。其主要作用包括：</p><ol><li><strong>简化数据库操作</strong>：MyBatis 可以通过 XML 或注解的方式，将 SQL 语句直接写在代码中，避免了使用传统 JDBC 时需要编写大量重复的代码，使得数据库操作更加简洁。</li><li><strong>灵活的 SQL 映射</strong>：MyBatis 允许开发人员编写自定义的 SQL 语句，然后将其与 Java 对象映射。这种方式提供了高度的灵活性，特别适用于复杂的查询操作。</li><li><strong>自动映射结果集</strong>：MyBatis 能够将 SQL 查询的结果集自动映射到 Java 对象中，这样开发者不需要手动解析 ResultSet，大大简化了开发过程。</li><li><strong>动态 SQL 支持</strong>：MyBatis 提供了一种动态 SQL 的能力，通过标签（如 <code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code> 等）来生成动态 SQL 语句，满足各种复杂的查询需求。</li></ol><p>MyBatis 可以进行数据库操作的原因是，它封装了 <strong>JDBC</strong> 操作，将 SQL 查询的执行与结果的处理自动化，并且与 Java 应用程序的对象模型无缝集成。这使得开发人员可以专注于业务逻辑，而不需要关心底层的数据库操作细节。</p></blockquote><h4 id="mybits原理"><a href="#mybits原理" class="headerlink" title="mybits原理"></a>mybits原理</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6daa7e673d972cdd3a904b3bc10d63ee.png" alt="6daa7e673d972cdd3a904b3bc10d63ee"></p><blockquote><p><strong>MyBatis 配置文件</strong>：</p><ul><li><code>SqlMapConfig.xml</code> 是 MyBatis 的全局配置文件，用于配置 MyBatis 的运行环境等信息。</li><li><code>mapper.xml</code> 是用于 SQL 语句和对象映射的文件，这些文件配置了操作数据库的 SQL 语句，需要在 <code>SqlMapConfig.xml</code> 中加载这些文件。</li></ul></blockquote><blockquote><p><strong>通过 MyBatis 环境配置创建 SqlSessionFactory（会话工厂）</strong>：</p><ul><li>通过 MyBatis 的环境配置信息构造一个 <code>SqlSessionFactory</code>，它用于创建会话（<code>SqlSession</code>）实例。</li></ul></blockquote><blockquote><p><strong>会话（SqlSession）的作用</strong>：</p><ul><li>由会话工厂创建的 <code>SqlSession</code> 用于执行数据库操作，开发者在代码中使用 <code>SqlSession</code> 对象来执行 SQL 语句。</li></ul></blockquote><blockquote><p><strong>Executor 执行器</strong>：</p><ul><li>MyBatis 底层定义了 <code>Executor</code> 执行器接口，负责接收并执行 SQL 语句，有两个实现：一个是批量执行器（Batch Executor），一个是缓存执行器（Caching Executor）。</li></ul></blockquote><blockquote><p><strong>Mapped Statement</strong>：-mapper</p><ul><li><code>Mapped Statement</code> 是 MyBatis 底层封装的对象，包含了 MyBatis 配置信息、SQL 映射信息等。</li><li>在 <code>mapper.xml</code> 文件中，每个 SQL 语句对应一个 <code>Mapped Statement</code> 对象，SQL 的 <code>id</code> 对应 Mapped Statement 的 <code>id</code>。</li></ul></blockquote><blockquote><p><strong>输入参数映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输入参数进行定义，包括 <code>HashMap</code>、基本类型、POJO（普通的 Java 对象）。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 前将输入的 Java 对象映射为 SQL 中的参数，类似于 JDBC 编程中 <code>PreparedStatement</code> 的设定参数的过程。</li></ul></blockquote><blockquote><p><strong>输出结果映射</strong>：</p><ul><li><code>Mapped Statement</code> 对 SQL 执行输出结果进行定义，包括 <code>HashMap</code>、基本类型、POJO。</li><li><code>Executor</code> 通过 <code>Mapped Statement</code> 在执行 SQL 后将输出结果映射至 Java 对象，类似于 JDBC 编程中结果集（<code>ResultSet</code>）的解析处理过程。</li></ul></blockquote><h4 id="Mybits入门"><a href="#Mybits入门" class="headerlink" title="Mybits入门"></a>Mybits入门</h4><h6 id="1-mybits使用"><a href="#1-mybits使用" class="headerlink" title="1.mybits使用"></a>1.mybits使用</h6><p>1.创建工程<br>2.导入依赖<br>3.创建配置文件</p><p>以下是一个 MyBatis 使用案例，包括配置文件 <code>mybatis-config.xml</code>、映射文件 <code>UserMapper.xml</code>、实体类 <code>User</code>、映射接口 <code>UserMapper</code>，以及一个使用 MyBatis 的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;<br>&lt;!DOCTYPE configuration<br>  PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br>  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;<br>&lt;configuration&gt;<br>  &lt;!-- 环境配置 --&gt;<br>  &lt;environments <span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>    &lt;environment id=<span class="hljs-string">&quot;development&quot;</span>&gt;<br>      &lt;!-- 使用 JDBC 事务管理器 --&gt;<br>      &lt;transactionManager type=<span class="hljs-string">&quot;JDBC&quot;</span> /&gt;<br>      &lt;!-- 配置数据源 --&gt;<br>      &lt;dataSource type=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;driver&quot;</span> value=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb?useSSL=false&amp;serverTimezone=UTC&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;root&quot;</span> /&gt;<br>        &lt;property name=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;password&quot;</span> /&gt;<br>      &lt;/dataSource&gt;<br>    &lt;/environment&gt;<br>  &lt;/environments&gt;<br>  <br>  &lt;!-- 指定映射文件 --&gt;<br>  &lt;mappers&gt;<br>    &lt;mapper resource=<span class="hljs-string">&quot;com/example/mapper/UserMapper.xml&quot;</span> /&gt;<br>  &lt;/mappers&gt;<br>&lt;/configuration&gt;<br><br></code></pre></td></tr></table></figure><p> 映射文件 <code>UserMapper.xml</code></p><p>这个文件包含 SQL 语句和 Java 方法的映射。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="language-xml">  ///对应路径映射</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="language-xml">///</span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 插入用户 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="language-xml">    INSERT INTO user (name, age) VALUES (#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">, #</span><span class="hljs-template-variable">&#123;age&#125;</span><span class="language-xml">)</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>映射接口 <code>UserMapper</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//会生成代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserMapper</span> &#123;<br>    <span class="hljs-built_in">void</span> insertUser(User user);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程</p><p><strong>配置加载</strong>：读取 MyBatis 配置文件，初始化 <code>SqlSessionFactory</code>。</p><p><strong>会话创建</strong>：通过 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code>，作为数据库操作的会话</p><p><strong>Mapper 映射</strong>：获取映射接口（Mapper）的代理对象，映射接口方法与 SQL 语句对应。</p><blockquote><p>通过 <code>SqlSession</code> 实例的 <code>getMapper(UserMapper.class)</code> 方法，获取 <code>UserMapper</code> 映射接口的代理对象。</p><p>MyBatis 底层会根据 <code>UserMapper.xml</code> 映射文件中定义的 SQL 语句和 <code>UserMapper</code> 接口中的方法进行绑定。</p></blockquote><p><strong>执行 SQL</strong>：使用 <code>Executor</code> 执行映射 SQL 语句，对数据库进行 CRUD 操作。</p><p><strong>参数映射</strong>：在执行 SQL 前，将输入参数映射到 SQL 语句中；执行 SQL 后，将结果集映射为 Java 对象。</p><p><strong>事务控制</strong>：通过 <code>SqlSession</code> 的 <code>commit()</code> 和 <code>rollback()</code> 控制事务。</p><p><strong>会话关闭</strong>：操作完成后，关闭 <code>SqlSession</code>，释放资源。</p><h6 id="2-占位符"><a href="#2-占位符" class="headerlink" title="2.占位符"></a>2.占位符</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id=&quot;insertUser&quot; parameterType=&quot;com.example.model.User&quot;&gt;    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (<span class="hljs-type">name</span>, age) <span class="hljs-keyword">VALUES</span> (#&#123;<span class="hljs-type">name</span>&#125;, #&#123;age&#125;)  &lt;/<span class="hljs-keyword">insert</span>&gt;<br></code></pre></td></tr></table></figure><p>#{} 实现向占位符添加值-自动进行java类型和jdbc类型转换-可以防止sql注入-可接收简单类型值和pojo属性值</p><p> ￥s{}拼接sql传&#x3D;不进行类型转换&#x3D;</p><h6 id="3-parameterType-resultType"><a href="#3-parameterType-resultType" class="headerlink" title="3.parameterType-resultType"></a>3.parameterType-resultType</h6><p>parameterType-传入的参数类型</p><p>resultType返回值类型</p><h6 id="4-selectOne和selectList"><a href="#4-selectOne和selectList" class="headerlink" title="4..selectOne和selectList"></a>4..selectOne和selectList</h6><p>selectOne查询一条记录</p><p>selectList查询多条记录</p><h6 id="5-mybits-主键"><a href="#5-mybits-主键" class="headerlink" title="5.mybits-主键"></a>5.mybits-主键</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f2a7da3c2707062c15cbbfc7c5f51f9.png" alt="3f2a7da3c2707062c15cbbfc7c5f51f9"></p><p>使用</p><p>SqlSession.insert(“test.insertUser”,user);</p><p>selectkey-&gt;select Last_INSERT_ID–用户添加后自动返回主键-</p><p>—返回主键 </p><p>uuid生成主键</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69eddd3b9e877d74e91d107aad7b6940.png" alt="69eddd3b9e877d74e91d107aad7b6940"></p><h6 id="6-mybits-删除"><a href="#6-mybits-删除" class="headerlink" title="6.mybits-删除"></a>6.mybits-删除</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f16033409c2f9eb00418ede68cffc228.png" alt="f16033409c2f9eb00418ede68cffc228"></p><p>sqlSession.delete(“test.deleteUser”,39);</p><h6 id="7-mybiits-更新用户"><a href="#7-mybiits-更新用户" class="headerlink" title="7.mybiits-&gt;更新用户"></a>7.mybiits-&gt;更新用户</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/95864300169e8c1df1b79f4d0102505e.png" alt="95864300169e8c1df1b79f4d0102505e"></p><p>sqlSession.update(“test.updateUser”,user);</p><h4 id="mybits-Dao开发"><a href="#mybits-Dao开发" class="headerlink" title="mybits-Dao开发"></a>mybits-Dao开发</h4><h6 id="1-Dao开发配置入门"><a href="#1-Dao开发配置入门" class="headerlink" title="1.Dao开发配置入门"></a>1.Dao开发配置入门</h6><p>Impl层</p><p>前言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Resources.getResourceAsStream(resource);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;<br>            <span class="hljs-comment">//生成的为代理对象</span><br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);   <br>                <span class="hljs-comment">// 插入用户</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                newUser.setName(<span class="hljs-string">&quot;John&quot;</span>);<br>                newUser.setAge(<span class="hljs-number">25</span>);<br>                mapper.insertUser(newUser);<br>                session.commit(); <span class="hljs-comment">// 提交事务</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个请求 都会创建 SqlSessionFactory  SqlSessionFactoryBuilder-影响资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/61928ee9fd81bc3528cdddda96a0d8be.png" alt="61928ee9fd81bc3528cdddda96a0d8be"></p><p><code>SqlSessionFactoryBuilder</code> 只是一个构建器，它的生命周期是短暂的，只需在创建 <code>SqlSessionFactory</code> 时使用一次。创建好 <code>SqlSessionFactory</code> 后，就不需要再保留 <code>SqlSessionFactoryBuilder</code> 实例。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a59f5c6efc930fdf24b4753e2d6c0165.png" alt="a59f5c6efc930fdf24b4753e2d6c0165"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8f73ed7437e15b3fd61ff570da0b265.png" alt="e8f73ed7437e15b3fd61ff570da0b265"></p><p>解决多次创建后代码–bean-单例bena实现 -如图还未bean 也就是简单的单例模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f89faf38a206b6547777bbea1aa5e14.png" alt="8f89faf38a206b6547777bbea1aa5e14"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d751486c93be306c26947fa45914c821.png" alt="d751486c93be306c26947fa45914c821"></p><p>dao层面-有非常多的重复代码-比如释放资源-拿取selSession-</p><h6 id="2-Mapper开发"><a href="#2-Mapper开发" class="headerlink" title="2.Mapper开发"></a>2.Mapper开发</h6><p>mapper代理方法（程序员只需要mapper接口）<br>程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a8d02d56bb89ffa8d43fd55385bb115a.png" alt="a8d02d56bb89ffa8d43fd55385bb115a"></p><p>需要一一对应进行映射</p><p>也就是mapper-函数映射到xml文件中–需要进行一一对应</p><h6 id="3-mapper代理"><a href="#3-mapper代理" class="headerlink" title="3.mapper代理"></a>3.mapper代理</h6><p>xml定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab74d1f694af3fb743e294f135a4041a.png" alt="ab74d1f694af3fb743e294f135a4041a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5eea9b8887ac8e1894fd8520adf4dcec.png" alt="5eea9b8887ac8e1894fd8520adf4dcec"></p><p>加载</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/922160ede6004b8fb5aea389641d68c2.png" alt="922160ede6004b8fb5aea389641d68c2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45e07e2b4ddd60cd021dcc2f31c066c8.png" alt="45e07e2b4ddd60cd021dcc2f31c066c8"></p><p>—如图–userMapper-来调用方法0由sqlSession-来生成代理对象</p><p>   代理对象内部调用selectOne或selectList<br>如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。<br>如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库</p><hr><p>mapper接口方法参数只能有一个，系统是否不利于扩展维护。</p><p>系统 框架中，dao层的代码是被业务层公用的。<br>即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。</p><p>注意：持久层方法的参数可以包装类型、map。。。，service方法中建议不要使用包装类型（不利于业务层的可扩展）。</p><h6 id="4-l配置"><a href="#4-l配置" class="headerlink" title="4.l配置"></a>4.l配置</h6><p>SqlMapConfig.xm</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a05192e83f10245208db8c09e74468f.png" alt="0a05192e83f10245208db8c09e74468f"></p><p> properties属性</p><p>将数据库连接参数只配置在db.properties中，原因：方便对参数进行统一管理，其它xml可以引用该db.properties</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5afb2ae748e665a0957970ae4a909e5d.png" alt="5afb2ae748e665a0957970ae4a909e5d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a29db16646c4c42d5d9896bd292741d.png" alt="2a29db16646c4c42d5d9896bd292741d"></p><p> settings全局参数配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0070c06383100dde987ddc21ea4a4b3a.png" alt="0070c06383100dde987ddc21ea4a4b3a"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62169f009b19205c6220b75f7a4bcb5a.png" alt="62169f009b19205c6220b75f7a4bcb5a"></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><blockquote><p>类型别名（Type Alias）是为了简化和减少 XML 配置文件中的类全限定名而引入的一种便捷方式。通过定义类型别名，你可以使用更短的名称来引用 Java 类，从而使得 Mapper XML 文件更简洁和易读。</p></blockquote><blockquote><p><strong>定义类型别名</strong>：在 MyBatis 配置文件 (<code>mybatis-config.xml</code>) 中，可以为 Java 类指定一个别名。</p><p><strong>使用类型别名</strong>：在 Mapper XML 文件中使用别名来代替类的全限定名。</p></blockquote><h6 id="1-普通类型别名"><a href="#1-普通类型别名" class="headerlink" title="1.普通类型别名"></a>1.普通类型别名</h6><p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p><p>自定义别名-当我们参数的pojo大部分一致的时候 定义别名可以减少代码繁杂</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e1d9343cb1eb8b59a484042657ed0f6.png" alt="8e1d9343cb1eb8b59a484042657ed0f6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7ae2a441a846072ed1c64575f9fa045.png" alt="d7ae2a441a846072ed1c64575f9fa045"></p><p>批量别名-常用-扫描po文件 给所有pojo注册别名</p><h6 id="3-mybits-类型处理器"><a href="#3-mybits-类型处理器" class="headerlink" title="3.mybits 类型处理器"></a>3.mybits 类型处理器</h6><blockquote><p>在 MyBatis 中，<strong>类型处理器（Type Handlers）</strong> 用于处理 Java 类型与 JDBC 类型之间的转换。它们在 MyBatis 从数据库中读取数据（结果集映射）或将数据写入数据库（参数映射）时起着关键作用。<br>例子</p><p><strong>Java 类型到 JDBC 类型的转换</strong>：将 Java 对象类型转换为 SQL 参数，发送到数据库。例如，将 <code>Integer</code> 类型的 Java 对象转换为数据库的 <code>INTEGER</code> 类型。</p><p><strong>JDBC 类型到 Java 类型的转换</strong>：将从数据库查询的结果转换为 Java 对象。例如，将数据库查询结果中的 <code>INTEGER</code> 类型转换为 Java 的 <code>Integer</code> 或 <code>int</code>。</p></blockquote><h6 id="4-mappers-映射配置"><a href="#4-mappers-映射配置" class="headerlink" title="4.  mappers 映射配置"></a>4.  mappers 映射配置</h6><ol><li><p>通过resource加载单个映射文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/982f90b2b3ead1f97c7560fa9326b4fe.png" alt="982f90b2b3ead1f97c7560fa9326b4fe"></p></li><li><p>通过mapper接口加载单个mapper</p></li></ol><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5c7c2136386dd9b06663cdf3631c412c.png" alt="5c7c2136386dd9b06663cdf3631c412c"></p><p>按照上边的规范，将mapper.java和mapper.xml放在一个目录 ，且同名</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/de35b2cb9ffb9c7af48ac36f9586f000.png" alt="de35b2cb9ffb9c7af48ac36f9586f000"></p><p>3 .  批量加载mapper(推荐使用)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3cc05d3339e8ebae691aaac0073392fa.png" alt="3cc05d3339e8ebae691aaac0073392fa"></p><p>4.输入映射</p><p>通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/80e95beb88e2a055ee91e47d12c5bc6e.png" alt="80e95beb88e2a055ee91e47d12c5bc6e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/16e891a8f40288f28679241a5f4a6dd0.png" alt="16e891a8f40288f28679241a5f4a6dd0"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eec86ff7c8c1cc0c909076d9d0827b36.png" alt="eec86ff7c8c1cc0c909076d9d0827b36"></p><h5 id="Mybits高级"><a href="#Mybits高级" class="headerlink" title="Mybits高级"></a>Mybits高级</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ec78fe0039ba4d7a0f0e93edde34ffd.png" alt="3ec78fe0039ba4d7a0f0e93edde34ffd"></p><h6 id="1-一对一查询"><a href="#1-一对一查询" class="headerlink" title="1.一对一查询"></a>1.一对一查询</h6><p>查询订单信息，关联查询创建订单的用户信息<br>sql语句<br>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS,USER WHRE ORDERS.USER_ID&#x3D;USER.ID;</p><p>select orders.*,  USER.username,<br>  USER.sex,<br>  USER.address FROM ORDERS JOIN USER ON ORDERS.USER_ID&#x3D;USER.ID;</p><p>实现该查询</p><p>1.创建pojo</p><p>2.mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;SELECT ID=<span class="hljs-string">&quot;FINDorderUser&quot;</span> resultType=<span class="hljs-string">&#x27;pojo&#x27;</span>&gt;<br>select orders.*,user.username,user.sexmuser.address from orders,user WHRE ORDERS.USER_ID=USER.ID;<br><br>&lt;/lelect&gt;<br></code></pre></td></tr></table></figure><p>3.mapper.java</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5efc0b312fab4d35aa879dd46fae93a0.png" alt="5efc0b312fab4d35aa879dd46fae93a0"></p><p>这个时候-只需要获取即可使用该sql语句<br>–    使用resultMap映射的思路<br>使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f8a7cbf8b3875476e103b0733ac7f7f5.png" alt="f8a7cbf8b3875476e103b0733ac7f7f5"></p><p>定义resultMap</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ee4c7227c01ec39fa1bfa811976628dc.png" alt="ee4c7227c01ec39fa1bfa811976628dc"></p><p>S定义</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e92a4eb35812042de17a350aa5405bc7.png" alt="e92a4eb35812042de17a350aa5405bc7"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55906bbde71b042c14daf40325e2734a.png" alt="55906bbde71b042c14daf40325e2734a"></p><h6 id="2-一对多查询"><a href="#2-一对多查询" class="headerlink" title="2.一对多查询"></a>2.一对多查询</h6><p>查询订单及订单明细的信息。<br>SELECT<br>  orders.*,<br>  USER.username,<br>  USER.sex,<br>  USER.address,<br>  orderdetail.id orderdetail_id,<br>  orderdetail.items_id,<br>  orderdetail.items_num,<br>  orderdetail.orders_id<br>from<br> orders,<br>  USER,<br>  orderdetail<br>whrer<br>orders.user_id &#x3D; user.id AND orderdetail.orders_id&#x3D;orders.id</p><hr><hr><hr><hr><p>使用resultType将上边的 查询结果映射到pojo中，订单信息的就是重复<br>要求：<br>对orders映射不能出现重复记录。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/affb5c09f23f5c042208c4323940698f.png" alt="affb5c09f23f5c042208c4323940698f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6c2accdfd7490aa05255bb2aaa6f9807.png" alt="6c2accdfd7490aa05255bb2aaa6f9807"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7c536bcee1988bbddfd784e6de1204ec.png" alt="7c536bcee1988bbddfd784e6de1204ec"></p><p>map-&gt;映射关系<br>将数据库字段-&gt;对象的字段中<br>同时会指定映射的属性和集合中</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/44c0fb3e4d6de667636651db0026ad85.png" alt="44c0fb3e4d6de667636651db0026ad85"></p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e59fc4b2bdacf3621426fec322ad24c3.png" alt="e59fc4b2bdacf3621426fec322ad24c3"></p><h6 id="3-多对多查询案例"><a href="#3-多对多查询案例" class="headerlink" title="3.多对多查询案例"></a>3.多对多查询案例</h6><hr><p>查询主表是：用户表<br>关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：<br>orders、orderdetail、items</p><hr><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5d503cb8e549dc16e9fb2f3d9f972be9.png" alt="5d503cb8e549dc16e9fb2f3d9f972be9"></p><p>映射</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c9ea555f307b956af31dbce8415170.png" alt="b4c9ea555f307b956af31dbce8415170"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bb9ca63b64a989b5b020ebe231fb555d.png" alt="bb9ca63b64a989b5b020ebe231fb555d"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/314f0ba042424242c4135b4302a65f13.png" alt="314f0ba042424242c4135b4302a65f13"></p><h4 id="resultmap总结"><a href="#resultmap总结" class="headerlink" title="resultmap总结"></a>resultmap总结</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/863ba0486e9be85c0c64ea7eccdead9a.png" alt="863ba0486e9be85c0c64ea7eccdead9a"></p><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>如果查询两张表-如果只需要查询一张表即可满足条件的情况下-那么就不需要查询下一章表<br>关联查询-&gt;单表查询<br>1.使用association实现延迟加载</p><p>查询订单并且关联查询用户信息</p><p>案例</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf67701ceb62d4d73d31491daee4f282.png" alt="cf67701ceb62d4d73d31491daee4f282"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>resultMap type<span class="hljs-operator">=</span>&quot;orders&quot; id&quot;map&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--对订单信息进行映射配置  --&gt;</span><br>            <span class="hljs-operator">&lt;</span>id <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;id&quot; property<span class="hljs-operator">=</span>&quot;id&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot; property<span class="hljs-operator">=</span>&quot;userId&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;number&quot; property<span class="hljs-operator">=</span>&quot;number&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;createtime&quot; property<span class="hljs-operator">=</span>&quot;createtime&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span><span class="hljs-keyword">result</span> <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;note&quot; property<span class="hljs-operator">=</span>&quot;note&quot;<span class="hljs-operator">/</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 实现对用户信息进行延迟加载</span><br>            <span class="hljs-keyword">select</span>：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）<br>            要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace<br>            <span class="hljs-keyword">column</span>：订单信息中关联用户信息查询的列，是user_id<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span>association property<span class="hljs-operator">=</span>&quot;user&quot; javaType<span class="hljs-operator">=</span>&quot;user&quot;<br>  <span class="hljs-keyword">select</span><span class="hljs-operator">=</span>&quot;cn.itcast.mybatis.mapper.UserMapper.findUserById&quot; <span class="hljs-keyword">column</span><span class="hljs-operator">=</span>&quot;user_id&quot;<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>懒加载<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>association<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>resultMap<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62a5de17ceb2efb1cb23ce43c27b6311.png" alt="62a5de17ceb2efb1cb23ce43c27b6311"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/83717cda1037366a4cc5b930afeefd1d.png" alt="83717cda1037366a4cc5b930afeefd1d"></p><p>也就是-我们编译器没有访问到user内容就不会去加载吗 2.延迟加载配置<br>mybits默认没有开启延迟加载-需要自己手动开启<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3055bee2e2c581a6d17f4c89b04fb4c.png" alt="img"><br>3.</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/41591507899361a44254c502150f44f5.png" alt="img"></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h6 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h6><p>第一层查询-如果没有-从数据库查 再添加进缓存中<br>sqlSession去执行增删改-清空一级缓存<br>2次发起-&gt;缓存有直接返回</p><p>redis缓存思路</p><p>mybits默认支持一级缓存<br>Sqlsession sqlsession&#x3D;sqlsessionfactry.ioensession();<br>UserMapper userMapper&#x3D;sqlsession.getMapper(usermapper.class);<br>User user&#x3D;usermapper.finduserbyid(1);第一层查询-如果没有-从数据库查 再添加进缓存中</p><p>User user&#x3D;usermapper.finduserbyid(1); 2次发起-&gt;缓存有直接返回</p><p>usermapper.updateuser(user1);sqlSession去执行增删改-清空一级缓存</p><p>一级缓存应用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ada7a24f8aeae89ccbcdb1d4e103400.png" alt="2ada7a24f8aeae89ccbcdb1d4e103400"></p><h6 id="2-2级缓存"><a href="#2-2级缓存" class="headerlink" title="2.2级缓存"></a>2.2级缓存</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0e49bf45af19e07fa4ee06a0b7335180.png" alt="0e49bf45af19e07fa4ee06a0b7335180"></p><p>二级缓存范围大-多个sqlsession可以共享一个usermapper二级缓存区域<br>二级缓存区域是按照namespace分-其他不同的mapper也有自己的二级缓存区域</p><p>一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同 的二级缓存区域中。</p><p>开启二级缓存<br>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0a1dafc8e5fd22b6cf93d8e8aae31c4e.png" alt="0a1dafc8e5fd22b6cf93d8e8aae31c4e"></p><h4 id="mybits整合ehcache"><a href="#mybits整合ehcache" class="headerlink" title="mybits整合ehcache"></a>mybits整合ehcache</h4><p>mybits整合ehcache<br>ehcache是一个分布式缓存框架<br>缓存的数据-进行集中管理-分布式集中访问 整合方法</p><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。<br>mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/45eaa4a652048030f4b17712288fbc56.png" alt="img"><br>ehcache配置<br><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/687820640853663a040469325cfb6a5b.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68e729a0da44d9d806007bc8178478d5.png" alt="img"></p><h6 id="二级应用场景"><a href="#二级应用场景" class="headerlink" title="二级应用场景"></a>二级应用场景</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fcf22de20a326941945b31d902fd8608.png" alt="fcf22de20a326941945b31d902fd8608"></p><h4 id="Mybits整合Spring"><a href="#Mybits整合Spring" class="headerlink" title="Mybits整合Spring"></a>Mybits整合Spring</h4><h6 id="1-bean配置"><a href="#1-bean配置" class="headerlink" title="1.bean配置"></a>1.bean配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/af73e0779b8e3e14680320c06a1d3e29_720.jpg" alt="af73e0779b8e3e14680320c06a1d3e29_720"></p><p>bean的配置</p><p> user.xml</p><p>![b13f504c2f17c64e26097dff4834aed8](G:\360MoveData\Users\nixg\Documents\Tencent Files\2760045743\nt_qq\nt_data\Pic\2024-04\Ori\b13f504c2f17c64e26097dff4834aed8.jpg)</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/92c073b510f63afca1597faf32e1d6be.jpg" alt="92c073b510f63afca1597faf32e1d6be"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/68ba41b8d0cb810134cb064e6eed67c5.jpg" alt="68ba41b8d0cb810134cb064e6eed67c5"></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/4b6944e971eb9c6af10fdffe3f6cd943.jpeg" alt="4b6944e971eb9c6af10fdffe3f6cd943"></strong></p><p>以上bean去读xml配置<br>然后mybits去注册 在接口实现类进行查询<br>之后注册为bean</p><p>后续直接使用</p><h6 id="2-mapper"><a href="#2-mapper" class="headerlink" title="2.mapper"></a>2.mapper</h6><p>还是要在同级目录以下 </p><p>注册为bean 扫描xml文件</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dad5b70ff70703d57a807c3d9a740926_720.jpg" alt="dad5b70ff70703d57a807c3d9a740926_720"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/38fcb7f3871e63a3686786685b0671b7.jpg" alt="38fcb7f3871e63a3686786685b0671b7"></p>]]></content>
    
    
    <categories>
      
      <category>mybits</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java字节码</title>
    <link href="/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <url>/2024/09/11/%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>1</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>maven笔记</title>
    <link href="/2024/09/10/maven%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/10/maven%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="maven笔记"><a href="#maven笔记" class="headerlink" title="maven笔记"></a>maven笔记</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Maven.png" alt="Maven"></p><h4 id="1-Maven入门"><a href="#1-Maven入门" class="headerlink" title="1.Maven入门"></a>1.Maven入门</h4><h6 id="1-maven是什么"><a href="#1-maven是什么" class="headerlink" title="1.maven是什么"></a>1.maven是什么</h6><p>maven是一个统一构建工具-帮助我们快速的导入jar包-同时通过pom对jar进行统一管理–maen还统一了目录结构</p><p>项目构建–依赖管理-统一开发结构</p><h6 id="2-maven仓库"><a href="#2-maven仓库" class="headerlink" title="2.maven仓库"></a>2.maven仓库</h6><p>云端存储jar包—同时本地-私服</p><h6 id="3-坐标"><a href="#3-坐标" class="headerlink" title="3.坐标"></a>3.坐标</h6><p>groupld-定义maven项目组织名称</p><p>artifactld–定义当前maven项目名称</p><p>version-定义当前版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>坐标作用-使用唯一表示-定位资源位置</p><h6 id="4-手动创建maven工程"><a href="#4-手动创建maven工程" class="headerlink" title="4.手动创建maven工程"></a>4.手动创建maven工程</h6><p>–省-就是用命令来创建</p><h4 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2.依赖管理"></a>2.依赖管理</h4><h6 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1.依赖配置"></a>1.依赖配置</h6><dependencies></dependency><dependency></dependencies><h6 id="2-依赖传递"><a href="#2-依赖传递" class="headerlink" title="2.依赖传递"></a>2.依赖传递</h6><p>直接依赖–再当前项目内直接通过pom建立依赖关系</p><p>间接依赖-一个依赖依赖于其他依赖–当前项目会都导入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88a5b650615c05bdb3b51bb6518a3044.png" alt="88a5b650615c05bdb3b51bb6518a3044"></p><h6 id="3-可选依赖"><a href="#3-可选依赖" class="headerlink" title="3.可选依赖"></a>3.可选依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69b032579ca283056eb5f2d056059bf4.png" alt="69b032579ca283056eb5f2d056059bf4"></p><h6 id="4-排查依赖"><a href="#4-排查依赖" class="headerlink" title="4.排查依赖"></a>4.排查依赖</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e2be3508cc74b63a6c7f32972fa4017e.png" alt="e2be3508cc74b63a6c7f32972fa4017e"></p><h6 id="5-依赖范围"><a href="#5-依赖范围" class="headerlink" title="5.依赖范围"></a>5.依赖范围</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eaf5484e109c98583c4af32c8cc48353.png" alt="eaf5484e109c98583c4af32c8cc48353"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9e74890abdf3d3cbdd37154251a5c005.png" alt="9e74890abdf3d3cbdd37154251a5c005"></p><h4 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h4><p>快速生命周期-compile-test-compile-test-package-install</p><p>生命周期介绍</p><p>clean-清理工作</p><p>default0核心工作-如编译-测试打包-部署</p><p>site-产生报告-发布站点</p><hr><p>Clean生命周期</p><p>pre-clean-执行一些需要再clean之前完成的工作</p><p>clean-移除上一次构建生成的文件</p><p>post-clean-执行一些需要再clean之后立刻完成的工作</p><hr><p>default构建生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1c6053fbcc84183fbc8f1a7789cee3fb.png" alt="1c6053fbcc84183fbc8f1a7789cee3fb"></p><hr><p>site生命周期</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7037669c99ca8e172d0144f4de087264.png" alt="7037669c99ca8e172d0144f4de087264"></p><hr><p>default 介绍</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/69d200277cfe62e6d98340f0269f0bfe.png" alt="69d200277cfe62e6d98340f0269f0bfe"></p><p>又分为三大周期</p><h4 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/455befffa49ca7d0354264bf3db7dd62.png" alt="455befffa49ca7d0354264bf3db7dd62"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d32a812fe29eddabf67bcda3cfbcae8b.png" alt="d32a812fe29eddabf67bcda3cfbcae8b"></p><h1 id="Maven-高级"><a href="#Maven-高级" class="headerlink" title="Maven-高级"></a>Maven-高级</h1><h4 id="1-分模块开发与设计"><a href="#1-分模块开发与设计" class="headerlink" title="1.分模块开发与设计"></a>1.分模块开发与设计</h4><p>将一个大型项目拆分为多个独立模块的开发方式。</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f0de39a2aea7bbe668e3574cef96944.png" alt="8f0de39a2aea7bbe668e3574cef96944"></p><p>如图 分模块开发就是将模块-导成架包–</p><p>例如-公司 -pojo包-导给你，你只需要导入pom即可使用</p><h4 id="2-聚合"><a href="#2-聚合" class="headerlink" title="2.聚合"></a>2.聚合</h4><p>将模块-聚合再一起构建</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/14b16e3b8bff7a90e90f6f6d42086115.png" alt="14b16e3b8bff7a90e90f6f6d42086115"></p><h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f4069f69f02e626eba8d6941cd4394.png" alt="b6f4069f69f02e626eba8d6941cd4394"></p><p>继承依赖使用</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/62d9f5c074c0336ef3fcb5d36fd6546d.png" alt="62d9f5c074c0336ef3fcb5d36fd6546d"></p><p>继承资源</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f3225c0c79867bfb1e4f2abe6cf748d9.png" alt="f3225c0c79867bfb1e4f2abe6cf748d9"></p><p>继承聚合区别</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240414120838551.png" alt="image-20240414120838551"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br>xml<br><span class="hljs-comment">&lt;!-- 子模块的pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-属性"><a href="#4-属性" class="headerlink" title="4.属性"></a>4.属性</h4><p>属性最大的作用-配置-和版本管理</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4c4f542e3165840110e15b9913de9dc.png" alt="b4c4f542e3165840110e15b9913de9dc"></p><p>1.自定义属性管理</p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/90eb8af64c4b02ba15ed77e0ac33fd16.png" alt="90eb8af64c4b02ba15ed77e0ac33fd16" style="zoom:75%;" /><h4 id="5-工厂版本"><a href="#5-工厂版本" class="headerlink" title="5.工厂版本"></a>5.工厂版本</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e1232256a286acb832c2975ad59ea8a1.png" alt="e1232256a286acb832c2975ad59ea8a1"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7d129e90eaca59df9ae2b62f7ab6ca55.png" alt="7d129e90eaca59df9ae2b62f7ab6ca55"></p><h4 id="6-资源配置"><a href="#6-资源配置" class="headerlink" title="6.资源配置"></a>6.资源配置</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9de34d5dbae1ebc7a72669952069638a.png" alt="9de34d5dbae1ebc7a72669952069638a"></h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5fc90c8dd4f839707b20624bdf4242c6.png" alt="5fc90c8dd4f839707b20624bdf4242c6"></p><h4 id="7-多环境开发配置"><a href="#7-多环境开发配置" class="headerlink" title="7.多环境开发配置"></a>7.多环境开发配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9c38f1922d021ec7c78c0c8ffbb0c0d5.png" alt="9c38f1922d021ec7c78c0c8ffbb0c0d5"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2eccbb8497a79d12ba5b7337f7a9d98f.png" alt="2eccbb8497a79d12ba5b7337f7a9d98f"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e8c84b9496ecb0a2922bc874f8019530.png" alt="e8c84b9496ecb0a2922bc874f8019530"></p><h4 id="8-跳过测试"><a href="#8-跳过测试" class="headerlink" title="8.跳过测试"></a>8.跳过测试</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d039b87b2aa7539c3a17519c5e509652.png" alt="d039b87b2aa7539c3a17519c5e509652"></p><h4 id="9-私服"><a href="#9-私服" class="headerlink" title="9.私服"></a>9.私服</h4><p>省</p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架</title>
    <link href="/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/09/10/Spring%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h1 id="Spring复习"><a href="#Spring复习" class="headerlink" title="Spring复习"></a>Spring复习</h1><h4 id="1-了解Spirng"><a href="#1-了解Spirng" class="headerlink" title="1.了解Spirng"></a>1.了解Spirng</h4><p>spirng-&gt;spring mvc -&gt;spring boot -&gt;spring cloud</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/48b2da9ced4cd0074a9fdd4f7c0a4318.png" alt="48b2da9ced4cd0074a9fdd4f7c0a4318"></p><p>层层递进–</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3a684778fcbcadf529eaad2b4e9ca34d.png" alt="3a684778fcbcadf529eaad2b4e9ca34d"></p><h4 id="2-IOC-Di-了解"><a href="#2-IOC-Di-了解" class="headerlink" title="2.IOC -Di 了解"></a>2.IOC -Di 了解</h4><p>由分层解耦引出的依赖注入 以及依赖反转</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ab5ce66c757c262b95bdbeb4ec1862ad.png" alt="ab5ce66c757c262b95bdbeb4ec1862ad"></p><p>如图 -&gt;当我们想更改对象 BookDaoImp12 名字时候-&gt;时 -&gt;所有业务代码都需要改动改动过大-&gt;</p><p>Ioc-&gt;控制反转<br>使用对象–由主动new-改为外部提供对象-&gt;对象控制器转移到外部</p><p>对此-spring提供容器-&gt;ioc容器 -&gt;提供了对象的创建和管理</p><p>依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/1f0310fa78da12366d47e8d7844a002a.png" alt="1f0310fa78da12366d47e8d7844a002a"></p><p>IOC-&gt;容器管理Bean-&gt;容器管理bookdaoimpl</p><p>DI-&gt;将具有依赖关系的Bean进行关系绑定-&gt;例如上面的bookdao-&gt;与bookdaoimpl进行绑定  Spring利用依赖注入机制来处理这些Bean之间的依赖关系，从而实现对象之间的松耦合。</p><h4 id="3-加入IOC-容器"><a href="#3-加入IOC-容器" class="headerlink" title="3.加入IOC 容器"></a>3.加入IOC 容器<img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ed3173cdd0c9bc6ba6d44953a8c38e0a.png" alt="ed3173cdd0c9bc6ba6d44953a8c38e0a"></h4><h6 id="1-配置Bean"><a href="#1-配置Bean" class="headerlink" title="1.配置Bean"></a>1.配置Bean</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/19c1fd155ec41e2182592cffc5262d96.png" alt="19c1fd155ec41e2182592cffc5262d96"></p><p>2.获取Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/506c12b2db4dd7aca712594fa5e279fa.png" alt="506c12b2db4dd7aca712594fa5e279fa"></p><p>当我们配置bean的时候–容器内就保存了我们的对象地址-&gt;单例-&gt;谁需要就给予</p><h6 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/838a65e2572d2c5fafc8c03d3a3ffd44.png" alt="838a65e2572d2c5fafc8c03d3a3ffd44"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dace05b9aa02d6ab02fd488a060b202e.png" alt="dace05b9aa02d6ab02fd488a060b202e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eed54b5a29e21c9568ee7b195168d180.png" alt="eed54b5a29e21c9568ee7b195168d180"></p><p>set容器执行-&gt;最后还是容器将Bean给予了</p><p>spring-&gt;编译 –自动找set 依赖方法注入</p><h4 id="4-Bean配置"><a href="#4-Bean配置" class="headerlink" title="4.Bean配置"></a>4.Bean配置</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2a1a6f9cec7eca02be1d7807228f64ae.png" alt="2a1a6f9cec7eca02be1d7807228f64ae"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/316948bfd792a80f844396040f862c94.png" alt="316948bfd792a80f844396040f862c94"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8f41e07fcd21e2e60e49873e445f8656.png" alt="8f41e07fcd21e2e60e49873e445f8656"></p><p>spring-&gt;默认的Bean是单例的</p><p>如果需要多例 就需要修改配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/20bd78b82f85ef5660348295b0f97bf6.png" alt="20bd78b82f85ef5660348295b0f97bf6"></p><p>为什么bean要单例–<br>开对象-&gt;耗费内存</p><p>由于是单例-&gt;需要改变的数据就不能加入spring管理-&gt;除非开多例</p><h4 id="5-Bean实例化"><a href="#5-Bean实例化" class="headerlink" title="5.Bean实例化"></a>5.Bean实例化</h4><h6 id="1-ioc过程"><a href="#1-ioc过程" class="headerlink" title="1.ioc过程"></a>1.ioc过程</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2509eb7c62e476183b724c53e7881f29.png" alt="2509eb7c62e476183b724c53e7881f29"></p><p>给接口内-&gt;一个构造-&gt;通过xml解析出 需要构造的对象-&gt;通过反射 -&gt;创建出对象返回-&gt;默认单例</p><p>通过类名动态加载类的方法</p><p>在使用 <code>Class.forName()</code> 方法时，情况会根据加载的类是否已存在而有所不同：</p><ol><li><strong>类已存在</strong>：<ul><li>如果使用 <code>Class.forName()</code> 加载的类在类路径中已经存在，则会返回对应的 Class 对象，而不会创建新的对象。这意味着它只是获取已加载类的引用，不会触发类的初始化和实例化。</li></ul></li><li><strong>类不存在</strong>：<ul><li>如果要加载的类在类路径中不存在，则会抛出 <code>ClassNotFoundException</code> 异常，而不会创建新的类对象。在这种情况下，不会创建新的类对象，因为类根本就没有被加载到内存中</li></ul></li></ol><h6 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h6><p>工厂模式 -&gt;由一个类中的静态方法-&gt;返回对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 静态工厂方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyService <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;通过静态工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createInstance()</code> 是静态工厂方法，负责返回 <code>MyService</code> 类型的对象。</p><p>在 Spring 配置文件中使用 <code>&lt;bean&gt;</code> 标签指定静态工厂方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span> <span class="hljs-attribute">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p> Java 注解配置静态工厂方法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-variable">@Bean</span><br>    public MyService myService() &#123;<br>        <span class="hljs-keyword">return</span> MyServiceFactory.createInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-实例工厂"><a href="#3-实例工厂" class="headerlink" title="3.实例工厂-"></a>3.实例工厂-</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceFactory</span> &#123;<br>    <span class="hljs-comment">// 实例工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyService <span class="hljs-title">createInstance</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;通过实例工厂方法创建 MyService 实例&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> Spring 配置文件（<code>applicationContext.xml</code>）中，通过 <code>&lt;bean&gt;</code> 标签配置实例工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-comment">&lt;!-- 配置工厂类的 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MyServiceFactory&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用工厂类的实例方法创建 Bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;myServiceFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>获取bean</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br>MyService myService <span class="hljs-operator">=</span> (MyService) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>)<span class="hljs-comment">;</span><br>myService.doSomething()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Spring 容器首先会创建 <code>MyServiceFactory</code> 的实例，然后调用其 <code>createInstance</code> 方法来创建 <code>MyService</code> 实例。</p><p> Java 注解配置实例工厂方法</p><p>&#x2F;&#x2F;多了一步-先获取到实例工厂bean才能够注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyServiceFactory <span class="hljs-title function_">myServiceFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceFactory</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> myServiceFactory().createInstance();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h6><p>在 Spring 框架中，<code>FactoryBean</code> 是一个特殊的接口，用于自定义 Bean 的创建逻辑</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Object <span class="hljs-title">getObject</span>(): 返回要创建的 Bean 实例。这个方法用于定义实际的对象创建逻辑。</span><br><span class="hljs-function">Class&lt;?&gt; <span class="hljs-title">getObjectType</span>(): 返回创建的 Bean 的类型。</span><br><span class="hljs-function">boolean <span class="hljs-title">isSingleton</span>(): 指示这个 Bean 是否是单例模式。返回 <span class="hljs-literal">true</span> 表示单例，<span class="hljs-literal">false</span> 表示每次请求都会创建一个新的实例。</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/dd082cfbea4d7e4b13aa31843b6f35c3.jpeg" alt="dd082cfbea4d7e4b13aa31843b6f35c3"></p><p>指定类-扫描</p><p>Spring 容器会创建一个 <code>CarFactoryBean</code> 的实例，并调用它的 <code>getObject()</code> 方法来获取 <code>Car</code> 对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext context <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)<span class="hljs-comment">;</span><br><br>// 获取由 CarFactoryBean 创建的 UserDao 实例<br>UserDao car <span class="hljs-operator">=</span> (Car) context.getBean(<span class="hljs-string">&quot;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(car)<span class="hljs-comment">;</span><br><br>// 获取 CarFactoryBean 实例本身<br>CarFactoryBean factoryBean <span class="hljs-operator">=</span> (CarFactoryBean) context.getBean(<span class="hljs-string">&quot;&amp;UserdAOfACTORBEAN&quot;</span>)<span class="hljs-comment">;</span><br>System.out.println(factoryBean)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="6-Bean生命周期"><a href="#6-Bean生命周期" class="headerlink" title="6.Bean生命周期"></a>6.Bean生命周期</h4><h6 id="1-生命周期配置"><a href="#1-生命周期配置" class="headerlink" title="1.生命周期配置"></a>1.生命周期配置</h6><p>1.配置法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3f411aabb27ce975d2121258bbe3d082.jpeg" alt="3f411aabb27ce975d2121258bbe3d082"></p><p>2.接口法</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a1a7897db2e6c6a81a71ae18c1629103.jpg" alt="a1a7897db2e6c6a81a71ae18c1629103"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/0b42710ae7bb291a8a7f65ac715b86bc.png" alt="0b42710ae7bb291a8a7f65ac715b86bc"></p><h6 id="2-bean销毁时间"><a href="#2-bean销毁时间" class="headerlink" title="2.bean销毁时间"></a>2.bean销毁时间</h6><p>为了体现生命周期-&gt;我们提前销毁bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/87ed0bfac3a4d77291ac594173873a77.jpeg" alt="87ed0bfac3a4d77291ac594173873a77"></p><h4 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7.依赖注入"></a>7.依赖注入</h4><h6 id="1-了解依赖注入"><a href="#1-了解依赖注入" class="headerlink" title="1.了解依赖注入"></a>1.了解依赖注入</h6><p>有Bean关系的类进行自动注入 —向类传递数据方式-set 传递 –构造传参</p><hr><p>参数–引用类型和简单类型</p><h6 id="2-引用注入"><a href="#2-引用注入" class="headerlink" title="2.引用注入"></a>2.引用注入</h6><p><strong>引用注入</strong> 是指将一个对象作为另一个对象的属性注入。例如，在一个类中注入另一个类的实例。在 XML 配置或基于注解的方式中，都可以实现引用注入。</p><p><strong>引用注入是指将一个 Bean 注入到另一个 Bean 中，这个 Bean 可以通过构造器、Setter 方法、或其他方式注入。引用注入强调的是一种</strong>引用关系**。</p><p><code>Person</code> 类需要 <code>Address</code> 类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String street;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Address address; <span class="hljs-comment">// 引用注入</span><br><span class="hljs-comment">// getters and setters</span><br><br><span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <span class="hljs-comment">//构造器</span><br>Person(Address address)<br>&#123;<br>    <span class="hljs-built_in">this</span>.address = address;<br>&#125;<br>    <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Person</code> 类依赖于 <code>Address</code> 类，即 <code>Person</code> 拥有一个 <code>Address</code> 类型的属性。我们可以通过 Spring 配置文件来实现引用注入。</p><p>XML 配置引用注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;New York&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5th Avenue&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John Doe&quot;</span>/&gt;</span>//属性注入<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 引用注入 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>///ref 属性表示引用另一个 Bean。<br></code></pre></td></tr></table></figure><p>基于注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <br><span class="hljs-keyword">private</span> String name;    <br><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 注解方式引用注入    </span><br><span class="hljs-keyword">private</span> Address address;   <br>/<br>/ getters and setters    <span class="hljs-comment">//... &#125;</span><br></code></pre></td></tr></table></figure><h6 id="3-setter注入"><a href="#3-setter注入" class="headerlink" title="3.setter注入"></a>3.setter注入</h6><p><strong>Setter 注入</strong> 是一种通过提供 setter 方法来实现依赖注入的方式</p><p>Setter 注入通常用于将简单数据类型（如 <code>String</code>、<code>int</code>）或引用类型注入到 Bean 中。在 XML 配置中使用 <code>&lt;property&gt;</code> 标签来定义：</p><p><code>&lt;property&gt;</code> 标签的 <code>name</code> 属性表示要注入的属性名称，<code>value</code> 属性表示简单数据类型的值，<code>ref</code> 属性表示对其他 Bean 的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;Jane Doe&quot;</span>/&gt; &lt;!-- 简单类型 --&gt;<br>    &lt;property name=<span class="hljs-string">&quot;address&quot;</span> ref=<span class="hljs-string">&quot;address&quot;</span>/&gt; &lt;!-- 引用类型 --&gt;<br>&lt;/bean&gt;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Address</span> address;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Address</span> <span class="hljs-title function_">getAddress</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">Address</span> address</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="4-构造器注入"><a href="#4-构造器注入" class="headerlink" title="4.构造器注入"></a>4.构造器注入</h6><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2ac8de3631e734a2817de72f0e21076e.jpeg" alt="2ac8de3631e734a2817de72f0e21076e"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/906d5345ed81c62f2ca79c2c87182043.jpeg" alt="906d5345ed81c62f2ca79c2c87182043"></strong></p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/37aa8dfa1862573eb20ad4710135f7a0.jpeg" alt="37aa8dfa1862573eb20ad4710135f7a0"></strong></p><h6 id="4-依赖注入方式选择"><a href="#4-依赖注入方式选择" class="headerlink" title="4.依赖注入方式选择"></a>4.依赖注入方式选择</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d7f4076b8a85df6389a465186386ba9f.jpeg" alt="d7f4076b8a85df6389a465186386ba9f"></p><h6 id="5-依赖自动装配"><a href="#5-依赖自动装配" class="headerlink" title="5.依赖自动装配"></a>5.依赖自动装配</h6><p>IOC容器根据bean所依赖的资源在容器中自动查找并注入到bena的过程称为自动装配</p><p>1.按类型</p><p>2.按名称</p><p>3.按构造方法</p><p>4.不启用自动装配</p><p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/d604dff0d944968b0f83ef5e0ed9148f.png" alt="d604dff0d944968b0f83ef5e0ed9148f"></strong></p><p>更改自动装配为按照类型</p><p>比如bookServcice依赖BookDao–我们不需要描述其关系 程序会自动根据名字找到对应类的bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 基于注解的 Setter 注入 不需要`&lt;property&gt;来描述引用关系</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAddress</span>(<span class="hljs-params"><span class="hljs-title class_">BookDao</span> bookDao</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">bookDao</span> = bookDao;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="8-集合注入"><a href="#8-集合注入" class="headerlink" title="8.集合注入"></a>8.集合注入</h4><h6 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6956e79faab9804acbd6a47b860b0245.png" alt="6956e79faab9804acbd6a47b860b0245"></p><h6 id="2-list"><a href="#2-list" class="headerlink" title="2.list"></a>2.list</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/43ed876a380305fa263d981c7a984c74.png" alt="43ed876a380305fa263d981c7a984c74"></p><h6 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;p&gt;</span><br><span class="hljs-section">&lt;set&gt;</span><br><br><span class="hljs-section">&lt;/set&gt;</span><br><span class="hljs-section">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><h6 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ca7bbcd65d882884d7297dd75609d006.png" alt="ca7bbcd65d882884d7297dd75609d006"></p><h6 id="5-Properties"><a href="#5-Properties" class="headerlink" title="5.Properties"></a>5.Properties</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2fac8b9f2d57b4c92547d6a8235169a4.png" alt="2fac8b9f2d57b4c92547d6a8235169a4"></p><h4 id="9-案例分析-bean注入"><a href="#9-案例分析-bean注入" class="headerlink" title="9.案例分析-bean注入"></a>9.案例分析-bean注入</h4><p>我们要拿到druid的连接</p><p>1.配置bean -注入参数</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/00252469c47ede33f309cf222de6d27a.png" alt="00252469c47ede33f309cf222de6d27a"></p><p>我们就可以进行拿取</p><p>Set注入–进行注入传普通参数</p><h4 id="10-加载properties文件"><a href="#10-加载properties文件" class="headerlink" title="10.加载properties文件"></a>10.加载properties文件</h4><p><code>.properties</code> 文件的结构和格式</p><ul><li><strong>文件扩展名</strong>：<code>.properties</code></li><li><strong>基本格式</strong>：每行包含一个键值对，格式为 <code>key=value</code></li></ul><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3259185201691e092710f1c19ad74f73.png" alt="3259185201691e092710f1c19ad74f73"></p><p>加载模式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e482c7cd8837d44f0b1684ae235838c7.png" alt="e482c7cd8837d44f0b1684ae235838c7"></p><h4 id="11-容器"><a href="#11-容器" class="headerlink" title="11.容器"></a>11.容器</h4><p>创建过程包括多个关键步骤，从加载配置文件、解析 Bean 定义，到创建和初始化 Bean，再到处理 Bean 的生命周期和容器的启动与关闭。</p><h6 id="1-初始化容器"><a href="#1-初始化容器" class="headerlink" title="1.初始化容器"></a>1.初始化容器</h6><p><strong>加载配置</strong>：Spring 容器从配置文件或注解中加载应用程序的配置。这些配置文件可以是 XML 文件、Java 配置类（使用 <code>@Configuration</code> 注解）、或通过其他方式如 YAML 文件等</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/88afb0e3109da0ceb049ce45b2ea81dd.png" alt="88afb0e3109da0ceb049ce45b2ea81dd"></p><p>创建 ApplicationContext 实例</p><p>ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“applicationContext.xml”);</p><h6 id="2-加载-Bean-定义"><a href="#2-加载-Bean-定义" class="headerlink" title="2.加载 Bean 定义"></a>2.加载 Bean 定义</h6><p>流程</p><p><strong>解析配置</strong>：Spring 容器解析配置文件中的 Bean 定义（包括 Bean 的类名、构造器参数、属性值等），或扫描标注有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类。</p><p><strong>注册 Bean 定义</strong>：将解析得到的 Bean 定义注册到容器中。这包括 Bean 的名称、类型、作用域（如单例或原型）、依赖关系等信息。</p><p><strong>创建 Bean 实例</strong>：根据 Bean 定义，Spring 容器创建 Bean 实例。Spring 使用反射机制调用 Bean 的构造函数（若是构造器注入）或默认构造函数。</p><p><strong>依赖注入</strong>：在 Bean 实例创建后，Spring 容器根据 Bean 定义的依赖关系注入所需的依赖。这包括构造器注入、Setter 注入、字段注入等方式。</p><p><strong>执行初始化方法</strong>：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6441e65ec06a343800d7d118ec915bf7.png" alt="6441e65ec06a343800d7d118ec915bf7"></p><p>处理 Bean 的生命周期</p><p><strong>Bean 销毁</strong>：在容器关闭时，Spring 会销毁 Bean。-&gt;bean生命周期方法</p><p> <strong>容器的启动和关闭</strong></p><p><strong>启动容器</strong>：Spring 容器在创建完成后会启动并准备好处理应用程序的请求和交互。此时，所有的 Bean 都已经被创建和初始化完毕，可以使用它们提供的功能。</p><p><strong>关闭容器</strong>：容器可以通过调用 <code>ApplicationContext</code> 的 <code>close</code> 方法来关闭。在关闭过程中，容器会执行 Bean 的销毁操作，释放资源，完成容器的清理工作。</p><h6 id="3-容器接口分析"><a href="#3-容器接口分析" class="headerlink" title="3.容器接口分析"></a>3.容器接口分析</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8d310da378a35e1bc86067389adf5c3b.png" alt="8d310da378a35e1bc86067389adf5c3b"></p><h6 id="4-BeanFactory初始化"><a href="#4-BeanFactory初始化" class="headerlink" title="4.BeanFactory初始化"></a>4.BeanFactory初始化</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ccb6cf9576f42e82a4190ea129f29b18.png" alt="ccb6cf9576f42e82a4190ea129f29b18"></p><h2 id="IOC-DI-Bean总结"><a href="#IOC-DI-Bean总结" class="headerlink" title="IOC DI Bean总结"></a>IOC DI Bean总结</h2><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/aec185bb8dc978e09e302c6e168d677e.jpeg" alt="aec185bb8dc978e09e302c6e168d677e"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/18abb534418dab1c205c287cd041975f.jpeg" alt="18abb534418dab1c205c287cd041975f"></p><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h4 id="12-注解"><a href="#12-注解" class="headerlink" title="12.注解"></a>12.注解</h4><h6 id="1-声明为Bean"><a href="#1-声明为Bean" class="headerlink" title="1.@声明为Bean"></a>1.@声明为Bean</h6><p>将一个类声明为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/86b345941eab120771d71166dbf2beb3.png" alt="86b345941eab120771d71166dbf2beb3"></p><p>为了适配MVC-&gt;故此还有 @Controller @Service @Repository</p><h6 id="2-纯注解配置"><a href="#2-纯注解配置" class="headerlink" title="2.纯注解配置"></a>2.纯注解配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/547c0427ec597688cc1c0ec42b75f8a2.png" alt="547c0427ec597688cc1c0ec42b75f8a2"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/8e5159d69c7dd85c33f019d20ac3be99.png" alt="8e5159d69c7dd85c33f019d20ac3be99"></p><h6 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/ede5cccd6b754d10bd7e5d2dfb4db131.png" alt="ede5cccd6b754d10bd7e5d2dfb4db131"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f4d394d6384f8e1211f0b8775862a884.png" alt="f4d394d6384f8e1211f0b8775862a884"></p><p>简单类型注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2cde566b050a6d34fbe85be5502e6c50.png" alt="2cde566b050a6d34fbe85be5502e6c50"></p><h6 id="4-加载properties文件"><a href="#4-加载properties文件" class="headerlink" title="4.加载properties文件"></a>4.加载properties文件</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/73301e328b26e40279005a10ac179d9b.png" alt="73301e328b26e40279005a10ac179d9b"></p><p>![22a1fbb70d0306860f7d4ce5107158b5](G:\360MoveData\Users\nixg\Documents\Tencent Files\819429207\nt_qq\nt_data\Pic\2024-03\Ori\22a1fbb70d0306860f7d4ce5107158b5.png)</p><h6 id="5-第三方bean管理例子"><a href="#5-第三方bean管理例子" class="headerlink" title="5.第三方bean管理例子"></a>5.第三方bean管理例子</h6><p>1.注册为bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b515a9216fdb4b0cf13229af949a5107.png" alt="b515a9216fdb4b0cf13229af949a5107"></p><p>2.加入管理-导入式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/26e0669596d4e65ef8badc876869a654.png" alt="26e0669596d4e65ef8badc876869a654"></p><p>扫描式</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/f1c3b59e56b859a8a04b94fa9cc65876.png" alt="f1c3b59e56b859a8a04b94fa9cc65876"></p><p>简单依赖注入</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240330164305805.png" alt="image-20240330164305805"></p><p>—连接池配置</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/2f09511581cde24e3c7dfcb783c3dc4c.png" alt="2f09511581cde24e3c7dfcb783c3dc4c"></p><h4 id="XML与注解-配置区别"><a href="#XML与注解-配置区别" class="headerlink" title="XML与注解 配置区别"></a>XML与注解 配置区别</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b4f6fbbd9134d7813d17dec19a77cd8c.jpeg" alt="b4f6fbbd9134d7813d17dec19a77cd8c"></p><h4 id="13-aop"><a href="#13-aop" class="headerlink" title="13.aop"></a>13.aop</h4><h5 id="1-Aop基础"><a href="#1-Aop基础" class="headerlink" title="1.Aop基础"></a>1.Aop基础</h5><h6 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h6><p>AOP的原理主要是通过使用代理对象来实现，在Spring中，AOP通过代理对象包装目标对象（被代理的对象），在代理对象中插入切面（aspect），实现对目标对象方法的增强。Spring AOP主要采用动态代理技术来实现AOP，其中包括JDK动态代理和CGLIB动态代理两种方式。</p><blockquote><p>只有那些被 Spring 容器管理的 Bean（例如使用 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, 或 <code>@Controller</code> 等注解的类，或者通过 XML 配置的 Bean），Spring 才能为它们创建代理对象。</p></blockquote><p>代理对象的工作原理</p><ol><li><p><strong>代理对象的生成</strong>：</p><ul><li>当容器启动并扫描到 <code>@EnableAspectJAutoProxy</code> 注解时，Spring AOP 框架会自动创建一个代理对象来包装原始的 <code>UserServiceImpl</code> 对象。</li><li>根据 <code>UserService</code> 接口类型，Spring 将使用 <strong>JDK 动态代理</strong> 创建代理对象。</li></ul></li><li><p><strong>切面拦截方法</strong>：</p><ul><li>代理对象接收到方法调用时，它会拦截调用并根据 AOP 配置执行相应的切面逻辑。</li><li>在这个例子中，代理对象会在方法执行前和执行后调用 <code>LoggingAspect</code> 中的切面方法 <code>logBeforeMethod()</code> 和 <code>logAfterMethod()</code>。</li></ul></li><li><p><strong>方法调用的委托</strong>：</p><ul><li><p>在执行完切面方法后，代理对象会将方法调用委托给实际的目标对象 (<code>UserServiceImpl</code>) 以完成核心业务逻辑4</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserService</span> <span class="hljs-title function_">userService</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-title function_">loggingAspect</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingAspect</span>();<br>    &#125;<br>&#125;<br>---------------------------------<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">&quot;execution(* com.example.service.UserService.*(..))&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">allUserServiceMethods</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logBeforeMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: Before method execution&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span>(<span class="hljs-string">&quot;allUserServiceMethods()&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logAfterMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;LoggingAspect: After method execution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><p>再框架中添加了个拦截器-&gt;依据正则过滤</p><h6 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h6><ol><li><strong>日志记录</strong>：记录方法的调用、参数、返回值等信息。</li><li><strong>事务管理</strong>：管理事务的开始、提交、回滚等操作。</li><li><strong>安全性</strong>：实现权限控制、加密解密等安全相关功能。</li><li><strong>性能监控</strong>：统计方法的执行时间、次数等性能指标。</li></ol><h6 id="3-连接点-切面-切入点-通知"><a href="#3-连接点-切面-切入点-通知" class="headerlink" title="3.连接点 切面 切入点 通知"></a>3.连接点 切面 切入点 通知</h6><hr><p>切面 @Aspect</p><p>定义一个类为切面类 -通知和切入点</p><p>@Aspect注解标识一个类为切面类，Spring会在扫描到这个注解的类时，自动创建代理对象，并将切面逻辑织入到目标方法中。</p><hr><p>通知</p><p>通知（Advice）是指切面（Aspect）中定义的在程序执行过程中插入的代码片段，它们是在指定的连接点（Join Point）处执行的行为逻辑。通知的主要作用是定义在目标方法执行前后、异常抛出时等特定情况下，应该执行的动作或逻辑。</p><p>@Before和@After</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.example.service.UserService.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeMethod</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Before method execution&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>切入点</p><p>它用于定义通知（Advice）应用的具体位置（方法或类）。切入点决定了通知在哪些连接点（Join Point）上执行。切入点的主要作用是<strong>定义通知的应用范围</strong>，即通知应该在什么情况下、对哪些方法或类生效。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* Calculator.divide(..)</span></span>)<br><br></code></pre></td></tr></table></figure><p>-通知+切入点-哪个方法被aop进行管理-再什么时候运行</p><hr><p>连接点</p><p>连接点是代码执行过程中的具体位置，可以被切面（Aspect）拦截并注入相应的增强逻辑。</p><p>当切入点表达式匹配到一个被 AOP 管理的类的方法时，这些方法就被认为是 <strong>连接点（Join Points）</strong>。</p><hr><p>@Before(“execution(* Calculator.add(..))”)</p><p>通知+切入点</p><p>代表了 Calculator类的add方法上执行增强操作</p><p>案例代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-comment">//连接点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-comment">//切面</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* Calculator.add(..))&quot;)</span><br>    <span class="hljs-comment">///通知 切入点 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logBeforeAdd</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging before the add method is called&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;execution(* Calculator.divide(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logAfterDivide</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logging after the divide method is called&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">&lt;aop:aspectj-autoproxy/&gt;<br>&lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="2-Aop进阶"><a href="#2-Aop进阶" class="headerlink" title="2.Aop进阶"></a>2.Aop进阶</h5><h6 id="1-通知类型"><a href="#1-通知类型" class="headerlink" title="1.通知类型"></a>1.通知类型</h6><ol><li><p>前置通知（Before Advice）：在目标方法执行之前调用通知方法。</p><p>对应注解：<code>@Before</code></p></li><li><p>后置通知（After Returning Advice）：在目标方法成功执行之后调用通知方法。</p><p>对应注解：<code>@AfterReturning</code></p></li><li><p>后置异常通知（After Throwing Advice）：在目标方法抛出异常后调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@AfterThrowing</span><br></code></pre></td></tr></table></figure></li><li><p>后置通知（After (finally) Advice）：无论目标方法是否成功执行，都会调用通知方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@After</span><br></code></pre></td></tr></table></figure></li><li><p>环绕通知（Around Advice）：在目标方法之前和之后执行通知方法，可以控制目标方法的执行过程。</p><p>对应注解：<code>@Around</code></p></li><li><p>引入通知（Introduction Advice）：向现有的对象添加新的方法或属性。</p></li><li><p>织入通知（AspectJ Advice）：在AOP中指定切点和通知的组合。</p></li></ol><hr><p>案例</p><ol><li><p>前置通知（Before Advice）：在用户进行结账操作时，检查用户的权限，确保用户具有足够的权限进行结账操作。</p></li><li><p>后置通知（After Returning Advice）：在用户提交订单成功后，记录订单信息到日志中，或者发送确认邮件给用户。</p></li><li><p>后置异常通知（After Throwing Advice）：如果订单处理过程中出现异常，比如库存不足，就发送通知给相关人员进行处理。</p></li><li><p>后置最终通知（After (finally) Advice）：无论订单处理成功与否，都需要关闭数据库连接或释放其他资源。</p></li><li><p>环绕通知（Around Advice）：在处理订单之前和之后记录订单处理时间，以及性能监控等功能。</p></li><li><p>引入通知（Introduction Advice）：向订单类引入一个新的接口，比如可追踪变更历史的接口。</p></li><li><p>织入通知（AspectJ Advice）：定义一个切面，将上述的各种通知类型织入到订单处理的流程中。</p></li></ol><p>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.aspectj.lang.annotation.AfterReturning;<br>import org.aspectj.lang.annotation.AfterThrowing;<br>import org.aspectj.lang.annotation.After;<br>import org.aspectj.lang.annotation.Around;<br>import org.aspectj.lang.ProceedingJoinPoint;</p><p>@Aspect<br>public class LoggingAspect {</p><pre><code class="hljs">@Before(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void beforeProcessOrder() &#123;    System.out.println(&quot;Before processing order...&quot;);&#125;@AfterReturning(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, returning = &quot;result&quot;)public void afterProcessOrder(Object result) &#123;    System.out.println(&quot;After processing order. Result: &quot; + result);&#125;@AfterThrowing(pointcut = &quot;execution(* com.example.service.OrderService.processOrder(..))&quot;, throwing = &quot;exception&quot;)public void afterThrowingProcessOrder(Exception exception) &#123;    System.out.println(&quot;Exception thrown during order processing: &quot; + exception.getMessage());&#125;@After(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public void afterProcessOrderCompletion() &#123;    System.out.println(&quot;After processing order completion...&quot;);&#125;@Around(&quot;execution(* com.example.service.OrderService.processOrder(..))&quot;)public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable &#123;    long startTime = System.currentTimeMillis();    Object result = joinPoint.proceed();    long endTime = System.currentTimeMillis();    System.out.println(&quot;Order processing time: &quot; + (endTime - startTime) + &quot; milliseconds&quot;);    return result;&#125;</code></pre><h6 id="2-通知顺序"><a href="#2-通知顺序" class="headerlink" title="2.通知顺序"></a>2.通知顺序</h6><p>当多个切面匹配到同一个类时，可以按照切入点所在类的字母顺序来决定通知方法的执行顺序</p><p>1.类字母</p><p>按照匹配到的切入点的类字母决定先后顺讯</p><p>1.前置-字母排名靠前的先执行</p><p>2.后置-字母排名靠前的后执行</p><p>2.@Order</p><p>可以使用<code>@Order</code>注解来控制多个通知方法的执行顺序。通过<code>@Order</code>注解可以指定通知方法的执行顺序，数值越小的通知方法优先执行。</p><p>具体步骤如下：</p><ol><li>在定义通知方法的类上添加<code>@Component</code>或其他相关注解，使其成为Spring容器中的Bean。</li><li>在通知方法上添加<code>@Order</code>注解，并指定执行顺序的数值，数值越小优先级越高。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(1)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 前置通知的实现</span><br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.example.service.MyService.*(..))&quot;)</span><br>    <span class="hljs-meta">@Order(2)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 后置通知的实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标前-数字小的先执行</p><p>目标后-数字小的后执行</p><h6 id="3-切入点"><a href="#3-切入点" class="headerlink" title="3.切入点"></a>3.切入点</h6><p>1.execution</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0484d9f1bbe10d4207d84882472bf29.png" alt="b0484d9f1bbe10d4207d84882472bf29"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e0a84ff1d8ccee34eb3876e12a63ef97.png" alt="e0a84ff1d8ccee34eb3876e12a63ef97"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ce5a2480e7eaf7f880d1624f4013487.png" alt="3ce5a2480e7eaf7f880d1624f4013487"></p><h4 id="2-注解aop开发"><a href="#2-注解aop开发" class="headerlink" title="2.注解aop开发"></a>2.注解aop开发</h4><p>代码案例</p><p>首先，定义一个自定义注解<code>CustomAnnotation</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-comment">//@Target(ElementType.METHOD)：表示该注解可以用于方法上。这意味着CustomAnnotation只能用于方法的声明中，而不能用于其他地方，比如类、字段等。</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-comment">///@Retention(RetentionPolicy.RUNTIME)：表示该注解在运行时可以被反射读取。这意味着在运行时，我们可以通过Java的反射机制来获取并处理带有CustomAnnotation注解的方法。</span><br>public <span class="hljs-variable">@interface</span> CustomAnnotation &#123;<br>    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">value</span>();<br>&#125;<br>这两个元数据的设定确保了<span class="hljs-selector-tag">CustomAnnotation</span>注解的使用方式和其在程序运行期间的可见性，使其可以被<span class="hljs-selector-tag">AOP</span>或其他机制所识别并进行相应的处理。<br></code></pre></td></tr></table></figure><p>接着，在一个服务类中使用<code>CustomAnnotation</code>注解：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Service</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;<br><br>    <span class="hljs-variable">@CustomAnnotation</span>(<span class="hljs-string">&quot;Custom Annotation Example&quot;</span>)<br>    public void myMethod() &#123;<br>        <span class="hljs-regexp">//</span> 方法实现<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>@CustomAnnotation(&quot;Custom Annotation Example&quot;)</code>这个注解中，双引号里面的参数是注解的属性值。在定义自定义注解时，可以为注解定义属性，并在使用注解时为这些属性赋值。</p><p>在这个示例中，自定义注解<code>CustomAnnotation</code>定义了一个名为<code>value</code>的属性，因此在使用这个注解时，需要为<code>value</code>属性赋值。双引号中的内容 <code>&quot;Custom Annotation Example&quot;</code> 就是为<code>value</code>属性赋的具体数值。</p><p>当在切面类中通过反射获取带有<code>CustomAnnotation</code>注解的方法时，可以通过访问注解的属性值来获取这里传入的参数值，从而实现根据不同的属性值执行不同的逻辑处理。</p><hr><p>然后，在切面类中使用<code>@annotation</code>注解匹配带有<code>CustomAnnotation</code>注解的方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Aspect</span><br>public class MyAspect &#123;<br><br>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;@annotation(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">annotatedMethod</span>(CustomAnnotation customAnnotation) &#123;&#125;<br><br>    <span class="hljs-variable">@Before</span>(<span class="hljs-string">&quot;annotatedMethod(customAnnotation)&quot;</span>)<br>    public void <span class="hljs-built_in">beforeAnnotatedMethod</span>(CustomAnnotation customAnnotation) &#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Before advice for method with custom annotation: &quot;</span> + customAnnotation.<span class="hljs-built_in">value</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个切入点表达式 <code>@annotation(customAnnotation)</code> 的作用是匹配所有被 <code>@CustomAnnotation</code> 注解标记的方法。</p><p><code>@annotation(customAnnotation)</code> 是 AspectJ 提供的一个语法，用来匹配方法级别的注解。这里，<code>customAnnotation</code> 是一个参数，它表示目标方法上使用的 <code>@CustomAnnotation</code>。</p><p>同时<code>annotatedMethod</code> f方法的主要用处是可以在通知（Advice）方法中使用一个更清晰、易读的命名标识来引用切入点。</p><hr><p><code>@Before(&quot;annotatedMethod(customAnnotation)&quot;)</code> 表示在所有匹配 <code>@annotation(customAnnotation)</code> 切入点的方法执行之前，执行 <code>beforeAnnotatedMethod</code> 这个方法。</p><p><code>beforeAnnotatedMethod</code> 方法将会在任何被 <code>@CustomAnnotation</code> 标记的方法执行之前运行。它可以访问这个自定义注解实例 <code>customAnnotation</code>，并获取该注解中的属性（例如 <code>value()</code> 方法）。</p><h6 id="4-连接点"><a href="#4-连接点" class="headerlink" title="4.连接点"></a>4.连接点</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/c9a1881e71612ce58b920331bae4d304.png" alt="c9a1881e71612ce58b920331bae4d304"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6ecb0785b0a6a59af4c08f919aeb6b9e.png" alt="6ecb0785b0a6a59af4c08f919aeb6b9e"></p><h4 id="14-事务"><a href="#14-事务" class="headerlink" title="14.事务"></a>14.事务</h4><h6 id="0-事务的声明式管理"><a href="#0-事务的声明式管理" class="headerlink" title="0.事务的声明式管理"></a>0.事务的声明式管理</h6><p><strong>Spring 事务管理</strong> 依赖于 <strong>AOP 的思想和机制</strong> 来实现声明式事务管理。</p><p>在 Spring 中，当你使用 <code>@Transactional</code> 注解声明一个方法或类需要事务管理时，Spring AOP 会在运行时为这些方法或类创建一个代理对象（Proxy）。代理对象负责在方法调用之前开始事务，在方法调用之后提交或回滚事务。</p><p>Spring 使用 AOP 机制来织入事务管理代码。<code>@Transactional</code> 注解背后是通过 AOP 来实现的。在方法执行的前后，AOP 拦截器会自动进行事务管理操作（如事务开启、提交和回滚），而这些操作对业务代码是透明的。</p><p>这种方式被称为 <strong>声明式事务管理</strong>，它使用 <code>@Transactional</code> 注解指定哪些方法或类需要事务支持，不需要在业务代码中显式地编写事务处理逻辑。</p><p>切面</p><p>Spring 框架定义了一个 <strong>事务切面</strong>（Transaction Aspect），用来拦截被 <code>@Transactional</code> 标记的方法。这个切面是在方法调用前后执行相应的事务操作。</p><p>切入点</p><p>@Transactional</p><p>通知</p><p>通知逻辑</p><p>在方法执行前，事务切面拦截器会开启一个事务。</p><p>如果方法正常执行完成，则事务切面拦截器会提交事务。</p><p>如果方法执行过程中抛出了异常，事务切面拦截器会根据配置决定是回滚事务还是提交事务。</p><h6 id="1-事务入门-例子"><a href="#1-事务入门-例子" class="headerlink" title="1.事务入门 -例子"></a>1.事务入门 -例子</h6><p>假设我们有一个简单的用户管理系统，其中包括一个服务类 <code>UserService</code>，负责创建用户。我们希望在执行用户</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserRepository</span> userRepository;<br><br>    <span class="hljs-comment">// 被 @Transactional 注解的方法将由 Spring AOP 管理</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> username</span>) &#123;<br>        <span class="hljs-comment">// 保存用户</span><br>        userRepository.<span class="hljs-title function_">save</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(username));<br><br>        <span class="hljs-comment">// 模拟一个异常情况，测试事务回滚</span><br>        <span class="hljs-keyword">if</span> (username == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Username cannot be null&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br>----------<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);<br>        <span class="hljs-title class_">UserService</span> userService = context.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">UserService</span>.<span class="hljs-property">class</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.<span class="hljs-title function_">createUser</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 将会导致事务回滚</span><br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Exception caught: &quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="2-事务管理员-事务协调员"><a href="#2-事务管理员-事务协调员" class="headerlink" title="2.事务管理员 事务协调员"></a>2.事务管理员 事务协调员</h6><p>例子事务</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/342dd9a76057ac1992637973417a63c8.png" alt="342dd9a76057ac1992637973417a63c8"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9b888313da273ab68bfb514f19274a0b.png" alt="9b888313da273ab68bfb514f19274a0b"></p><h6 id="3-事务配置"><a href="#3-事务配置" class="headerlink" title="3.事务配置"></a>3.事务配置</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b6f65b886518d3736b235a310f1a6754.png" alt="b6f65b886518d3736b235a310f1a6754"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/59d7f8499d23c0a2bcfdb780f1e00ea3.png" alt="59d7f8499d23c0a2bcfdb780f1e00ea3"></p><h5 id="4-事务加入-规则"><a href="#4-事务加入-规则" class="headerlink" title="4.事务加入-规则"></a>4.事务加入-规则</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/03f05df2aa222c9fb3abd3efb44ef699.png" alt="03f05df2aa222c9fb3abd3efb44ef699"></p><p>例子</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5dde408db43ac7d09f859c76ed257c91.png" alt="5dde408db43ac7d09f859c76ed257c91"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fba20ae7cf0e8f32ff7aa3de0fb42e42.png" alt="fba20ae7cf0e8f32ff7aa3de0fb42e42"></p><p>如图-都加入同一事务-一旦有异常-日志也会回滚</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/9972f6f167883d144abc515733c62536.png" alt="9972f6f167883d144abc515733c62536"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5f99a409d1ff453639c1d9cc7aa2fcf2.png" alt="5f99a409d1ff453639c1d9cc7aa2fcf2"></p><p>解决</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/cf8e05d7e9f071a8464d78b45eab2ae5.png" alt="cf8e05d7e9f071a8464d78b45eab2ae5"></p><h6 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/fa818038f3cf6f80cf14608cec80c598.png" alt="fa818038f3cf6f80cf14608cec80c598"></p><h4 id="0-1-Spring-整合mybatis"><a href="#0-1-Spring-整合mybatis" class="headerlink" title="0.1 Spring 整合mybatis"></a>0.1 Spring 整合mybatis</h4><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/11abe4ba3472982e3b1b217edb94c96e.png" alt="11abe4ba3472982e3b1b217edb94c96e"></p><p>-&gt;将该注册为Bean</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e038210f851e6d054f2de5a40605d29c.png" alt="e038210f851e6d054f2de5a40605d29c"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/eb16bf7c1655375464b67dcd0194534b.png" alt="eb16bf7c1655375464b67dcd0194534b"></p><p>如图–以上配置全部进行修改</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/241a0676f37e4b12a5eef8cdc8e7fe35.png" alt="241a0676f37e4b12a5eef8cdc8e7fe35"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/79a9256b4115e3f74adcb4dfc1db5f30.png" alt="79a9256b4115e3f74adcb4dfc1db5f30"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3ba320445dccb955e30224a3bbee6193.png" alt="3ba320445dccb955e30224a3bbee6193"></p><p>收纳</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/7ff11a9112a3615d298943a68b54e9d6.png" alt="7ff11a9112a3615d298943a68b54e9d6"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/55cab2a9fb9c8def31581e7f33474ad0.png" alt="55cab2a9fb9c8def31581e7f33474ad0"></p><h4 id="0-2-Spring整合测试"><a href="#0-2-Spring整合测试" class="headerlink" title="0.2 Spring整合测试"></a>0.2 Spring整合测试</h4><p>设定类运行器</p><p>整合spring运行器</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/6981732edb98c9b849ff758c5c4053c1.png" alt="6981732edb98c9b849ff758c5c4053c1"></p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础题目</title>
    <link href="/2024/09/10/nk/"/>
    <url>/2024/09/10/nk/</url>
    
    <content type="html"><![CDATA[<h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h6 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">JAVA2 简单运算<br>题目<br>题解(<span class="hljs-number">32</span>)<br>讨论(<span class="hljs-number">49</span>)<br>排行<br>入门  通过率：<span class="hljs-number">38.22%</span>  时间限制：<span class="hljs-number">1</span>秒  空间限制：<span class="hljs-number">256</span>M<br>warning 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。<br>描述<br>输入两个正整数<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>，输出这两个正整数的和，差，积，商，模（若<span class="hljs-selector-tag">a</span>&gt;<span class="hljs-selector-tag">b</span>则输出<span class="hljs-selector-tag">a</span>-<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">a</span>%<span class="hljs-selector-tag">b</span>的值反之输出<span class="hljs-selector-tag">b</span>-<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>/<span class="hljs-selector-tag">a</span>，<span class="hljs-selector-tag">b</span>%<span class="hljs-selector-tag">a</span>的值，不考虑小数，请使用int类型）<br>输入描述：<br>两个正整数<br>输出描述：<br>它们的和，差，积，商，模。每个值之间用空格隔开<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">10</span> <span class="hljs-number">5</span><br>复制<br>输出：<br><span class="hljs-number">15</span> <span class="hljs-number">5</span> <span class="hljs-number">50</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> a = scanner.<span class="hljs-built_in">nextInt</span>();<br>        <span class="hljs-type">int</span> b = scanner.<span class="hljs-built_in">nextInt</span>();<br>        scanner.<span class="hljs-built_in">close</span>();<br><br>        <span class="hljs-keyword">if</span>(a&gt;b)<br>        &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>        &#125;<br><br><br>        <span class="hljs-comment">//write your code here......</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt; <span class="hljs-comment">//堆区开辟对象 将它的引用压入操作数栈</span><br> <span class="hljs-number">3</span> dup <span class="hljs-comment">//复制了该对象引用，并再次将其压入操作数栈。</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt; <br> <span class="hljs-comment">///获取 System.in，即标准输入流，并将其压入操作数栈。</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">///调用 Scanner 的构造方法，使用 System.in 作为输入流参数来初始化 Scanner 对象。</span><br><span class="hljs-number">10</span> astore_1<br>将操作数栈顶的引用类型Scanner（对象引用）存储到局部变量表的索引 <span class="hljs-number">1</span> 位置 并弹出<br><span class="hljs-number">11</span> aload_1<br><span class="hljs-comment">//从局部变量表中加载索引为 1 的引用类型（对象引用）到操作数栈。</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextInt 方法，读取输入的下一个整数，并将其结果（一个 int）压入操作数栈。</span><br><span class="hljs-number">15</span> istore_2<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">2</span>）。并弹出<br><span class="hljs-number">16</span> aload_1<br>加载 Scanner 对象引用。<br><span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextInt : ()I&gt;<br><span class="hljs-number">20</span> istore_3<br>将读取到的第一个整数存储到局部变量表的第二个位置（index <span class="hljs-number">3</span>）。并弹出<br><span class="hljs-number">21</span> aload_1<br>加载 Scanner 对象引用<br><span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.close : ()V&gt;<br>调用 Scanner 的 close 方法，关闭输入流。<br>--------- <br>       <br>       Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> a = scanner.nextInt();<br>        <span class="hljs-keyword">int</span> b = scanner.nextInt();<br>        scanner.close();<br>------------<br><span class="hljs-number">25</span> iload_2<br><span class="hljs-number">26</span> iload_3<br>将 <span class="hljs-number">2</span> <span class="hljs-number">3</span> 索引值存储到操作数栈<br><br><span class="hljs-number">27</span> if_icmple <span class="hljs-number">55</span> (+<span class="hljs-number">28</span>)  <span class="hljs-keyword">if</span>(a&gt;b)<br>-&gt;比较大小<br>  System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><br><span class="hljs-number">30</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-comment">//获取标准输出流 System.out。-到操作数栈</span><br><span class="hljs-number">33</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-comment">//将格式化字符串 &quot;%d&quot; 压入操作数栈。</span><br><span class="hljs-number">35</span> iconst_1<br>将常量整数 <span class="hljs-number">1</span> 压入操作数栈，表示需要一个参数进行格式化。<br><span class="hljs-comment">///</span><br><br><span class="hljs-number">36</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br>创建一个 Object 类型的新数组，大小为 <span class="hljs-number">1</span>。<br><span class="hljs-number">39</span> dup<br>复制新建的数组引用。 压入操作数栈<br><span class="hljs-number">40</span> iconst_0<br>将整数 <span class="hljs-number">0</span> 压入操作数栈，表示数组的索引位置。<br><span class="hljs-number">41</span> iload_2<br><span class="hljs-number">42</span> iload_3<br><span class="hljs-number">43</span> iadd<br><span class="hljs-comment">//将 23 索引数据存储到操作数栈-并且相加</span><br><span class="hljs-number">44</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br>调用 Integer.valueOf 方法，将和转换为 Integer 对象。<br><span class="hljs-number">47</span> aastore<br>将 Integer 对象存储到数组的第一个位置。<br><span class="hljs-number">48</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br>调用 printf 方法输出结果。<br><span class="hljs-number">51</span> <span class="hljs-keyword">pop</span><br>弹出 PrintStream 对象的引用，清理操作数栈。<br><span class="hljs-number">52</span> goto <span class="hljs-number">77</span> (+<span class="hljs-number">25</span>)<br><span class="hljs-number">77</span><br><br>代码跳处 <br> System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br><span class="hljs-number">55</span> getstatic #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">58</span> ldc #<span class="hljs-number">8</span> &lt;%d&gt;<br><span class="hljs-number">60</span> iconst_1<br><span class="hljs-number">61</span> anewarray #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>Object&gt;<br><span class="hljs-number">64</span> dup<br><span class="hljs-number">65</span> iconst_0<br><span class="hljs-number">66</span> iload_2<br><span class="hljs-number">67</span> iload_3<br><span class="hljs-number">68</span> iadd<br><span class="hljs-number">69</span> invokestatic #<span class="hljs-number">10</span> &lt;java<span class="hljs-regexp">/lang/I</span>nteger.valueOf : (I)Ljava<span class="hljs-regexp">/lang/I</span>nteger;&gt;<br><span class="hljs-number">72</span> aastore<br><span class="hljs-number">73</span> invokevirtual #<span class="hljs-number">11</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.printf : (Ljava<span class="hljs-regexp">/lang/</span>String;[Ljava<span class="hljs-regexp">/lang/</span>Object;)Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">76</span> <span class="hljs-keyword">pop</span><br><span class="hljs-number">77</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h6><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">描述<br>定义一个<span class="hljs-built_in">int</span>类型变量i,i为由浮点数变量d四舍五入后的整数类型，请将转换后的i进行输出<br>输入描述：<br>用户随机输入的浮点数<br>输出描述：<br>四舍五入之后的整数（小数点后一位&gt;=<span class="hljs-number">5</span>则进一，否则舍去）<br>示例<span class="hljs-number">1</span><br>输入：<br><span class="hljs-number">14.99</span><br>复制<br>输出：<br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">double</span> d= scanner.<span class="hljs-built_in">nextDouble</span>();<br><br>        <span class="hljs-comment">//write your code here......</span><br>        <span class="hljs-type">double</span> v = d + <span class="hljs-number">0.5</span>;<br>        <span class="hljs-type">int</span> i= (<span class="hljs-type">int</span>) v;<br>        System.out.<span class="hljs-built_in">println</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码分析</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner&gt;<br> <span class="hljs-comment">//创建scanner引用 压入到操作数栈 1</span><br> <span class="hljs-number">3</span> dup<br> <span class="hljs-comment">//复制操作数栈顶的Scanner对象引用 并将该引用再次压入操作数栈。2</span><br> <span class="hljs-number">4</span> getstatic #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>System.in : Ljava<span class="hljs-regexp">/io/I</span>nputStream;&gt;<br> <span class="hljs-comment">//获取输入流 压入到操作数栈 3</span><br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.&lt;init&gt; : (Ljava<span class="hljs-regexp">/io/I</span>nputStream;)V&gt;<br> <span class="hljs-comment">//调用构造方法 System.in 作为参数</span><br><br><span class="hljs-number">10</span> astore_1 -弹出 <span class="hljs-number">1</span><br><span class="hljs-number">11</span> aload_1  <span class="hljs-number">2</span><br><span class="hljs-comment">//int *1=&amp;input;</span><br><span class="hljs-comment">//int **1=&amp;1;--存到操作数栈</span><br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">5</span> &lt;java<span class="hljs-regexp">/util/</span>Scanner.nextDouble : ()D&gt;<br><span class="hljs-comment">//调用 Scanner 对象的 nextDouble 方法，读取输入的 double 类型的数值，将其压入操作数栈。 3</span><br><span class="hljs-number">15</span> dstore_2 弹出-数据存储到索引 <span class="hljs-number">2</span><br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>      <br>       <span class="hljs-keyword">double</span> d= scanner.nextDouble();<br>       <br>       <br><span class="hljs-number">16</span> dload_2<br>压入操作数栈- <span class="hljs-number">3</span><br><span class="hljs-number">17</span> ldc2_w #<span class="hljs-number">6</span> &lt;<span class="hljs-number">0.5</span>&gt;<br>将常量池中 #<span class="hljs-number">6</span> 位置的 <span class="hljs-keyword">double</span> 类型常量 <span class="hljs-number">0.5</span> 压入操作数栈。 <span class="hljs-number">4</span><br><span class="hljs-number">20</span> dadd<br>相加<br><span class="hljs-number">21</span> dstore <span class="hljs-number">4</span> <span class="hljs-number">3</span><br>弹出 最新的相加值 存储到槽<span class="hljs-number">4</span><br><span class="hljs-number">23</span> dload <span class="hljs-number">4</span> <span class="hljs-number">4</span><br>再压入操作数栈<br><span class="hljs-number">25</span> d2i<br>将栈顶的 <span class="hljs-keyword">double</span> 类型数值转换为 <span class="hljs-keyword">int</span> 类型（取整）。<br><span class="hljs-number">26</span> istore <span class="hljs-number">6</span> <span class="hljs-number">3</span><br>弹出 存储到 <span class="hljs-number">6</span><br><span class="hljs-number">28</span> getstatic #<span class="hljs-number">8</span> &lt;java<span class="hljs-regexp">/lang/</span>System.out : Ljava<span class="hljs-regexp">/io/</span>PrintStream;&gt;<br><span class="hljs-number">31</span> iload <span class="hljs-number">6</span>  <span class="hljs-number">4</span> 弹出 存储槽<span class="hljs-number">6</span> <br><span class="hljs-number">33</span> invokevirtual #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/io/</span>PrintStream.<span class="hljs-keyword">println</span> : (I)V&gt; 打印<br><span class="hljs-number">36</span> <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h6 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h6><p>不使用第三方变量交换值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>        <span class="hljs-comment">//write your code here.......</span><br>        a=a+b;<br>        b=a-b;<br>        a=a-b;<br><br>        System.out.println(a+<span class="hljs-string">&quot; &quot;</span>+b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2048实现秒过关</title>
    <link href="/2024/09/06/2048/"/>
    <url>/2024/09/06/2048/</url>
    
    <content type="html"><![CDATA[<h1 id="so分析"><a href="#so分析" class="headerlink" title="so分析"></a>so分析</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/041e24788116aad3e5b9d66d153c0597.png" alt="041e24788116aad3e5b9d66d153c0597"></p><p>hook其参数-得知</p><p>修改.</p><p>text:000A1CE8 01 32                         ADDS    R2, #1</p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/5997fd65e2f23df2dedd500f805418d1.png" alt="5997fd65e2f23df2dedd500f805418d1"></p><p>text:000A1CE8 01 32                         ADDS    R2, #8</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/b0c2eab99470f976c0cc393352fa1b15.png" alt="b0c2eab99470f976c0cc393352fa1b15"></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240908230448204.png" alt="`image-20240908230448204`"></p><p>修改盒子初始值达到快速过关</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三级缓存解决循环依赖</title>
    <link href="/2024/09/06/huanchun/"/>
    <url>/2024/09/06/huanchun/</url>
    
    <content type="html"><![CDATA[<h1 id="循环依赖解决"><a href="#循环依赖解决" class="headerlink" title="循环依赖解决"></a>循环依赖解决</h1><h6 id="1-了解循环依赖问题"><a href="#1-了解循环依赖问题" class="headerlink" title="1.了解循环依赖问题"></a>1.了解循环依赖问题</h6><p>在 Spring 中，如果一个 bean 尝试将自身引用注入到自身中，通常会引发循环依赖。</p><p>首先搞清楚什么是循环依赖：</p><p>两个Bean，A依赖B，B依赖A就构成了循环依赖，如下图：</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20240606225332349.png" alt="image-20240606225332349"></p><p>同样的道理，如果在A中注入A表示A依赖A，也就构成了循环依赖。</p><p>创建A实例–》初始化A–》注入B–》创建B实例–》初始化B–》注入A</p><p>A-初始化-需要初始化完成bean-&gt;初始化B-&gt;b也要初始化其中的bean-》A-初始化-</p><p>卡入死循环</p><h6 id="2-避免循环依赖流程"><a href="#2-避免循环依赖流程" class="headerlink" title="2.避免循环依赖流程"></a>2.避免循环依赖流程</h6><p>针对循环依赖的问题Spring会上边的过程调整为下边的流程：</p><p>创建A实例– -》创建B实例–》在B中注入A—*<code>B的成员保存A的内存地址</code>*》B初始化—成员赋值了》在A中注入B–》A初始化。</p><p><strong>实例-内存地址</strong>       </p><p>A -&gt;注入B-&gt;初始化</p><p>B-&gt;A(地址)–{最后存储的就是A}-&gt;初始化</p><p>延迟了A的初始化只保留了地址</p><h6 id="3-三级缓存解决循环依赖"><a href="#3-三级缓存解决循环依赖" class="headerlink" title="3.三级缓存解决循环依赖"></a>3.三级缓存解决循环依赖</h6><p>Spring是如何做到呢？</p><p>Spring会延迟初始化，B需要注入A,此时Spring会先实例化A，把一个半成品A注入给B，延迟A的初始化。</p><p>具体的底层原理是Spring通过三级缓存实现：</p><blockquote><p>1）<strong>singletonObjects缓存</strong>：这是 Spring 容器<strong>用来缓存完全初始化好的****单例</strong> <strong>bean 实例的缓存</strong>。当一个 bean 初始化完成后，它会被放入singletonObjects缓存中。这个缓存是单例 bean 的最终缓存，也是 BeanFactory 中保存 bean 的主要缓存。</p><p>2）<strong>earlySingletonObjects缓存</strong>：这个缓存是<strong>用来保存被实例化但还未完全初始化的 bean 的引用</strong>。当一个 bean 已经被实例化（但还未初始化）时，它会被放入earlySingletonObjects缓存中。</p><p>给空间了-但是类数据没有放入</p><p>3）<strong>singletonFactories缓存</strong>：这个缓存保存的是用于创建 bean 实例的 ObjectFactory，用于支持循环依赖的延迟初始化。当一个 bean 被实例化，但尚未完全初始化时，Spring 会在singletonFactories缓存中查找该 bean 的ObjectFactory。这个ObjectFactory会在需要时被调用来完成 bean 的初始化。</p></blockquote><p>类工厂</p><p>Spring 通过这三级缓存的组合，来确保在循环依赖情况下，能够正常初始化 bean。当两个或多个 bean 之间存在循环依赖时，Spring  使用 singletonFactories 缓存来存储 bean 的提供者（ObjectFactory）。当一个 bean  在初始化过程中需要依赖另一个还未初始化的 bean 时，Spring 会调用相应的 ObjectFactory 来获取对应的 bean  实例，这样就实现了循环依赖的延迟初始化。一旦 bean 初始化完成，它就会被移动到singletonObjects缓存中。</p><p>举例：</p><p>创建A实例–》创建B实例–》在B中注入A–》B初始化—》在A中注入B–》A初始化。</p><p>创建A实例（半成品），在earlySingletonObjects放入A半成品。</p><p>创建B实例（半成品），在earlySingletonObjects放入B半成品。</p><p>在B中注入A，通过singletonFactories拿到A的对象工厂，通过对象工厂拿到A的半成品注入到B中。</p><p>B初始化完成，将B从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>在A中注入B-，通过singletonFactories拿到B的对象工厂，通过对象工厂拿到B的成品注入到A中。</p><p>A初始化完成，将A从earlySingletonObjects移动到singletonObjects<strong>。</strong></p><p>A是一片空间-当初始化完成后-地址就有数据了</p><p>说来说去 就是个内存地址的问题</p><p>**构造参数注入</p><h6 id="4-构造循环依赖解决"><a href="#4-构造循环依赖解决" class="headerlink" title="4.构造循环依赖解决"></a>4.构造循环依赖解决</h6><p>虽然Spring可以解决上边通过成员变量注入引发的循环依赖问题，但是<strong>通过构造参数注入引发的循环依赖问题是会报错。</strong></p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/e9464064bc6f0632ead497e183ca6d3a-1717687581273-4.png" alt="e9464064bc6f0632ead497e183ca6d3a"></p><p>因为创建C需要调用构造方法，而构造方法需要依赖D，此时C是无法实例化的</p><p>上边分析Spring解决循环依赖是通过延迟初始化，当出现循环依赖问题可以注入一个半成品</p><p><strong>但是如上半成品也无法生成</strong></p><p>如何解决这种通过构造参数注入导致的循环依赖问题呢？</p><p>可以在C或D的任意一方注入另一方的代理对象而不是注入原始对象，如下：</p><p>假设在C的构造方法中注入D的代理对象可以写为：</p><p>在构造参数前加@Lazy注解，表示注入D的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-meta">@Lazy</span> D d)</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础笔记</title>
    <link href="/2024/09/06/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/"/>
    <url>/2024/09/06/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础笔记"><a href="#java基础笔记" class="headerlink" title="java基础笔记"></a>java基础笔记</h1><p>ps:很遗憾，由于第一次的笔记很短暂。并不怎么深入<br>后续会更新String流处理 包括多线程 线程共享 线程安全 等<br>还有网络编程-各类心跳处理机制-多线程服务器-</p><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/Java.png" alt="Java">通过网盘分享的文件：java2笔记<br>链接: <a href="https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5">https://pan.baidu.com/s/13oVCrb7AOOk_GeN4Bc6sYQ?pwd=vka5</a> 提取码: vka5</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏逆向思路cpp</title>
    <link href="/2024/09/06/test2/"/>
    <url>/2024/09/06/test2/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏逆向思路cpp"><a href="#游戏逆向思路cpp" class="headerlink" title="游戏逆向思路cpp"></a>游戏逆向思路cpp</h1><p>游戏引擎 :cocos2dx<br>逆向思路</p><p>libcocos2dcpp.so  libgame.so     &#x2F;data&#x2F;app-lib&#x2F;包名<br>1.字符串信息查找关键函数<br>2.send函数进行定位<br>3.hook hook函数修改参数-返回值-或者多次调用-或者返回-根据情况</p><p><img src="https://s2.loli.net/2024/09/07/yZxfF9IcLlMbUzW.png" alt="2024-09-07 222659.png"></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云岚到家1-4技术栈</title>
    <link href="/2024/09/06/yunlan/"/>
    <url>/2024/09/06/yunlan/</url>
    
    <content type="html"><![CDATA[<h1 id="云岚到家-1-4"><a href="#云岚到家-1-4" class="headerlink" title="云岚到家 1-4"></a>云岚到家 1-4</h1><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6.png" alt="云岚到家"></p><p>技术栈-</p><p>微信小程序登录流程</p><p>用户定位接口</p><p>SpringCache</p><p>Redis  </p><p>缓存穿透 缓存击穿 缓存雪崩 缓存不一致 -</p><p>门户优化</p><p>XXL-JOB使用 </p><p>具体这些框架原理后续我会剖析</p><p>2.27-5.24具体笔记所在</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
