

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://q.qlogo.cn/headimg_dl?dst_uin=819429207&amp;spec=640&amp;img_type=jpg">
  <link rel="icon" href="https://q.qlogo.cn/headimg_dl?dst_uin=819429207&amp;spec=640&amp;img_type=jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="java网络通信本笔记来源  黑马C++网络编程 黑马java Nio bio aio基础讲解 网络基础1.mac地址网卡-&gt;物理地址 通常不会重复 虚拟网卡除外 48位 6字节 00:00:00:00:00:00 2.ip地址标识主机Id 为虚拟的 有ipv4(32位) ipv6(64位) 分为子网ID 和主机 ID 其中的计算需要子网掩码搭配 netmask ip中连续的1覆盖的位 子网">
<meta property="og:type" content="article">
<meta property="og:title" content="java网络通信">
<meta property="og:url" content="http://example.com/2024/11/10/java/javaIo/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/java%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="逆向狗">
<meta property="og:description" content="java网络通信本笔记来源  黑马C++网络编程 黑马java Nio bio aio基础讲解 网络基础1.mac地址网卡-&gt;物理地址 通常不会重复 虚拟网卡除外 48位 6字节 00:00:00:00:00:00 2.ip地址标识主机Id 为虚拟的 有ipv4(32位) ipv6(64位) 分为子网ID 和主机 ID 其中的计算需要子网掩码搭配 netmask ip中连续的1覆盖的位 子网">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bbcc39fa6e524cf485a0685d97dd28c5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106104603426.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/796873de8ad287eb584fb7275c01f440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image002.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106105615967.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197287-20230817213100878-1430094444.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106105955301.png">
<meta property="og:image" content="https://xiehongfeng100.github.io/images/network/tcp/tcp-state-transition-diagram/tcp-state-transition-diagram.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a94aadf6633e7592243edbc0c03244a6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111001207.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111045351.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111251206.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107102941646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107104749199.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107110025257.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107112959220.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111103809430.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104002133.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104159852.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104624115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111105239984.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111135338630.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111140153891.png">
<meta property="article:published_time" content="2024-11-10T12:22:30.000Z">
<meta property="article:modified_time" content="2024-11-11T06:43:17.311Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bbcc39fa6e524cf485a0685d97dd28c5.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>java网络通信 - 逆向狗</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>逆向狗</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s1.locimg.com/2024/09/06/63bc048e8a257.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="java网络通信"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        John Doe
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-10 20:22" pubdate>
          2024年11月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          100 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">java网络通信</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="java网络通信"><a href="#java网络通信" class="headerlink" title="java网络通信"></a>java网络通信</h1><p>本笔记来源 </p>
<p>黑马C++网络编程</p>
<p>黑马java Nio bio aio基础讲解</p>
<h4 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h4><h6 id="1-mac地址"><a href="#1-mac地址" class="headerlink" title="1.mac地址"></a>1.mac地址</h6><p>网卡-&gt;物理地址 通常不会重复 虚拟网卡除外 48位 6字节</p>
<p>00:00:00:00:00:00</p>
<h6 id="2-ip地址"><a href="#2-ip地址" class="headerlink" title="2.ip地址"></a>2.ip地址</h6><p>标识主机Id 为虚拟的 有ipv4(32位) ipv6(64位)</p>
<p>分为子网ID 和主机 ID 其中的计算需要子网掩码搭配 netmask</p>
<p>ip中连续的1覆盖的位 子网ip</p>
<p>连续0覆盖的位 主机id</p>
<p>ip:(二进制)10.1.1.2 -&gt;0000 1010 0000 0001 0000 0001 0000 0010</p>
<p>netmask-&gt;255.255.255.0-&gt;1111 1111 1111 1111 1111 1111 0000 0000</p>
<p>10.1.1 子网id 主机id2</p>
<p>网段地址：10.1.1.0</p>
<p>广播地址:10.1.1.255</p>
<p>可设置范围</p>
<p>1-254</p>
<h6 id="3-ping"><a href="#3-ping" class="headerlink" title="3.ping"></a>3.ping</h6><p>127.0.0.1-&gt;254 都是属于对本机进行联通</p>
<h6 id="5-ip-netmask设置"><a href="#5-ip-netmask设置" class="headerlink" title="5.ip netmask设置"></a>5.ip netmask设置</h6><p>linux中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">sudo  ifconfig ens33 <span class="hljs-number">192.168</span><span class="hljs-number">.26</span><span class="hljs-number">.33</span> netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure>

<h6 id="6-桥接和nat的区别"><a href="#6-桥接和nat的区别" class="headerlink" title="6.桥接和nat的区别"></a><strong>6.桥接和nat的区别</strong></h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/bbcc39fa6e524cf485a0685d97dd28c5.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>桥接（Bridge）<strong>是用于连接不同网络段的设备，主要在数据链路层工作，转发数据帧并实现不同网络之间的通信；</strong></p>
<p><strong>NAT（网络地址转换，Network Address Translation）</strong>是一种在网络层使用的技术，主要用于将私有网络地址转换为公网地址，或者将公网地址映射到多个私有网络地址，从而实现内外网的通信。NAT通常用于路由器或防火墙设备，帮助多个设备共享一个公网IP地址，解决IPv4地址不足的问题。</p>
<h6 id="7-端口"><a href="#7-端口" class="headerlink" title="7.端口"></a>7.端口</h6><p>每个程序都有一个&#x2F;多个端口<br>作用:用来标识应用程序</p>
<p>port:2字节 0-65535 其中0-1023知名端口 自定义端口1024-65535</p>
<p>端口类似于进程号，同一时刻只能只能标志一个，可以重复使用</p>
<h6 id="8-网络分层模型"><a href="#8-网络分层模型" class="headerlink" title="8.网络分层模型"></a>8.网络分层模型</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106104603426.png" srcset="/img/loading.gif" lazyload alt="image-20241106104603426"></p>
<p>物理层：双绞线的接口类型 光纤的传输速度<br>数据链路层：mac 负责收发数据<br>网络层：ip给两台主机 提供路径选择<br>传输层：port 区分数据递送到哪一个应用层<br>会话层：建立链接<br>表示层：解码<br>应用层：拿到数据<br>物 数 网 传 会 话 层</p>
<p>开发中 四层 TCP&#x2F;IP模型</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image001.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="8-协议"><a href="#8-协议" class="headerlink" title="8.协议"></a>8.协议</h6><p>规定数据传输的方式和格式</p>
<p>应用层协议<br>ftp:文件传输协议<br>http:超文本传输协议<br>省<br>传输层协议<br>tcp:传输控制协议<br>udp:用户数据报协议</p>
<p>网络层<br>ip:因特网互联协议<br>icmp：因特网控制报文协议 ping命令<br>ugmp：因特网管理协议】链路层<br>arp:地址解析协议 通过Ip找mac<br>rarp:反向地址解析协议 通过mac找ip</p>
<p>ttl-&gt;最大在网络出游走数</p>
<blockquote>
<p>TCP&#x2F;IP中的TTL 原创 <strong>TTL是IP协议包中的一个值，它告诉网络,数据包在网络中的时间是否太长而应被丢弃</strong>。</p>
</blockquote>
<p>防止在路由器内循环</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/796873de8ad287eb584fb7275c01f440.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="9-组包过程"><a href="#9-组包过程" class="headerlink" title="9.组包过程"></a>9.组包过程</h6><p>组包。简单的说就是tcp协议把过大的数据包分成了几个小的包传输，接收方要把同一组的数据包重新组合成一个完整的数据包。</p>
<p>圆圈内通过</p>
<blockquote>
<p>以前笔记的图片丢失想不起来了</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Chaman1378/article/details/107160327">https://blog.csdn.net/Chaman1378/article/details/107160327</a></p>
<h6 id="10-arp通信"><a href="#10-arp通信" class="headerlink" title="10.arp通信"></a>10.arp通信</h6><p>地址解析协议 ip找mac地址</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image001.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>a-&gt;广播发送信息 传给b b返回mac(局域网）</p>
<h6 id="11-网络模式"><a href="#11-网络模式" class="headerlink" title="11.网络模式"></a>11.网络模式</h6><p>B&#x2F;S 网页&#x2F;服务器 开发周期段</p>
<p>CS 客户端&#x2F;服务器-&gt;客户端计算 容易开挂 开发时间长</p>
<h6 id="12-socket通信流程"><a href="#12-socket通信流程" class="headerlink" title="12.socket通信流程"></a>12.socket通信流程</h6><p>tcp服务器通信步骤<br>1.创建套接字<br>2.绑定<br>3.监听<br>4.提取<br>5.读写<br>6.关闭</p>
<p>服务器创建api</p>
<p>给套接字绑定固定的端口和ip</p>
<p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/clip_image002.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>在网络通信中，套接字一定是成对出现的。</strong>一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106105615967.png" srcset="/img/loading.gif" lazyload alt="image-20241106105615967"></p>
<h6 id="13-粘包"><a href="#13-粘包" class="headerlink" title="13.粘包"></a>13.粘包</h6><p>对服务器客户端等函数进行报错处理 以及简化处理</p>
<p>缓冲区内 由于没发送完毕另外一个包就来了直接挤占前一个包的缓冲区(被信号打断的情况</p>
<p>解决方式<br>1.约定 一次发送固定字节数<br>2.数据结尾要\n<br>3.头部加上数据的大小</p>
<h6 id="14三次握手"><a href="#14三次握手" class="headerlink" title="14三次握手"></a>14三次握手</h6><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/3197287-20230817213100878-1430094444.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106105955301.png" srcset="/img/loading.gif" lazyload alt="image-20241106105955301"></p>
<p>三次握手<br>我们如果要设计一个通信软件 如和设计<br>设计 连接性<br>1.创建套接字 -&gt;让套接字中包含服务器的ip和端口进行链接<br>链接实现</p>
<p>1 发送链接请求<br>2 收到链接请求 并且链接客户端<br>3 测试是否发送成功<br>设计处三次请求</p>
<p>如果丢包了呢<br>TCP 第一次握手的 SYN 丢包了，会发生了什么？<br>场景 客户端链接服务器 但是服务器被D死了<br>重复发送 第一次超时1s 第2次超时 4s 一次增加<br>当超过最大重传次数后，客户端不再发送 SYN 包。</p>
<p>内核中定义超时请求次数 5次 那么就发送5次 时间会叠加</p>
<p>TCP 第二次握手的 SYN、ACK 丢包了，会发生什么？<br>场景 客户端链接服务器 服务器防火墙禁止数据链接</p>
<p>客户端:无法收到syn ack包 超时重传 达到内核设置次数 就终止<br>服务器:服务器能收但是不能传 服务器回syn ack 但是客户端收不到 服务器就等待客户端回第三次握手的ack<br>超时重传</p>
<p>TCP 第三次握手的 ACK 包丢了，会发生什么？</p>
<p>场景 客户端链接服务器 但是服务器被D死了</p>
<p>客户端状态:已完成 TCP 连接建立，处于 ESTABLISHED 状态-&gt;<br>手法发送数据 ——&gt;到达不了 自动断开<br>依靠保活机制</p>
<p>服务端状态:处于 SYN_RECV 如果一直收不到ack包则断开链接 -&gt;重发syn ack包 到达次数就断开链接</p>
<h6 id="15四次挥手"><a href="#15四次挥手" class="headerlink" title="15四次挥手"></a>15四次挥手</h6><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">第一次挥手（<span class="hljs-built_in">Active</span> <span class="hljs-built_in">Close</span>）：<br>客户端发送一个<span class="hljs-variable">FIN</span>（<span class="hljs-variable">Finish</span>）报文给服务器，表示客户端不再发送数据。客户端进入<span class="hljs-type">FIN_WAIT</span><span class="hljs-type">_</span><span class="hljs-number">1</span>状态，等待服务器的确认。<br><br>第二次挥手（<span class="hljs-variable">Passive</span> <span class="hljs-built_in">Close</span>）：<br>服务器收到客户端的<span class="hljs-variable">FIN</span>报文后，发送一个<span class="hljs-variable">ACK</span>（<span class="hljs-variable">Acknowledge</span>）报文作为确认，表示已经收到了客户端的关闭请求。服务器进入<span class="hljs-type">CLOSE_WAIT</span>状态。此时，服务器可能还有未发送完的数据，因此仍可以发送数据给客户端。<br><br>第三次挥手（<span class="hljs-variable">Passive</span> <span class="hljs-built_in">Close</span>）：<br>服务器发送一个<span class="hljs-variable">FIN</span>报文给客户端，表示服务器也准备关闭连接。同时，服务器通知客户端：我已经没有数据要发送了。服务器进入<span class="hljs-type">LAST_ACK</span>状态。<br><br>第四次挥手（<span class="hljs-built_in">Active</span> <span class="hljs-built_in">Close</span>）：<br>客户端收到服务器的<span class="hljs-variable">FIN</span>报文后，发送一个<span class="hljs-variable">ACK</span>报文作为确认。客户端进入<span class="hljs-type">TIME_WAIT</span>状态，并等待一段时间（两个最大报文段生存时间的时间），以确保服务器接收到了<span class="hljs-variable">ACK</span>报文。<br><br>在等待时间结束后，客户端关闭了连接，进入<span class="hljs-variable">CLOSED</span>状态。服务器接收到<span class="hljs-variable">ACK</span>报文后，也关闭了连接，进入<span class="hljs-variable">CLOSED</span>状态。<br></code></pre></td></tr></table></figure>

<p>服务器在发送最后一个FIN报文后，并不会立即断开连接，而是进入LAST_ACK状态。在LAST_ACK状态下，服务器等待客户端发送确认的ACK报文。</p>
<p>在接收到客户端的确认ACK报文后，服务器才会关闭连接并进入CLOSED状态。这个过程中，服务器也需要等待一段时间以确保客户端接收到ACK报文，避免出现网络延迟或丢包导致的问题。</p>
<p>因此，可以说服务器在发送最后一个FIN报文后并不立即断开连接，而是等待客户端的确认ACK报文后才关闭连接。这样做是为了确保连接的正常关闭，并保证数据的可靠传输。</p>
<p>如果服务器最后发送的FIN报文没有收到客户端的ACK报文，那么服务器就无法确认连接已经被关闭，因此不能立即关闭连接。在这种情况下，服务器会等待一段时间（通常是2倍的最大报文段生存时间）以确认ACK报文是否丢失或者延迟到达。</p>
<p>如果在等待时间结束后服务器仍然没有收到客户端的ACK报文，那么服务器就会强制关闭连接。在强制关闭连接后，服务器可能会向上层应用程序或者其他系统发送错误报告或日志，以提醒管理员发现和修复问题。</p>
<p>需要注意的是，在正常情况下，四次挥手过程中服务器不会强制关闭连接，除非发送的FIN报文丢失或者延迟到达导致ACK报文没有及时到达。四次挥手过程中的等待时间是为了保证数据传输的可靠性和完整性，并尽可能避免数据丢失或损坏。</p>
<h6 id="16-滑动窗口"><a href="#16-滑动窗口" class="headerlink" title="16 滑动窗口"></a>16 滑动窗口</h6><p>mms</p>
<p>mss 出现三次握手前两次 告知对方发送数据最大长度<br>MTU 跟网卡有关系 一帧最大传输单元</p>
<h6 id="17-tcp浏览控制"><a href="#17-tcp浏览控制" class="headerlink" title="17.tcp浏览控制"></a>17.tcp浏览控制</h6><p>TCP报文窗口尺寸 发送报文者的最大缓冲区</p>
<p>三次握手第2次告诉<br>发送流程</p>
<h6 id="18-tcp状态"><a href="#18-tcp状态" class="headerlink" title="18.tcp状态"></a>18.tcp状态</h6><p>概念图</p>
<p><img src="https://xiehongfeng100.github.io/images/network/tcp/tcp-state-transition-diagram/tcp-state-transition-diagram.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>简化图</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/a94aadf6633e7592243edbc0c03244a6.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>简化图未考虑特殊情况</p>
<p>netstat 命令（了解)</p>
<h6 id="19-什么是套接字"><a href="#19-什么是套接字" class="headerlink" title="19 什么是套接字"></a>19 什么是套接字</h6><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-number">1</span>.客户端与服务端 如何靠sock进行通信<br>服务器端的返回的套接字是不是客户端的套接字<br><br>服务器端<br>创建监听套接字<span class="hljs-keyword">socket</span> 绑定<span class="hljs-keyword">bind</span> 监听 <span class="hljs-keyword">listen</span> 提取<span class="hljs-keyword">accept</span><br>客户端<br>创建链接套接字 链接<br><br><span class="hljs-keyword">socket</span> 是用来实现网络传输功能的，它负责不同主机进程之间的网络通信连接<br><span class="hljs-number">1</span>.寻找<br>结构体<br><br>ip+端口 实现进程通信<br><span class="hljs-number">2</span>.协议选择<br><br>创建多个数据结构继承sock<br><br>例如 负责udp协议 udp_sock<br><br><span class="hljs-number">3</span>.sock<br>sock进行网络传输,对网卡进行操作 需在内核中 我们将各类sock封装成文件 并返回一个文件句柄 fd<br>使得应用层可以靠文件句柄进行操作<br><br>接口 <span class="hljs-keyword">send</span> <span class="hljs-keyword">bind</span> <span class="hljs-keyword">listen</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">recv</span><br><br>处在用户态的程序通过 <span class="hljs-keyword">socket</span> 提供的接口，将网络传输的这部分工作外包给了 Linux 内核<br><br><span class="hljs-number">4</span>.总结sock是什么<br>sock是处于内核的一种数据结构 用来实现网络传输<br>因为协议不同 衍生了各类sock<br>同时sock会在linux中生成为文件 提高接口<br><br>应用层<br>创建sock 绑定文件描述符 让应用层可以调用接口<br></code></pre></td></tr></table></figure>

<h6 id="20-总结"><a href="#20-总结" class="headerlink" title="20.总结"></a>20.总结</h6><p>一年前学习的网络基础，同时大部分笔记图片消失，Io复用基于的cpp不进行探究</p>
<p>但是一年前讲cpp的老师也是选择讲java的一个人</p>
<h4 id="Java-数据交换"><a href="#Java-数据交换" class="headerlink" title="Java 数据交换"></a>Java 数据交换</h4><p>I&#x2F;O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能，Java 共支持 3 种网络编程的&#x2F;IO 模型：<strong>BIO、NIO、AIO</strong><br>实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的I&#x2F;O模型</p>
<h5 id="1-bio"><a href="#1-bio" class="headerlink" title="1.bio"></a>1.bio</h5><p>同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器<br>端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111001207.png" srcset="/img/loading.gif" lazyload alt="image-20241106111001207"></p>
<h5 id="2-nio"><a href="#2-nio" class="headerlink" title="2.nio"></a>2.nio</h5><p>Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注<br>册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求就进行处理 【简单示意图】</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111045351.png" srcset="/img/loading.gif" lazyload alt="image-20241106111045351"></p>
<h5 id="3-aio"><a href="#3-aio" class="headerlink" title="3.aio"></a>3.aio</h5><p>Java AIO(NIO.2) ： 异步 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较<br>多且连接时间较长的应用</p>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241106111251206.png" srcset="/img/loading.gif" lazyload alt="image-20241106111251206"></p>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><h5 id="Bio介绍"><a href="#Bio介绍" class="headerlink" title="Bio介绍"></a>Bio介绍</h5><ul>
<li>Java BIO 就是传统的 java io  编程，其相关的类和接口在 java.io</li>
<li>BIO(blocking I&#x2F;O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需<br>要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器).</li>
</ul>
<h5 id="bio工作机制"><a href="#bio工作机制" class="headerlink" title="bio工作机制"></a>bio工作机制</h5><p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107102941646.png" srcset="/img/loading.gif" lazyload alt="image-20241107102941646"></p>
<p>对 对 BIO  编程流程的梳理</p>
<ol>
<li><p>服务器端启动一个 <strong>ServerSocket</strong>，注册端口，调用accpet方法监听客户端的Socket连接。</p>
<p>绑定 监听  提取 读写 </p>
</li>
<li><p>客户端启动 <strong>Socket</strong> 对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</p>
<p>链接 读写</p>
</li>
</ol>
<h5 id="bio编程实例回顾"><a href="#bio编程实例回顾" class="headerlink" title="bio编程实例回顾"></a>bio编程实例回顾</h5><p>​	网络编程的基本模型是Client&#x2F;Server模型，也就是两个进程之间进行相互通信<strong>，其中服务端提供位置信（绑定IP地址和端口）</strong>，<strong>客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。</strong></p>
<p>​		传统的同步阻塞模型开发中，服务端ServerSocket负责绑定IP地址，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。<br>​	 	基于BIO模式下的通信，<strong>客户端 - 服务端是完全同步，完全耦合的</strong>。	 </p>
<h6 id="1-单行发送"><a href="#1-单行发送" class="headerlink" title="1.单行发送"></a>1.单行发送</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ser&quot;</span>);<br>        <span class="hljs-comment">//注册</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//注册端口</span><br>            ServerSocket sersocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>            <span class="hljs-comment">//等待链接</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">soccket</span> <span class="hljs-operator">=</span> sersocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>);<br>            <span class="hljs-comment">//拿取输入流</span><br>            InputStream is=soccket.getInputStream();<br>            <span class="hljs-comment">//转字节</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>            <span class="hljs-comment">//读取数据</span><br>            String msg;<br>            <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>            &#125;<br><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cli</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//链接服务器</span><br>        System.out.println(<span class="hljs-string">&quot;cli&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>            System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>            <span class="hljs-comment">//转字符</span><br>           <span class="hljs-comment">// BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os));</span><br>            <span class="hljs-comment">///FilterOutputStream继承</span><br>            PrintStream ps=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br>            ps.println(<span class="hljs-string">&quot;你好&quot;</span>);<br>            ps.flush();<br><br><br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<span class="hljs-comment">//异常规范1 捕捉详细异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-comment">//输出流发送信息</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.RuntimeException</span>: java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketException</span>: Connection reset<br>	at oenday<span class="hljs-selector-class">.ser</span><span class="hljs-selector-class">.main</span>(ser<span class="hljs-selector-class">.java</span>:<span class="hljs-number">33</span>)<br>Caused by: java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketException</span>: Connection reset<br>	at java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketInputStream</span><span class="hljs-selector-class">.read</span>(SocketInputStream<span class="hljs-selector-class">.java</span>:<span class="hljs-number">209</span>)<br>	at java<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.SocketInputStream</span><span class="hljs-selector-class">.read</span>(SocketInputStream<span class="hljs-selector-class">.java</span>:<span class="hljs-number">141</span>)<br>	at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.cs</span><span class="hljs-selector-class">.StreamDecoder</span><span class="hljs-selector-class">.readBytes</span>(StreamDecoder<span class="hljs-selector-class">.java</span>:<span class="hljs-number">284</span>)<br>	at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.cs</span><span class="hljs-selector-class">.StreamDecoder</span><span class="hljs-selector-class">.implRead</span>(StreamDecoder<span class="hljs-selector-class">.java</span>:<span class="hljs-number">326</span>)<br>	at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.cs</span><span class="hljs-selector-class">.StreamDecoder</span><span class="hljs-selector-class">.read</span>(StreamDecoder<span class="hljs-selector-class">.java</span>:<span class="hljs-number">178</span>)<br>	at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.InputStreamReader</span><span class="hljs-selector-class">.read</span>(InputStreamReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">184</span>)<br>	at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.BufferedReader</span><span class="hljs-selector-class">.fill</span>(BufferedReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">161</span>)<br>	at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.BufferedReader</span><span class="hljs-selector-class">.readLine</span>(BufferedReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">324</span>)<br>	at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.BufferedReader</span><span class="hljs-selector-class">.readLine</span>(BufferedReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">389</span>)<br>	at oenday<span class="hljs-selector-class">.ser</span><span class="hljs-selector-class">.main</span>(ser<span class="hljs-selector-class">.java</span>:<span class="hljs-number">26</span>)<br><br></code></pre></td></tr></table></figure>

<p>双方没有规范退出</p>
<h6 id="2-多行发送"><a href="#2-多行发送" class="headerlink" title="2.多行发送"></a>2.多行发送</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cli</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//链接服务器</span><br>        System.out.println(<span class="hljs-string">&quot;cli&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>            System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>            <span class="hljs-comment">//转字符</span><br>           <span class="hljs-comment">// BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(os));</span><br>            <span class="hljs-comment">///FilterOutputStream继承</span><br>            PrintStream ps=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(os);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                System.out.print(<span class="hljs-string">&quot;请说:&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                ps.println(msg);<br>                ps.flush();<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<span class="hljs-comment">//异常规范1 捕捉详细异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-comment">//输出流发送信息</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="3-接收多个客户端-多线程"><a href="#3-接收多个客户端-多线程" class="headerlink" title="3.接收多个客户端-多线程"></a>3.接收多个客户端-多线程</h6><p>改造思路</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107104749199.png" srcset="/img/loading.gif" lazyload alt="image-20241107104749199"></p>
<p>写法1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ser&quot;</span>);<br>        <span class="hljs-comment">//注册</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//注册端口</span><br>            ServerSocket sersocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>            <span class="hljs-comment">//等待链接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">soccket</span> <span class="hljs-operator">=</span> sersocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;链接成功&quot;</span>+soccket.getInetAddress());<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>                 <span class="hljs-keyword">private</span> <span class="hljs-type">Socket</span> <span class="hljs-variable">socketInstance</span> <span class="hljs-operator">=</span> soccket;<br>                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                     <span class="hljs-keyword">try</span> &#123;<br>                         <span class="hljs-comment">//拿取输入流</span><br>                         InputStream is=soccket.getInputStream();<br>                         <span class="hljs-comment">//转字节</span><br>                         <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));<br>                         <span class="hljs-comment">//读取数据</span><br>                         String msg;<br>                         <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                             System.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>                         &#125;<br><br>                     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                     &#125;<br>                 &#125;<br>             &#125;.start();<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>写法2</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerReadThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Socket</span> socket;<br>    <span class="hljs-type">ServerReadThread</span>(<span class="hljs-type">Socket</span> socket) &#123;<br>        <span class="hljs-keyword">this</span>.socket=socket;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public void run() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//拿取输入流</span><br>            <span class="hljs-type">InputStream</span> is=socket.getInputStream();<br>            <span class="hljs-comment">//转字节</span><br>            <span class="hljs-type">BufferedReader</span> br = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(is));<br>            <span class="hljs-comment">//读取数据</span><br>            <span class="hljs-type">String</span> msg;<br>            <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">IOException</span> e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;==服务器的启动==&quot;</span>);<br>        <span class="hljs-comment">// （1）注册端口</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">7777</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReadThread</span>(socket).start();<br>            System.out.println(socket.getRemoteSocketAddress()+<span class="hljs-string">&quot;上线了！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题</p>
<ul>
<li>1.每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；</li>
<li>2.每个线程都会占用栈空间和CPU资源；</li>
<li>3.并不是每个socket都进行IO操作，无意义的线程处理；  </li>
<li>4.客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</li>
</ul>
<h6 id="4-伪异步IO"><a href="#4-伪异步IO" class="headerlink" title="4.伪异步IO"></a>4.伪异步IO</h6><p>​	在上述案例中：客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</p>
<p>​	接下来我们采用一个伪异步I&#x2F;O的通信框架，</p>
<p>采用线程池和任务队列实现</p>
<p>当客户端接入时，将客户端的Socket封装成一个Task(该任务实现java.lang.Runnable线程任务接口)交给后端的线程池中进行处理。</p>
<p>JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>图示如下:</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107110025257.png" srcset="/img/loading.gif" lazyload alt="image-20241107110025257"></p>
<p>线程池</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerSocketThreadPool</span> &#123;<br>    <span class="hljs-keyword">private</span> ExecutorService executor;<br>    <span class="hljs-built_in">HandlerSocketThreadPool</span>(<span class="hljs-type">int</span> maxPoolSize,<span class="hljs-type">int</span> queueSize) &#123;<br>        <span class="hljs-keyword">this</span>.executor=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadPoolExecutor</span>(<br>                maxPoolSize,<span class="hljs-comment">//最大线程数</span><br>                maxPoolSize,<span class="hljs-comment">//活跃线程数</span><br>                <span class="hljs-number">120L</span><span class="hljs-comment">//线程空闲时间</span><br>                ,  TimeUnit.SECONDS,<span class="hljs-comment">//时间单位</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBlockingQueue</span>&lt;Runnable&gt;(queueSize)<span class="hljs-comment">//队列长度</span><br>        );<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.executor.<span class="hljs-built_in">execute</span>(r);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>服务端编写</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderClientRunnable</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Runnable</span></span></span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    ReaderClientRunnable(Socket socket) &#123;<br>        <span class="hljs-built_in">this</span>.socket=socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void run() &#123;<br>        <span class="hljs-comment">//拿取输入流</span><br>        InputStream <span class="hljs-keyword">is</span>= <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">is</span> = socket.getInputStream();<br>            BufferedReader br = <span class="hljs-keyword">new</span><span class="hljs-type"></span> BufferedReader(<span class="hljs-keyword">new</span><span class="hljs-type"></span> InputStreamReader(<span class="hljs-keyword">is</span>));<br>            <span class="hljs-comment">//读取数据</span><br>            <span class="hljs-keyword">String</span> msg;<br>            <span class="hljs-keyword">while</span> ((msg=br.readLine())!=<span class="hljs-literal">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;客户端说：&quot;</span>+msg);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> RuntimeException(e);<br>        &#125;<br><br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ser</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;ser&quot;</span>);<br>        <span class="hljs-comment">//注册</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//注册端口</span><br>            ServerSocket sersocket=<span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);<br>            HandlerSocketThreadPool handlerSocketThreadPool =<br>                    <span class="hljs-keyword">new</span> HandlerSocketThreadPool(<span class="hljs-number">3</span>, <span class="hljs-number">1000</span>);<br>            <span class="hljs-comment">//等待链接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                Socket soccket = sersocket.accept();<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;链接成功&quot;</span>+soccket.getInetAddress());<br>                handlerSocketThreadPool.execute(<span class="hljs-keyword">new</span> ReaderClientRunnable(soccket));<br><br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。</li>
<li>如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的i&#x2F;o消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。</li>
</ul>
<h6 id="5-bio文件传递"><a href="#5-bio文件传递" class="headerlink" title="5.bio文件传递"></a>5.bio文件传递</h6><p>cli</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cli</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Socket socket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>            <span class="hljs-comment">//打开文件输入流</span><br>            InputStream is=<span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;D:\\调试信息.txt&quot;</span>);<br>            DataOutputStream dos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataOutputStream</span>(socket.<span class="hljs-built_in">getOutputStream</span>());<br>            dos.<span class="hljs-built_in">writeUTF</span>(<span class="hljs-string">&quot;.txt&quot;</span>);<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span>((len=is.<span class="hljs-built_in">read</span>(buffer))&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                dos.<span class="hljs-built_in">write</span>(buffer,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            dos.<span class="hljs-built_in">flush</span>();<br>            Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br><br><br>        &#125; <span class="hljs-built_in">catch</span> (IOException | InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>ser</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ServerReaderThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    ServerReaderThread(Socket socket)<br><br>    &#123;<br>        <span class="hljs-keyword">this</span>.socket = socket;<br><br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(socket.getInputStream());<br>            String suffx=dis.readUTF();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;服务端已经成功接收到了文件类型：&quot;</span> + suffx);<br>            OutputStream <span class="hljs-keyword">out</span>=<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;I:\\mp3&quot;</span>);<br>            <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-built_in">int</span> len;<br>            <span class="hljs-keyword">while</span>((len=dis.read(buffer))&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">out</span>.write(buffer,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            <span class="hljs-keyword">out</span>.close();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;服务端接收文件保存成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(clientSocket).run();<br><br><br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="6-端口转发思想"><a href="#6-端口转发思想" class="headerlink" title="6.端口转发思想"></a>6.端口转发思想</h6><p>需求：需要实现一个客户端的消息可以发送给<strong>所有的客户端去接收</strong>。（群聊实现）</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241107112959220.png" srcset="/img/loading.gif" lazyload alt="image-20241107112959220"></p>
<p>客户端接收文件</p>
<p>服务端</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">List&lt;Socket&gt; sockets <span class="hljs-operator">=</span> new ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//不排除自己</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>           &#123;<br>               Socket clientSocket = serverSocket.accept();<br>               sockets.<span class="hljs-keyword">add</span>(clientSocket);<br>               <span class="hljs-keyword">new</span> ServerReaderThread(sockets,clientSocket).run();<br><br>           &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>&#123;<br><span class="hljs-comment">//clientsocket获取输入流</span><br><span class="hljs-comment">//循环往sockets写获取到的输入流</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>NIO支持面<strong>向缓冲区</strong>的、基于<strong>通道</strong>的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO</p>
<p>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</p>
<p>NIO 有三大核心部分：<strong>Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</strong></p>
<p>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来,根据实际情况，可以分配20 或者 80个线程来处理。不像之前的阻塞 IO 那样，非得分配 1000 个。</p>
<p>* </p>
<ul>
<li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</li>
<li>BIO 是阻塞的，NIO 则是非阻塞的</li>
<li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道<br>读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111103809430.png" srcset="/img/loading.gif" lazyload alt="image-20241111103809430"></p>
<h5 id="Nio三大核心"><a href="#Nio三大核心" class="headerlink" title="Nio三大核心"></a>Nio三大核心</h5><h6 id="1-Buffer缓冲区"><a href="#1-Buffer缓冲区" class="headerlink" title="1.Buffer缓冲区"></a>1.Buffer缓冲区</h6><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer API更加容易操作和管理。</p>
<h6 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2.Channel"></a>2.Channel</h6><p>Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output)读写通常是单向的。 通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。</p>
<h6 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3.Selector"></a>3.Selector</h6><p>Selector是 一个Java NIO组件，可以能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104002133.png" srcset="/img/loading.gif" lazyload alt="image-20241111104002133"></p>
<ul>
<li>每个 channel 都会对应一个 Buffer</li>
<li>一个线程对应Selector ， 一个Selector对应多个 channel(连接)</li>
<li>程序切换到哪个 channel 是由事件决定的</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li><strong>Buffer 就是一个内存块 ， 底层是一个数组</strong></li>
<li>数据的读取写入是通过 Buffer完成的 , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。</li>
<li>Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。</li>
<li>通道表示打开到 IO 设备(例如：文件、 套接字)的连接。</li>
<li>若需要使用 NIO 系统，需要获取 用于连接 IO 设备的通道以及用于容纳数据的缓冲 区。</li>
<li>然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</li>
</ul>
<h5 id="Nio-Buffer"><a href="#Nio-Buffer" class="headerlink" title="Nio-Buffer"></a>Nio-Buffer</h5><h6 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h6><p>一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104159852.png" srcset="/img/loading.gif" lazyload alt="image-20241111104159852"></p>
<h6 id="2-子类及本身"><a href="#2-子类及本身" class="headerlink" title="2.子类及本身"></a>2.子类及本身</h6><p><strong>Buffer</strong> 就像一个数组，可以保存多个相同类型的数据。根 据数据类型不同 ，有以下 Buffer 常用子类： </p>
<ul>
<li>ByteBuffer </li>
<li>CharBuffer </li>
<li>ShortBuffer </li>
<li>IntBuffer </li>
<li>LongBuffer </li>
<li>FloatBuffer </li>
<li>DoubleBuffer</li>
</ul>
<p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> XxxBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> : 创建一个容量为capacity 的 XxxBuffer 对象<br></code></pre></td></tr></table></figure>

<h6 id="3-基本属性"><a href="#3-基本属性" class="headerlink" title="3.基本属性"></a>3.基本属性</h6><p>Buffer 中的重要概念： </p>
<p><strong>容量 (capacity)</strong> ：作为一个内存块，Buffer具有一定的固定大小，也称为”容量”，缓冲区容量不能为负，并且创建后不能更改。 </p>
<p><strong>限制 (limit)<strong>：表示缓冲区中可以操作数据的大小</strong>（limit 后数据不能进行读写）</strong>。缓冲区的限制不能为负，并且不能大于其容量。 <strong>写入模式，限制等于buffer的容量。读取模式下，limit等于写入的数据量</strong>。</p>
<p><strong>位置 (position)<strong>：</strong>下一个要读取或写入的数据的索引</strong>。缓冲区的位置不能为 负，并且不能大于其限制 </p>
<p>**标记 (mark)与重置 (reset)**：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position.</p>
<p><strong>标记、位置、限制、容量遵守以下不变式： 0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111104624115.png" srcset="/img/loading.gif" lazyload alt="image-20241111104624115"></p>
<h6 id="4-常见方法"><a href="#4-常见方法" class="headerlink" title="4.常见方法"></a>4.常见方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs j">Buffer clear() 清空缓冲区并返回对缓冲区的引用<br>Buffer flip() 为 将缓冲区的界限设置为当前位置，并将当前位置充值为 0<br>int capacity() 返回 Buffer 的 capacity 大小<br>boolean hasRemaining() 判断缓冲区中是否还有元素<br>int limit() 返回 Buffer 的界限(limit) 的位置<br>Buffer limit(int n) 将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象<br>Buffer mark() 对缓冲区设置标记<br>int position() 返回缓冲区的当前位置 position<br>Buffer position(int n) 将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象<br>int remaining() 返回 position 和 limit 之间的元素个数<br>Buffer reset() 将位置 position 转到以前设置的 mark 所在的位置<br>Buffer rewind() 将位置设为为 0， 取消设置的 mark<br></code></pre></td></tr></table></figure>

<h6 id="5-缓冲区数据操作"><a href="#5-缓冲区数据操作" class="headerlink" title="5.缓冲区数据操作"></a>5.缓冲区数据操作</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Buffer 所有子类提供了两个用于数据操作的方法：<span class="hljs-built_in">get</span>()<span class="hljs-built_in">put</span>() 方法<br>取获取 Buffer中的数据<br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">()</span></span> ：读取单个字节<br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(byte[] dst)</span></span>：批量读取多个字节到 dst 中<br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(int index)</span></span>：读取指定索引位置的字节(不会移动 <span class="hljs-attribute">position</span>)<br>    <br>放到 入数据到 Buffer 中 中<br><span class="hljs-function"><span class="hljs-title">put</span><span class="hljs-params">(byte b)</span></span>：将给定单个字节写入缓冲区的当前位置<br><span class="hljs-function"><span class="hljs-title">put</span><span class="hljs-params">(byte[] src)</span></span>：将 <span class="hljs-attribute">src</span> 中的字节写入缓冲区的当前位置<br><span class="hljs-function"><span class="hljs-title">put</span><span class="hljs-params">(int index, byte b)</span></span>：将指定字节写入缓冲区的索引位置(不会移动 <span class="hljs-attribute">position</span>)<br></code></pre></td></tr></table></figure>

<p><strong>使用Buffer读写数据一般遵循以下四个步骤：</strong></p>
<ul>
<li>1.写入数据到Buffer</li>
<li>2.调用flip()方法，转换为读取模式  &#x2F;&#x2F;&#x2F;为 将缓冲区的界限设置为当前位置，并将当前位置充值为 0</li>
<li>3.从Buffer中读取数据</li>
<li>4.调用buffer.clear()方法或者buffer.compact()方法清除缓冲区</li>
</ul>
<p><strong><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111105239984.png" srcset="/img/loading.gif" lazyload alt="image-20241111105239984"></strong></p>
<h6 id="6-案例演示"><a href="#6-案例演示" class="headerlink" title="6.案例演示"></a>6.案例演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> nio1;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBuffer</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//分配直接缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);<br>        System.out.println(buf.isDirect());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据读取</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itheima&quot;</span>;<br><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        buf.put(str.getBytes());<br><br>        <span class="hljs-comment">///开启读</span><br>        buf.flip();<br>        <span class="hljs-comment">//缓冲区的大小</span><br>        <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>        buf.get(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>        <span class="hljs-comment">//返回当前位置 position</span><br>        System.out.println(buf.position());<br><br>        <span class="hljs-comment">//mark() : 标记</span><br>        buf.mark();<br><br>        buf.get(dst, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>        <span class="hljs-comment">//返回当前位置 position</span><br>        System.out.println(buf.position());<br><br>        <span class="hljs-comment">//reset() : 恢复到 mark 的位置</span><br>        buf.reset();<br>        System.out.println(buf.position());<br><br>        <span class="hljs-comment">//判断缓冲区中是否还有剩余数据</span><br>        <span class="hljs-keyword">if</span>(buf.hasRemaining())&#123;<br>            <span class="hljs-comment">//获取缓冲区中可以操作的数量</span><br>            System.out.println(buf.remaining());<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itheima&quot;</span>;<br>        <span class="hljs-comment">//1. 分配一个指定大小的缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        System.out.println(<span class="hljs-string">&quot;-----------------allocate()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//2. 利用 put() 存入数据到缓冲区中</span><br>        buf.put(str.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;-----------------put()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//3. 切换读取数据模式</span><br>        buf.flip();<br>        System.out.println(<span class="hljs-string">&quot;-----------------flip()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//4. 利用 get() 读取缓冲区中的数据</span><br>        <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buf.limit()];<br>        buf.get(dst);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(dst, <span class="hljs-number">0</span>, dst.length));<br><br>        System.out.println(<span class="hljs-string">&quot;-----------------get()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br>        <span class="hljs-comment">//5. rewind() : 可重复读</span><br>        buf.rewind();<br>        System.out.println(<span class="hljs-string">&quot;-----------------rewind()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br><br>        <span class="hljs-comment">//6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span><br>        buf.clear();<br>        System.out.println(<span class="hljs-string">&quot;-----------------clear()----------------&quot;</span>);<br>        System.out.println(buf.position());<br>        System.out.println(buf.limit());<br>        System.out.println(buf.capacity());<br>        System.out.println((<span class="hljs-type">char</span>)buf.get());<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="7-直接与非直接缓冲区"><a href="#7-直接与非直接缓冲区" class="headerlink" title="7.直接与非直接缓冲区"></a>7.直接与非直接缓冲区</h6><p>什么是直接内存与非直接内存</p>
<p>根据官方文档的描述：</p>
<p><strong><code>byte byffer</code>可以是两种类型，一种是基于直接内存（也就是非堆内存）</strong>；</p>
<p>另一种是非直接内存（也就是堆内存）。</p>
<p>对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。</p>
<p>从数据流的角度，非直接内存是下面这样的作用链：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">本地IO</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">非直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">本地IO</span><br></code></pre></td></tr></table></figure>

<p>而直接内存是：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">本地IO</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">直接内存</span><span class="hljs-literal">--</span>&gt;<span class="hljs-comment">本地IO</span><br></code></pre></td></tr></table></figure>

<p>很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用<strong>allocateDirect</strong>创建，但是它比申请普通的堆内存需要耗费更高的性能。不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以呢，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect()  方法来确定。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>1 有很大的数据需要存储，它的生命周期又很长</li>
<li>2 适合频繁的IO操作，比如网络并发场景</li>
</ul>
<h5 id="Nio-channel"><a href="#Nio-channel" class="headerlink" title="Nio-channel"></a>Nio-channel</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h6><p>通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互。</p>
<p>1、 NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li><p>通道可以同时进行读写，而流只能读或者只能写</p>
</li>
<li><p>通道可以实现异步读写数据</p>
</li>
<li><p>通道可以从缓冲读数据，也可以写数据到缓冲:</p>
</li>
</ul>
<p>2、BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)<br>  是双向的，可以读操作，也可以写操作。</p>
<p>3、Channel 在 NIO 中是一个接口</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Channel</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Closeable</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h6 id="2-channel实现类"><a href="#2-channel实现类" class="headerlink" title="2.channel实现类"></a>2.channel实现类</h6><ul>
<li><p><strong>FileChannel</strong>：用于读取、写入、映射和操作文件的通道。</p>
</li>
<li><p><strong>DatagramChannel</strong>：通过 UDP 读写网络中的数据通道。</p>
</li>
<li><blockquote>
<p><strong>SocketChannel</strong>：通过 TCP 读写网络中的数据。</p>
</blockquote>
</li>
<li><p><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 <strong>SocketChannel</strong>。 <strong>【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</strong></p>
</li>
</ul>
<h6 id="3-FileChannel类"><a href="#3-FileChannel类" class="headerlink" title="3.FileChannel类"></a>3.FileChannel类</h6><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p>
<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
<li>RandomAccessFile</li>
<li>DatagramSocket</li>
<li>Socket</li>
<li>ServerSocket<br>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道</li>
</ul>
<h6 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(ByteBuffer dst)</span> 从 从  Channel 到 中读取数据到  ByteBuffer<br><span class="hljs-type">long</span>  <span class="hljs-title function_">read</span><span class="hljs-params">(ByteBuffer[] dsts)</span> 将 将  Channel 到 中的数据“分散”到  ByteBuffer[]<br><span class="hljs-type">int</span>  <span class="hljs-title function_">write</span><span class="hljs-params">(ByteBuffer src)</span> 将 将  ByteBuffer 到 中的数据写入到  Channel<br><span class="hljs-type">long</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ByteBuffer[] srcs)</span> 将 将  ByteBuffer[] 到 中的数据“聚集”到  Channel<br><span class="hljs-type">long</span> <span class="hljs-title function_">position</span><span class="hljs-params">()</span> 返回此通道的文件位置<br>FileChannel <span class="hljs-title function_">position</span><span class="hljs-params">(<span class="hljs-type">long</span> p)</span> 设置此通道的文件位置<br><span class="hljs-type">long</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> 返回此通道的文件的当前大小<br>FileChannel <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">long</span> s)</span> 将此通道的文件截取为给定大小<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">force</span><span class="hljs-params">(<span class="hljs-type">boolean</span> metaData)</span> 强制将所有对此通道的文件更新写入到存储设备中<br></code></pre></td></tr></table></figure>

<h6 id="5-本地读写文件"><a href="#5-本地读写文件" class="headerlink" title="5.本地读写文件"></a>5.本地读写文件</h6><p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,黑马Java程序员！” 写入到 data.txt 中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1、字节输出流通向目标文件</span><br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>            <span class="hljs-comment">// 2、得到字节输出流对应的通道Channel</span><br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> fos.getChannel();<br>            <span class="hljs-comment">// 3、分配缓冲区</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            buffer.put(<span class="hljs-string">&quot;hello,黑马Java程序员！&quot;</span>.getBytes());<br>            <span class="hljs-comment">// 4、把缓冲区切换成写出模式</span><br>            buffer.flip();<br>            channel.write(buffer);<br>            channel.close();<br>            System.out.println(<span class="hljs-string">&quot;写数据到文件中！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>本地读</p>
<p>1.获取输入流  获取通道 </p>
<p>2.开辟缓存区-将通道数据传到缓冲区</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Test</span><br><span class="hljs-function"> <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> throws Exception </span>&#123;<br>     <span class="hljs-comment">// 1、定义一个文件字节输入流与源文件接通</span><br>     FileInputStream is = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>     <span class="hljs-comment">// 2、需要得到文件字节输入流的文件通道</span><br>     FileChannel channel = is.<span class="hljs-built_in">getChannel</span>();<br>     <span class="hljs-comment">// 3、定义一个缓冲区</span><br>     ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">1024</span>);<br>     <span class="hljs-comment">// 4、读取数据到缓冲区</span><br>     channel.<span class="hljs-built_in">read</span>(buffer);<br>     buffer.<span class="hljs-built_in">flip</span>();<br>     <span class="hljs-comment">// 5、读取出缓冲区中的数据并输出即可</span><br>     <span class="hljs-type">String</span> rs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(buffer.<span class="hljs-built_in">array</span>(),<span class="hljs-number">0</span>,buffer.<span class="hljs-built_in">remaining</span>());<br>     System.out.<span class="hljs-built_in">println</span>(rs);<br><br> &#125;<br></code></pre></td></tr></table></figure>

<h6 id="6-文件拷贝完成"><a href="#6-文件拷贝完成" class="headerlink" title="6.文件拷贝完成"></a>6.文件拷贝完成</h6><p>使用 FileChannel(通道) ，完成文件的拷贝。</p>
<p>1.打开文件&#x3D;&gt;获取输入流&#x3D;&gt;获取通道</p>
<p>2.打开文件 &#x3D;&gt;获取输出流&#x3D;&gt;获取通道</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 源文件</span><br>  <span class="hljs-type">File</span> srcFile <span class="hljs-operator">=</span> new <span class="hljs-type">File</span>(<span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>dlei<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>BIO,NIO,AIO<span class="hljs-subst">\\</span>文件<span class="hljs-subst">\\</span>壁纸.jpg&quot;</span>);<br>  <span class="hljs-type">File</span> destFile <span class="hljs-operator">=</span> new <span class="hljs-type">File</span>(<span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>dlei<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>BIO,NIO,AIO<span class="hljs-subst">\\</span>文件<span class="hljs-subst">\\</span>壁纸new.jpg&quot;</span>);<br>  <span class="hljs-comment">// 得到一个字节字节输入流</span><br>  <span class="hljs-type">FileInputStream</span> fis <span class="hljs-operator">=</span> new <span class="hljs-type">FileInputStream</span>(srcFile);<br>  <span class="hljs-comment">// 得到一个字节输出流</span><br>  <span class="hljs-type">FileOutputStream</span> fos <span class="hljs-operator">=</span> new <span class="hljs-type">FileOutputStream</span>(destFile);<br>  <span class="hljs-comment">// 得到的是文件通道</span><br>  <span class="hljs-type">FileChannel</span> isChannel <span class="hljs-operator">=</span> fis.getChannel();<br>  <span class="hljs-type">FileChannel</span> osChannel <span class="hljs-operator">=</span> fos.getChannel();<br></code></pre></td></tr></table></figure>

<p>3.开辟缓冲区&#x3D;&gt;1往缓冲区赛值 &#x3D;&gt;2往缓冲区放值-写入</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 分配缓冲区<br>  ByteBuffer buffer <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-comment">// 必须先清空缓冲然后再写入数据到缓冲区</span><br>      buffer.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-comment">// 开始读取一次数据</span><br>      <span class="hljs-type">int</span> flag = isChannel.<span class="hljs-built_in">read</span>(buffer);<br>      <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>)&#123;<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">// 已经读取了数据 ，把缓冲区的模式切换成可读模式</span><br>      buffer.<span class="hljs-built_in">flip</span>();<br>      <span class="hljs-comment">// 把数据写出到</span><br>      osChannel.<span class="hljs-built_in">write</span>(buffer);<br>  &#125;<br>  isChannel.<span class="hljs-built_in">close</span>();<br>  osChannel.<span class="hljs-built_in">close</span>();<br>  System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;复制完成！&quot;</span>);<br></code></pre></td></tr></table></figure>

<h6 id="7-分散和聚合"><a href="#7-分散和聚合" class="headerlink" title="7.分散和聚合"></a>7.分散和聚合</h6><p>分散读取（Scatter ）:是指把<strong>Channel通道</strong>的数据<strong>读入到多个缓冲区</strong>中去</p>
<p>聚集写入（Gathering ）是指将<strong>多个 Buffer 中的数据“聚集”到 Channel</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>       <span class="hljs-comment">//1. 获取通道</span><br>       <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel1</span> <span class="hljs-operator">=</span> raf1.getChannel();<br><br>       <span class="hljs-comment">//2. 分配指定大小的缓冲区</span><br>       <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">100</span>);<br>       <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf2</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>       <span class="hljs-comment">//3. 分散读取</span><br>       ByteBuffer[] bufs = &#123;buf1, buf2&#125;;<br>       channel1.read(bufs);<br><br>       <span class="hljs-keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;<br>           byteBuffer.flip();<br>       &#125;<br><br>       System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufs[<span class="hljs-number">0</span>].array(), <span class="hljs-number">0</span>, bufs[<span class="hljs-number">0</span>].limit()));<br>       System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>       System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufs[<span class="hljs-number">1</span>].array(), <span class="hljs-number">0</span>, bufs[<span class="hljs-number">1</span>].limit()));<br><br>       <span class="hljs-comment">//4. 聚集写入</span><br>       <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>       <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel2</span> <span class="hljs-operator">=</span> raf2.getChannel();<br><br>       channel2.write(bufs);<br>   &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药�</span><br><span class="hljs-section">-----------------</span><br>��谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁我毒药是谁<br></code></pre></td></tr></table></figure>

<h6 id="8-transferFrom"><a href="#8-transferFrom" class="headerlink" title="8.transferFrom()"></a>8.transferFrom()</h6><p>从目标通道中去复制原通道数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1、字节输入管道</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">isChannel</span> <span class="hljs-operator">=</span> is.getChannel();<br>    <span class="hljs-comment">// 2、字节输出流管道</span><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;data03.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">osChannel</span> <span class="hljs-operator">=</span> fos.getChannel();<br>    <span class="hljs-comment">// 3、复制</span><br>    osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());<br>    isChannel.close();<br>    osChannel.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="9-transferTo"><a href="#9-transferTo" class="headerlink" title="9.transferTo()"></a>9.transferTo()</h6><p>把原通道数据复制到目标通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1、字节输入管道</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;data01.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">isChannel</span> <span class="hljs-operator">=</span> is.getChannel();<br>    <span class="hljs-comment">// 2、字节输出流管道</span><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;data04.txt&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">osChannel</span> <span class="hljs-operator">=</span> fos.getChannel();<br>    <span class="hljs-comment">// 3、复制</span><br>    isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);<br>    isChannel.close();<br>    osChannel.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Nio-选择器-Selector"><a href="#Nio-选择器-Selector" class="headerlink" title="Nio-选择器 Selector"></a>Nio-选择器 Selector</h5><h6 id="1-选择器介绍"><a href="#1-选择器介绍" class="headerlink" title="1.选择器介绍"></a>1.选择器介绍</h6><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111135338630.png" srcset="/img/loading.gif" lazyload alt="image-20241111135338630"></p>
<ul>
<li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <strong>Selector</strong>(选择器)</li>
<li>Selector <strong>能够检测多个注册的通道上是否有事件发生</strong>(注意:<strong>多个 Channel 以事件的方式可以注册到同一个</strong><br><strong>Selector</strong>)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管<br>理多个通道，也就是管理多个连接和请求。</li>
<li>只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都<br>创建一个线程，不用去维护多个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ul>
<h6 id="2-选择器应用"><a href="#2-选择器应用" class="headerlink" title="2.选择器应用"></a>2.选择器应用</h6><p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure>

<p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 获取通道</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><span class="hljs-comment">//2. 切换非阻塞模式</span><br>ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//3. 绑定连接</span><br>ssChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9898</span>));<br><span class="hljs-comment">//4. 获取选择器</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span><br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure>

<p> 当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey  的四个常量 表示）：</p>
<ul>
<li>读 : SelectionKey.OP_READ （1）</li>
<li>写 : SelectionKey.OP_WRITE （4）</li>
<li>连接 : SelectionKey.OP_CONNECT （8）</li>
<li>接收 : SelectionKey.OP_ACCEPT （16）</li>
<li>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</li>
</ul>
<h5 id="nio网络通信解析"><a href="#nio网络通信解析" class="headerlink" title="nio网络通信解析"></a>nio网络通信解析</h5><p>Selector 示意图和特点说明</p>
<p>Selector可以实现： 一个 I&#x2F;O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I&#x2F;O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
<p><img src="https://raw.githubusercontent.com/Xlan-cell/tupian/master/image-20241111140153891.png" srcset="/img/loading.gif" lazyload alt="image-20241111140153891"></p>
<p>服务端流程</p>
<p>当客户端连接服务端时，服务端会通过 ServerSocketChannel 得到 SocketChannel：</p>
<ol>
<li>获取通道</li>
</ol>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ServerSocketChannel ssChannel <span class="hljs-operator">=</span> ServerSocketChannel.open()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>2、切换非阻塞模式</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ssChannel.configureBlocking(false)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>3、绑定连接</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ssChannel.bind(new InetSocketAddress(<span class="hljs-number">9999</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>4.获取选择器</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure>

<p>5、 将通道注册到选择器上, 并且指定“监听接收事件”</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">ssChannel.<span class="hljs-keyword">register</span>(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure>

<p>6.轮询式的获取选择器上已经“准备就绪”的事件</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//轮询式的获取选择器上已经“准备就绪”的事件</span><br> <span class="hljs-keyword">while</span> (selector.<span class="hljs-keyword">select</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;轮一轮&quot;</span>);<br>        <span class="hljs-comment">//7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span><br>        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-comment">//8. 获取准备“就绪”的是事件</span><br>            SelectionKey sk = it.next();<br>            <span class="hljs-comment">//9. 判断具体是什么事件准备就绪</span><br>            <span class="hljs-keyword">if</span> (sk.isAcceptable()) &#123;<br>                <span class="hljs-comment">//10. 若“接收就绪”，获取客户端连接</span><br>                SocketChannel sChannel = ssChannel.accept();<br>                <span class="hljs-comment">//11. 切换非阻塞模式</span><br>                sChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">//12. 将该通道注册到选择器上</span><br>                sChannel.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sk.isReadable()) &#123;<br>                <span class="hljs-comment">//13. 获取当前选择器上“读就绪”状态的通道</span><br>                SocketChannel sChannel = (SocketChannel) sk.channel();<br>                <span class="hljs-comment">//14. 读取数据</span><br>                ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="hljs-number">0</span>) &#123;<br>                    buf.flip();<br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));<br>                    buf.clear();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//15. 取消选择键 SelectionKey</span><br>            it.<span class="hljs-keyword">remove</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端</p>
<p>1.获取通道</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">SocketChannel sChannel = SocketChannel.<span class="hljs-keyword">open</span>(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>2.切换非阻塞模式</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">sChannel.configureBlocking(false)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>3.分配指定大小的缓冲区</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuffer buf <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>4.发送数据给服务端</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Scanner scan = <span class="hljs-built_in">new</span> Scanner(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>);<br><span class="hljs-keyword">while</span>(scan.hasNext())&#123;<br>	String str = scan.nextLine();<br>	buf.put((<span class="hljs-built_in">new</span> SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(<span class="hljs-keyword">System</span>.currentTimeMillis())<br>			+ &quot;\n&quot; + str).getBytes());<br>	buf.flip();<br>	sChannel.<span class="hljs-keyword">write</span>(buf);<br>	buf.clear();<br>&#125;<br>//关闭通道<br>sChannel.<span class="hljs-keyword">close</span>();<br></code></pre></td></tr></table></figure>

<h5 id="nio网络通信案例代码"><a href="#nio网络通信案例代码" class="headerlink" title="nio网络通信案例代码"></a>nio网络通信案例代码</h5><p>ser</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">nioser</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerSocketChannel ssChannel=   ServerSocketChannel.<span class="hljs-built_in">open</span>();<br>            ssChannel.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            ssChannel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>            Selector selector = Selector.<span class="hljs-built_in">open</span>();<br>            ssChannel.<span class="hljs-built_in">register</span>(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-keyword">while</span> (selector.<span class="hljs-built_in">select</span>()&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                Iterator&lt;SelectionKey&gt; key = selector.<span class="hljs-built_in">selectedKeys</span>().<span class="hljs-built_in">iterator</span>();<br>                <span class="hljs-keyword">while</span> (key.<span class="hljs-built_in">hasNext</span>())<br>                &#123;<br>                    SelectionKey selKey = key.<span class="hljs-built_in">next</span>();<br>                    <span class="hljs-keyword">if</span>(selKey.<span class="hljs-built_in">isAcceptable</span>())<br>                    &#123;<br>                        SocketChannel sChannel =  ssChannel.<span class="hljs-built_in">accept</span>();<br>                        sChannel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                        sChannel.<span class="hljs-built_in">register</span>(selector,SelectionKey.OP_READ);<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;有新链接上线了&quot;</span>);<br><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selKey.<span class="hljs-built_in">isReadable</span>())<br>                    &#123;<br>                        SocketChannel sChannel = (SocketChannel) selKey.<span class="hljs-built_in">channel</span>();<br><br>                        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">while</span>((len=sChannel.<span class="hljs-built_in">read</span>(buffer))&gt;<span class="hljs-number">0</span>)<br>                        &#123;<br>                            buffer.<span class="hljs-built_in">flip</span>();<br>                            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(buffer.<span class="hljs-built_in">array</span>(),<span class="hljs-number">0</span>,len));<br>                            buffer.<span class="hljs-built_in">clear</span>();<br><br>                        &#125;<br>                    &#125;<br>                    key.<span class="hljs-built_in">remove</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>cli</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">public class niocli &#123;<br><br>    public static void main(String[] args) throws Exception&#123;<br>        SocketChannel <span class="hljs-keyword">sch=SocketChannel.open(new </span>InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>));<br>        <span class="hljs-keyword">sch.configureBlocking(false);</span><br><span class="hljs-keyword"></span>        <span class="hljs-keyword">ByteBuffer </span><span class="hljs-keyword">buf=ByteBuffer.allocate(1024);</span><br><span class="hljs-keyword"></span>        <span class="hljs-keyword">Scanner </span><span class="hljs-keyword">scan </span>= new <span class="hljs-keyword">Scanner(System.in);</span><br><span class="hljs-keyword"></span>        while (<span class="hljs-keyword">scan.hasNext())&#123;</span><br><span class="hljs-keyword"></span>            String str=<span class="hljs-keyword">scan.nextLine();</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">buf.put(str.getBytes());</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">buf.flip();</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">sch.write(buf);</span><br><span class="hljs-keyword"></span>            <span class="hljs-keyword">buf.clear();</span><br><span class="hljs-keyword"></span>        &#125;<br>        <span class="hljs-keyword">sch.close();</span><br><span class="hljs-keyword"></span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="nio群聊系统"><a href="#nio群聊系统" class="headerlink" title="nio群聊系统"></a>nio群聊系统</h5><ul>
<li>编写一个 NIO 群聊系统，实现客户端与客户端的通信需求（非阻塞）</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 channel 可以无阻塞发送消息给其它所有客户端用户，同时可以接受其它客户端用户通过服务端转发来的消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-comment">//定义属性</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> ServerSocketChannel ssChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">9999</span>;<br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//初始化工作</span><br>    Server()&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ssChannel=ServerSocketChannel.open();<br>            ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            ssChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.net.InetSocketAddress(PORT));<br>            selector=Selector.open();<br>            ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-comment">//监听</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listen</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;开始一轮事件处理~~~&quot;</span>);<br>                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>                <span class="hljs-keyword">while</span>(it.hasNext())<br>                &#123;<br>                 SelectionKey selectionKey=  it.next();<br>                 <span class="hljs-keyword">if</span>(selectionKey.isAcceptable())<br>                 &#123;<br>                     <span class="hljs-comment">// 10、直接获取当前接入的客户端通道</span><br>                     <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">schannel</span> <span class="hljs-operator">=</span> ssChannel.accept();<br>                     <span class="hljs-comment">// 11 、切换成非阻塞模式</span><br>                     schannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                     <span class="hljs-comment">// 12、将本客户端通道注册到选择器</span><br>                     System.out.println(schannel.getRemoteAddress() + <span class="hljs-string">&quot; 上线 &quot;</span>);<br>                     schannel.register(selector , SelectionKey.OP_READ);<br>                     <span class="hljs-comment">//提示</span><br>                 &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(selectionKey.isReadable())<br>                 &#123;<br>                     <span class="hljs-comment">//处理读 (专门写方法..)</span><br>                     readData(selectionKey);<br>                 &#125;<br><br>                &#125;<br><br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readData</span><span class="hljs-params">(SelectionKey sk)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel= (SocketChannel) sk.channel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>            <span class="hljs-comment">//根据count的值做处理</span><br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//把缓存区的数据转成字符串</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array());<br>                <span class="hljs-comment">//输出该消息</span><br>                System.out.println(<span class="hljs-string">&quot;form 客户端: &quot;</span> + msg);<br>                <span class="hljs-comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span><br>                sendInfoToOtherClients(msg, channel);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)<br>        &#123; <br>            System.out.println(channel.getRemoteAddress() + <span class="hljs-string">&quot; 离线了..&quot;</span>);<br>            e.printStackTrace();<br>            <span class="hljs-comment">//取消注册</span><br>            sk.cancel();<br>            <span class="hljs-comment">//关闭通道</span><br>            channel.close();<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器转发消息中...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span><br>        <span class="hljs-keyword">for</span>(SelectionKey key: selector.keys()) &#123;<br>            <span class="hljs-comment">//通过 key  取出对应的 SocketChannel</span><br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">targetChannel</span> <span class="hljs-operator">=</span> key.channel();<br>            <span class="hljs-comment">//排除自己</span><br>            <span class="hljs-keyword">if</span>(targetChannel <span class="hljs-keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != channel) &#123;<br>                <span class="hljs-comment">//转型</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> (SocketChannel)targetChannel;<br>                <span class="hljs-comment">//将msg 存储到buffer</span><br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msg.getBytes());<br>                <span class="hljs-comment">//将buffer 的数据写入 通道</span><br>                dest.write(buffer);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建服务器对象</span><br>        <span class="hljs-type">Server</span> <span class="hljs-variable">groupChatServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>        groupChatServer.listen();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>cli</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-comment">//定义相关的属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HOST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <span class="hljs-comment">// 服务器的ip</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">9999</span>; <span class="hljs-comment">//服务器端口</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">//构造器, 完成初始化工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        selector = Selector.open();<br>        <span class="hljs-comment">//连接服务器</span><br>        socketChannel = socketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, PORT));<br>        <span class="hljs-comment">//设置非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//将channel 注册到selector</span><br>        socketChannel.register(selector, SelectionKey.OP_READ);<br>        <span class="hljs-comment">//得到username</span><br>        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);<br>        System.out.println(username + <span class="hljs-string">&quot; is ok...&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendInfo</span><span class="hljs-params">(String info)</span> &#123;<br>        info = username + <span class="hljs-string">&quot; 说：&quot;</span> + info;<br>        <span class="hljs-keyword">try</span> &#123;<br>            socketChannel.write(ByteBuffer.wrap(info.getBytes()));<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//读取从服务器端回复的消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">readChannels</span> <span class="hljs-operator">=</span> selector.select();<br>            <span class="hljs-keyword">if</span>(readChannels &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有可以用的通道</span><br><br>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                    <span class="hljs-keyword">if</span>(key.isReadable()) &#123;<br>                        <span class="hljs-comment">//得到相关的通道</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-comment">//得到一个Buffer</span><br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-comment">//读取</span><br>                        sc.read(buffer);<br>                        <span class="hljs-comment">//把读到的缓冲区的数据转成字符串</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array());<br>                        System.out.println(msg.trim());<br>                    &#125;<br>                &#125;<br>                iterator.remove(); <span class="hljs-comment">//删除当前的selectionKey, 防止重复操作</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span><br><br>            &#125;<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//启动我们客户端</span><br>        <span class="hljs-type">Client</span> <span class="hljs-variable">chatClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br>        <span class="hljs-comment">//启动一个线程, 每个3秒，读取从服务器发送数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    chatClient.readInfo();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);<br>                    &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-comment">//发送数据给服务器端</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            chatClient.sendInfo(s);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="Aio"><a href="#Aio" class="headerlink" title="Aio"></a>Aio</h4><p>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">AIO</span><br>异步非阻塞，基于<span class="hljs-variable">NIO</span>的，可以称之为<span class="hljs-variable">NIO2</span><span class="hljs-number">.0</span><br>    <span class="hljs-variable">BIO</span>                   <span class="hljs-variable">NIO</span>                              <span class="hljs-variable">AIO</span>        <br><span class="hljs-built_in">Socket</span>                <span class="hljs-variable">SocketChannel</span>                    <span class="hljs-variable">AsynchronousSocketChannel</span><br><span class="hljs-variable">ServerSocket</span>          <span class="hljs-variable">ServerSocketChannel</span>	       <span class="hljs-variable">AsynchronousServerSocketChannel</span><br></code></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">与NIO不同，当进行读写操作时，只须直接调用API的<span class="hljs-built_in">read</span>或<span class="hljs-built_in">write</span>方法即可, 这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入<span class="hljs-built_in">read</span>方法的缓冲区,对于写操作而言，当操作系统将<span class="hljs-built_in">write</span>方法传递的流写入完毕时，操作系统主动通知应用程序<br><br>即可以理解为，<span class="hljs-built_in">read</span>/<span class="hljs-built_in">write</span>方法都是异步的，完成后会主动调用回调函数。在JDK1<span class="hljs-number">.7</span>中，这部分内容被称作NIO<span class="hljs-number">.2</span>，主要在Java.nio.channels包下增加了下面四个异步通道：<br></code></pre></td></tr></table></figure>

<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AsynchronousSocketChannel</span><br><span class="hljs-attribute">AsynchronousServerSocketChannel</span><br><span class="hljs-attribute">AsynchronousFileChannel</span><br><span class="hljs-attribute">AsynchronousDatagramChannel</span><br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>BIO、NIO、AIO：</strong></p>
<ul>
<li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
<li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>
<li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li>
</ul>
<p><strong>BIO、NIO、AIO适用场景分析:</strong></p>
<ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。Netty!</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>java网络通信</div>
      <div>http://example.com/2024/11/10/java/javaIo/网络编程/java网络通信/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/11/10/java/javaIo/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UnixIO%E6%A8%A1%E5%9E%8B/" title="UnixIo模型">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">UnixIo模型</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/11/06/java%20jvm/%E5%9F%BA%E7%A1%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="jvm 垃圾回收篇">
                        <span class="hidden-mobile">jvm 垃圾回收篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.css')
      Fluid.utils.createScript('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://abc.nixgou.cn/","path":"window.location.pathname","meta":["nick"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
